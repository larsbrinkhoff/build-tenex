TITLE LNKOV2 - PHASE 2 OVERLAY MODULE FOR LINK-10
SUBTTL	D.M.NIXON/DMN		11-JUL-74


;***COPYRIGHT 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKOV2
SEARCH	LNKPAR,LNKLOW,C,SCNMAC
EXTERN	LNKMAP,LNKXIT

CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==207		;DEC EDIT VERSION



VERSION


SALL
SEGMENT

SUBTTL	REVISION HISTORY

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;136	FIX VARIOUS BUGS
;174	FIX BUGS IN RELOCATABLE OVERLAYS
;203	GET DDT SYMBOLS INTO ALL LINKS
;207	REDUCE SIZE OF OVERHEAD TABLES
SUBTTL	DEFINITIONS

EI.ZZ==4		;NO. OF WORDS IN EXT/INT HASH BLOCKS

;INDEX TO ITEMS IN EXT/INT TABLE
EI.FLG==0		;FLAGS,,LINK#
EI.SYM==1		;SYMBOL
EI.VAL==2		;VALUE
EI.INT==3		;INTTAB ENTRY
EI.LEN==4		;LENGTH OF SYMBOL BLOCK

;TEMP "SYMBOL" FLAGS
IT.DEF==(PS.GLB)	;SYMBOL IS DEFINED IN OTHER LINK
IT.MDF==(PS.MDF)	;SYMBOL IS DEFINED IN MORE THAN 1 LINK
IT.UDF==(PS.UDF)	;SYMBOL IS NOT YET DEFINED
IT.LST==(PS.DDT)	;LAST SYMBOL IF EXTENDED

;FLAGS IN OVERLAY BLOCK (JSP CALL)
F.LIC==1B0		;LINK IN CORE (ONLY USED FOR UNDEFS)
F.MDL==1B1		;LINK IS MULTIPLY-DEFINED
F.RLC==1B2		;LINK IS RELOCATED (NOT USED)

;IOWD FOR PREAMBLE SECTION

IFE FTKIONLY,<
PHIOWD:	IOWD	PH.ZZ,PH.HDR
	0
>
IFN FTKIONLY,<EXTERN	PHIOWD>		;BUG IN DMOVE MACRO

DEFINE SETBIT (BIT,%ADD)<
	SKIPN	RT.PT		;;DO WE NEED TO SET RELOC TABLE?
	JRST	%ADD		;;NO
 %BIT==0
 IRP BIT,<
  IFE BIT,<
	IBP	RT.PT		;;LEAVE 0 THERE
  >
  IFN BIT,<
   IFN BIT-%BIT,<
	MOVEI	T1,BIT		;;BIT PATTERN WE WANT
    %BIT==BIT
   >
	IDPB	T1,RT.PT	;;STORE BIT PATTERN
 >>
 %ADD:	PURGE %BIT
>
SUBTTL	ENTRY POINT

LNKOV2:	JFCL	.+1		;NORMAL ENTRY
	.ERR.	(MS,,V%L,L%I,S%I,OS2,<Overlay segment phase 2>)
	RELEASE	DC,		;CLOSE INPUT I/O
	MOVEI	T1,DC		;FINISHED WITH INPUT BUFFERS NOW
	MOVEM	T1,IO.CHN
	PUSHJ	P,DVRET.##	;RETURN TO FREE POOL
	SETZM	IO.PTR+DC
	MOVE	T1,IO.PTR+%OC	;PSEUDO CHAN#
	MOVE	T2,LODNAM	;GET DEFAULT NAME
	SKIPN	I.NAM(T1)	;DID USER SUPPLY?
	MOVEM	T2,I.NAM(T1)	;NO, USE DEFAULT
	MOVE	T2,VERNUM	;GET VERSION#
	SKIPN	I.VER(T1)	;SKIP IF SET BY SWITCH
	MOVEM	T2,I.VER(T1)
OVR2:	MOVEI	T1,BG.IX	;DONE WITH BOUND GLOBALS
	PUSHJ	P,XX.ZAP##	;SO REMOVE THEM
	SETZM	BG.SCH		;CERTAINLY CAN NOT SEARCH THEM NOW
	HRRZ	T2,BRNLEN	;HIGHEST USED
	HLRE	T1,BRNLEN	;-COUNT OF WHATS LEFT
	SUB	T2,T1		;INITIAL SIZE
	ADDI	T2,1
	HRRZ	T1,BRNTBL	;START ADDRESS
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	HRRZ	T1,BRNDSK
	PUSHJ	P,DY.RET##	;PARALLEL TABLE
	MOVN	T1,LNKMAX	;HIGHEST LINK# ASSIGNED
	HRLI	T1,2		;BLOCK NUMBER OF LINK TABLE
	MOVSM	T1,DI.LPT	;PUT IOWD/USETI PTR IN DIRECTORY
	HRRZ	T2,LNMPTR	;NO. OF LINK NAMES
	MOVN	T1,T2		;- FOR IOWD PART
	LSH	T1,1+^D18	;WORD PAIRS IN LEFT HALF
	LSH	T2,1
	ADD	T2,L.MAX	;NO. USED BY LINK #'S
	CAIL	T2,LN.OVL/2	;ENOUGH SPACE LEFT?
	JRST	[HALT]		;NO
	MOVE	T2,L.MAX	;NO. OF WORDS USED
	LSH	T2,-7		;BLOCKS
	HRRI	T1,2(T2)	;START BLOCK FOR NAMES
	MOVEM	T1,DI.NPT	;STORE IN DIRECTORY
	MOVSI	T1,(POINT 18)
	MOVEM	T1,PRMPTR	;MAKE SURE ITS SET TO INITIAL VALUE
	MOVE	T1,EXTCNT	;THIS MANY EXTERN REQUESTS
	ADDI	T1,^D50		;A FEW SPARE
	IMULI	T1,^D100	;MAKE SURE HASH TABLE NEVER FILLS
	IDIVI	T1,.HS%		;SO WE WOULD HAVE TO REHASH
	MOVEM	T1,HT.PRM
	PUSHJ	P,NPRIME##	;GET NEAREST PRIME#
	MOVE	T1,GS.LB	;GET BASE
	SETZM	(T1)		;PROBABLY JUNK THERE
	HRRM	T1,HT.PTR	;PUT HASH TABLE THERE
	ADD	T1,HT.PRM	;ACCOUNT FOR IT
	MOVEM	T1,GS.PT
	IORI	T1,.IPM		;ROUND UP
	CAMG	T1,GS.AB	;FIT IN WHAT WE HAVE?
	JRST	OVR2A		;YES
	SUB	T1,GS.AB	;NO, GET DIFF
	MOVM	P2,T1		;WHAT WE NEED
	MOVEI	P1,GS.IX	;FROM WHERE
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
	SKIPA	T1,GS.AB	;GS.AB IS NOW SETUP CORRECTLY
OVR2A:	MOVEM	T1,GS.AB
	SUB	T1,GS.PT	;SEE WHATS LEFT
	MOVEM	T1,GS.FR
	AOS	LS.FR		;RESET LS AREA TO USE WORD 0'
	SOS	LS.PT
OVR3:	SETOM	LNKNO.		;SO WE WILL START BACK AT 0
	MOVE	P2,LC.AB	;MAKE SURE ENOUGH CORE FOR 2 BLOCKS
	SUB	P2,LC.LB
	CAIL	P2,377
	JRST	OVR3A		;OK
	MOVEI	P1,LC.IX
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
OVR3A:	AOS	P1,LNKNO.	;PICKUP LINK #
	CAMLE	P1,LNKMAX	;SEE IF FINISHED
	JRST	OVR4		;YES, NOW RATIONALIZE TABLES
	PUSHJ	P,RDCST		;READ IN BLOCK CONTAINING CONTROL SEC.
	  JRST	OVR3A		;GIVE UP SINCE NO EXTTAB OR INTTAB
OVR3C:	SETZB	W1,W3		;NO FLAGS YET
	HLL	R2,CS.EXT	;FORM AOBJN PTR.
	JUMPGE	R2,OVR3I	;DONE IF NONE THERE
OVR3D:	HRRZ	T1,R2		;GET REL ADDRESS
	ADD	T1,LC.LB	;LOCATE
	MOVE	W2,ET.NAM(T1)	;GET NAME
	PUSHJ	P,TRYSYM##	;SEE IF IN TABLE
	  JRST	OVR3F		;NO
	  JFCL			;YES
OVR3E:	ADDI	R2,ET.ZZ-1	;ACCOUNT FOR MULTIPLE WORDS
	AOBJN	R2,OVR3D	;LOOP FOR ALL TABLE
	JRST	OVR3I		;NOW FOR INTTAB

OVR3F:	MOVEI	T2,EI.ZZ	;4 WORD TABLES
	PUSHJ	P,GS.GET##
	MOVX	W1,IT.UDF!<PT.SGN!PT.OTH>_^D18	;NOT YET DEFINED FLAG
	DMOVEM	W1,EI.FLG(T1)	;STORE FLAG & NAME (REST IS ZERO)
	SUB	T1,GS.LB	;REMOVE BASE
	HRL	T1,P3		;HASH TOTAL IN LEFT
	MOVEM	T1,@HT.PTR	;HASH TOTAL ,, REL ADDRESS
	JRST	OVR3E


OVR3I:	HLRE	T2,CS.INT	;GET NO OF WORDS
	JUMPE	T2,OVR3A	;NONE
	IMUL	T2,[-2]		;ACTUALLY 2 WORDS PER ENTRY
	ADDI	T2,1		;PLUS ONE FOR LINK#
	MOVE	T1,LS.FR	;NUMBER OF WORDS FREE
	SUBI	T1,(T2)		;MINUS WHAT WE NEED
	JUMPL	T1,OVR3X	;MUST EXPAND
	MOVEM	T1,LS.FR	;STORE NEW COUNT
	ADDM	T2,LSYM		;COUNT EXTRA WORDS
	MOVE	T3,LS.PT	;GET NEXT FREE
	ADDB	T2,LS.PT
	MOVE	T1,CS.INT
	HRR	T1,CS.NUM	;-COUNT ,, LINK #
	MOVEM	T1,(T3)		;STORE FIRST WORD
	HRRZI	T1,1(T3)	;ACCOUNT FOR IT
	ADD	R2,LC.LB	;FIX SOURCE
	HRL	T1,R2		;FORM BLT PTR
	BLT	T1,-1(T2)	;MOVE ALL WORDS
	JRST	OVR3A		;GET NEXT

OVR3X:	MOVEI	P1,LS.IX
	MOVE	P2,T2
	SUB	P2,LS.FR	;WHAT WE REALLY NEED
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
	JRST	OVR3I		;TRY AGAIN

OVR4:	SETZ	R2,		;START ON FIRST WORD
OVR4A:	HRRZ	T1,R2		;GET REL ADDRESS
	ADD	T1,LS.LB
	MOVE	T1,(T1)		;GET -LENGTH,,LINK#
	HLL	R2,T1		;AOBJN LH
	HRRZM	T1,LNKNO.	;STORE WHO WE ARE
	HRRI	R2,1(R2)	;ACCOUNT FOR WORD
	SETOM	INTCNT		;START AT -1 SO AOS WORKS
OVR4B:	HRRZ	T1,R2
	ADD	T1,LS.LB
	DMOVE	W2,(T1)		;GET NAME AND VALUE
	PUSHJ	P,TRYSYM##	;SEE IF REQUIRED
	  JRST	OVR4C		;NO
	  JFCL
	MOVE	T1,0(P1)	;GET FLAGS
	TXOE	T1,IT.DEF	;SEE IF ALREADY DEFINED
	JRST	OVR4D		;YES, STORE ALL DEFINITIONS
	TXZ	T1,IT.UDF	;NOW DEFINED
	HRR	T1,LNKNO.	;WHICH LINK
	MOVEM	T1,EI.FLG(P1)	;PUT BACK
	HRRZM	W3,EI.VAL(P1)	;VALUE
	AOS	T1,INTCNT	;COUNT NO. IN INTTAB
	HLL	T1,W3		;START OF TABLE
	MOVSM	T1,EI.INT(P1)
OVR4C:	ADDI	R2,1		;WORDS COME IN 2S
	AOBJN	R2,OVR4B	;LOOP FOR ALL THIS LINK
	MOVE	T1,LNKNO.	;GET THIS LINK #
	CAMGE	T1,LNKMAX	;ALL DONE?
	JRST	OVR4A		;NO, GET NEXT LINK
	JRST	OVR5		;YES
;HERE TO HANDLE GLOBAL DEFINED IN MORE THAN 1 LINK
OVR4D:	TXON	T1,IT.MDF	;SIGNAL SO
	MOVEM	T1,0(P1)	;AND STORE BACK
				;NOW MOVE SYMBOL TO NEW LOCATION
	PUSHJ	P,EI.CNT	;SEE HOW LONG IT IS
	ADDI	T2,4		;EXTRA WE NEED
	PUSHJ	P,GS.GET##	;GET NEW BLOCK
	HRRZ	P1,@HT.PTR	;INCASE WE MOVED
	ADD	P1,GS.LB
	EXCH	P1,T1		;PUT NEW BLOCK IN P1 OLD IN T1
	SUBI	T2,EI.LEN	;LENGTH BACK AS IT WAS
	HRLZ	T3,T1
	HRR	T3,P1		;BLT PTR
	HRRZ	T4,P1
	ADDI	T4,(T2)		;END OF BLT +1
	BLT	T3,-1(T4)	;MOVE SYMBOL TO NEW HOME
	MOVE	T3,P1
	SUB	T3,GS.LB	;OFFSET ONLY
	HRRM	T3,@HT.PTR	;MAKE HASH TABLE POINT TO NEW BLOCK
	MOVSI	T3,PT.EXT
	IORB	T3,EI.FLG-EI.LEN(T4)	;SET LAST BLOCK EXTENDED
	TLZ	T3,PT.EXT	;NEW LAST NOT EXTENDED
	HRR	T3,LNKNO.	;WHICH LINK
	MOVEM	T3,EI.FLG(T4)	;SET FLAGS FOR NEW LAST BLOCK
	MOVEM	W2,EI.SYM(T4)	;STORE SYMBOL NAME AGAIN
	HRRZM	W3,EI.VAL(T4)	;VALUE
	AOS	T3,INTCNT	;COUNT NO. IN TABLE
	HLL	T3,W3		;START OF TABLE
	MOVSM	T3,EI.INT(T4)
	PUSHJ	P,GS.RET##	;GIVE BACK OLD BLOCK
	JRST	OVR4C		;AND RETURN

;ROUTINE EI.CNT - TO COUNT LENGTH OF EI SYMBOL BLOCK
;ENTER WITH
;P1 = POINTS TO SYMBOL
;RETURNS
;LENGTH IN T2
;USES T1
EI.CNT:	MOVE	T3,P1		;GET A COPY
	MOVEI	T2,EI.LEN	;LENGTH OF SYMBOL
EICNT1:	MOVE	T1,0(T3)	;GET FLAGS
	TLNN	T1,PT.EXT	;IS IT EXTENDED?
	POPJ	P,		;NO, ALL DONE
	ADDI	T2,EI.LEN		;YES
	ADDI	T3,EI.LEN
	JRST	EICNT1		;ACCOUNT FOR IT AND TRY AGAIN
OVR5:	MOVE	T1,LS.LB	;GET BASE
	SETZM	(T1)
	MOVEM	T1,LS.PT	;MAKE IT ALL FREE
	HRLZ	T2,T1
	HRRI	T2,1(T1)
	BLT	T2,@LS.AB	;CLEAR ALL OF CORE
	IORI	T1,.IPM
	MOVEM	T1,LS.AB	;ALLOCATE ONE BLOCK
	MOVEI	T1,.IPS
	MOVEM	T1,LS.FR	;KEEP FREE SPACE COUNT RIGHT

	SETOM	LNKNO.		;START BACK ON LINK 0
	AOS	T2,BRNMAX	;NEED TABLE OF 1/2 WORD PER LINK ON PATH
	LSH	T2,-1
	ADDI	T2,PH.ZZ	;PLUS SPACE FOR PREAMBLE
	MOVEM	T2,BRNLEN
	PUSHJ	P,DY.GET##
	HRLI	T1,(POINT 18)
	MOVEM	T1,BRNTBL	;STORE ORIGINAL PTR

OVR6:	AOS	P1,LNKNO.	;GET NEXT LINK
	CAMLE	P1,LNKMAX	;SEE IF FINISHED
	JRST	OVR7		;YES
	PUSHJ	P,RDCST		;READ IN BLOCK CONTAINING CONTROL SEC.
	  JRST	OVR6G		;NEITHER EXTTAB NOR INTTAB
	PUSHJ	P,RDREL		;IF RELOCATABLE SETUP RT.PT
	ADD	R2,LC.LB	;CORE WILL NOT MOVE NOW
	SETZB	W1,W3		;SAVE CONFUSION
	HLL	R2,CS.EXT
	JUMPGE	R2,OVR6D	;NO EXTTAB
	HRRZ	P3,CS.EXT	;GET START ADDRESS
	SKIPE	RT.PT		;IS IT RELOCATABLE?
	PUSHJ	P,RT.P3##	;SET UP RT.PT
OVR6C:	MOVE	W2,ET.NAM(R2)	;GET NAME
	PUSHJ	P,TRYSYM##	;LOOK IT UP
	  JRST	OVR6CU
	  JRST	OVR6CU
	MOVE	T2,EI.FLG(P1)	;GET LINK#
	TXNE	T2,IT.MDF	;MULTIPLY-DEFINED?
	JRST	OVR6M		;YES
	SPUSH	<FSTPTR,P3>
	MOVE	P3,P1		;SAVE SYMBOL PTR
	SKIPN	P1,CS.NUM	;ONLY WANT TO LOOK AT TREE ABOVE US
	JRST	OVR6CA		;ALL IS ABOVE ROOT
	PUSHJ	P,TR.WLK##	;THESE ARE ONLY LINKS WE CAN REACH
	JUMPE	P2,[MOVE P2,CS.NUM	;SHOULD NOT HAPPEN
		PUSHJ	P,ER.LNC##]	;BUT!!!
	HLRZ	T1,P1		;GET POINTER
	HRRZ	T1,(T1)		;GET LINK# OF HEAD OF NODE
	CAIE	T1,(P1)		;IF NOT EQUAL THEN REQUIRED NODE IS A TERMINAL ONE
	JRST	OVR6CN		; IN WHICH CASE IT HAS NO SONS
	HLRZM	P1,FSTPTR	;CREATE SUB-TREE PTR
	HRRZ	P1,EI.FLG(P3)	;LINK# WE WANT
	PUSHJ	P,TR.WLK##	;SEE IF WE CAN SEE IT
	JUMPE	P2,OVR6CN	;NOT VISIBLE
OVR6CA:	MOVE	P1,P3		;PUT P1 BACK
	SPOP	<P3,FSTPTR>
OVR6CB:	MOVE	T2,EI.FLG(P1)	;GET LINK #
	HRLM	T2,ET.CST(R2)	;SAVE IT
	HLRZ	T1,EI.INT(P1)	;GET ITEM NO. IN INTTAB
	LSH	T1,1		;2 WORDS PER ITEM
	ADD	T1,EI.INT(P1)	;FIX IT
	HRRZM	T1,ET.INC(R2)	;STORE IT WITH 0 FLAGS
OVR6CC:	SETZM	ET.NAM(R2)	;CLEAR NAME NOW
OVR6CD:	SETBIT	<0,0,1,0>
	ADDI	R2,ET.ZZ-1
	AOBJN	R2,OVR6C	;LOOP FOR ALL OF EXTTAB
	JRST	OVR6D

OVR6CU:	.ERR.	(MS,.EC,V%L,L%F,S%W,USC,<Undefined subroutine >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,< called from link number >)
	.ETC.	(DEC,.EP,,,,CS.NUM)
OVR6CE:	MOVE	T1,ADDOVU	;ADDRESS OF UNDEFINED ROUTINE
	HLRZM	T1,ET.CST(R2)	; AND ROOT CST
	HRLI	T1,(F.LIC)	;ALWAYS IN CORE
	MOVEM	T1,ET.INC(R2)	;TO SAVE TIME AND EFFORT
	JRST	OVR6CD		;IN OVERLAY HANDLER


OVR6CN:	HRRZ	P1,EI.FLG(P3)	;GET LINK #
	.ERR.	(MS,.EC,V%L,L%W,S%W,SNP,<Subroutine >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,< in link number >)
	.ETC.	(DEC,.EC!.EP,,,,P1)
	.ETC.	(STR,.EC,,,,,< not on path for call from link number >)
	.ETC.	(DEC,.EP,,,,CS.NUM)
	MOVE	P1,P3		;RESTORE P1
	SPOP	<P3,FSTPTR>
	JRST	OVR6CE		;AND MAKE IT UNDEFINED AT RUN TIME
OVR6M:	SPUSH	<FSTPTR,P3,P4>
	MOVE	P3,P1		;SAVE SYMBOL PTR
	SETZ	P4,		;KEEP POINTER TO FIRST AVAILABLE SYMBOL
	SKIPN	P1,CS.NUM	;WE ONLY WANT TO LOOK AT TREE ABOVE US
	JRST	OVR6MA		;ALL OF TREE IS ABOVE ROOT
	PUSHJ	P,TR.WLK##	;SINCE THESE ARE THE ONLY LINKS WE
				;CAN REACH, ALL OTHERS ARE NOT AVAILABLE
	JUMPE	P2,[MOVE P2,CS.NUM	;CANNOT HAPPEN
		PUSHJ	P,ER.LNC##]	;BUT!
	HLRZ	T1,P1		;GET POINTER
	HRRZ	T1,(T1)		;GET LINK# OF HEAD OF NODE
	CAIE	T1,(P1)		;IF NOT EQUAL THEN REQUIRED NODE IS A TERMINAL ONE
	SETZB	P1,P2		; IN WHICH CASE IT HAS NO SONS
	HLRZM	P1,FSTPTR	;USE THIS AS START OF SUB TREE
OVR6MA:	HRRZ	P1,EI.FLG(P3)	;GET LINK#
	SKIPE	FSTPTR		;INDICATES NO POSSIBLE SONS
	PUSHJ	P,TR.WLK##	;SEE IF WE CAN GET TO IT
	JUMPE	P2,OVR6MB	;NO, TRY NEXT
	JUMPN	P4,OVR6MC	;NOT FIRST, SO ERROR
	MOVE	P4,P3		;SAVE PTR TO FIRST AVAILABLE
OVR6MB:	MOVE	T1,EI.FLG(P3)	;GET FLAGS
	TLNN	T1,PT.EXT	;MORE TO COME?
	JRST	OVR6MZ		;NO, ITS THE END
	ADDI	P3,4		;GET NEXT
	JRST	OVR6MA		;

OVR6MZ:	MOVE	P1,P4		;UNIQUE SYMBOL
	POP	P,P4
	JUMPE	P1,OVR6CN	;NONE CAN BE REACHED
	SPOP	<P3,FSTPTR>
	JRST	OVR6CB		;RETURN WITH P1 SETUP

OVR6MC:	MOVX	T1,F.MDL	;MARK IT MULTIPLY DEFINED
	IORM	T1,ET.INC(R2)	;IN EXTTAB
	SUB	P4,GS.LB	;INCASE WE MOVE
	SUB	P3,GS.LB
	PUSH	P,P4		;SAVE ORIGINAL
	PUSH	P,P3		;SAVE SECOND DEF
	ADD	P3,GS.LB	;PUT BASE BACK
	MOVEI	P4,2		;COUNT NUMBER IN P4
	JRST	OVR6ME		;GET NEXT

OVR6MD:	HRRZ	P1,EI.FLG(P3)	;GET LINK#
	PUSHJ	P,TR.WLK##	;SEE IF WE CAN GET TO IT
	JUMPE	P2,OVR6ME	;NO, TRY NEXT
	SUB	P3,GS.LB
	PUSH	P,P3		;SAVE IT
	ADDI	P4,1		;ONE MORE
OVR6ME:	MOVE	T1,EI.FLG(P3)	;GET FLAGS
	TLNN	T1,PT.EXT	;MORE TO COME?
	JRST	OVR6MF		;NO, ITS THE END
	ADDI	P3,4		;GET NEXT
	JRST	OVR6MD		;

OVR6MF:	SUB	R2,LC.LB	;CORE MIGHT MOVE
	MOVE	T2,P4		;NO. OF DEFINITIONS
	LSH	T2,1		;2 WORDS EACH
	ADDI	T2,2		;PLUS LINK TO NEXT & NAME
	PUSHJ	P,DY.GET##	;SPACE TO BUILD THE TABLE
	MOVN	P3,P4
	HRLZ	P3,P3
	HRR	P3,T1		;AOBJN WORD
	HRRZ	T1,CS.RLC	;USE THIS TO POINT TO LIST
	HRL	T1,R2		;POINT TO WHICH ONE
	MOVEM	T1,(P3)		;STORE IN FIRST WORD
	HRRZM	P3,CS.RLC	;RESET TO POINT TO THIS FIRST
	ADDI	P3,2		;BYPASS FIRST TWO WORD
	MOVE	T2,P4		;ALSO NEED SPACE TO STORE ERROR MESSAGE
	IMULI	T2,7		;6 CHAR NAME PLUS COMMA
	IDIVI	T2,5		;STORED AS ASCII
	ADDI	T2,1		;FOR PARTIAL WORD
	PUSHJ	P,DY.GET##	;GET SPACE
	MOVE	P1,T1		;PUT IN SAFE PLACE (CANNOT USE STACK)
	HRLI	P1,(POINT 7,)	;FORM BYTE PTR
	HRLZ	P2,T2
	HRR	P2,T1		;SO WE CAN GIVE IT BACK
	ADD	R2,LC.LB	;PUT BASE BACK
	HLLM	P3,ET.CST(R2)	;STORE COUNT BACK IN EXTTAB
	MOVE	T2,ET.NAM(R2)	;GET NAME
	MOVEM	T2,-1(P3)	;STORE IN SECOND WORD
OVR6MG:	POP	P,T4		;GET ADDRESS  BACK
	ADD	T4,GS.LB	;FIX IN CORE
	HRL	T1,EI.FLG(T4)	;GET LINK #
	HRR	T1,ET.CST(R2)	;AND CONTROL SECTION (WILL GET DESTROYED)
	HLRZ	T2,T1		;GET LINK #
	PUSHJ	P,[IDIVI T2,^D10	;USUAL RADIX PRINTER
		HRLM	T3,0(P)		;STORE ON STACK
		SKIPE	T2		;DONE?
		PUSHJ	P,@.		;NOT YET
		HLRZ	T2,0(P)		;RECOVER CHAR
		ADDI	T2,"0"		;MAKE ASCII
		IDPB	T2,P1		;STORE
		POPJ	P,]		;RETURN
	MOVEI	T2,","
	IDPB	T2,P1		;SEPARATOR
	HLRZ	T2,EI.INT(T4)	;GET ITEM NO. IN INTTAB
	LSH	T2,1		;2 WORDS PER ITEM
	ADD	T2,EI.INT(T4)	;FIX IT
	HLL	T2,ET.INC(R2)	;COPY FLAGS
	MOVEM	T2,0(P3)	;STORE
	MOVEM	T1,1(P3)	;...
	ADDI	P3,1
	AOBJN	P3,OVR6MG	;MORE TO DO

	SETZ	T1,		;STORE A NULL
	DPB	T1,P1		;AT END OF STRING
	.ERR.	(MS,.EC,V%L,L%F,S%W,ARL,<Ambiguous request in link  >)
	.ETC.	(DEC,.EC!.EP,,,,CS.NUM)
	.ETC.	(STR,.EC,,,,,< for >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,<, defined in links >)
	.ETC.	(STR,.EP,,,,P1)

	HRRZ	T1,P2
	HLRZ	T2,P2
	PUSHJ	P,DY.RET##	;GIVE SPACE BACK
	SPOP	<P4,P3,FSTPTR>
	JRST	OVR6CC		;GET NEXT SYMBOL
OVR6D:	HLL	R2,CS.INT	;GET NO. OF INTTABS
	JUMPGE	R2,OVR6FA	;NONE
	HRRZ	R3,R2		;USED TO STORE BACK IF REQUIRED
	HRRZ	P3,CS.INT	;GET START ADDRESS
	SKIPE	RT.PT		;IS IT RELOCATABLE?
	PUSHJ	P,RT.P3##	;SET UP RT.PT
OVR6E:	DMOVE	W2,(R2)		;GET SYMBOL & VALUE
	PUSHJ	P,TRYSYM##	;SEE IF WANTED
	  JRST	OVR6F		;NOT IN TABLE SO NOT WANTED
	  HALT
	MOVE	T1,0(P1)	;GET FLAGS
	TXNN	T1,IT.DEF	;SEE IF ITS WANTED
	JRST	OVR6F		;NO
	HRRZM	W3,0(R3)	;STORE PTR AS VALUE
	SETZM	1(R3)		;NO REFS YET
	ADDI	R3,2
	SETBIT	<1,0>,OVR6F
OVR6F:	ADDI	R2,1
	AOBJN	R2,OVR6E	;LOOP
	HRRZ	R2,R2
	CAML	R3,R2		;DID WE REDUCE?
	JRST	OVR6FA		;NO
	HRLZI	T1,0(R3)
	HRRI	T1,1(R3)	;FORM BLT PTR
	SETZM	(R3)		;CLEAR FIRST WORD
	BLT	T1,-1(R2)	;AND REST
	SUB	R3,R2		;SEE BY HOW MUCH WE REDUCED
	MOVM	T1,R3		;+DIFF
	ADD	R2,R3		;BACKUP NEXT FREE PTR
	LSH	T1,^D17		;CUT IN HALF AND PUT IN LHS
	ADDM	T1,CS.INT	;MAKE THIS RIGHT
	SKIPE	SYMSEG		;HOWEVER IF DDT SYMBOLS
	JRST	OVR6FA		;DON'T REDUCE
	ADDB	R3,PH.LEN	;TO THIS MUCH
	MOVN	R3,R3		;NEGATE FOR IOWD
	HRLM	R3,PH.OVL
OVR6FA:	SKIPN	P1,CS.RLC	;ANY MULTIPLY DEF GLOBALS?
	JRST	OVR6G		;NO
	HLRE	R3,CS.INT	;THESE WILL GO AT END OF TABLES
	IMUL	R3,[-2]
	ADD	R3,CS.INT
	JUMPN	R3,OVR6FB	;BUT IF NO INTTAB
	HLRE	R3,CS.EXT	; USE EXTTAB
	IMUL	R3,[-ET.ZZ]
	ADD	R3,CS.EXT
OVR6FB:	MOVE	T1,0(P1)	;GET NEXT PTR
	HRRZM	T1,CS.RLC	;AND SET IT
	HLRZ	P2,T1		;PTR TO EXTTAB BLOCK
	ADD	P2,LC.LB	;IN CORE
	HRRM	R3,ET.CST(P2)	;POINT TO BLOCK OF DEFINITIONS
	HLRE	T1,ET.CST(P2)	;GET LENGTH
	MOVM	T2,T1		;+ LENGTH
	LSH	T2,1		;WORD PAIRS
	ADDI	T2,1		;PLUS ONE FOR NAME
	HRLZI	T1,1(P1)	;FROM (EXCLUDING PTR WORD)
	HRR	T1,R2		; TO
	ADD	R2,T2
	BLT	T1,-1(R2)	;BLT BLOCK
	MOVE	T1,P1
	ADD	R3,T1		;SET FOR NEXT BLOCK
	ADDI	T2,1		;PTR WORD IN FRONT ALSO
	PUSHJ	P,DY.RET##	;RETURN SPACE
	SUBI	T2,1
	MOVE	T1,PH.ADD	;BASE OF LINK
	ADD	T2,PH.LEN	;ACCOUNT FOR IT
	MOVEM	T2,PH.LEN
	ADD	T1,T2		;END OF IT
	MOVN	T2,T2
	HRLM	T2,PH.OVL	;MORE TO SAVE
	HRRZ	T2,OV.S1	;SEE IF WE GOT LARGER
	CAILE	T1,T2		;SINCE IF LINK 0
	HRRM	T1,OV.S1	;WE MUST INCREASE .JBFF
	SKIPN	RT.PT		;RELOCATABLE?
	JRST	OVR6FC		;NO
	MOVEI	T1,1		;SET BIT
	HLRE	T2,ET.CST(P2)	;NO. OF PAIRS
	IBP	RT.PT		;ACCOUNT FOR NAME
	IBP	RT.PT		;INTTAB
	IDPB	T1,RT.PT	;CS IS RELOCATABLE
	AOJL	T2,.-2		;LOOP FOR ALL TABLE
OVR6FC:	SKIPE	P1,CS.RLC	;MORE TO DO?
	JRST	OVR6FA		;TRY AGAIN
;	JRST	OVR6G		;NO

OVR6G:	MOVE	T1,PH.LEN	;GET LENGTH
	HRLM	T1,CS.COR	;INTO CONTROL SECTION
	MOVE	T1,PH.CST	;NOW TO COPY CS BACK
	SUB	T1,PH.ADD
	ANDI	T1,.IPM		;MAKE REL TO THIS BLOCK
	ADD	T1,LC.LB	;FIX IN CORE
	MOVEI	T2,CS.ZZ-1(T1)	;END OF BLT
	HRLI	T1,CS.HDR
	BLT	T1,(T2)		;MOVE IT ALL
	SKIPN	P1,CS.NUM	;NOW SET TO WRITE BACK THIS LINK
	JRST	OVR6GC		;DON'T BOTHER IF LINK 0
	PUSHJ	P,TR.WLK##	;GET PATH
	JUMPE	P2,OVR6GC	;DONE IF NONE LINKED TO IT
	ROT	P2,-1		;STORE 2 LINK# PER WORD
	SKIPGE	P2		;IF A REMAINDER
	ADDI	P2,1		;ADD ONE FOR IT
	MOVEI	T1,PH.ZZ
	HLL	T1,OVLBLK	;AND BLOCK#
	ADDI	P2,-1(T1)	;GET BYTE POINTER TO END
	MOVSM	T1,PH.FPT	;LIST IN FORWARDS DIRECTION
	HRLZM	P2,PH.BPT	;AND IN BACKWARDS DIRECTION
	ADD	P2,BRNTBL	;SO WE CAN STORE BACKWARDS
	TLOE	P2,(1B0)	;SEE WHICH HALF WORD TO START WITH
	IBP	P2		;STORE IN RIGHT HALF ON EVEN P2
	MOVS	T1,P1		;GET POINTER BACK
	HRRZ	T2,(T1)		;GET LINK #
	CAIN	T2,(P1)		;POINTING TO NON-TERMINAL LINK?
	MOVE	T1,1(T1)	;YES, GET BACK POINTER
	SETZM	(P2)		;MAKE SURE LAST LINK IS 0
OVR6GA:	HRRZ	T2,(T1)		;LINK#
	JUMPE	T2,OVR6GB	;DONE WHEN BACK TO 0
	IDPB	T2,P2		;STORE IT
	MOVE	T1,1(T1)	;GET BACK POINTER
	SOJA	P2,OVR6GA	;LOOP

OVR6GB:	HLRZ	T2,PH.BPT	;REL START IN BACK DIRECTION
	LSH	T2,-7		;IN BLOCKS
	HLRZ	T1,OVLBLK	;GET STARTING BLOCK#
	ADDI	T2,(T1)		;ACCOUNT FOR EXTRA BLOCKS USED (PERHAPS)
	HRRM	T2,PH.BPT	;AND STORE BLOCK#
OVR6GC:	USETO	OC,(R1)		;RESET BACK TO BLOCK WE NEED
	MOVE	T1,LC.LB
	SUBI	T1,1
	HLRZ	T2,R1		;GET NO. OF WORDS TO OUTPUT
	MOVN	T2,T2
	HRL	T1,T2		;IOWD
	SETZ	T2,
	OUT	OC,T1		;OUTPUT IT
	  JRST	OVR6H
	PUSHJ	P,ER.OOV##	;OUTPUT ERROR
OVR6H:	SKIPN	RT.PT		;RELOC TABLE TO PUT OUT?
	JRST	OVR6S		;NO
	HRRZ	P3,PH.CST
	ADDI	P3,CS.PTR-CS.HDR+1	;BYPASS KNOWN ZEROS AND FIRST IBP
	PUSHJ	P,RT.P3##	;RESET IT
	MOVEI	T1,1		;RELOC BIT
	MOVE	T2,[CS.PTR-CS.HDR+1-CS.ZZ,,CS.PTR]	;AOBJN PTR
	SKIPE	0(T2)		;NEED TO RELOC
	DPB	T1,RT.PT	;YES
	IBP	RT.PT		;ADVANCE
	AOBJN	T2,.-3		;FOR ALL TABLE
	MOVE	T1,PH.ADD	;WHERE ADDRESS WOULD BE
	MOVE	T2,PH.CST	;BUT THIS IS LOWEST ADDRESS WE CARE ABOUT
	SUB	T2,T1		;I.E CST PLUS TABLES
	IDIVI	T2,^D128*^D18	;BYTES PER DSK BLOCK
	MOVE	T3,T2		;NO. OF WHOLE BLOCKS TO SKIP
	ADD	T3,PH.REL	;PLUS FIRST
	USETO	OC,(T3)		;SET ON IT
	IMULI	T2,^D128	;NO. OF WORDS TO SKIP
	HLRE	T1,PH.REL	;NO. OF WORDS ORIGINALLY
	ADD	T1,T2		;NO. LEFT
	HRLZ	T1,T1		;LHS OF IOWD
	HRR	T1,RT.LB
	HRRI	T1,-1(T1)	;IOWD AT LAST
	SETZ	T2,
	OUT	OC,T1
	  JRST	OVR6S		;OK
	PUSHJ	P,ER.IOV##
OVR6S:	SKIPE	R,SYMSEG	;WANT TO KEEP SYMBOLS?
	SKIPN	T1,PH.SYM	;YES, BUT MAKE SURE THERE ARE SOME
	JRST	OVR6P		;NO
	SETZM	USYM		;THERE ARE NO UNDEFINED SYMBOLS IN THIS TABLE
	USETI	OC,(T1)		;SET ON SYMBOL BLOCK
	HLRE	T1,T1		;SIZE WE NEED
	MOVE	P2,LS.UB
	MOVEM	P2,LS.AB	;USE IT ALL
	SUB	P2,LS.LB	;SIZE WE HAVE
	ADD	P2,T1		;GET DIFF
	JUMPGE	P2,OVR6S1	;IS IT ENOUGH
	MOVEI	P1,LS.IX	;NO, GET AREA
	MOVM	P2,P2		;AND SIZE
	PUSHJ	P,LNKCOR##	;EXPAND
	  PUSHJ	P,NO.COR##	;TOO BAD
OVR6S1:	HLRE	T1,PH.SYM	;GET -LENGTH AGAIN
	MOVM	T1,T1
	MOVE	T2,LS.UB	;TOP
	MOVEM	T2,LS.AB	;MAKE SURE THE SAME
	IORI	T1,.IPM		;ROUND UP
	SUB	T2,T1		;FIND WHERE LOWER BOUND SHOULD BE
	CAMN	T2,LS.LB	;ARE WE USING IT ALL
	JRST	.+3		;YES
	MOVEI	T1,-1(T2)	;HIGHEST TO GIVE BACK
	PUSHJ	P,GBCK.L##	;WILL RESET LS.LB
	MOVE	T1,LS.LB	;WHERE TO READ INTO
	SUBI	T1,1
	HLL	T1,PH.SYM	;IOWD
	SETZ	T2,
	IN	OC,T1		;READ BACK SYMBOLS
	  SKIPA	T1,LSYM		;OK, NOW TO RESET LAST SYM PTR
	PUSHJ	P,ER.IOV##	;ERROR
	SUB	T1,LW.LS	;SHOULD BE 0
	ADD	T1,LS.LB	;OFFSET IN CORE
	MOVEM	T1,LS.PT
	MOVE	T2,T1
	IORI	T2,.IPM		;MAKE SURE ON BLOCK BOUND
	SUBI	T2,(T1)		;FIND WHATS FREE
	MOVEM	T2,LS.FR	;AND STORE IT
	MOVEI	T1,.IPS		;SIZE WE CARE ABOUT
	SUB	T1,T2		;MINUS FREE
	PUSHJ	P,LSOVX##	;STORE WHATS LEFT FOR LNKXIT
				;NOW FOR LC AREA
				;WE ACTUALLY NEED ABOUT 2/3 THE LS SPACE
				;JUST ALLOCATE 1 BLOCK WE WILL EXPAND AS REQUIRED
	HRRZ	T1,TAB.LB(R)
	HRL	T1,T1
	HRRI	T1,1(T1)	;FORM BLT PTR
	SETZM	-1(T1)
	BLT	T1,@TAB.AB(R)	;ZERO AREA
	MOVE	T1,TAB.LB(R)	;NOW RESET ACTUAL BOUND
	MOVEM	T1,TAB.PT(R)	;ALSO FREE POINTER
	IORI	T1,.IPM		;USING ONLY ONE BLOCK
	MOVEM	T1,TAB.AB(R)
	MOVEI	T1,.IPS		;NO. OF FREE WORDS
	MOVEM	T1,TAB.FR(R)	;IN THIS BLOCK
	MOVE	P3,PH.ADD	;SYMBOL TABLE STARTS AT REL 0
	SETZM	OVLOFF		; TO FAKE OUT RT.P3
	SKIPN	RT.PT		;RELOCATABLE?
	JRST	OVR6L		;NO
	PUSHJ	P,RT.P3##	;YES, SETUP PTR
	MOVE	T1,RT.LB	;YES, MUST ZERO PREVIOUS JUNK
	HRL	T1,T1
	ADDI	T1,1
	SETZM	-1(T1)
	BLT	T1,@RT.AB	;AT LAST ITS DONE
OVR6L:	PUSHJ	P,LSLOOP##	;YES
	MOVE	T2,TAB.PT(R)	;FINAL LENGTH
	SUB	T2,TAB.LB(R)	;
	MOVN	T1,T2		;- LENGTH OF SYMBOLS
	HRLZ	T1,T1		; IN LHS FOR IOWD
	HRR	T1,OVLBLK	;BLOCK NUMBER
	MOVEM	T1,PH.RDX	;POINTER TO RADIX-50 SYMBOLS
	USETO	OC,(T1)		;SET ON IT
	ADDI	T2,.IPS
	LSH	T2,-7		;NO. OF BLOCKS
	ADDM	T2,OVLBLK	;ACCOUNT FOR THEM
	HRR	T1,TAB.LB(R)	;START OF CORE TO OUTPUT
	HRRI	T1,-1(T1)	;-1 OF COURSE
	SETZ	T2,		;TERMINATOR
	OUT	OC,T1		;OUTPUT IT
	  JRST	OVR6R		;OK
	PUSHJ	P,ER.OOV##	;FAILED

OVR6R:	SKIPN	T1,RT.PT	;ANY RELOCATION TABLES
	JRST	OVR6P		;NO
	MOVEI	T1,1(T1)	;TOP
	SUB	T1,RT.LB	;- BOTTOM
	MOVEI	T2,200(T1)	;MAKE INTO FULL BLOCKS (+ REMAINDER)
	MOVN	T1,T1		;-LENGTH
	HRLZ	T1,T1		; IN LHS FOR IOWD
	HRR	T1,OVLBLK	;POINT TO NEXT FREE BLOCK
	MOVEM	T1,PH.RDR	;STORE PTR
	USETO	OC,(T1)		;SET ON IT
	LSH	T2,-7		;INTO BLOCKS
	ADDM	T2,OVLBLK	;ACCOUNT FOR THEM
	HRR	T1,RT.LB	;BASE
	HRRI	T1,-1(T1)	;IOWD
	SETZ	T2,
	OUT	OC,T1		;OUTPUT
	  JRST	OVR6P		;FINISHED
	PUSHJ	P,ER.OOV##	;ERROR

OVR6P:	HLRZ	T1,OVLBLK	;BLOCK # OF PREAMBLE
	USETO	OC,(T1)		;SET BACK TO IT
	DMOVE	T1,PHIOWD
	SKIPN	T3,PH.BPT	;DO WE HAVE TO OUTPUT THE PATH?
	JRST	OVR6Z		;NO
	MOVN	T1,T3		;NEGATE
	HRLI	T3,PH.HDR	;SINCE GATHER WRITE DOESN'T WORK
	HRR	T3,BRNTBL	;WE MUST BLT THE STUFF TOGETHER
	HRRI	T1,-1(T3)	;COMPLETE IOWD
	BLT	T3,PH.ZZ(T1)
OVR6Z:	OUT	OC,T1
	  JRST	OVR6X		;NOW FIXUP CS.DDT IF REQUIRED
	PUSHJ	P,ER.OOV##	;OUTPUT ERROR

OVR6X:	SKIPN	PH.RDX		;ANY RADIX-50 SYMBOLS
	JRST	OVR6		;NO, LOOP FOR ALL LINKS
	HRRZ	R1,PH.OVL	;BLOCK# OF CODE SECTION
	MOVE	T3,PH.CST	;ADDRESS OF HEADER
	SUB	T3,PH.ADD	;MINUS BASE
	ROT	T3,-7		;CONVERT TO BLOCKS
	ADDI	R1,(T3)		;POINT TO IT
	USETI	OC,(R1)		;SET ON IT
	LSH	T3,-35		;ANDI 177 WITH ORIGINAL T3
	MOVEI	T1,CS.DDT-CS.HDR(T3)	;GET NO. OF WORDS TO END
	IORI	T1,177		;INCASE IT CROSSES BLOCK BOUND
	MOVNI	T1,1(T1)	;IOWD
	HRL	T1,T1
	HRR	T1,LC.LB
	HRRI	T1,-1(T1)	;AT LAST
	SETZ	T2,
	IN	OC,T1
	  TDOA	T3,LC.LB		;ADDRESS OF CS.HDR
	PUSHJ	P,ER.IOV##
	MOVE	T2,PH.RDX	;GET SYMBOL TABLE PTR
	MOVEM	T2,CS.DDT-CS.HDR(T3)	;STORE
	USETO	OC,(R1)		;SET BACK
	SETZ	T2,
	OUT	OC,T1		;WRITE IT BACK
	  JRST	OVR6		;LOOP
	PUSHJ	P,ER.OOV##

OVR7:	MOVE	T1,[0,,DI.ZZ]	;CODE ,, LENGTH
	MOVEM	T1,DI.HDR
	MOVE	T1,VERNUM	;GET VERSION#
	MOVEM	T1,DI.VER	;INTO DIRECTORY
	USETO	OC,1		;NOW FOR DIRECTORY BLOCK
	SKIPA	T1,.+1
	IOWD	DI.ZZ,DI.HDR	;VERY LOCAL CODE
	SETZ	T2,
	OUT	OC,T1
	  CAIA
	PUSHJ	P,ER.OOV##	;OUTPUT ERROR
	MOVN	T1,L.MAX	;GET MAX LINKS ALLOWED
	HRLZ	T1,T1
	HRR	T1,LNKTBL	;ADDRESS OF IT
	HRRI	T1,-1(T1)	;IOWD
	SETZ	T2,
	OUT	OC,T1
	  CAIA
	PUSHJ	P,ER.OOV##	;OUTPUT ERROR
;NOW FOR LINK NAMES, THERE WILL BE AT LEAST ONE (ROOT)
	MOVE	T1,DI.NPT	;GET AOBJN/USETO PTR
	USETO	OC,(T1)		;WHERE WE WILL START OUTPUT
	HLRE	T1,T1		;- NO. OF WORDS
	MOVM	T2,T1
	PUSHJ	P,DY.GET##	;GET BUFFER
	SUBI	T1,1		;BACKUP
	HLL	T1,DI.NPT	;FORM IOWD
	PUSH	P,T1		;SAVE I/O WORD FOR LATER
	MOVS	T2,LNMPTR	;GET INITIAL PTR TO NAMES
OVR7A:	DMOVE	T3,(T2)		;GET NAME AND LINK #
	HRRZ	T2,T4		;GET NEXT
	HLRZM	T4,1(T1)	;STORE NUMBER
	MOVEM	T3,2(T1)	; AND NAME
	JUMPE	T2,OVR7B	;END
	AOBJN	T1,.+1		;INCREMENT 
	AOBJN	T1,OVR7A	;TWICE
	HALT			;ERROR
OVR7B:	POP	P,T1		;GET BACK IOWD
	SETZ	T2,
	OUT	OC,T1		;OUTPUT IT
	  CAIA			;OK
	PUSHJ	P,ER.OOV##	;ERROR
	HLRE	T2,T1		;GET BACK LENGTH
	MOVM	T2,T2
	HRRZI	T1,1(T1)	;ADDRESS
	PUSHJ	P,DY.RET##
	SKIPE	IO.PTR+%VC	;SAVE SWITCH SEEN?
	JRST	OVR8		;YES
	MOVEI	T2,F.LEN	;NO, FAKE IT
	PUSHJ	P,DY.GET##	;SPACE FOR FILE SPEC
	MOVEM	T1,IO.PTR+%VC
	HRLZ	T2,IO.PTR+%OC
	HRR	T2,T1
	BLT	T2,F.LEN-1(T1)	;COPY OVERLAY SPEC
	MOVSI	T2,'HGH'	;ASSUME NOT SHAREABLE
	MOVEM	T2,I.EXT(T1)	; BUT MIGHT BE TWO SEG
	MOVEM	T2,SSEXT
	MOVE	T2,I.NAM(T1)	;GET OVERLAY NAME
	MOVEM	T2,SSNAME
	SETZM	I.EST(T1)

OVR8:	MOVE	T2,BRNLEN
	HRRZ	T1,BRNTBL
	PUSHJ	P,DY.RET##	;GIVE SPACE BACK
	MOVE	T1,MAPSW	;SEE IF WE WANT A MAP
	CAMN	T1,[$MAPEND]	;AT THE END
	PUSHJ	P,LNKMAP	;YES
	MOVEI	T1,GS.IX	;WE CAN NOW REDUCE CORE
	PUSHJ	P,XX.ZAP##	;DELETE GLOBALS
	MOVEI	T1,FX.IX
	PUSHJ	P,XX.ZAP##	;AND FIXUP SPACE
	SKIPN	R,SYMSEG	;SAVING DDT SYMBOLS?
	JRST	OVR8B		;NO
	SETZ	P1,		;READ BACK
	PUSHJ	P,INPH		; ROOT PREAMBLE
	SKIPN	T1,PH.RDX	;MAKE SURE ITS SETUP
	JRST	LNKXIT		;NO?
	USETI	OC,(T1)		;SET ON BLOCK
	HLRE	T1,T1		;-SIZE WE NEED
	MOVE	P2,LS.UB
	MOVEM	P2,LS.AB	;USE IT ALL
	SUB	P2,LS.LB	;SIZE WE HAVE
	ADD	P2,T1		;GET DIFF
	JUMPGE	P2,OVR8A	;IS IT ENOUGH
	MOVEI	P1,LS.IX	;NO, GET AREA
	MOVM	P2,P2		;AND SIZE
	PUSHJ	P,LNKCOR##	;EXPAND
	  PUSHJ	P,NO.COR##	;TOO BAD
OVR8A:	MOVE	T2,LS.UB	;GET TOP
	MOVEM	T2,LS.AB	;ALLOCATE IT ALL
	HLRE	T1,PH.RDX	;GET -LENGTH
	MOVM	T1,T1		;+
	IORI	T1,.IPM		;ROUND UP
	SUB	T2,T1		;FIND WHERE BOUND SHOULD BE
	CAMN	T2,LS.LB	;USED IT ALL?
	JRST	.+3		;YES
	MOVEI	T1,-1(T2)	;HIGHEST TO GIVE BACK
	PUSHJ	P,GBCK.L##
	MOVE	T1,LS.LB	;BASE
	SUBI	T1,1
	HLL	T1,PH.RDX	;IOWD
	SETZ	T2,
	IN	OC,T1
	  JRST	LNKXIT		;OK, NOW EXIT
	PUSHJ	P,ER.IOV##	;ERROR

OVR8B:	MOVEI	T1,LS.IX	;NOW DELETE LOCAL SYMBOLS
	PUSHJ	P,XX.ZAP##	;TO GET AS MUCH SPACE AS POSSIBLE
	JRST	LNKXIT		;EXIT
RDCST::	PUSHJ	P,INPH		;READ IN PREAMBLE
	HRRZ	R1,PH.OVL	;BLOCK# OF CODE SECTION
	MOVE	T3,PH.CST	;ADDRESS OF CONTROL SECTION
	SUB	T3,PH.ADD	;MINUS BASE
	ROT	T3,-7		;CONVERT INTO BLOCKS
	ADDI	R1,(T3)		;POINT TO BLOCK CONTAINING THE CONTROL SECTION
	USETI	OC,(R1)		;SET ON IT
	LSH	T3,-35		;EQUIVALENT TO ANDI 177 WITH ORIGINAL T3
	MOVEI	T1,CS.ZZ(T3)	;GET NO. OF WORDS TO END
	IORI	T1,177		;INCASE CROSSES BLOCK BOUND
	HRLI	R1,1(T1)	;HOW MANY WORDS WE WILL READ
	MOVNI	T1,1(T1)
	HRL	T1,T1		;LH OF IOWD
	HRR	T1,LC.LB	;SAFE PLACE TO READ IT INTO
	HRRI	T1,-1(T1)	;AN IOWD AT LAST
	SETZ	T2,
	IN	OC,T1		;NOW FOR DATA
	  CAIA
	PUSHJ	P,ER.IOV##	;INPUT ERROR
	ADD	T3,LC.LB	;POINT TO FIRST CS WORD
	HRLZ	T1,T3
	HRRI	T1,CS.HDR	;FORM BLT WORD
	BLT	T1,CS.HDR+CS.ZZ-1
	HLRE	T1,CS.EXT	;NO. OF EXTTAB
	HLRE	T2,CS.INT	;SAME FOR INTTAB
	IMUL	T1,[-ET.ZZ]	;+ NUMBER OF WORDS
	IMUL	T2,[-2]		;
	ADD	T1,T2		;TOTAL NO. WE NEED
	HRRZ	T2,CS.EXT	;START OF EXTTABS
	JUMPN	T2,.+3		;MIGHT BE ZERO IF END OF PATH
	HRRZ	T2,CS.INT	;SO TRY INTTAB
	JUMPE	T2,CPOPJ	;GIVE UP IF NEITHER!
	SUB	T2,PH.ADD	;REL TO START OF FIRST BLOCK
	MOVE	R2,T2		;REL START OF EXTTAB
	ADD	T1,T2		;TOTAL WORDS WE NEED
	IORI	T1,177		;UPTO DSK BLOCK BOUND
	MOVE	T2,PH.CST	;NOW GET ADDRESS OF CS
	SUB	T2,PH.ADD	;REL TO LINK ORIGIN
	ANDCMI	T2,177		;ADDRESS OF FIRST LOC IN CORE
	SUB	R2,T2		;THENCE OFFSET TO EXTTAB
	HLRZ	T3,R1		;WORDS ALREADY READ
	ADDI	T2,-1(T3)	;WE HAVE THIS MUCH IN CORE ALREADY
	SUB	T1,T2		;SEE IF WE HAVE IT ALL
	JUMPE	T1,CPOPJ1	;YES
	ADD	T3,T1		;NEW WORDS COUNT
	HLRZ	P3,R1		;SAVE PREVIOUS SIZE
	HRL	R1,T3		;SAVE EXCESS
	MOVE	P2,LC.AB	;NOW SEE IF WE HAVE ENOUGH ROOM
	SUB	P2,LC.LB
	ANDCMI	P2,177		;THIS WE ALREADY HAVE
	CAMG	T1,P2		;WILL IT FIT?
	JRST	RDCST1		;YES
	MOVEI	P1,LC.IX
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
	HLRZ	T1,R1		;RESET EXCESS SIZE
RDCST1:	MOVN	T1,T1		;USUAL CODE TO MAKE IOWD PTR
	HRL	T1,T1
	HRR	T1,LC.LB
	ADDI	T1,-1(P3)	;BYPASS WHAT WE ALREADY HAVE
	SETZ	T2,
	IN	OC,T1		;INPUT EXTTAB & INTTAB
CPOPJ1:	  AOSA	(P)
	PUSHJ	P,ER.IOV##	;INPUT ERROR
CPOPJ:	POPJ	P,

INPH::	ROT	P1,-1		;CUT IN HALF
	MOVE	T1,@LNKTBL	;PICKUP BLOCK #
	SKIPL	P1		;PICK CORRECT HALF
	MOVS	T1,T1
	ROT	P1,1		;PUT IT BACK
	USETI	OC,(T1)
	HRLM	T1,OVLBLK	;STORE BLOCK# OF PREAMBLE
	DMOVE	T1,PHIOWD
	IN	OC,T1		;INPUT PREAMBLE
	  POPJ	P,
	PUSHJ	P,ER.IOV##	;INPUT ERROR
RDREL:	SETZM	RT.PT		;ASSUME NOT RELOCATABLE
	SKIPN	PH.REL		;IS IT RELOCATABLE?
	POPJ	P,		;NO
	MOVE	T1,PH.ADD	;WHERE ADDRESS WOULD BE
	MOVE	T2,PH.CST	;BUT THIS IS LOWEST ADDRESS WE CARE ABOUT
	SUB	T2,T1		;I.E CST PLUS TABLES
	IDIVI	T2,^D128*^D18	;BYTES PER DSK BLOCK
	MOVE	T3,T2		;NO. OF WHOLE BLOCKS TO SKIP
	ADD	T3,PH.REL	;PLUS FIRST
	USETI	OC,(T3)		;SET ON IT
	IMULI	T2,^D128	;NO. OF WORDS TO SKIP
	MOVEM	T2,OVLOFF	;SET BASE OFFSET
	HLRE	T1,PH.REL	;NO. OF WORDS ORIGINALLY
	ADD	T1,T2		;NO. LEFT
	JUMPGE	T1,[HALT .]	;ERROR
	MOVM	T2,T1		;+ NO.
	HRLZ	T1,T1		;LHS OF IOWD
	SUB	T2,RT.AB
	ADD	T2,RT.LB	;SEE IF ENOUGH SPACE
	JUMPLE	T2,RDREL1	;YES
	DMOVE	P1,T1		;SAFE PLACE FOR IOWD & COUNT
	PUSHJ	P,RT.INC##	;EXPAND BY 1 BLOCK
	SUBI	P2,.IPS		;SHOULD BE ENOUGH
	JUMPG	P2,.-2		;LOOP IF NOT
	MOVE	T1,P1		;RECOVER IOWD
RDREL1:	HRR	T1,RT.LB
	HRRI	T1,-1(T1)	;IOWD AT LAST
	SETZ	T2,
	IN	OC,T1
	  SOSA	RT.PT		;MAKE NON-ZERO
	PUSHJ	P,ER.IOV##
	POPJ	P,		;AREA IS NOW SETUP

OV2LIT:

END	LNKOV2

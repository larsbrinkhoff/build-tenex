TITLE	LNKMAP - MAP MODULE FOR LINK-10
SUBTTL	D.M.NIXON/DMN		1-JUL-74	


;***COPYRIGHT 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKMAP
SEARCH	LNKPAR,LNKLOW,C,SCNMAC
EXTERN	LNKFIO,LNKXIT,LNKLOD,LNKLOG,LNKCOR,.TYOCH



CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==205		;DEC EDIT VERSION


VERSION


SALL
SEGMENT

SUBTTL	REVISION HISTORY

;START OF VERSION 1A
;47	INTEGRATE WITH SCAN %4, ADD DATE75 HACK
;54	ADD KIONLY D.P. INST.
;55	PUT VERSION# IN .RBVER OF MAP FILE
;63	PUT MULTIPLY-DEFINED SYMBOLS IN MAP
;104	PUT FAIL BLOCKS OUT ON MAP

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;144	(12772) FIX LOOP IF MORE THAN 1 SFD
;160	(12736) ADD WORDS FREE IN EACH SEGMENT TO MAP OUTPUT
;205	ADD NO. OF GLOBALS AND MIN. HASH SIZE TO MAP OUTPUT
SUBTTL	HEADER LINES

LNKMAP:	JFCL	.+1		;INCASE CCL
	.ERR.	(MS,0,V%L,L%I,S%I,MPS,<MAP segment>)
	ZAPTMP			;CLEAR DATA AREA
	SETOM	LS.PP		;PROHIBIT DEFAULT PAGING OF SYMBOL TABLE
	AOS	SYMPTR		;SKIP INITIAL ZERO
	PUSHJ	P,RDVER		;SET UP VERSION # IN MAPVER
	MOVEI	T1,MC		;SET IO.CHN
	MOVEM	T1,IO.CHN	;TO MAP CHAN#
	MOVE	T1,IO.PTR+MC	;GET DATA BLOCK
	SKIPN	T2,VERNUM	;GET VERSION FROM SWITCH
	MOVE	T2,MAPVER	;OR VERSION FROM CORE
	SKIPN	I.VER(T1)	;BUT NOT IF SET IN FILE
	MOVEM	T2,I.VER(T1)	;PUT IN .RBVER
	SKIPN	T2,I.NAM(T1)	;GET USER OR DEFAULT NAME
	PUSHJ	P,DVNAM.##	;SET DEFAULT
	MOVEM	T2,MAPNAM	;FOR HEADER INFO
	PUSHJ	P,DVCHK.##	;GET DEVCHR AGAIN
	MOVE	T2,IO.CHR	;GET DEVCHR WORD
	TXNE	T2,DV.TTY	;IF TTY
	JRST	.+3		;IGNORE INIT & ENTER
	PUSHJ	P,DVOPN.##	;OPEN MAP DEVICE
	PUSHJ	P,DVENT.##	;AND ENTER FILE NAME
	MOVE	T1,IO.PTR+MC	;GET POINTER BACK
	SKIPN	I.RNG(T1)	;IS THERE SOME BUFFERS
	TDZA	T1,T1		;NO, MUST BE TTY
	MOVEI	T1,MAPIT	;SOSGE ROUTINE FOR MAP (0 IF TTY)
	PUSHJ	P,.TYOCH##	;INIT OUTPUT
	MOVEM	T1,OLDDEV	;SAVE OLD .TYOCH RETURN INCASE ERROR
	MOVEI	T1,LN.LPP	;NO OF LINES PER PAGE
	MOVEM	T1,CNTLPP
LNKMP1:	MOVEI	T1,HEAD1	;NORMAL HEADER
	MOVEM	T1,PAGHDR	;FOR PAGES
	PUSHJ	P,.TYHDR	;TYPE HEADER LINE
	MOVEI	T1,HEAD2
	PUSHJ	P,.TSTRG##
	MOVSI	T1,.		;FIND OUT WHERE WE ARE
	SKIPL	T1		;SHOULD BE IN HIGH SEG
	SKIPA	T1,.JBVER	;NO, GET LOW VERSION
	MOVE	T1,%HISEG+.JBHVR	;HIGH SEG VER
	PUSHJ	P,.TYVER##	;TYPED IN VERSION FORMAT
	MOVEI	T1,[ASCIZ	\ on \]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TDATN##	;DAY
	MOVEI	T1,[ASCIZ	\ at \]
	PUSHJ	P,.TSTRG##	;
	PUSHJ	P,.TTIMN##	;TIME
	PUSHJ	P,.TYLPP	;END LINE
	PUSHJ	P,.TYLPP	;BLANK LINE
	SETZ	R1,		;NOW FOR PER-SEGMENT STUFF
IFN FTOVERLAY,<
	AOS	FSTPGN		;INCASE NO OVERLAYS, START ON PAGE 1
	SKIPGE	T2,LNKMAX	;ANY OVERLAYS?
	JRST	SEGSTF		;NO
	LSH	T2,-1
	ADDI	T2,1		;TAKE CARE OF ODD#
	PUSHJ	P,DY.GET##	;GET SPACE FOR NO. INDEX
	HRLI	T1,T1		;PUT T1 IN INDEX FIELD
	MOVEM	T1,OVMIDX
	SETZM	LNKNO.		;START AT LINK# 0
	JRST	OVMAP1
OVMAP0:	SETZM	CNTLPP		;START ON NEW PAGE
	MOVEI	T1,HEAD1	;RESET HEADER LINE
	MOVEM	T1,PAGHDR
	PUSHJ	P,.TYLPP	;NEW PAGE & HEADER LINE
	MOVEI	T1,1
	MOVEM	T1,SYMPTR	;RESET SYMBOL PTR
	SKIPN	T2,PRGNO	;NO. OF PROGRAMS
	JRST	OVMAP1		;NONE
	LSH	T2,1		;2 WORDS EACH
	HRRZ	T1,MDLIDX	;GIVE BACK TITLE BUFFER
	PUSHJ	P,DY.RET##
OVMAP1:	MOVE	P1,LNKNO.
	PUSHJ	P,RDCST##	;READ THE PREAMBLE & CS FOR THIS LINK
	  JFCL			;NEITHER EXTTAB NOR INTTAB
	MOVE	T1,OV.S1	;LENGTH
	HRRM	T1,HL.S1	;SO BOUNDS COME OUT RIGHT
	MOVEI	T1,[ASCIZ	\	Overlay no.	\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,LNKNO.	;GET THIS ONE
	PUSHJ	P,.TDECW##	;LIST IN DECIMAL
	SKIPN	PH.NAM		;SEE IF NAME
	JRST	OVMAP2		;NO
	MOVEI	T1,[ASCIZ	\	name	\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,PH.NAM	;GET NAME
	PUSHJ	P,.TSIXN##	;IN SIXBIT
OVMAP2:	PUSHJ	P,.TYLPP
;SEGMENT LENGTHS
	SETZ	R1,		;MAKE SURE R IS CORRECT
SGSTF0:	PUSHJ	P,.TTABC##
	MOVEI	T1,SEG0(R1)
	PUSHJ	P,.TSTRG##
	MOVEI	T1,SEG1
	PUSHJ	P,.TSTRG##
	HRRZ	T1,PV.S1(R1)	;STARTS AT
	PUSHJ	P,.T6OCT##
	MOVEI	T1,SEG2
	PUSHJ	P,.TSTRG##
	HRRZ	T1,OV.S1(R1)	;ENDS AT
	SKIPE	T1
	SUBI	T1,1		;ONE LESS THAN PROG BREAK
;	ADD	T1,LL.S1(R1)	;DON'T FORGET OFFSET
	PUSHJ	P,.T6OCT##
	MOVEI	T1,SEG3
	PUSHJ	P,.TSTRG##
	HRRZ	T1,OV.S1(R1)
	HRRZ	T2,PV.S1(R1)	;PREVIOUS
	SUB	T1,T2		;DIFFERENCE
	PUSH	P,T1		;SAVE IT
	PUSHJ	P,.T6OCT##	;LENGTH IN OCTAL
	MOVEI	T1,[ASCIZ	\ = \]
	PUSHJ	P,.TSTRG##
	POP	P,T1		;LENGTH BACK
IFN FTVM!FTENEX,<
	JUMPE	T1,.+3		;LEAVE 0 ALONE
	IORI	T1,.PGSIZ	;ALWAYS PAGES
	ADDI	T1,1
>
IFE FTVM!FTENEX,<
	MOVE	T2,.PGSIZ	;P OR K BOUND
	JUMPE	T1,.+3		;LEAVE 0 ALONE
	IOR	T1,T2
	ADDI	T1,1
	CAIE	T2,777		;PAGES?
	JRST	[LSH	T1,-^D10	;K
		PUSHJ	P,.TDEC3	;IN DECIMAL
		MOVEI	T1,"K"
		JRST	SGSTF1]	
>;END OF IFE FTVM!FTENEX
	LSH	T1,-^D9		;P
	PUSHJ	P,.TDEC3	;IN DECIMAL
	MOVEI	T1,"P"
SGSTF1:	PUSHJ	P,.TCHAR##
	PUSHJ	P,.TYLPP
	JUMPN	R1,OVMP2A	;DONE HIGH SEG ALREADY?
	HRRZ	T1,OV.S2	;NO, BUT IS THERE ANY HIGH SEGMENT?
	HRRZ	T2,PV.S2
	SUB	T1,T2
	SKIPE	T1		;NO
	AOJA	R1,SGSTF0	;NOW FOR HIGH SEG

OVMP2A:	MOVEI	T1,[ASCIZ	\	Control Block address is \]
	PUSHJ	P,.TSTRG##
	HRRZ	T1,PH.CST
	PUSHJ	P,.T6OCT##
	MOVEI	T1,[ASCIZ	\, length \]
	PUSHJ	P,.TSTRG##
	HLRE	T1,CS.INT	;LENGTH OF INTTAB
	JUMPE	T1,[HLRE T1,CS.EXT
		JUMPE	T1,OVMAP4	;NEITHER
		IMUL	T1,[-ET.ZZ]	;GET LENGTH
		ADD	T1,CS.EXT	;PLUS START
		JRST	OVMAP3]
	IMUL	T1,[-2]		;2 WORDS PER INTTAB
	ADD	T1,CS.INT
OVMAP3:	SUB	T1,PH.CST	;- START
	TLZA	T1,-1		;RIGHT HALF ONLY
OVMAP4:	MOVEI	T1,CS.ZZ	;USE LENGTH OF CS ONLY
	PUSH	P,T1		;SAVE IT
	PUSHJ	P,.T6OCT##	;LIST IN OCTAL
	MOVEI	T1,[ASCIZ	\ (octal), \]
	PUSHJ	P,.TSTRG##
	POP	P,T1
	PUSHJ	P,.TDECW##	;AND IN DECIMAL
	MOVEI	T1,[ASCIZ	\. (decimal)\]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TYLPP
	HLRE	P2,PH.SYM	;LENGTH WE NEED
	MOVM	P2,P2
	SUB	P2,LS.AB	;SEE IF ENOUGH
	ADD	P2,LS.LB
	JUMPLE	P2,OVMAP5	;YES
	MOVEI	P1,LS.IX
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
OVMAP5:	SKIPN	LNKNO.		;LIST PATH FOR ALL BUT ROOT
	JRST	OVMAP6
	MOVEI	T1,[ASCIZ	\	Path is	\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,PH.FPT	;GET PATH POINTER
	USETI	OC,(T1)		;SET ON BLOCK
	HLRZ	P1,T1		;GET WORD NUMBER
	ADD	P1,LS.LB	;WHERE IN CORE
	HRLI	P1,(POINT 18)	;1/2 WORDS
	MOVE	T1,LS.LB
	SUBI	T1,1
	HRLI	T1,-200		;FORM IOWD
	SETZ	T2,
	IN	OC,T1
	  CAIA
	PUSHJ	P,ER.IOV##
	ILDB	T1,P1		;GET FIRST #
	PUSHJ	P,.TDECW##	;AUGHT TO BE 0 BUTB MUST PRINT IT
OVMP5A:	ILDB	T1,P1		;GET NEXT
	JUMPE	T1,OVMP5B	;DONE
	MOVEI	T1,[ASCIZ	\,	\]
	PUSHJ	P,.TSTRG##	;SEPARATOR
	LDB	T1,P1		;GET # BACK
	PUSHJ	P,.TDECW##
	JRST	OVMP5A		;GET NEXT

OVMP5B:	PUSHJ	P,.TYLPP	;END LINE
OVMAP6:	MOVE	T1,PH.SYM	;GET BLOCK# OF SYMBOLS
	USETI	OC,(T1)		;SET ON IT
	MOVE	T1,LS.LB	;FORM IOWD TO READ IN SYMBOLS
	SUBI	T1,1
	HLL	T1,PH.SYM	;EVENTUALLY
	SETZB	T2,USYM
	IN	OC,T1
	  SKIPA	T1,LNKNO.	;OK
	PUSHJ	P,ER.IOV##	;INPUT ERROR
	ROT	T1,-1		;USUAL WAY TO ADDRESS 1/2 WORD
	MOVE	T2,PAGENO	;PAGE # OF FIRST MODULE INCASE NO INDEX
	MOVEM	T2,FSTPGN	;SO WE CAN SEE IF INDEX REQUIRED
	JUMPL	T1,[HRRM T2,@OVMIDX
		JRST	.+2]
	HRLM	T2,@OVMIDX
	MOVE	T1,LS.LB
	ADD	T1,LSYM		;NEXT FREE LOCATION
	SETZM	(T1)		;CLEAR UP TO END OF LS.AB WITH A BLT
	HRLZI	T2,0(T1)
	HRRI	T2,1(T1)
	BLT	T2,@LS.AB
	IORI	T1,.IPM
	MOVEM	T1,LS.AB	;GIVE BACK EXCESS SPACE
	JRST	SEGDN

>;END OF IFN FTOVERLAY
;SEGMENT LENGTHS
SEGSTF:	PUSHJ	P,.TTABC##
	MOVEI	T1,SEG0(R1)
	PUSHJ	P,.TSTRG##
	MOVEI	T1,SEG1
	PUSHJ	P,.TSTRG##
	MOVE	T1,LL.S1(R1)	;STARTS AT
	PUSHJ	P,.T6OCT##
	MOVEI	T1,SEG2
	PUSHJ	P,.TSTRG##
	SKIPE	T1,HL.S1(R1)	;ENDS AT
	SUBI	T1,1		;ONE LESS THAN PROG BREAK
	ADD	T1,LL.S1(R1)	;DON'T FORGET OFFSET
	PUSHJ	P,.T6OCT##
	MOVEI	T1,SEG3
	PUSHJ	P,.TSTRG##
	MOVE	T1,HL.S1(R1)
	PUSH	P,T1
	PUSHJ	P,.T6OCT##	;LENGTH IN OCTAL
	MOVEI	T1,[ASCIZ	\ = \]
	PUSHJ	P,.TSTRG##
	POP	P,T1		;GET BACK LENGTH
IFN FTVM!FTENEX,<
	JUMPE	T1,.+3		;LEAVE 0 ALONE
	IORI	T1,.PGSIZ	;ALWAYS PAGES
	ADDI	T1,1
>
IFE FTVM!FTENEX,<
	MOVE	T2,.PGSIZ	;P OR K BOUND
	JUMPE	T1,.+3		;LEAVE 0 ALONE
	IOR	T1,T2
	ADDI	T1,1
	CAIE	T2,777		;PAGES?
	JRST	[LSH	T1,-^D10	;K
		PUSHJ	P,.TDECW##	;IN DECIMAL
		MOVEI	T1,"K"
		JRST	SGSTF2]	
>;END OF IFE FTVM!FTENEX
	LSH	T1,-^D9		;P
	PUSHJ	P,.TDECW##	;IN DECIMAL
	MOVEI	T1,"P"
SGSTF2:	PUSHJ	P,.TCHAR##
	PUSHJ	P,.TYLPP
	SKIPN	R1		;DONE HIGH SEG ALREADY?
	SKIPN	HL.S2		;NO, BUT IS THERE ANY HIGH SEGMENT?
	JRST	SEGDN		;NO
	AOJA	R1,SEGSTF	;NOW FOR HIGH SEG

;HERE TO READ THE VERSION NUMBER IN USER LOC .JBVER

RDVER:
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;ANY OVERLAYS?
	JRST	RDVER1		;NO
	SETZB	P1,LNKNO.	;NEED LINK# 0 IN CORE
	PUSHJ	P,INPH##	;GET PREAMBLE
	MOVE	T1,PH.OVL	;BLOCK# OF JOBDAT
	USETI	OC,(T1)		;SET ON IT
	MOVE	T1,LC.LB
	SUBI	T1,1
	HRLI	T1,-200		;READ FIRST BLOCK
	SETZ	T2,
	IN	OC,T1
	  SKIPA	T1,.JBVER+1(T1)	;GET VERSION#
	PUSHJ	P,ER.IOV##	;INPUT ERROR
	MOVEM	T1,MAPVER
	POPJ	P,
RDVER1:
>;END OF IFN FTOVERLAY
	SKIPE	PAG.S1		;IF PAGING LOW SEG
	SKIPN	LW.S1		;AND JOBDAT NOT IN CORE
	JRST	[MOVE	T1,LC.LB	;GET START OF LOW AREA
		MOVE	T1,.JBVER(T1)	;GET VERSION#
		MOVEM	T1,MAPVER	;SAVE FOR HEADER LINE
		POPJ	P,]		;RETURN
	MOVEI	T2,.JBDA		;NEED 140 WORDS
	PUSHJ	P,DY.GET##	;TO HOLD JOBDAT
	SUBI	T1,1		;IOWD STARTS 1 BACK
	HRLI	T1,-140		;NO OF WORDS
	SETZ	T2,		;TERMINATE LIST
	USETI	LC,1		;TO READ BLOCK 1
	IN	LC,T1		;FOR FIRST 140 WORDS
	  JRST	[MOVEI	T1,1(T1)	;INCR T1
		MOVE	T2,.JBVER(T1)	;GET VERSION #
		MOVEM	T2,MAPVER	;SAVED
		MOVEI	T2,.JBDA	;NOW TO RESTORE BLOCK
		PJRST	DY.RET##]	;AND RETURN
	PUSH	P,[LC]		;CHAN #
	.ERR.	(ST,,V%L,L%F,S%F,ILC)

SEGDN:	PUSHJ	P,.TTABC##
	MOVE	T1,HL.S1	;GET LOW SEG BREAK
	IOR.	T1,.PGSIZ	;ROUND UP TO NEXT P OR K
	SUB	T1,HL.S1	;FIND WHATS LEFT
	ADDI	T1,1
	PUSHJ	P,.TDECW##	;PRINT IN DECIMAL
	MOVEI	T1,[ASCIZ	\ words free in Low segment\]
	PUSHJ	P,.TSTRG##
	SKIPN	HL.S2		;ANY HIGH SEGMENT
	JRST	SEGDN1		;NO, CLOSE OUT LINE
	MOVEI	T1,[ASCIZ	\, \]
	PUSHJ	P,.TSTRG##	;SEPARATE
	MOVE	T1,HL.S2	;SAME FOR HIGH SEG
	IOR.	T1,.PGSIZ	
	SUB	T1,HL.S2
	ADDI	T1,1
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ	\ words free in high segment\]
	PUSHJ	P,.TSTRG##
SEGDN1:	PUSHJ	P,.TYLPP
	PUSHJ	P,.TTABC##	;TAB OUT
	MOVE	T1,GSYM		;NO. OF GLOBALS
IFN FTOVERLAY,<
	ADD	T1,BSYM		;PLUS BOUND SYMBOLS
>
	PUSHJ	P,.TDECW##	;PRINT NO.
	MOVEI	T1,[ASCIZ	\ Global symbols loaded, therefore min. hash size is \]
	PUSHJ	P,.TSTRG##
	MOVE	T1,GSYM		;NO. OF SYMBOLS
IFN FTOVERLAY,<
	ADD	T1,BSYM		;PLUS BOUND SYMBOLS
>
	IMULI	T1,^D100
	IDIVI	T1,.HS%		;HOW MUCH SPACE WE WILL NEED TO AVOID REHASH
	ADDI	T1,1		;JUST INCASE A PRIME NO.
	PUSHJ	P,.TDECW##
	PUSHJ	P,.TYLPP	;CLOSE LINE
	SKIPN	STADDR		;IS THERE A STARTING ADDRESS
	JRST	NOSTAD		;NO
	MOVEI	T1,[ASCIZ	\	Start address is \]
	PUSHJ	P,.TSTRG##
	HRRZ	T1,STADDR	;GET IT
	PUSHJ	P,.T6OCT##
	SKIPN	STANAM		;NAME OF PROG CONTAINING ST ADDR.
	JRST	TTLDN		;NONE, OR SET BY SWITCH
	MOVEI	T1,[ASCIZ	\, located in program \]
	PUSHJ	P,.TSTRG##
	MOVE	T1,STANAM	;PROGRAM NAME
	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TYLPP
	JRST	TTLDN

NOSTAD:
IFN FTOVERLAY,<
	SKIPL	LNKMAX		;ANY OVERLAYS
	SKIPN	LNKNO.		;YES, BUT NOT ROOT
	CAIA
	JRST	TTLDN		;DON'T GIVE MESSAGE TO OTHER LINKS
>
	MOVEI	T1,[ASCIZ	\	No start address\]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TYLPP

TTLDN:	SKIPL	NOSYMS		;USER SET FOR NO SYMBOLS
	SKIPN	LS.LB		;OR NOTHING YET STORED?
	JRST	NOMAP		;EITHER WAY 
	PUSHJ	P,SYMINI	;GET SYMBOL TABLE RE-INITIALIZED
	SKIPN	T2,PRGNO	;GET NUMBER OF MODULE NAMES
	JRST	TTLSRT		;NO MODULES LOADED YET
	MOVEM	T2,MDLCNT	;HELPS TO TRAP ERRORS
	LSH	T2,1		;2 WORDS PER ENTRY
	PUSHJ	P,DY.GET##	;GET SPACE TO HOLD INDEX
	MOVEM	T1,MDLIDX	;START OF IT
	HRLI	T1,(POINT 36)	;FORM BYTE PTR
	MOVEM	T1,MDLPTR	;TO DEPOSIT NAMES
				;AND ADDRESSES

TTLSRT:	SETZB	R2,R1		;INCASE UNSORTED
	JRST	NXTSYM		;GET NEXT SYMBOL

	SKIPN	T1,NXTTTL	;REL POSITION ON NEXT TITLE
	MOVE	T1,LSYM		;USE END IF LAST
	SUB	T1,SYMPTR	;REMOVE CURRENT POSITION
	SUB	T1,LW.LS	;INCASE ON DSK
	LSH	T1,1		;NEED 2 WORDS
	IDIVI	T1,.L		;FROM TRIPLET ORIGINALLY
	ADD	T2,T1		;ACCOUNT FOR REMAINDER?
	PUSHJ	P,DY.GET##	;GET SPACE
	HRL	T1,T2
	MOVEM	T1,SRTPTR	;STORE START AND SIZE
	HRLZI	T2,(POINT 36)
	HRR	R2,T2		;BYTE POINTER TO STORE NAMES ETC
	MOVE	R1,MAPSRT	;INDEX TO SORT TYPE
;	JRST	NXTSYM		;JUMP TO SYMBOL LOOP
SUBTTL	SYMBOL LOOP

NXTSYM:	PUSHJ	P,GETSYM	;GET FIRST SYMBOL
	  JRST	SYMDN		;ALL OVER
	  JRST	TTLBLK		;A TITLE BLOCK
	PUSHJ	P,SYMCHK	;SEE IF WE WANT THIS SYMBOL?
	  JRST	NXTSYM		;NO
	JUMPN	R2,STRSYM	;JUMP IF SORTING

PNTSYM:	PUSHJ	P,.TTABC##	;TAB
	MOVEM	W1,SYFLAG	;SAVE PRIMARY FLAGS
	MOVE	T1,W2		;FIRST 6 CHARS OF NAME
	MOVEM	W3,VALUE	;VALUE OF SYMBOL
	PUSHJ	P,.TSIXN##
SYMLNG:	MOVSI	T1,S.SYM	;SEE IF LONG SYMBOL
	PUSHJ	P,FNDAST
	  JRST	SYMVAL		;NO
	MOVE	T1,W2
	PUSHJ	P,.TSIXN##
	SKIPE	T1,W3
	PUSHJ	P,.TSIXN##
	JRST	SYMLNG		;SEE IF MORE

SYMVAL:	PUSHJ	P,.TTABC##
	MOVE	T1,VALUE
	PUSHJ	P,.TFOCT##	;FULL WORD OCTAL WITH LEADING BLANKS
	PUSHJ	P,.TTABC##
	MOVE	T1,SYFLAG
	TLNE	W1,PS.ENT	;TEST FOR ENTRY POINT
	JRST	ENTSYM		;FOUND ONE
	TLNE	W1,PS.COM	;OR COMMON
	JRST	COMSYM		;BOTH ARE SPECIAL CASES OF GLOBALS
	TLNE	W1,PS.UDF	;UNDEFINED?
	JRST	UDFSYM		;YES
	TLNE	W1,PS.GLB
	JRST	GLBSYM		;NORMAL GLOBAL
	TLNE	W1,PS.LCL	;SHOULD BE LOCAL
	JRST	LCLSYM		;IT WAS
RELTST:	TLNE	W1,PS.MDF	;MULTIPLY-DEFINED?
	JRST	[MOVEI	T1,[ASCIZ	\Multiply-defined\]
		JRST	TSTFIN]
	MOVEI	T1,[ASCIZ	\Relocatable \]
	TLNN	W1,PS.REL	;ASSUME IT WAS RELOCATABLE
	MOVEI	T1,[ASCIZ	\Absolute    \]
	PUSHJ	P,.TSTRG##	;OUTPUT ONE OR OTHER
	MOVEI	T1,[ASCIZ	\Suppressed\]
	TLNN	W1,PS.DDT	;SUPPRESSED?
COMRET:	MOVEI	T1,[ASCIZ	\	\]
TSTFIN:	PUSHJ	P,.TSTRG##	;YES
	SETCMB	T1,ODDNESS	;AT END OF LINE?
	JUMPN	T1,ENDSYM	;NOT THIS TIME
	PUSHJ	P,.TYLPP	;END LINE
ENDSYM:	JUMPE	R2,NXTSYM	;IF NOT SORTING, NOW FOR NEXT
	POPJ	P,		;SORTING
;HERE FOR ENTRY
ENTSYM:	MOVEI	T1,[ASCIZ	\Entry	\]
	PUSHJ	P,.TSTRG##
	JRST	RELTST

;HERE FOR GLOBAL
GLBSYM:	MOVEI	T1,[ASCIZ	\Global	\]
	PUSHJ	P,.TSTRG##
	JRST	RELTST

;HERE FOR LOCAL
LCLSYM:	MOVEI	T1,[ASCIZ	\Local	\]
	PUSHJ	P,.TSTRG##
	JRST	RELTST

;HERE FOR UNDEFINED SYMBOL (LOCAL OR GLOBAL)
UDFSYM:	MOVEI	T1,[ASCIZ	\Undefined	\]
	PUSHJ	P,.TSTRG##
	JRST	RELTST

;HERE FOR COMMON
COMSYM:	MOVEI	T1,[ASCIZ	\Common	length	\]
	PUSHJ	P,.TSTRG##
	MOVSI	T1,S.COM	;FIND SECONDARY
	PUSHJ	P,FNDAST
	  JRST	COMRET		;FAILED!
	MOVE	T1,W3		;GET LENGTH
	PUSHJ	P,.TDSPC	;ALLIGN IT
	MOVE	T1,W3		;NO. AGAIN
	PUSHJ	P,.TDECW##	;IN DECIMAL
	MOVEI	T1,"."		;SIGNIFY DECIMAL
	PUSHJ	P,.TCHAR##
	JRST	COMRET		;END LINE
;HERE TO STORE SYMBOL IN SORT BUFFER

STRSYM:	JRST	@STRTBL(R1)	;GO TO RIGHT FUNCTION

DEFINE KEYMAC (A,B)<
 IFIDN <A><MPS>,<
  IRP B,<
   STR'B
>>>
STRTBL:	KEYWORDS

STRALPHA:
	MOVS	W3,SYMPTR	;RELATIVE ADDRESS NOW
	LSHC	W2,-2		;MAKE SPACE SO SIGNED TEST WILL WORK
	LSH	W3,-1		;SAME FOR 2ND WORD
	TXNN	W2,3B3		;IF NOT ALPHANUMERIC
	TXO	W2,1B1		;MAKE .,%,$ LARGER
	IDPB	W2,R2
	IDPB	W3,R2
	JRST	NXTSYM		;GET NEXT SYMBOL

STRNUMERIC:
STRUNSORTED:
	HALT
SUBTTL	SYMBOL REQUIRED TEST

;HERE TO SEE IF SYMBOL SHOULD BE LISTED
;CALLED BY
;	MOVE	W1,FLAGS
;	PUSHJ	P,SYMCHK
;RETURNS
;+1	IGNORE THIS SYMBOL
;+2	PRINT THIS SYMBOL
;USES T1, T2, T3

	SALL
SYMCHK:	SKIPGE	T1,MAPCON	;GET CONTENTS SWITCH
	JRST	CPOPJ1		;ALL WAS SET
	MOVE	T2,W1		;GET FLAGS
	AND	T2,[PS.GLB!PS.ENT!PS.UDF!PS.LCL!PS.COM!PS.REL,,0]
	TLZN	T2,PS.REL	;MUST BE ABS IF NOT REL
	JRST	%%.ABS		;SEE IF ALLOWED
%%.REL:	TXNN	T1,C%RELOC	;IS IT ALLOWED?
	POPJ	P,		;NO
;	JRST	SYMTST		;YES, TRY OTHER BITS

SYMTST:	JFFO	T2,.+2		;GET LEADING BIT
	AOSA	(P)		;NO TESTS LEFT
	JRST	@TSTTAB-%%F(T3)	;MUST WAIT TIL T3 SETUP
	POPJ	P,


DEFINE MAKSYM (A)<
 %%L==0
 %%F==^D36
 IRP A,<
  %%==^L<<PS.'A>_^D18>
  IFG %%F-%%,<%%F==%%>
  IFL %%L-%%,<%%L==%%>
  STRSYM \%%,A
>>

DEFINE STRSYM (%%,A)<
 %%.'%%==%%.'A
>

DEFINE SYMGEN <
 IF1,<BLOCK 1>
 IF2,<
  SYMDMP \%%
  %%==%%+1
>>

DEFINE SYMDMP (%%)<
 IFDEF %%.'%%,<%%.'%%>
 IFNDEF %%.'%%,<0>
 PURGE %%.'%%
>
SALL
MAKSYM <GLB,ENT,UDL,UDR,LCL,COM,REL>
	%%==%%F
TSTTAB:REPEAT %%L-%%F+1,<SYMGEN>

IF2,<PURGE	%%,%%F,%%L>

;HERE FOR ABSOLUTE
%%.ABS:	TLNE	T2,PS.COM	;HOWEVER COMMON IS NOT REALLY ABS
	JRST	SYMTST		;SO PASS THIS TEST
	TXNN	T1,C%ABSOLUTE
	POPJ	P,
	JRST	SYMTST

;HERE FOR GLOBAL
%%.GLB:	TLZ	T2,PS.GLB	;CLEAR IT
	TXNN	T1,C%GLOBAL
	POPJ	P,
	JRST	SYMTST

;HERE FOR LOCAL
%%.LCL:	TLZ	T2,PS.LCL
	TXNN	T1,C%LOCAL
	POPJ	P,
	JRST	SYMTST

;HERE FOR ENTRY
%%.ENT:	TLZ	T2,PS.ENT!PS.GLB
	TXNN	T1,C%ENTRY
	POPJ	P,
	JRST	SYMTST

;HERE FOR COMMON
%%.COM:	TLZ	T2,PS.COM!PS.GLB
	TXNN	T1,C%COMMON
	POPJ	P,
	JRST	SYMTST


;HERE FOR UNDEFINED (RH OR LH)
%%.UDL:!%%.UDR:!
%%.UDF:	TLZ	T2,PS.UDF
	TXNN	T1,C%UNDEFINED
	POPJ	P,
	JRST	SYMTST
;HERE TO SORT AND PRINT SYMBOL TABLE

SRTSYM:	HRRZ	W2,SRTPTR	;INITIAL VALUE
	SUBI	W2,(R2)		;- NO. OF PAIRS OF WORDS
	LSH	W2,^D17		;CUT IN HALF AND PUT IN LHS
	HRR	W2,SRTPTR	;-N,,ADDRESS
	PUSHJ	P,IDXLP0	;SORT IT
	HRRZ	R2,SRTPTR	;POINT TO TOP OF BUFFER

SRTSY1:	SKIPN	T1,1(R2)	;GET POINTER
	JRST	SRTFIN		;ALL DONE
	LSH	T1,3-^D18	;PUT IN RHS
	ADD	T1,LS.LB	;FIX INCORE
	TMOVE	W1,(T1)		;GET TRIPLET AGAIN
	PUSHJ	P,PNTSYM	;PRINT IT NOW
	JRST	SRTSY1

SRTFIN:	HRRZ	T1,SRTPTR
	HLRZ	T2,SRTPTR
	PUSHJ	P,DY.RET##	;GIVE BACK BUFFER
	SKIPE	ODDNESS		;NEED TO END LINE
	PUSHJ	P,[SETCMM ODDNESS
		PJRST	.TYLPP]		;YES
	MOVE	T1,SYMPTR
	ADD	T1,LS.LB
	TMOVE	W1,(T1)		;GET BACK ORIGINAL TRIPLET
	POPJ	P,
SUBTTL	TITLE ROUTINES

;HERE IF TRIPLET FOUND IS A TITLE
TTLBLK:	SKIPE	ODDNESS		;NEED TO END LINE?
	PUSHJ	P,[SETCMM ODDNESS
		PJRST	.TYLPP]		;YES
	TLNE	W1,PT.BLK	;FAIL BLOCK HEADER?
	JRST	BTITLE		;YES
	MOVEM	W3,NXTTTL	;SAVE POINTER TO NEXT TITLE
	PUSHJ	P,.TYLPP	;BLANK LINE
	PUSHJ	P,TYSTAR	;PRINT SEPARATORS
	SETZM	CURPRG		;FINISHED WITH THIS PROG NOW
	PUSHJ	P,.TSTP5	;SEE IF ENOUGH SPACE ON THIS PAGE
	  JFCL
	PUSHJ	P,.TYLPP	;BLANK LINE
	MOVE	T1,W2		;FIRST 6 CHARS OF NAME
	MOVEM	W2,CURPRG	;SAVE INCASE GOES OVER PAGE
	PUSHJ	P,.TSIXN##
	TLNE	W1,PT.FAK	;ONLY A FAKE TITLE?
	JRST	TTLFAK		;YES, NO ROOM IN INDEX
	MOVE	T1,W2		;NAME
	MOVS	T2,PAGENO	;GET PAGE NUMBER
	LSHC	T1,-2		;SO SIGNED TEST CAN WORK
	LSH	T2,-1		;SAME FOR 2ND WORD OF PAIR
	TXNN	T1,3B3		;IF NOT ALPHANUMERIC
	TXO	T1,1B1		;MAKE .,%,$ LARGER
	IDPB	T1,MDLPTR	;STORE MODIFIED NAME
	IDPB	T2,MDLPTR	;AND PAGE NO
	SOSGE	MDLCNT		;STILL ROOM LEFT?
	JRST	TTLTTF		;NO, MUST BE ERROR
TTLFAK:	MOVSI	T1,S.TTL	;SEE IF ANY MORE TO NAME
	PUSHJ	P,FNDAST
	  JRST	TTLDEV		;NO, TRY CREATION
TTLLNM:	MOVE	T1,W2		;GET NEXT SIX CHARS
	PUSHJ	P,.TSIXN##
	SKIPE	T1,W3		;AND NEXT SIX
	PUSHJ	P,.TSIXN##
	MOVSI	T1,S.TTL
	PUSHJ	P,FNDNAS	;SEE IF ANY MORE (NOT INCLUDING THIS ONE)
	  JRST	TTLDEV		;NO
	JRST	TTLLNM		;YES
TTLDEV:	MOVSI	T1,S.TTL!S.DEV	;GET DEVICE & FILENAME
	PUSHJ	P,FNDAST
	  JRST	TTLPRC		;SKIP REST OF THIS ALSO
	MOVEI	T1,[ASCIZ	\	from \]
	PUSHJ	P,.TSTRG##
	MOVE	T1,W2		;DEVICE
	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TCOLN##
	PUSH	P,W3		;SAVE UFD
	MOVSI	T1,S.TTL!S.NAM	;FILE NAMR & EXT
	PUSHJ	P,FNDAST
	  JRST	TTLUFD
	MOVE	T1,W2		;FILE NAME
	PUSHJ	P,.TSIXN##
	MOVEI	T1,"."
	PUSHJ	P,.TCHAR##
	SKIPE	T1,W3		;EXT
	PUSHJ	P,.TSIXN##
TTLUFD:	POP	P,W3		;RECOVER UFD
	JUMPE	W3,TTLSEG	;NO UFD
	MOVEI	T1,"["
	PUSHJ	P,.TCHAR##
	MOVE	T1,W3		;GET PPN
	PUSHJ	P,.TXWDW##	;PROG,PROJ
	MOVSI	T1,S.TTL!S.SFD	;NOW FOR POSSIBLE SFD
	PUSHJ	P,FNDAST
	  JRST	TTLDIR		;CLOSE [DIRECTORY]
TTLSFD:	PUSHJ	P,.TCOMA##
	MOVE	T1,W2
	PUSHJ	P,.TSIXN##
	JUMPE	W3,TTLDIR
	PUSHJ	P,.TCOMA##
	MOVE	T1,W3
	PUSHJ	P,.TSIXN##
	MOVSI	T1,S.TTL!S.SFD	;NOW FOR NEXT SFD
	PUSHJ	P,FNDNAS
	  JRST	TTLDIR		;CLOSE [DIRECTORY]
	JRST	TTLSFD

TTLDIR:	MOVEI	T1,"]"
	PUSHJ	P,.TCHAR##

TTLPRC:	MOVSI	T1,S.TTL!S.PRC	;FIND PROCESSOR NAME
	PUSHJ	P,FNDAST
	  JRST	TTLCRE		;NO LUCK, USE DEFAULT IN CRE
	MOVEI	T1,[ASCIZ	\	created by \]
	PUSHJ	P,.TSTRG##
	MOVE	T1,W2		;GET NAME
	PUSHJ	P,.TSIXN##

	MOVSI	T1,S.TTL!S.CRE	;NOW FOR DATE
	PUSHJ	P,FNDAST
	  JRST	TTLSEG
TTLDAT:	MOVEI	T1,[ASCIZ	\ on \]
	PUSHJ	P,.TSTRG##
	HRRZ	T1,W2		;GET DATE (15 BITS AT MOST)
	PUSHJ	P,.TDATE##
	MOVEI	T1,[ASCIZ	\ at \]
	PUSHJ	P,.TSTRG##
	HLRZ	T1,W2		;GET TIME (11 BITS)
	IMULI	T1,^D60000	;CONVERT TO MILLISECS
	PUSHJ	P,.TTIME##
	JRST	TTLSEG		;NOW FOR DEVICE ETC

TTLCRE:	MOVSI	T1,S.TTL!S.CRE
	PUSHJ	P,FNDAST
	  JRST	TTLSEG
	JUMPE	W3,TTLCRU	;UNKNOWN PROCESSOR SO SKIP
	MOVEI	T1,[ASCIZ	\	created by \]
	PUSHJ	P,.TSTRG##
	SKIPGE	T1,W3		;GET PROCESSOR TYPE
	JRST	[AOJN	T1,.+1		;SET BY LINK-10 IF [-1]
		SETZ	W3,		;YES, CLEAR CPU TYPE
		SOJA	T1,TTLCRL]
	ANDI	T1,7777		;MASK OUT CPU BITS
	caile	t1,ct.len	;make sure in range
	SETZ	T1,		;USE UNKNOWN
TTLCRL:	MOVE	T1,PRCTAB(T1)	;pickup name
	pushj	p,.tstrg##
	MOVE	T1,W3		;GET CPU BITS
	LSH	T1,-^D12	;RIGHT JUSTIFIED
	JUMPE	T1,TTLDAT	;DON'T CARE IF 0
	CAILE	T1,CP.LEN	;MAKE SURE IN RANGE
	SETZ	T1,		;NO, SO MAKE UNKNOWN TYPE
	MOVE	T1,CPUTAB(T1)	;PICKUP NAME
	PUSHJ	P,.TSTRG##	;AND OUTPUT IT
	JRST	TTLDAT		;AND DATE


TTLCRU:	MOVEI	T1,[ASCIZ	\	created\]
	pushj	p,.tstrg##
	JRST	TTLDAT
TTLSEG:	PUSHJ	P,.TYLPP	;END LINE
	SETZB	R1,ZERLEN	;ASSUME NOT ZERO LENGTH
	MOVSI	T1,S.TTL!S.SEG
	PUSHJ	P,FNDAST	;GET SEGMENT INFO
	  JRST	TTLEND
TTLHSG:	HLRZ	T1,W2(R1)	;GET LOW SEG INIT REL
	HRRZ	T2,W2(R1)	;AND FINAL
	CAMN	T2,T1		;SAME?
	JRST	[JUMPN	R1,TTLEND	;THIS IS HIGH SEG
		SKIPN	W3		;
		SETOM	ZERLEN		;BOTH SEGMENTS ZERO
		AOJA	R1,TTLHSG]	;TRY AGAIN
	PUSHJ	P,.TTABC##
	MOVEI	T1,SEG0(R1)
	PUSHJ	P,.TSTRG##
	MOVEI	T1,SEG1
	PUSHJ	P,.TSTRG##
	HLRZ	T1,W2(R1)
	PUSHJ	P,.T6OCT##	;STARTING
	MOVEI	T1,SEG2
	PUSHJ	P,.TSTRG##
	HRRZ	T1,W2(R1)
	SKIPE	T1		;MIGHT NOT BE SETUP (IF 0)
	SUBI	T1,1		;ONE LESS THAN PROG BREAK
	PUSHJ	P,.T6OCT##	;ENDS
	MOVEI	T1,SEG3
	PUSHJ	P,.TSTRG##
	HRRZ	T1,W2(R1)
	HLRZ	T2,W2(R1)
	SUB	T1,T2
	MOVEM	T1,W2(R1)	;SAFE PLACE TO STORE IT
	PUSHJ	P,.T6OCT##	;LENGTH
	MOVEI	T1,[ASCIZ	\ (octal),\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,W2(R1)
	PUSHJ	P,.TDSPC	;ALLIGN WORD
	MOVE	T1,W2(R1)	;GET LENGTH BACK
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ	\. (decimal)\]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TYLPP	;END LINE
	JUMPN	R1,TTLEND	;DONE
	AOJA	R1,TTLHSG	;NO , TRY HIGH

TTLEND:	PUSHJ	P,.TYLPP	;BLANK LINE
	MOVE	T1,MAPCON	;GET MASK FOR MAP CONT
	SKIPGE	ZERLEN		;MAKE ZERO LENGTH TEST NOW
	TXNE	T1,C%ZERO	;SKIP IF NOT ALLOWED
	JRST	TTLSRT		;OK, ALLOWED
	MOVEI	T1,[ASCIZ	\	Zero length module\]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TYLPP
	PUSHJ	P,GETSYM	;GET FIRST SYMBOL
	  JRST	SYMDN		;ALL OVER
	  JRST	TTLBLK		;A TITLE BLOCK
	JRST	.-3		;LOOP TIL NEXT TITLE OR ELSE END

TTLTTF:	.ERR.	(MS,,V%L,L%W,S%W,TTF,<Too many titles found>)
	JRST	NXTSYM		;IGNORE, BUT TRY TO COMPLETE MAP
SUBTTL	FAIL BLOCK HEADER

BTITLE:	MOVSI	W1,PS.LCL	;FAKE A LOCAL SYMBOL
	PUSHJ	P,SYMCHK	;SEE IF WE WANT THIS SYMBOL?
	  JRST	NXTSYM		;NO
	PUSHJ	P,.TYLPP	;BLANK LINE
	PUSHJ	P,.TTABC##	;TAB
	MOVEM	W1,SYFLAG	;SAVE PRIMARY FLAGS
	MOVE	T1,W2		;FIRST 6 CHARS OF NAME
	HRRZM	W3,VALUE	;VALUE OF SYMBOL
	PUSHJ	P,.TSIXN##
	MOVEI	T1,[ASCIZ	\	block level	\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,VALUE
	PUSHJ	P,.TDECW##	;LEVEL IN DECIMAL
	PUSHJ	P,.TYLPP	;END LINE
	JRST	NXTSYM

SUBTTL	SYMBOL TABLE ROUTINES

;HERE TO READ BACK SYMBOL TABLE IF ON DSK
;CALLED BY
;	PUSHJ	P,SYMINI

SYMINI:	SKIPN	T1,UW.LS	;PAGING SYMBOLS?
	POPJ	P,		;NO
	JUMPGE	T1,.+4		;ALREADY OUTPUT ALL OF SYMBOLS!
	MOVS	T1,LW.LS	;LOWEST INCORE
	HRR	T1,LSYM		;HIGHEST
	IORI	T1,.DBM		;PUT ON DSK BLOCK BOUND (NOT NECESSARY)
	PUSHJ	P,LS.OUT##	;DUMP THEM
	SETZM	LW.LS		;START AGAIN AT 0
	PUSH	P,FRECOR	;SAVE INCASE NOT 0
	SETZM	FRECOR		;DON'T NEED EXTRA SPACE IN MAPS
	PUSHJ	P,FR.CNT##	;COUNT ALL OF FREE CORE
	MOVEI	P1,LS.IX	;WILL WANT TO EXPAND LS AREA MOST LIKELY
	MOVE	P2,LSYM		;WE WANT THIS MUCH MOST LIKELY
	ADD	P2,LS.LB	;FIND EXTRA WE NEED
	SUB	P2,LS.AB	;REMOVING WHAT WE HAVE
	CAMLE	P2,T1		;MORE THAN WHATS FREE?
	MOVE	P2,T1		;YES, SO JUST GET WHAT WE CAN
	PUSHJ	P,LOGBCK	;INCASE LOG FILE OPEN
	PUSHJ	P,LNKCOR	;GET IT ALL
	  JFCL			;TOO BAD
	PUSHJ	P,LOGBCK	;RESTORE MAP DEVICE
	POP	P,FRECOR	;RESTORE
	MOVE	T1,LS.UB	;SIGNAL ALL OF AREA LS IN USE
	MOVEM	T1,LS.AB	;SO PAGER WILL FILL IT
	SUB	T1,LS.LB	;SEE HOW BIG
	MOVEM	T1,UW.LS	;BIGGEST IN CORE
	PJRST	LS.IN##		;INPUT AND RETURN


;HERE TO GET NEXT PRIMARY SYMBOL
;CALLED BY
;	PUSHJ	P,GETSYM
;RETURNS
;+1	END OF SYMBOL TABLE
;+2	TRIPLET IS A TITLE OR OTHER NON-SYMBOL
;+3	NORMAL SYMBOL RETURN
;USES T1
;SETS UP W1, W2, W3 & SYMPTR

GETSYM:	MOVE	T1,SYMPTR	;GET POINTER TO LAST PRIMARY
	ADD	T1,LS.LB	;ADD IN OFFSET
NOTPRM:	ADDI	T1,.L		;GET TO END OF NEXT TRIPLET
	CAMLE	T1,LS.AB	;STILL IN CORE
	JRST	SHFSYM		;NO, GET NEXT BLOCK OR GIVE UP
	SKIPL	W1,-.L(T1)	;GET FLAGS
	JRST	NOTPRM		;NOT A PRIMARY
	DMOVE	W2,-.L+1(T1)	;LOAD REST OF TRIPLET
	SUB	T1,LS.LB	;REMOVE OFFSET
	MOVEM	T1,SYMPTR	;STORE POINTER
	AOS	(P)		;AT LEAST SKIP RET
	TLNE	W1,PT.SYM	;SEE IF SYMBOL TYPE
	AOS	(P)		;YES, RET +3
	POPJ	P,

;HERE TO SHIFT NEW SYMBOL WINDOW INTO CORE
;ALL EXCEPT THE LAST 128 WORDS ARE THROWN AWAY (KEPT INCASE SYMBOL ACROSS A BOUND)
;READ IN NEW PART AND ADJUST POINTERS
;IF THERE IS MORE SPACE THAN WE NEED GIVE BACK THE EXCESS

SHFSYM:	SKIPN	UW.LS		;PAGING?
	POPJ	P,		;NO, ALL DONE
	MOVE	T1,UW.LS	;LAST HIGHEST
	ADDI	T1,1		;NEW LOWEST
	CAMLE	T1,LSYM		;STILL SOME SYMBOLS LEFT?
	POPJ	P,		;NO, ALL DONE
				;KEEP LAST BLOCK IN CORE AGAIN
	HRLI	T1,-.DBS(T1)	;IN BOTH HALVES
	HLRZ	T2,T1
	SUB	T2,LW.LS	;DIFFERENCE = WINDMW SIZE
	ADDM	T2,LW.LS	;FIXUP WINDOW PTRS
	ADDM	T2,UW.LS
	MOVN	T2,T2
	ADDM	T2,SYMPTR	;BACKUP SYMBOL PTR
	MOVM	T2,T2		;BACK POSITIVE
	MOVE	T3,UW.LS	;GET NEXT UPPER BOUND
	CAMG	T3,LSYM		;HAVE WE TOO MUCH ROOM NOW?
	SOJA	T2,SHFSY1	;NO, READ ALL WE CAN GET
	MOVE	T2,LSYM		;GET UPPER WE NEED
	IORI	T2,.IPM		;BLOCK BOUND
	SUB	T2,LW.LS	;LENGTH WE REALLY NEED
	MOVE	T3,LSYM		;HIGHEST SYMBOL SEEN
	IORI	T3,.IPM		;PUT ON BOUND
	MOVEM	T3,UW.LS	;STORE AS HIGHEST WINDOW
	MOVE	T3,LS.LB	;ACTUAL LOWER
	ADD	T3,T2		;NEW UPPER
	MOVEM	T3,LS.AB	;ACTUAL BOUND IN USE
	SETZM	1(T3)		;CLEAR IT
	HRLI	T3,1(T3)
	ADDI	T3,2		;FORM BLT PTR
	BLT	T3,@LS.UB	;CLEAR IT ALL
SHFSY1:	ADDI	T1,(T2)		;INPUT PTR
	PUSHJ	P,LS.IN##	;READ IN NEW BLOCKS
	JRST	GETSYM		;AND CONTINUE



;HERE TO FIND ASSOCIATED SECONDARY TRIPLET
;CALLED BY
;	MOVE	T1,FLAGS
;	PUSHJ	P,FNDAST
;RETURNS
;+1	FAILED
;+2	SUCCESS
;USES T1, T2, T3
;SETS UP W1, W2, W3

FNDAST:	SKIPA	T2,SYMPTR	;GET POINTER
FNDNAS:	SKIPA	T2,ASTPTR	;ALREADY RELOCATED
	ADD	T2,LS.LB	;FIX
FNDNAT:	ADDI	T2,.L		;GET NEXT TRIPLET
	CAMLE	T2,LS.AB	;STILL IN CORE?
	PUSHJ	P,FNDNIC	;NOT IN CORE, OR FINISHED
	SKIPGE	T3,-.L(T2)	;GET FLAGS
	POPJ	P,		;FOUND A PRIMARY (FAILED)
	XOR	T3,T1		;IFF ALL BITS MATCH
	TLZ	T3,S.LST	;IGNORE THIS BIT HOWEVER
	JUMPN	T3,FNDNAT	;TRY AGAIN
	TMOVE	W1,-.L(T2)	;LOAD TRIPLET
	MOVEM	T2,ASTPTR	;SAVE INCASE CALLED AGAIN
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,


;HERE TO READ IN MORE OF SYMBOL TABLE IF PAGING
;LEAVES THE CURRENT SYMBOL IN CORE
;BUT ADJUSTS SYMPTR ETC
;CALLED BY
;	PUSHJ	P,FNDNIC
;
FNDNIC:	SKIPN	UW.LS
	JRST	TPOPJ		;REMOVE RETURN AND EXIT
	MOVE	T1,UW.LS	;GET CURRENT HIGHEST
	ADDI	T1,1
	CAMLE	T1,LSYM		;ANY MORE TO READ IN?
	JRST	TPOPJ		;NO, GIVE UP
	SUB	T2,LS.LB	;REMOVE OFFSET
	MOVE	T1,SYMPTR	;GET PTR TO CURRENT PRIMARY
	ANDCMI	T1,.IPM		;KEEP THAT BLOCK
	SUB	T2,T1		;ADJUST T2 FOR NEW VALUE
	PUSH	P,T2		;SAVE IT FOR RETURN
	MOVEI	T2,.IPM
	ANDM	T2,SYMPTR	;BACKUP PRIMARY PTR
	ADDM	T1,LW.LS	;GET NEW
	ADDB	T1,UW.LS	;AFTER NEXT INPUT
	CAML	T1,LSYM		;DO WE NEED ALL OF IT?
	PUSHJ	P,REDUSM	;NO, REDUCE SIZE
	HRLZ	T1,LW.LS	;LOWEST ADDRESS
	HRR	T1,UW.LS	;HIGHEST
	PUSHJ	P,LS.IN##	;READ IN AGAIN
	POP	P,T2		;RESTORE T2
	ADD	T2,LS.LB	;RESTORE OFFSET
	POPJ	P,		;RETURN

;HERE TO REDUCE SIZE SO WE DON'T WASTE TIME LOOKING AT ZEROS
;AND SAVES READIN TIME
REDUSM:	SUB	T1,LSYM		;GET EXCESS
	ANDCMI	T1,.IPM		;IN THIS BLOCK
	MOVN	T1,T1		;AS - OFFSET
	ADDM	T1,UW.LS	;BACKUP WINDOW
	ADD	T1,LS.AB	;WILL BE NEW TOP LATER
				;FIRST WE MUST CLEAR JUNK FROM THIS SPACE
	MOVEI	T2,1(T1)	;FIRST FREE LOC
	SETZM	(T2)		;CLEAR IT
	HRL	T2,T2	
	ADDI	T2,1		;BLT PTR
	BLT	T2,@LS.AB	;UP TO OLD LIMIT
	MOVEM	T1,LS.AB	;NOW SET TOP
	POPJ	P,

TPOPJ:	POP	P,T1		;REMOVE RETURN
	POPJ	P,
SUBTTL	OUTPUT ROUTINES

MAPIT:	SOSGE	MCBUF+2		;ANY SPACE EFT
	JRST	MAPDMP		;NO
	IDPB	T1,MCBUF+1	;YES
	POPJ	P,

MAPDMP:	OUT	MC,
	  JRST	MAPIT
	PUSHJ	P,LOGBCK	;RESTORE LOG CHAN
	PUSH	P,[MC]		;ERROR, SAVE CHAN
	.ERR.	(ST,0,V%L,L%W,S%W,OEM,<Output error on MAP file, file closed, job continuing>)
	CLOSE	MC,
	JRST	MAPRET		;AND RETURN

;HERE TO SWAP CURRENT OUTPUT SUBROUTINE WITH PREVIOUS
;CALLEDD BY
;	PUSHJ	P,LOGBCK

LOGBCK:	MOVE	T1,OLDDEV	;RESTORE
	PUSHJ	P,.TYOCH##
	MOVEM	T1,OLDDEV
	POPJ	P,

;HERE TO OUTPUT CR-LF OR CR-FF & HEADER
;CALLED BY
;	PUSHJ	P,.TYLPP

.TYLPP:	SOSL	CNTLPP		;STILL SPACE ON THIS PAGE?
	PJRST	.TCRLF##	;YES, JUST CRLF
	MOVEI	T1,LN.LPP	;NO, RESET PAGE COUNT
	MOVEM	T1,CNTLPP
	PUSHJ	P,.TCRLF##	;CR-LF
	MOVEI	T1,.CHFFD	;FF
	PUSHJ	P,.TCHAR##
.TYHDR:	MOVE	T1,PAGHDR	;HEADER AGAIN
	PUSHJ	P,.TSTRG##
	MOVE	T1,MAPNAM	;GET MAP FILE NAME
	PUSHJ	P,.TSIXN##	;IN SIXBIT
	SKIPN	MAPVER		;ONLY PRINT IF NOT ZERO
	JRST	TYPAGE		;JUST PAGE NUMBER
	MOVEI	T1,[ASCIZ	\	version \]
	PUSHJ	P,.TSTRG##
	MOVE	T1,MAPVER	;VERSION
	PUSHJ	P,.TYVER##
TYPAGE:
IFN FTOVERLAY,<
	SKIPL	LNKMAX		;ANY OVERLAYS?
	SKIPG	LNKNO.		;EXCEPT #0
	JRST	TYPAG1		;NO
	MOVEI	T1,[ASCIZ	\	#\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,LNKNO.
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ	\	page \]
	CAIA
TYPAG1:
>;END OF IFN FTOVERLAY
	MOVEI	T1,[ASCIZ	\		page \]
	PUSHJ	P,.TSTRG##
	AOS	T1,PAGENO	;GET PAGE NUMBER
	PUSHJ	P,.TDECW##
	PUSHJ	P,.TYLPP
	MOVE	T1,PAGENO	;GET PAGE NUMBER
	CAIN	T1,1		;BLANK LINE UNLESS PAGE 1
	POPJ	P,
	SKIPE	T1,CURPRG	;GET CURRENT PROG NAME
	PUSHJ	P,.TSIXN##	;OUTPUT IT SO WE KNOW WHERE WE ARE
	PJRST	.TYLPP


;HERE TO TEST FOR 5 FREE LINE ON PAGE
;CALLED BY
;	PUSHJ	P,.TSTP5

.TSTP5:	MOVEI	T1,5
				;FALL INTO .TSTPG

;HERE TO SEE IF WITHIN SO MANY LINES FROM END OF PAGE
;IF SO END PAGE AND RETURN +1
;IF NOT JUST RETURN +2
;CALLED BY
;	MOVEI	T1,NO. OF LINES TO TEST FOR
;	PUSHJ	P,.TSTPG
;RETURNS
;+1	ON A NEW PAGE
;+2	ENOUGH SPACE ON CURRENT PAGE

.TSTPG:	CAMG	T1,CNTLPP	;ENOUGH FREE LINES?
	JRST	CPOPJ1		;YES
	SETZM	CNTLPP		;NO, FORCE END
	PJRST	.TYLPP		;AND WRITE IT OUT

;HERE TO PRINT LINE OF STARS
;CALLED BY
;	PUSHJ	P,TYSTAR

TYSTAR:	MOVEI	T1,STARS	;GET LINE
	PUSHJ	P,.TSTRG##	;OUTPUT
	PJRST	.TYLPP		;AND CLOSE LINE
;.TDSPC - SUBROUTINE TO PRINT ALLIGNMENT SPACES FOR DECIMAL NO.
;CALLED BY
;	MOVE	T1,NUMBER
;	PUSHJ	P,.TDSPC
;OUTPUTS ONE SPACE FOR EVERY DIGIT NOT PRINTED

.TDSPC:	MOVSI	T2,-SPCLEN	;AOBJN WORD
	CAMGE	T1,SPCTBL(T2)	;SEE HOW BIG
	AOBJN	T2,.-1		;NOT YET
	MOVEI	T1," "		;SPACE
	HRRZ	T2,T2		;COUNT OF HOW MANY
	JUMPE	T2,CPOPJ	;NONE
	PUSHJ	P,.TCHAR##
	SOJG	T2,.-1		;LOOP
	POPJ	P,

SPCTBL:	^D100000
	^D10000
	^D1000
	^D100
	^D10
SPCLEN==.-SPCTBL

;.TDEC3 -- TYPE DECIMAL AT LEAST THREE DIGITS
;CALL:	SAME AS .TDECW WITH T2=FILLER CHAR (" " OR "0")

.TDEC3:	CAILE	T1,^D99		;SEE IF TWO DIGITS OR LESS
	PJRST	.TDECW##	;NO--JUST OUTPUT
	MOVEI	T2," "		;SET FILLER
	EXCH	T1,T2		;SWAP
	PUSHJ	P,.TCHAR##	;OUTPUT FILLER
	EXCH	T1,T2		;PUT BACK
	PJRST	.TDEC2##	;OUTPUT OTHER TWO DIGITS
SUBTTL	HEADER MESSAGES ETC

HEAD1:	ASCIZ	\		LINK-10 symbol map of	\
HEAD2:	ASCIZ	\	Produced by LINK-10 version \

SEG0:	ASCIZ	\Low \
	ASCIZ	\High\
SEG1:	ASCIZ	\ segment starts at	\
SEG2:	ASCIZ	\ ends at	\
SEG3:	ASCIZ	\ length	\
STARS:	ASCIZ	\		*************\
END1:	ASCIZ	\	[End of LINK-10 map of	\
DEFINE X (A,B)<
 IFIDN <A><FORTRAN>,<
	[ASCIZ	\A'-10\]
 >
 IFDIF <A><FORTRAN>,<
  IFIDN <A><PLI>,<
	[ASCIZ	\PL/I\]
  >
  IFDIF <A>,<PLI>,<
	[ASCIZ	\A\]
>>>

	[ASCIZ	\LINK-10\]
PRCTAB:	PROCESSORS

DEFINE X (A,B)<
	[ASCIZ	\ /A\]
>

CPUTAB:	CPUS
SUBTTL	END OF MAP

SYMDN:	SETZM	CURPRG		;DON'T WANT LAST PROG ON UNDEF PAGES
	SKIPE	ODDNESS		;NEED TO END LINE?
	PUSHJ	P,[SETCMM ODDNESS
		PJRST	.TYLPP]		;YES
	PUSHJ	P,.TYLPP	;BLANK
	PUSHJ	P,TYSTAR	;SEPARATE THIS AREA
	PUSHJ	P,.TYLPP	;AND BLANK LINE
	SKIPN	USYM		;ANY UNDEFINED SYMBOLS?
	JRST	MULDF0		;NO, TRY FOR MULTIPLY DEFINED

UNRES0:	MOVE	T1,CNTLPP	;GET NUMBER OF LINES ON PAGE
	CAIGE	T1,LN.LPP-3	;UNLESS JUST OUTPUT HEADER
	SETZM	CNTLPP		;START NEW PAGE
	PUSHJ	P,.TYLPP	;START ON A NEW LINE
	MOVE	P1,USYM		;GET NUMBER OF UNDEFS IN A PRESERVED AC
	MOVE	T1,P1		;WHERE SCAN EXPECTS NUMBER
	PUSHJ	P,.TDECW##	;TYPE NO.
	MOVE	T1,P1		;GET UNDEFS AGAIN
	CAILE	T1,2		;LEAVE 0 OR 1 ALONE
	MOVEI	T1,2		;SET INDEX TO 0,1, OR 2
	MOVE	T1,UNRTAB-1(T1)	;GET ADDRESS
	PUSHJ	P,.TSTRG##	;OUTPUT MESSAGE
	PUSHJ	P,.TYLPP	;AND CR-LF
	PUSHJ	P,.TYLPP
	MOVE	P2,HT.PRM	;GET INDEX INTO HASH TABLE
UNRES1:	SKIPN	P3,@HT.PTR	;GET POINTER TO SYMBOL
	JRST	UNRES2		;NO POINTER, NO SYMBOL
	ADD	P3,GS.LB	;ADD IN BASE
	MOVE	T1,0(P3)	;GET FLAGS
	TLNE	T1,PT.SYM	;WE ONLY WANT SYMBOLS
	TLNN	T1,PS.UDF!PS.REQ	;SEE IF UNDEFINED STILL
	JRST	UNRES2		;NO
	MOVE	T1,1(P3)	;GET SYMBOL
	PUSHJ	P,.TSIXN##	;SIXBIT WORD
	PUSHJ	P,.TTABC##	;TAB
	MOVE	T1,2(P3)	;VALUE
	PUSHJ	P,.TOCTW##	;IN OCTAL
	PUSHJ	P,.TYLPP	;NEW LINE
IFE DEBSW,<			;IF DEBUGGING SCAN ALL OF TABLE
	SOJLE	P1,UNRES3	;DONE IF NO MORE UNDFS
				;INCASE COUNT OFF>
UNRES2:	SOJGE	P2,UNRES1	;LOOP IF MORE SYMBOLS TO LOOK AT
UNRES3:	PUSHJ	P,.TYLPP	;BLANK
	PUSHJ	P,TYSTAR	;OUTPUT STARS

;NOW FOR MULTIPLY DEFINED SYMBOLS

MULDF0:	SKIPN	MSYM		;ANY TO OUTPUT?
	JRST	MAPIDX		;NO
	PUSHJ	P,.TSTP5	;SEE IF ENOUGH ROOM
	  JFCL
	MOVE	P1,MSYM		;GET NUMBER OF MULT-DEFS IN A PRESERVED AC
	MOVE	T1,P1		;WHERE SCAN EXPECTS NUMBER
	PUSHJ	P,.TDECW##	;TYPE NO.
	MOVE	T1,P1		;GET MULT-DEFS AGAIN
	CAILE	T1,2		;LEAVE 0 OR 1 ALONE
	MOVEI	T1,2		;SET INDEX TO 0,1, OR 2
	MOVE	T1,MDFTAB-1(T1)	;GET ADDRESS
	PUSHJ	P,.TSTRG##	;OUTPUT MESSAGE
	PUSHJ	P,.TYLPP	;AND CR-LF
	PUSHJ	P,.TYLPP
	MOVE	P2,HT.PRM	;GET INDEX INTO HASH TABLE
MULDF1:	SKIPN	P3,@HT.PTR	;GET POINTER TO SYMBOL
	JRST	MULDF2		;NO POINTER, NO SYMBOL
	ADD	P3,GS.LB	;ADD IN BASE
	MOVE	T1,0(P3)	;GET FLAGS
	TLNE	T1,PT.SYM	;WE ONLY WANT SYMBOLS
	TLNN	T1,PS.MDF	;SEE IF MULT-DEFINED
	JRST	MULDF2		;NO
	MOVE	T1,1(P3)	;GET SYMBOL
	PUSHJ	P,.TSIXN##	;SIXBIT WORD
	PUSHJ	P,.TTABC##	;TAB
	MOVE	T1,2(P3)	;VALUE
	PUSHJ	P,.TOCTW##	;IN OCTAL
	PUSHJ	P,.TYLPP	;NEW LINE
IFE DEBSW,<			;IF DEBUGGING SCAN ALL OF TABLE
	SOJLE	P1,MULDF3	;DONE IF NO MORE UNDFS
				;INCASE COUNT OFF>
MULDF2:	SOJGE	P2,MULDF1	;LOOP IF MORE SYMBOLS TO LOOK AT
MULDF3:	PUSHJ	P,.TYLPP
	PUSHJ	P,TYSTAR
	JRST	MAPIDX

UNRTAB:	[ASCIZ	/ undefined global symbol/]
	[ASCIZ	/ undefined global symbols/]

MDFTAB:	[ASCIZ	/ multiply-defined global symbol/]
	[ASCIZ	/ multiply-defined global symbols/]

SUBTTL	MAP INDEX

IDXHDR:	ASCIZ	\	Index to LINK-10 symbol map of	\

MAPIDX:	MOVE	T1,PRGNO
	SOJLE	T1,MAPEND	;IGNORE INDEX IF ONLY ONE PROGRAM
	MOVE	T1,PAGENO
IFE FTOVERLAY,<
	SOJLE	T1,MAPEND	;OR ONLY ONE PAGE
>
IFN FTOVERLAY,<
	SUB	T1,FSTPGN	;- START OF THIS OVERLAY
	JUMPLE	T1,MAPEND	;OR ONLY ONE PAGE
>
	SETZM	CNTLPP		;WANT NEW PAGE
	MOVEI	T1,IDXHDR	;CHANGE HEADER
	MOVEM	T1,PAGHDR
	PUSHJ	P,.TYLPP	;AND FORCE IT OUT
IFN FTOVERLAY,<
	MOVE	T1,LNKNO.
	ROT	T1,-1		;USUAL WAY TO ADDRESS 1/2 WORD
	MOVE	T2,PAGENO	;PAGE # OF INDEX
	JUMPL	T1,[HRRM T2,@OVMIDX
		JRST	.+2]
	HRLM	T2,@OVMIDX
>;END OF IFN FTOVERLAY
	PUSHJ	P,IDXSRT	;SORT AND LIST
	JRST	MAPEND		;ALL DONE
;NOW TO SORT INDEX

;USES W1, W2, W3 TO HOLD AOBJN POINTERS
;R1, R2 TO HOLD COUNT AND POSITION
;T1 T2 TO HOLD CURRENT NAME AND PAGE
;T3 T4 FOR EXCHANGE

IDXLP0:	MOVE	W1,W2		;GET RUNNING COPY
	DMOVE	T1,0(W1)	;NAME & PAGE

IDXLP1:	CAMLE	T1,2(W1)	;BIGGER THAN ONE FOLLOWING?
	JRST	IDXSWP		;YES, MUST EXCH
	CAML	T1,2(W1)	;HOWEVER IF JUST EQUAL
	JRST	[CAMLE	T2,3(W1)	;TEST 2ND WORD
		JRST	IDXSWP		;SMALLER, SO SWAP
		JRST	.+1]		;REALLY IS BIGGER
	DMOVE	T1,2(W1)	;NO GET BIGGER
	ADDI	W1,1		;ACCOUNT FOR 2ND ENTRY
IDXLP2:	AOBJN	W1,IDXLP1	;AND FOR ALL NAMES IN TABLE

	AOBJP	W2,CPOPJ	;ALL SORTED NOW
	SOJA	W2,IDXLP0	;TRY AGAIN

IDXSWP:	DMOVE	T3,2(W1)	;GET NAME & PAGE
	DMOVEM	T3,0(W1)	;AND STORE
	DMOVEM	T1,2(W1)
	AOJA	W1,IDXLP2	;TRY NEXT

IDXSRT:	MOVN	W2,PRGNO	;NO. OF NAMES
	AOJE	W2,IDXFIN	;DON'T SORT IF SINGLE ITEM
	HRLZ	W2,W2
	HRR	W2,MDLIDX	;-N+1,,INDEX
	PUSHJ	P,IDXLP0	;SORT BUFFER
;	JRST	IDXFIN		;PRINT RESULTS
IDXFIN:	MOVE	R1,PRGNO	;INITIAL NO OF NAMES
	MOVE	R2,MDLIDX	;INITIAL POSSITION
IDXHDI:	MOVE	T1,R1		;NO. OF MODULE NAMES LEFT
	CAILE	T1,4*<LN.LPP-4>	;WILL IT FIT ON PAGE
	MOVEI	T1,4*<LN.LPP-4>	;NO, JUST USE MAX
	SUBI	R1,(T1)		;REDUCE COUNT NOW LEFT
	MOVE	T3,T1		;GET A COPY
	IDIVI	T1,4		;4 ACCROSS
	MOVSI	W1,-4		;AOBJN POINTER
	MOVEM	T1,LCOUNT(W1)	;STORE COUNT
	SOSL	T2		;IF REMAINDER
	AOS	LCOUNT(W1)	;COUNT ONE MORE
	AOBJN	W1,.-3		;LOOP FOR ALL 4
	MOVSI	W1,-4+1		;RESET POINTER
	MOVE	T1,R2		;GET ADDRESS OF FIRST ITEM FOR THIS PAGE
	ADDI	R2,(T3)		;INCREMENT FOR NEXT TIME
	HRLI	T1,(POINT 36)	;FORM BASIC BYTE PTR
	MOVEM	T1,BYTEPT(W1)	;STORE IT
	ADD	T1,LCOUNT(W1)	;GET TO NEXT
	ADD	T1,LCOUNT(W1)	;2 WORDS PER ITEM
	MOVEM	T1,BYTEPT+1(W1)
	AOBJN	W1,.-3		;FOR ALL
IDXHD0:	MOVSI	W1,-4		;BASIC LOOP
	MOVEI	T1,[ASCIZ	\	Name	Page\]
	SKIPE	LCOUNT(W1)	;ANYTHING TO OUTPUT FOR THIS COLUMN
	PUSHJ	P,.TSTRG##
	AOBJN	W1,.-3
	PUSHJ	P,.TYLPP	;END LINE
	PUSHJ	P,.TYLPP	;AND BLANK LINE
	MOVSI	W1,-4		;NOW FOR OUTPUT
IDXHD1:	SOSGE	LCOUNT(W1)	;ANYTHING TO DO
	JRST	IDXHD2		;NOT FOR THIS COLUMN
	PUSHJ	P,.TTABC##	;SPACE ACROSS
	ILDB	T1,BYTEPT(W1)	;GET NAME
	ILDB	T2,BYTEPT(W1)	;AND PAGE
	LSH	T2,1		;NOW PUT BACK
	LSHC	T1,2		;AS SIXBIT AND PAGE NO
	PUSH	P,T2		;SAVE PAGE
	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TTABC##
	POP	P,T1		;PAGE
	MOVS	T1,T1		;RIGHT JUSTIFIED
	MOVEI	T2," "		;FILLER CHAR
	PUSHJ	P,.TDEC2##	;DECIMAL
IDXHD2:	AOBJN	W1,IDXHD1	;LOOP ACCROSS PAGE
	PUSHJ	P,.TYLPP	;END LINE
	MOVSI	W1,-4		;REINIT COUNTER
	SKIPLE	LCOUNT(W1)	;DONE IF NOTHING LEFT ON THIS PAGE
	JRST	IDXHD1		;NO, OUTPUT NEXT LINE
	JUMPG	R1,IDXHDI	;MORE TO COME
	POPJ	P,		;ALL DONE

MAPEND:
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;ANY OVERLAYS?
	JRST	MAPND1		;NO
	AOS	T1,LNKNO.
	CAMG	T1,LNKMAX	;ALL DONE?
	JRST	OVMAP0		;NO
	SETZM	CNTLPP		;WANT NEW PAGE
	MOVEI	T1,OVXHDR	;CHANGE HEADER
	MOVEM	T1,PAGHDR
	SETOB	R2,LNKNO.	;START WITH LINK# 0
	PUSHJ	P,.TYLPP	;AND FORCE IT OUT
	MOVE	R1,LNKMAX	;HIGHEST LINK NO.
	ADDI	R1,1		;INITIAL NO. OF LINKS
OVXHDI:	MOVE	T1,R1		;NO. OF MODULE NAMES LEFT
	CAILE	T1,4*<LN.LPP-4>	;WILL IT FIT ON PAGE
	MOVEI	T1,4*<LN.LPP-4>	;NO, JUST USE MAX
	SUBI	R1,(T1)		;REDUCE COUNT NOW LEFT
	MOVE	T3,T1		;GET A COPY
	IDIVI	T1,4		;4 ACROSS
	MOVSI	W1,-4		;AOBJN POINTER
	MOVEM	T1,LCOUNT(W1)	;STORE COUNT
	SOSL	T2		;IF REMAINDER
	AOS	LCOUNT(W1)	;COUNT ONE MORE
	AOBJN	W1,.-3		;LOOP FOR ALL 4
	MOVSI	W1,-4+1		;RESET POINTER
	MOVE	T1,R2		;GET ADDRESS OF FIRST ITEM FOR THIS PAGE
	ADDI	R2,(T3)		;INCREMENT FOR NEXT TIME
	MOVEM	T1,BYTEPT(W1)	;STORE IT
	ADD	T1,LCOUNT(W1)	;GET TO NEXT
	MOVEM	T1,BYTEPT+1(W1)
	AOBJN	W1,.-2		;FOR ALL
OVXHD0:	MOVSI	W1,-4		;BASIC LOOP
	MOVEI	T1,[ASCIZ	\	overlay	Page\]
	SKIPE	LCOUNT(W1)	;ANYTHING TO OUTPUT FOR THIS COLUMN
	PUSHJ	P,.TSTRG##
	AOBJN	W1,.-3
	PUSHJ	P,.TYLPP	;END LINE
	PUSHJ	P,.TYLPP	;AND BLANK LINE
	MOVSI	W1,-4		;NOW FOR OUTPUT
OVXHD1:	SOSGE	LCOUNT(W1)	;ANYTHING TO DO
	JRST	OVXHD2		;NOT FOR THIS COLUMN
	PUSHJ	P,.TTABC##	;SPACE ACROSS
	MOVEI	T1,"#"		;SAVE CONFUSION, MARK LINKS WITH #
	PUSHJ	P,.TCHAR##
	AOS	T1,BYTEPT(W1)	;GET LINK# OF NEXT LINK
	PUSHJ	P,.TDECW##
	PUSHJ	P,.TTABC##
	MOVE	T1,BYTEPT(W1)	;LINK#
	ROT	T1,-1		;1/2 WORD PICKUP
	JUMPL	T1,[HRRZ T1,@OVMIDX	;GET PAGE #
		JRST	.+2]
	HLRZ	T1,@OVMIDX
	MOVEI	T2," "		;FILLER CHAR
	PUSHJ	P,.TDEC2##	;DECIMAL
OVXHD2:	AOBJN	W1,OVXHD1	;LOOP ACCROSS PAGE
	PUSHJ	P,.TYLPP	;END LINE
	MOVSI	W1,-4		;REINIT COUNTER
	SKIPLE	LCOUNT(W1)	;DONE IF NOTHING LEFT ON THIS PAGE
	JRST	OVXHD1		;NO, OUTPUT NEXT LINE
	JUMPG	R1,OVXHDI	;MORE TO COME

	HRRZ	T2,LNMPTR	;GET NUMBER OF NAMES
	JUMPE	T2,MAPND1	;NONE
	LSH	T2,1		;2 WORDS PER NAME
	PUSHJ	P,DY.GET##	;GET SPACE TO HOLD LIST SO WE CAN SORT
	MOVEM	T1,MDLIDX
	HRLI	T1,(POINT 36)
	MOVEM	T1,MDLPTR
	PUSHJ	P,.TYLPP	;BLANK LINE
	MOVEI	T1,OVNHDR	;NEW HEADER LINE
	MOVEM	T1,PAGHDR	;INCASE NEEDED
	PUSHJ	P,.TSTRG##	;OUTPUT IT ANYWAY
	MOVE	T1,MAPNAM
	PUSHJ	P,.TSIXN##
	SKIPE	MAPVER		;ANY VERSION
	PUSHJ	P,[MOVEI T1,[ASCIZ	\	version \]
		PUSHJ	P,.TSTRG##
		MOVE	T1,MAPVER
		PJRST	.TYVER##]
	PUSHJ	P,.TYLPP	;END LINE
	PUSHJ	P,.TYLPP	;BLANK LINE SEPARATOR
	HLRZ	T2,LNMPTR	;GET INITIAL PTR
OVXHD4:	MOVE	T3,0(T2)	;GET NAME
	MOVE	T2,1(T2)	;NUMBER ,, PTR
	HLRZ	T1,T2		;NUMBER
	ROT	T1,-1		;1/2 WORD PICKUP
	JUMPL	T1,[HRLZ T4,@OVMIDX
		JRST	.+2]
	HLLZ	T4,@OVMIDX	;PAGE CORRESPONDING TO LINK#
	LSHC	T3,-2		;SO SIGNED TEST CAN WORK
	LSH	T4,-1		;SAME FOR 2ND WORD OF PAIR
	TXNN	T3,3B3		;IF NOT ALPHANUMERIC
	TXO	T3,1B1		;MAKE .,%,$ LARGER
	IDPB	T3,MDLPTR	;STORE MODIFIED NAME
	IDPB	T4,MDLPTR	;AND PAGE NO
	TRNE	T2,-1		;DONE?
	JRST	OVXHD4		;NOT YET
	PUSH	P,PRGNO		;EASIEST WAY TO FAKE OUT IDXSRT
	HRRZ	T1,LNMPTR
	MOVEM	T1,PRGNO
	PUSHJ	P,IDXSRT	;SORT AND LIST
	POP	P,PRGNO
	JRST	MAPND1


OVXHDR:	ASCIZ	\	index to overlay numbers of \
OVNHDR:	ASCIZ	\	index to overlay names of \
>;END OF IFN FTOVERLAY
MAPND1:	PUSHJ	P,.TYLPP	;BLANK LINE
	MOVEI	T1,END1		;AND FINAL MESSAGE
	PUSHJ	P,.TSTRG##
	MOVE	T1,MAPNAM
	PUSHJ	P,.TSIXN##
	MOVEI	T1,"]"
	PUSHJ	P,.TCHAR##
	PUSHJ	P,.TCRLF##

MAPRET:	PUSHJ	P,LOGBCK	;RESTORE LOG DEVICE
	.ERR.	(MS,0,V%L,L%I,S%I,EMS,<End of MAP segment>)
	SKIPN	T2,PRGNO	;NOW RESTORE INDEX BLOCK
	JRST	MAPRT0		;BUT NOT IF ZERO
	LSH	T2,1		;2 WORDS PER ENTRY
	HRRZ	T1,MDLIDX	;ADDRESS OF BLOCK
	JUMPE	T1,MAPRT0	;WE HAD NO SYMBOLS
	PUSHJ	P,DY.RET##
MAPRT0:	MOVE	T1,LS.LB	;NOW TO MAKE SURE LS.PT IS CORRECT
	ADD	T1,LSYM		;BASE + LENGTH
	SUB	T1,LW.LS	; - OFFSET
	MOVEM	T1,LS.PT	;POINTS TO NEXT FREE SYMBOL SLOT
	SUB	T1,LS.AB	;GET NO. OF FREE WORDS
	MOVMM	T1,LS.FR	; IN LAST BLOCK
	SETZM	LS.PP		;OK TO DEFAULT PAGE SYMBOLS AGAIN
	MOVE	T1,MAPSW	;SEE WHAT SORT OF MAP IT WAS
	CAMN	T1,[$MAPEND]	;@ END?
	JRST	MAPXIT		;YES, FINISH OFF
	SKIPN	UW.LS		;PAGING SYMBOLS?
	JRST	MAPRT1		;NO
	MOVE	T1,LS.AB	;TOP
	SUB	T1,LS.LB	;LENGTH
	SUBI	T1,.IPM		;MINUS LAST BLOCK
	ADDM	T1,LW.LS	;ONLY KEEP LAST BLOCK IN CORE
	MOVE	T1,LS.AB
	SUBI	T1,.IPS		;LAST ADDRESS TO KEEP
	PUSHJ	P,GBCK.L##	;GIVE IT AWAY
MAPRT1:	CAMN	T1,[$MAPNOW]	;@ NOW
	JRST	MAPRT2		;YES, CLOSE MAP AND DELETE BUFFERS
	CAME	T1,[$MAPERROR]	;ON ERROR
	POPJ	P,
	PUSHJ	P,DVRLS.##	;CLOSE OUT MAP FILE
	RELEASE	RC,		;AND LOG FILE
	EXIT			;GIVE UP

MAPRT2:	SETZM	MAPSW		;DONE WITH MAP SPEC
	PUSHJ	P,DVRLS.##	;CLOSE FILE
	MOVEI	T1,MC		;NOW DELETE BUFFERS
	MOVEM	T1,IO.CHN
	PUSHJ	P,DVZAP.##	;AND DATA BLOCK
	JRST	LNKLOD		;GET NEXT F/S

;HERE IF SYMBOL AREA EMPTY
NOMAP:	MOVEI	T1,[ASCIZ	\	No symbols to output
\]
	pushj	p,.tstrg##
	jrst	mapret		;and give up

IFE FTOVERLAY,<
	MAPXIT=LNKXIT
>

IFN FTOVERLAY,<
MAPXIT:	SKIPL	LNKMAX		;ANY OVERLAYS?
	POPJ	P,		;YES, RETURN TO LNKOV2
	JRST	LNKXIT		;NO
>
SUBTTL	DATA STORAGE

.ZZ==.TEMP
U	(OLDDEV)		;LOG DEVICE WHILE MAP IN USE
U	(CNTLPP)		;LINE PER PAGE
U	(PAGENO)		;PAGE NUMBER (STARTS AT 1)
U	(MAPNAM)		;SIXBIT NAME OF MAP FILE
U	(SYMPTR)		;POINTER TO CURRENT SYMBOL (REL TO LS.LB)
U	(ASTPTR)		;POINTER TO CURRENT ASSOCIATED TRIPLET (ABS)
U	(SYFLAG)		;TEMP W1
U	(VALUE)		;TEMP W3
U	(ZERLEN)		;-1 IF ZERO LENGTH PROG
U	(MAPVER)		;VERSION IN LOC 137 (REL TO LC.LB)
U	(CURPRG)		;CURRENT OUTPUT PROG NAME
U	(PAGHDR)		;POINTER TO PAGE HEADER
U	(MDLIDX)		;INDEX TO PROG NAMES
U	(MDLPTR)		;BYTE POINTER TO NAMES
U	(MDLCNT)		;RUNNING COUNT OF PROGRAM NAMES
U	(BYTEPT,4)		;BYTE POINTERS FOR OUTPUT
U	(LCOUNT,4)		;LINE COUNTS FOR OUTPUT
U	(OVMIDX)		;INDEX TO LINK NUMBERS
U	(ODDNESS)		;COLUMN COUNTER (ON/OFF)
U	(NXTTTL)		;REL POSITION OF NEXT TITLE
U	(SRTPTR,2)		;START AND SIZE OF SORT BUFFER
U	(FSTPGN)		;FIRST PAGE# OF THIS LINK

MAPLIT:
END	LNKMAP

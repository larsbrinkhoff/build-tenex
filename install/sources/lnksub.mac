TITLE	LNKPRM - RETURN NEXT PRIME NUMBER FOR HASH SEARCH
SUBTTL D.M.NIXON/DMN	24-JULY-73

;***COPYRIGHT (C) 1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

SEARCH LNKLOW,LNKPAR

CUSTVR==0		;CUSTMER VERSIN
DECVER==1		;DEC VERSION
DECMVR==1		;DEC MINOR VERSION
DECEVR==36		;DEC EDIT VERSION

SEGMENT

ENTRY	NPRIME
EXTERN	LNKLOG

;HERE TO GET THE REQUIRED PRIME NUMBER INTO HT.PRM
;USUALLY JUST THE NEXT PRIME IS REQUIED, IN WHICH CASE
;HT.PRM CONTAINS THE LAST PRIME USED
;OTHERWISE HT.PRM CONTAINS A NUMBER ON ENTRY, THE RETURN WILL SET
;HT.PRM WITH A PRIME NUMBER LARGER THAN THE ENTRY NUMBER.
;USES T1

NPRIME:	IBP	PRMPTR		;INCREMENT REL POINTER
	MOVE	T1,PRMPTR	;GET IT
	ADDI	T1,PRMTAB	;MAYBE IN MORE THAN ONE SEGMENT
	ILDB	T1,T1		;GET NEXT PRIME
	JUMPE	T1,PRMERR	;NONE THERE (0 IS END MARKER)
	SKIPE	HASHSZ		;SKIP IF NO USER SIZE REQUEST
	CAML	T1,HASHSZ	;AS BIG AS USER REQUESTED?
	CAMGE	T1,HT.PRM	;IS IT BIG ENOUGH?
	JRST	NPRIME		;NO, TRY AGAIN
	MOVEM	T1,HT.PRM	;STORE NEW PRIME
	POPJ	P,		;AND RETURN

PRMERR:	.ERR.	(MS,0,V%L,L%F,S%F,HTL,<Symbol hash table too large>)

SUBTTL	TABLE OF PRIME NUMBER STORED 2 PER WORD
;POINTER IS IN PRMPRT (REL TO PRMTAB)
;THE PRIMES ARE THE NEAREST PRIME TO N*P-3
;WHERE P IS ONE PAGE (512.) WORDS

DEFINE MAKPRM (PRIME)<
 RADIX 10
 %PL==<%PR==0>
 IRP PRIME,<
  IFN %PL,<%PR==PRIME>
  IFE %PL,<%PL==PRIME>
  IFN %PR,<
	%PL,,%PR
   %PL==<%PR==0>
 >>
	%PL,,%PR
 RADIX 8
>

PRMTAB:
MAKPRM <127,251,509,1021,1531,2039,2557,3067,3581,4093,4603,5099,5623,
6133,6653,7159,7673,8179,8699,9209,9721,10223,10739,11261,11743,12281,
12791,13309,13807,14327,14843,15349,15859,16381,16889,17401,17911,18427,
18919,19447,19963,20477,20983,21499,22013,22511,23029,23549,24061,24571,25073>


PRGEND
TITLE .TSUBS - TYPE OUT ROUTINES
SUBTTL	D.M.NIXON/DMN	24-JULY-73

;***COPYRIGHT (C) 1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

SEARCH LNKLOW,LNKPAR,C

CUSTVR==0		;CUSTMER VERSIN
DECVER==1		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==36		;DEC EDIT VERSION

SEGMENT
ENTRY	.T6OCT,.TFOCT,.T6ZOC,.TYVER,.TDEP,.TOEP

;HERE TO OUTPUT OCTAL FULL WORD WITH LEADING BLANKS
;IGNORES SIGN BIT AND USES 36 BIT VALUE
;CALLED BY 
;	MOVE	T1,WORD
;	PUSHJ	P,.TFOCT
;USES T1, T2, T3

.TFOCT:	TLNN	T1,-1		;ANY LEFT HALF?
	JRST	T6SPAC		;NO
	HRRZ	T2,T1		;GET LAST 6 DIGITS
	PUSH	P,T2		;SAVE
	HLRZ	T1,T1		;FIRST SIX
	PUSHJ	P,.T6OCT	;LEADING SPACES
	POP	P,T1		;GET 2ND PART
	PJRST	.T6ZOC		;WITH LEADING 0'S

T6SPAC:	PUSH	P,T1		;SAVE NUMBER
	MOVEI	T2,6		;SIX SPACES
	PUSHJ	P,.TSPAC##
	SOJG	T2,.-1		;LOOP
	POP	P,T1		;RESTORE ORIGINAL NUMBER
				;FALL INTO.T6OCT

;HERE TO OUTPUT OCTAL HALF WORD WITH LEADING BLANKS
;CALLED BY 
;	HRRZ	T1,WORD
;	PUSHJ	P,.T6OCT
;USES T1, T2, T3

.T6OCT:	JFFO	T1,.+2		;COUNT LOADING ZEROS
	MOVEI	T2,^D18+5*3	;ALL ZERO
	SUBI	T2,^D18		;IGNORE LEFT HALF
	IDIVI	T2,3		;INTO OCTAL (3 BITS PER 0)
	JUMPE	T2,.TOCTW##	;NO LEADING SPACES
	MOVE	T3,T1		;SAVE T1
	PUSHJ	P,.TSPAC##	;FILL
	SOJG	T2,.-1		;LOOP
	MOVE	T1,T3		;RESTORE
	PJRST	.TOCTW##	; AND OUTPUT OCTAL NUMBER


;HERE TO OUTPUT OCTAL HALF WORD WITH LEADING ZEROS
;CALLED BY 
;	HRRZ	T1,WORD
;	PUSHJ	P,.T6ZOC
;USES T1, T2, T3

.T6ZOC:	JFFO	T1,.+2		;COUNT LOADING ZEROS
	MOVEI	T2,^D18+5*3	;ALL ZERO
	SUBI	T2,^D18		;IGNORE LEFT HALF
	IDIVI	T2,3		;INTO OCTAL (3 BITS PER 0)
	JUMPE	T2,.TOCTW##	;NO LEADING SPACES
	MOVE	T3,T1		;SAVE T1
	MOVEI	T1,"0"
	PUSHJ	P,.TCHAR##	;FILL
	SOJG	T2,.-2		;LOOP
	MOVE	T1,T3		;RESTORE
	PJRST	.TOCTW##	; AND OUTPUT OCTAL NUMBER

;DEC NUM IN PARENS "(###)"
;CALLED BY
;	MOVE	T1,DEC. NUMBER
;	PUSHJ	P,.TDEP

.TDEP::	PUSH	P,T1		;SAVE NUMBER
	MOVEI	T1,"("
	PUSHJ	P,.TCHAR##	;ENCLOSE NUMBER IN ()
	POP	P,T1
	PUSHJ	P,.TDECW##
	MOVEI	T1,")"
	PJRST	.TCHAR##

;OCTAL NUMBER ENCLOSED IN PARENS
;CALLED BY
;	MOVE	T1,NUMBER
;	PUSHJ	P,.TOEP

.TOEP::	PUSH	P,T1		;SAVE NUMBER
	MOVEI	T1,"("
	PUSHJ	P,.TCHAR##
	POP	P,T1
	PUSHJ	P,.TOCTW##
	MOVEI	T1,")"
	PJRST	.TCHAR##

;.TYVER -- TYPE WORD IN VERSION NUMBER FORMAT
;CALL:	MOVE	T1,WORD
;	PUSHJ	P,.TYVER
;USES T1, T2, T3, T4

.TYVER:	MOVE	T4,T1		;SAFER PLACE FOR VERSION WORD
	LDB	T1,[POINT 9,T4,11]  ;GET MAJOR VERSION
	SKIPE	T1		;IF NON-ZERO,
	PUSHJ	P,.TOCTW##	;  PRINT IN OCTAL
	LDB	T1,[POINT 6,T4,17]  ;GET MINOR VERSION
	JUMPE	T1,TYVER2	;IF NON-ZERO,
	IDIVI	T1,^D26		;  PRINT IN ALPHA
	JUMPE	T1,TYVER1	;  ONE OR TWO
	MOVEI	T1,"A"-1(T1)	;  CHARACTERS
	PUSHJ	P,.TCHAR##	;  ..
TYVER1:	MOVEI	T1,"A"-1(T2)	;  ..
	PUSHJ	P,.TCHAR##	;  ..
TYVER2:	HRRZ	T1,T4		;GET EDIT NUMBER
	SKIPE	T1		;IF NON-ZERO,
	PUSHJ	P,.TOEP		;(OCTAL) IN PARENS
	LDB	T2,[POINT 3,T4,2]
	JUMPE	T2,CPOPJ	;IF CUST. NUMBER NON-ZERO,
	MOVEI	T1,"-"		;  PRINT -
	PUSHJ	P,.TCHAR##	;  ..
	MOVE	T1,T2
	PJRST	.TOCTW##	;  AND NUMBER

CPOPJ:	POPJ	P,


PRGEND
TITLE	CSTORE - DUMMY FOR CSTORE MACRO
SUBTTL	D.M.NIXON/DMN	22-MAR-74

ENTRY	CS.LHS,CS.RHS
SEARCH	LNKPAR

CS.LHS==(MOVEM W1,(P3))
CS.RHS==0

PRGEND
TITLE LNK000 - DUMMY LINK10
SUBTTL D.M.NIXON/DMN	27-OCT-72

ENTRY	LINK10
SEARCH	LNKPAR,LNKLOW

SEGMENT

LINK10:
IFE FTSINGLE,<
	MOVE	T1,['LINK  ']
	JRST	@NXTSEG
>

PRGEND

TITLE	LNK001 - DUMMY LNKSCN
SUBTTL	D.M.NIXON/DMN	24-OCT-72

ENTRY	LNKSCN
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKSCN:
IFE FTSINGLE,<
	MOVE	T1,['LNKSCN']
	JRST	@NXTSEG
>

PRGEND

TITLE	LNK002 - DUMMY LNKLOD
SUBTTL	D.M.NIXON/DMN	24-OCT-72

ENTRY	LNKLOD
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKLOD:
IFE FTSINGLE,<
	MOVE	T1,['LNKLOD']
	JRST	@NXTSEG
>

PRGEND

TITLE	LNK003 - DUMMY LNKMAP
SUBTTL	D.M.NIXON/DMN	27-OCT-72

ENTRY	LNKMAP
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKMAP:
IFE FTSINGLE,<
	MOVE	T1,['LNKMAP']
	JRST	@NXTSEG
>

PRGEND
TITLE	LNK004 - DUMMY LNKXIT
SUBTTL	D.M.NIXON/DMN	24-OCT-72

ENTRY	LNKXIT
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKXIT:
IFE FTSINGLE,<
	MOVE	T1,['LNKXIT']
	JRST	@NXTSEG
>

PRGEND

TITLE	LNK005 - DUMMY LNKERR
SUBTTL	D.M.NIXON/DMN	26-JULY-73

ENTRY	LNKERR
SEARCH	LNKPAR,LNKLOW,C

SEGMENT

LNKERR:
IFE FTSINGLE,<
	MOVE	T1,%HISEG+.JBHNM	;GET NAME OF THIS SEGMENT
	CAMN	T1,['LNK999']	;IF LNK999
	JRST	.RPOPJ		;DON'T ALLOW EXTRA GETSEGS
	MOVE	T1,[P2,,SAVEAC+P2]
	BLT	T1,SAVEAC+16	;SAVE ALL VAULABLE ACCS
				;NOTE P1 IS ALREADY SAVED ONCE
	MOVEM	P1,SAVEAC+T1	;SO SAVE IT AGAIN IN T1 FOR LNKLOG
	MOVE	T1,['LNKERR']
	JRST	@NXTSEG

.RPOPJ::MOVE	T1,UUOTRAP	;PICKUP PC WORD
	TXZ	T1,PC.LIP	;INCASE EXECUTE ONLY
	JRSTF	@T1		;SINCE JSR WAS IN PUBLIC PAGE
>

PRGEND

TITLE	LNK006 - DUMMY LNKOV1
SUBTTL	D.M.NIXON/DMN	28-NOV-73

ENTRY	LNKOV1
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKOV1:
IFE FTSINGLE,<
	MOVE	T1,['LNKOV1']
	JRST	@NXTSEG
>

PRGEND
TITLE	LNK007 - DUMMY LNKOV2
SUBTTL	D.M.NIXON/DMN	28-NOV-73

ENTRY	LNKOV2
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKOV2:
IFE FTSINGLE,<
	MOVE	T1,['LNKOV2']
	JRST	@NXTSEG
>

PRGEND
TITLE	LNK010 - DUMMY LNKPLT
SUBTTL	D.M.NIXON/DMN	1-MAR-74

ENTRY	LNKPLT
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKPLT:
IFE FTSINGLE,<
	MOVE	T1,['LNKPLT']
	JRST	@NXTSEG
>

PRGEND
TITLE	LNK100 - DUMMY OVERLAY ROUTINES
SUBTTL	D.M.NIXON/DMN	20-JUN-74
SEARCH	LNKPAR,LNKLOW

SEGMENT

DEFINE $LABEL (A)<
 IRP A,<
  ENTRY %'A
  INTERN .'A
  .'A:%'A:
>>

ENTRY	ER.IOV
RT.INC:: LINKGO:: INPH:: RDCST:: ER.IOV:
RT.T2F:: RT.T2R:: RT.T2L:: RT.P3:: RT.P2:: RT.FX::
$LABEL <OVERLAY,LINK,NODE,NOENTRY,PLOT,NOREQUEST,RESET,REGION,REQUEST,SPACE>
	.ERR.	(MS,,V%M,L%W,S%I,ONS,<OVERLAYS not supported in this version of LINK-10>)
	POPJ	P,

PRGEND
TITLE	LNK011 - DUMMY TRY.BG
SUBTTL	D.M.NIXON/DMN	28-NOV-73

ENTRY	TRY.BG
SEARCH	LNKPAR

SEGMENT

TRY.BG:	POPJ	P,		;CAN NEVER GET HERE 
				;BUT IF WE DO, POPJ IS RIGHT

PRGEND
TITLE	LNK400 - DUMMY OLD FORTRAN MODULE
SUBTTL	D.M.NIXON/DMN	8-JAN-74

ENTRY	LNKF40
INTERN	T.400,T.401
EXTERN	LNKLOD,LNKLOG
SEARCH	LNKPAR,LNKLOW

SEGMENT

LNKF40:
T.400:
T.401:	.ERR.	(MS,0,V%M,L%F,S%F,OFN,<Old FORTRAN (F40) module not available.>)
END

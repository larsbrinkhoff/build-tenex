TITLE LNKOLD - LOAD OLD BLOCKS MODULE FOR LINK-10
SUBTTL	D.M.NIXON/DMN	9-JUL-74


;***COPYRIGHT 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKOLD
SEARCH	LNKPAR,LNKLOW,C,SCNMAC
EXTERN	LNKSCN,LNKLOD,LNKCOR,LNKWLD,LNKLOG,LNKCST



CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==217		;DEC EDIT VERSION





;LOCAL ACC DEFINITIONS
INTERN	R,RB,WC

R=R1		;CURRENT RELOCATION COUNTER
RB=R+1		;RELOCATION BYTE WORD
WC=R3		;WORD COUNT

SEGMENT

SUBTTL	REVISION HISTORY

;START OF VERSION 1A
;43	FORTRAN-10 LOCAL SYMBOLS IN COMMON NOT FIXED UP CORRECTLY
;46	ADD KLUDGE FEATURE
;47	INTEGRATE WITH SCAN %4, ADD DATE75 HACK
;54	ADD KIONLY D.P. INST.
;61	ADD STORE CODE IN CORE FOR T.3 TWOSEG FIXUPS
;62	FIX BUG IN BLOCK TYPE 11 (POLISH FOR FORTRAN-10)
;63	ADD EXTERNAL START ADDRESS IN BLOCK TYPE 7
;71	ADD MORE STANDARD MESSAGES
;72	(11315) CTYPE NOT CLEARED ON UNKNOWN COMPILER TYPE
;75	FIX ALGOL OWN BLOCK, CALL ADCHK. ROUTINE
;101	MORE FIXES FOR FAIL CODE IF UNDEF GLOBAL REQUEST
;102	ADD TEST AND CURE FOR NO END BLOCK
;104	PUT FAIL BLOCK HEADERS IN LOCAL SYMBOL TABLE
;105	MAKE BLOCK TYPE 12 WORK
;106	ALLOW HIGH SEG TO LOAD AT ADDRESS OTHER THAN 400000
;107	REPLACE KLUDGE BY MIXFOR
;111	MAKE MIXFOR WORK EVEN IF NOT SEARCH MODE
;116	FIX UNDEFINED SYMBOL COUNT IN FAIL BLOCKS
;126	CHANGE CALLING SEQUENCE ON ADDRESS CHECKING AND STORING INTO CORE
;130	(12315) NOT ALL SYMBOL COPIED WHEN PREVIOUSLY REQUESTED COMMON IS DEFINED
;133	CAN NOT LOAD LIBSAI (SAIL LIBRARY), RETURN FROM T.11EV IS WRONG
;131	(12431) OCCASIONALLY ABS SYMBOLS SHOW AS REL IN MAP

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;136	FIX VARIOUS BUGS
;143	MAKE /INCLUDE WORK BETTER
;144	(12772) DON'T STORE SFD FOR MAP IF BOTH WORDS ARE 0
;162	CHANGE W1 TO W3 IN T.14 CODE TO AVOID CONFLICT WITH OVERLAYS
;166	READ BACK RADIX50 SYMBOL FILES (TYPE 776)
;171	(13234) FIX ILL MEM REF IF FORTRAN-10 PROG TOO BIG
;174	FIX BUGS IN RELOCATABLE OVERLAYS
;201	MAKE FORDDT WORK
;206	FIX CHAINED REF IF NOT ALL OF CHAIN IN CORE
;210	(13461) MORE OF #172, FIX BLOCK TYPE 16 CORRECTLY
;212	FIX ZEROS IN SYMBOL TABLE BUG AT T.5XPL
;217	STORE POLISH FIXUP POINTER RELOCATED INCASE CORE MOVES
COMMENT	\

ALL OLD LINK ITEMS (BLOCK TYPES) HAVE THE SAME GENERAL FORMAT.
THE FIRST WORD IS THE BLOCK HEADER
	LEFT HALF IS BLOCK TYPE
	RIGHT HALF IS DATA WORD COUNT
THEN FOLLOWS ONE OR MORE 18 WORD SUB-BLOCKS.
EACH SUB-BLOCK IS PRECEDED BY A BYTE WORD CONTAINING 18 2-BIT BYTES
THE BYTE WORDS ARE NOT INCLUDED IN THE DATA WORD COUNT

	----------------
	! TYPE ! COUNT !
	----------------
	! BYTE   WORD  !
	----------------
	! DATA   WORDS !
	----------------
	     ...
	----------------
	! BYTE   WORD  !
	----------------
	! DATA   WORDS !
	----------------
\
SUBTTL BLOCK DISPATCH TABLES

ODSPTB:	LITYPE (0,37)

ODISPL==.-ODSPTB

SALL
SUBTTL	DISPATCH TO OLD BLOCK TYPE

;ENTER WITH BLOCK TYPE IN T1
;ALSO IN W1

LNKOLD:	CAIL	T1,ODISPL*2	;IS IT LEGAL TYPE
	JRST	OLDERR		;NO, SEE IF CUSTOMER SUPPLIED
	TRNE	FL,R.LIB!R.INC	;IN LIBRARY SEARCH MODE OR /INC MODE?
	JRST	T.SRCH		;YES, IGNORE IF NOT BLOCK TYPE 4
	CAIGE	T1,ODISPL	;SEE WHICH HALF OF TABLE TO USE
	SKIPA	T1,ODSPTB(T1)	;USE RIGHT HALF
	HLRZ	T1,ODSPTB-ODISPL(T1)	;USE LEFT HALF
	JRST	(T1)		;DISPATCH


;HERE TO SEE IF "ILLEGAL" LINK ITEM IS IN LNKCST
OLDERR:	CAIGE	T1,100		;IS IT IN CUSTOMER RANGE
	JRST	T.ERR##		;NO
	JRST	LNKCST		;YES, GIVE IT A TRY
;HERE IF IN LIBRARY SEARCH MODE - TEST FOR BLOCK TYPE 4, 6, 14

T.SRCH:	CAIN	T1,4		;IS IT ENTRY BLOCK?
	JRST	T.4		;YES, SEE IF WE WANT IT
	CAIN	T1,6		;TITLE BLOCK (INCASE /INCLUDE)
	JRST	T.6
	CAIN	T1,14		;INDEX BLOCK?
	JRST	T.14A		;YES, READ INDEX TO SEE IF PROG REQUIRED
	CAIE	T1,5		;END BLOCK?
	JRST	T.0		;NO, IGNORE THIS BLOCK
	PUSHJ	P,T.5ENT	;REMOVE ALL ENTRY POINTS STORED FOR THIS PROG
	HRR	FL,FLAGS	;RESTORE INCASE /EXCL WAS ON
	JRST	T.0		;AND IGNORE BLOCK


SUBTTL	BLOCK TYPE 0 - ALGOL OR JUNK WORD

;	----------------
;	!    0 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! DATA   WORDS !
;	----------------

T.0:	HRRZ	T1,W1		;GET WORD COUNT
	JUMPE	T1,LOAD##	;JUST IGNORE
	CAIG	T1,^D18		;ONLY ONE SUB BLOCK?
	AOJA	T1,T.0A		;YES
	IDIVI	T1,^D18		;GET NUMBER OF SUB BLOCKS
	IMULI	T1,^D19		;COUNT RELOCATION WORD
	JUMPE	T2,T.0A		;ANY REMAINDER?
	ADDI	T1,1(T2)	;IT HAS RELOCATION WORD ALSO
T.0A:	CAML	T1,DCBUF+2	;ENOUGH WORDS IN BLOCK?
	SOJA	T1,T.0B		;NO, BUT ACCOUNT FOR INITIAL ILDB
	ADDM	T1,DCBUF+1	;ADVANCE BYTE POINTER
	MOVN	T1,T1		;NEGATE
	ADDM	T1,DCBUF+2	;COUNT DOWN WORD COUNT
	JRST	LOAD##		;GET NEXT BLOCK

T.0B:	SUB	T1,DCBUF+2	;COUNT DOWN WORDS IN BUFFER
	PUSHJ	P,D.INP##	;GET NEXT BUFFER
	JRST	T.0A		;FINISH OFF BLOCK

T.0C:	PUSHJ	P,RB.1		;GET NEXT WORD
	  JRST	LOAD##		;ALL DONE
	JRST	.-2

SUBTTL	BLOCK TYPE 1 - CODE AND DATA

;			  OR
;	----------------	----------------
;	!    1 ! COUNT !	!    1 ! COUNT !
;	----------------	----------------
;	! BYTE   WORD  !	! BYTE   WORD  !
;	----------------	----------------
;	!      ADDRESS !	!       SYMBOL !
;	----------------	----------------
;	! DATA   WORDS !	!       OFFSET !
;	----------------	----------------
;				! DATA   WORDS !
;				----------------

T.1:	HRRZI	W3,-1(W1)	;GET WORD COUNT OF DATA
	PUSHJ	P,RB.1		;READ ONE WORD AND RELOCATE IT
	  JRST	LOAD##		;GET NEXT BLOCK
	TLZ	R,-1		;CLEAR LEFT HALF NON-RELOC FLAG
	JUMPGE	W1,.+3		;NOT SYMBOLIC
	MOVEI	T1,1		;BLOCK TYPE INCASE ERROR
	PUSHJ	P,T.1S		;SYMBOLIC IF BIT 0 SET
	MOVE	P3,W1		;SAVE START ADDRESS IN P3
	ADD	W1,W3		;HIGHEST ADDRESS NEEDED
	SETO	W3,		;NOT TYPE 21
T.1AD:	MOVE	P2,W1		;GET LOCATION REQUIRED
	.JDDT	LNKOLD,T.1AD,<<CAML	P2,$LOCATION##>,<CAMLE	P3,$LOCATION##>,<CAIA>>
	JUMPE	R,T.1A		;SPECIAL CHECK IF ABSOLUTE ADDRESS
T.1AL:	MOVE	T1,RC.SG(R)	;GET SEGMENT NUMBER
	CAILE	T1,1		;STORE TO LOW SEGMENT
	JRST	T.1H		;NO, CHECK HIGH
	TRNE	FL,R.HSO	;ONLY WANT HIGH SEG CODE?
	JRST	T.0C		;YES, IGNORE THIS BLOCK
IFN FTOVERLAY,<
	CAMGE	P3,PH.ADD	;MAKE SURE ADDRESSIS LEGAL
	JRST	T.1OVE		;NOT IN THIS LINK
	SKIPE	RT.LB		;RELOCATION TABLE SETUP?
	PUSHJ	P,RT.P2##	;YES, SETUP BYTE PTR
>
	CAMLE	P2,HL.S1	;RESET HIGHEST LOCATION COUNTER
	MOVEM	P2,HL.S1	;
	CAMLE	P2,HC.S1	;AND HIGHEST DATA LOADED COUNTER
	MOVEM	P2,HC.S1
	SKIPE	PAG.S1		;PAGING?
	JRST	T.1LP		;YES, SEE IF IN CORE
IFN FTOVERLAY,<
	SUB	P2,PH.ADD	;REMOVE BASE
	SUB	P3,PH.ADD	;SO AS NOT TO WASTE SPACE
>
	ADD	P2,LC.LB	;RELOCATE RELATIVE ADDRESS
	CAMG	P2,LC.AB	;WILL IT FIT IN EXISTING SPACE?
	JRST	T.1L1		;YES
	SUB	P2,LC.AB	;GET EXTRA REQUIRED
	MOVEI	P1,LC.IX	;AREA REQUIRED TO EXPAND
	PUSHJ	P,LNKCOR##	;TRY TO GET MORE SPACE
	  JRST	T.1LP		;FAILED, BUT MUST BE ON DSK BY NOW
	SUB	P3,LW.S1	;INCASE WE DUMPED CORE FOR FIRST TIME
T.1L1:	ADD	P3,LC.LB	;FINALLY FIX THIS INCASE CORE MOVED
;	JRST	T.1DP


T.1DP:	CAMLE	W1,RC.HL(R)	;TEST AGAINST HIGHEST SEEN SO FAR
	MOVEM	W1,RC.HL(R)	;A NEW RECORD
	PUSHJ	P,RB.1		;GET THE DATA WORDS
	  JRST	LOAD##		;FINISHED BLOCK
	CSTORE			;STORE IN CORE
	SOJE	W3,CPOPJ	;T.21 RETURN
	AOJA	P3,.-4		;WILL RETURN TO LOAD WHEN RUN OUT


;HERE IF PAGING TO SEE IF ADDRESS IS
;LESS THAN 140
;OR IF IN CORE
;IF GREATER THAN 137 READ IN FROM DSK
T.1LP:	CAIG	P2,.JBDA	;IN JOBDAT AREA?
	SKIPN	LW.S1		;YES, ONLY IN CORE IF ON BLOCK 1
	CAIA			;NO SUCH LUCK
	JRST	T.1LPJ		;LINK TO LIST OF REPLACEMENTS
	PUSHJ	P,PG.LSG##	;MAKE FULL TEST AND READ IN
	JRST	T.1L1		;NOW IN CORE

T.1LPJ:	PUSHJ	P,RB.1		;GET DATA WORD
	  JRST	LOAD##		;ALL DONE
	HRRZ	T2,P3		;ADDRESS OF WHERE TO LOAD
	EXCH	W1,W3		;DATA IN W3, BUT SAVE OLD W3
	HRLI	T2,CPF.RF	;LOAD OFFSET FOR FULL REPLACEMENT
	MOVEI	R,LC.IX		;MUST BE LOW SEG
	PUSHJ	P,SY.CHP##	;LINK IN LIST
	EXCH	W1,W3		;GET W3 BACK INCASE TYPE 21
	SOJE	W3,CPOPJ	;ALL DONE IF IT WAS
	AOJA	P3,T.1LPJ	;SEE IF ANY MORE (USUALLY NOT)
;HERE FOR ABSOLUTE CODE THIS CAN GO TO EITHER HIGH OR LOW SEGMENT
;KEYED UPON LL.S2, USUALLY TO LOW SEG
T.1A:	MOVE	R,@RC.TB	;SETUP POINTER TO ABS RC BLOCK
	CAMLE	W1,RC.HL(R)	;KEEP TRACK OF LARGEST ABS ADDRESS
	MOVEM	W1,RC.HL(R)	;MIGHT BE USEFUL SOME DAY
	MOVEI	R,2		;ASSUME HIGH
	TRNE	FL,R.TWSG	;MUST BE LOW IF ONLY ONE SEG
	CAMGE	P2,LL.S2	;SEE WHICH SEGMENT
	SOJA	R,.+2		;LOW
	JRST	T.1HA		;HIGH SEG
	MOVE	R,@SG.TB	;SET UP POINTER TO RC BLOCK
	JRST	T.1AL		;TREAT AS IF LOW SEGMENT DATA


T.1HA:	MOVE	R,@SG.TB	;FIXUP R FOR ABS TO HIGH
T.1H:	TRNE	FL,R.LSO	;WANT LOW SEG CODE ONLY
	JRST	T.0C		;YES, IGNORE THIS BLOCK
	SUB	P2,LL.S2	;REMOVE 400000 RELOCATION OFFSET
	SUB	P3,LL.S2	;SINCE THE ARE RELATIVE TO 0 NOW
	CAMLE	P2,HL.S2	;RESET HIGHEST LOCATION COUNTER
	MOVEM	P2,HL.S2	;
	CAMLE	P2,HC.S2	;AND HIGHEST DATA LOADED COUNTER
	MOVEM	P2,HC.S2
	SKIPE	PAG.S2		;PAGING?
	JRST	T.1HP		;YES
	ADD	P2,HC.LB	;RELOCATE RELATIVE ADDRESS
	CAMG	P2,HC.AB	;FIT IN WHAT WE HAVE?
	JRST	T.1H1		;YES
	SUB	P2,HC.AB	;GET EXTRA REQUIRED
	MOVEI	P1,HC.IX	;IN THIS AREA
	PUSHJ	P,LNKCOR##	;GET IT NOW
	  JRST	T.1HP		;NOW IN CORE
	SUB	P3,LW.S2	;INCASE CORE DUMPED FOR FIRST TIME
T.1H1:	ADD	P3,HC.LB
	JRST	T.1DP

T.1HP:	PUSHJ	P,PG.HSG##	;MAKE FULL TEST AND READ IN
	JRST	T.1H1		;NOW IN CORE
;HERE IF FIRST WORD IS A SYMBOL
;SECOND WORD IS OFFSET

T.1S:	MOVE	W2,W1		;EXPECTED IN W2
	LDB	T2,[POINT 4,W2,3]	;CHECK CODE NOT JUST SIGN BIT
	CAIE	T2,14		;MUST BE RADIX50 60,
	JRST	T.ERR##		;GIVE ERROR MESSAGE
	PUSHJ	P,R50T6		;SIXBITIZE IT
	MOVSI	W1,PT.SGN!PT.SYM!PS.GLB	;SET SOME REASONABLE FLAGS
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED
	  JRST	T.1ND		;NOT EVEN IN TABLE
	  JRST	T.1UN		;UNDEFINED, SO STILL NO USE
	MOVE	W2,2(P1)	;GET VALUE
IFN FTOVERLAY,<
	CAMGE	W2,PH.ADD	;MAKE SURE ARRAY IS IN THIS LINK
	JRST	T.1SE		;NO, MUST BE COMMON IN FATHER LINK
>
	PUSHJ	P,RB.1		;READ OFFSET
	  JFCL			;CANNOT HAPPEN
	ADD	W1,W2		;GET START ADDRESS IN W1
	SOJA	W3,CPOPJ	;ONE LESS REAL DATA WORD

IFN FTOVERLAY,<
T.1SE:	MOVE	W2,1(P1)	;ITS NOT, GET NAME
	AOS	W3,LNKMAX	;POINT TO RIGHT LINK
	.ERR.	(MS,.EC,V%L,L%F,S%F,DSC,<Data store to common >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(JMP,.EC,,,,T.1OVG)

T.1OVE:	AOS	W3,LNKMAX	;POINT TO RIGHT LINK
	CAIGE	P3,.JBDA	;MAKE ONLY A WARNING IF TO JOB DATA AREA
	JRST	T.1OVW		;IT WAS
	.ERR.	(MS,.EC,V%L,L%F,S%F,DSL,<Data store to location >)
T.1OVF:	.ETC.	(OCT,.EC!.EP,,,,P3)
T.1OVG:	.ETC.	(STR,.EC,,,,,< not in link number >)
	.ETC.	(DEC,.EP!.EC,,,,W3)
	.ETC.	(STR,.EC,,,,,< for >)
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM)
	.ETC.	(STR,.EC,,,,,< in >)
	.ETC.	(FSP,,,,,DC)
	JRST	T.0C		;GET RID OF BLOCK

T.1OVW:	SOS	LNKMAX		;PUT LINK # BACK
	.ERR.	(MS,.EC,V%L,L%F,S%W,DSL)
	.ETC.	(JMP,.EC,,,,T.1OVF)
>


;HERE IF SYMBOLIC ADDRESS NOT YET DEFINED
T.1UN:	PUSHJ	P,T.1FX		;PUT WHOLE BLOCK IN FIXUP TABLE
	.ERR.	(MS,.EC,V%L,L%F,S%F,CNW)
	.ETC.	(STR,,,,,,<T.1UN+1>)

;HERE IF SYMBOL NOT EVEN IN TABLE
T.1ND:	PUSHJ	P,T.1FX		;PUT WHOLE BLOCK IN FIXUP TABLE
	MOVEI	T2,.L*2		;NEED AT LEAST 2 TRIPLETS
	PUSHJ	P,GS.GET##	;IN GLOBAL AREA
	MOVSI	W1,FP.LBT	;LOADER BLOCK TYPE
	MOVEM	W1,.L(T1)	;STORE FLAGS
	MOVEM	W3,.L+1(T1)	;AND REL POINTER
	MOVSI	W1,PT.SGN!PT.EXT!PT.SYM!PS.REQ!PS.UDF!PS.FXP
	SETZB	W3,2(T1)	;ZERO VALUE
	DMOVEM	W1,0(T1)	;FLAGS & SYMBOL
	MOVE	W3,T1		;INSERT EXPECTS POINTER IN W3
	SUB	W3,NAMLOC	;RELATIVE
	HRRZ	P1,@HT.PTR	;SETUP P1 AGAIN
	ADD	P1,NAMLOC
	PJRST	INSRT##		;AND STORE SYMBOL

;HERE TO PUT WHOLE BLOCK IN FIXUP  TABLE
;W3 CONTAINS WORD COUNT -1
;BUT WE HAVE ALREADY READ 
;HEADER	1,,WORD COUNT
;BYTE WORD
;FIRST DATA ITEM
;DATA IS STORED WITH ONE OVERHEAD WORD OF FLAG BITS ,, POINTER

T.1FX:	MOVEI	T1,1(W3)	;GET WORD COUNT BACK
	IDIVI	T1,^D18		;BUT IT DOESN'T INCLUDE BYTE WORDS
	IMULI	T1,^D19		;AS ONE PER SUB-BLOCK
	SKIPE	T2
	ADDI	T1,1(T2)	;PLUS ONE FOR PARTIAL BLOCK
	MOVEI	T2,2(T1)	;PLUS FLAGS AND HEADER
	PUSHJ	P,FX.GET##	;THATS WHAT WE NEED
	MOVE	W3,T1		;SAVE FOR LATER FIXUP TO GLOBAL
	SUB	W3,FX.LB	;SO WE DON'T FORGET THAT IT'S RELATIVE
	HRLI	T1,(POINT 36,)	;EASY WITH A BYTE POINTER
	MOVSI	W1,FP.SGN!FP.PTR	;SOME FLAGS
	IDPB	W1,T1		;STORE
	POP	P,W1		;RESTORE DATA COUNT
	HRLI	W1,1		;FAKE HEADER UP
	IDPB	W1,T1
	MOVE	W1,RB		;GET RELOCATION BITS
	LSH	W1,-2		;WE'VE ALREADY GOT ONE WORD
	IDPB	W1,T1
T.11LP:	PUSHJ	P,D.IN1##	;READ NEXT DATA WORD
	IDPB	W1,T1		;STORE IT
	SOJG	T2,T.11LP	;LOOP TIL DONE
	POPJ	P,
SUBTTL	BLOCK TYPE 2 - SYMBOLS

;	----------------
;	!    2 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!       SYMBOL !
;	----------------
;	!        VALUE !
;	----------------

;READS A PAIR OF WORDS IN W1 AND W2
;CONVERTS THEN TO NEW TRIPLET FORM IN W1, W2, AND W3
;AND CHANGES RADIX-50 SYMBOL IN W2 TO SIXBIT SYMBOL IN W2

T.2:	PUSHJ	P,RB.2		;GET TWO WORDS
	  JRST	LOAD##		;GET NEXT BLOCK
	MOVE	W3,W1		;PUT VALUE IN W3 WHERE IT BELONGS
	MOVSI	W1,PT.SGN!PT.SYM	;SET SYMBOL FLAGS
	LDB	P1,[POINT 4,W2,3]	;PICK UP LEADING 4 BITS
	PUSHJ	P,R50T6		;CONVERT TO SIXBIT SYMBOL
	.JDDT	LNKOLD,T.2,<<CAMN	W2,$SYMBOL##>>
	SKIPE	R		;SYMBOL RELOCATABLE?
	TLO	W1,PS.REL	;YES
	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,@T.2STB(P1)	;YES, SEE IF NEEDED
	  PUSHJ	P,@T.2TAB(P1)	;GET TO RIGHT ROUTINE
	JRST	T.2		;RETURN FOR NEXT PAIR

;JUMP TABLE TO HANDLE CODE BITS OF RADIX-50 SYMBOL
;UNKNOWN TYPES GIVE ERROR

T.2TAB::T.2R5U			; 0 - 00 NAME (SHOULD NEVER HAPPEN)
	SY.GS			; 1 - 04 GLOBAL DEFINITION
	SY.LS			; 2 - 10 LOCAL DEFINITION
	SY.BH			; 3 - 14 BLOCK HEADER (FAIL)
	T.2R5U			; 4 - 20
	SY.DGR			; 5 - 24 GLOBAL DEFINITION DEFERED RIGHT HALF
	T.2R5U			; 6 - 30
	T.2R5U			; 7 - 34
	T.2R5U			;10 - 40
	SY.GSS			;11 - 44 GLOBAL DEF. (SUPPRESSED) ! LEFT DEFERED 
	SY.LSS			;12 - 50 LOCAL DEF. (SUPPRESSED)
	T.2R5U			;13 - 54
	SY.RQ			;14 - 60 GLOBAL REQUEST
	SY.DGL			;15 - 64 GLOBAL DEFERED DEF (RH) SUPP. ! LEFT HALF
	T.2R5U			;16 - 70
;	T.2R5U			;17 - 74

T.2R5U:	.ERR.	(MS,.EC,V%L,L%F,S%I,URC,<Uknown radix-50 symbol code  >)
	.ETC.	(OCT,.EC!.EP,,,,P1)
	.ETC.	(STR,.EC,,,,,< >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,< in >)
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM)
	.ETC.	(STR,.EC,,,,,< in >)
	.ETC.	(FSP,,,,,DC)
	POPJ	P,		;BUT CONTINUE
;JUMP TABLE IF SELECTIVE LOADING OF EITHER LOW OR HIGH SEGMENT

T.2STB::CPOPJ			; 0 - 00 NAME (SHOULD NEVER HAPPEN)
	T.2CHK			; 1 - 04 GLOBAL DEFINITION
	T.2CHK			; 2 - 10 LOCAL DEFINITION
	CPOPJ			; 3 - 14 BLOCK HEADER (FAIL)
	CPOPJ			; 4 - 20
	T.2CHK			; 5 - 24 GLOBAL DEFINITION DEFERED RIGHT HALF
	CPOPJ			; 6 - 30
	CPOPJ			; 7 - 34
	CPOPJ			;10 - 40
	T.2CHK			;11 - 44 GLOBAL DEF. (SUPPRESSED) ! LEFT DEFERED 
	T.2CHK			;12 - 50 LOCAL DEF. (SUPPRESSED)
	CPOPJ			;13 - 54
	T.2CHK			;14 - 60 GLOBAL REQUEST
	T.2CHK			;15 - 64 GLOBAL DEFERED DEF (RH) SUPP. ! LEFT HALF
	CPOPJ			;16 - 70
	CPOPJ			;17 - 74

T.2CHK:	TLNN	W1,PS.REL	;WE CAN ONLY HANDLE RELOCATABLE SYMBOLS
	POPJ	P,		;ALWAYS LOAD ABS ONES
	EXCH	W1,W3		;PUT ADDRESS IN W1
	PUSHJ	P,CHKSEG	;SEE IF WANTED
	  CAIA			;YES
	AOS	(P)		;NO
	EXCH	W1,W3
	POPJ	P,

;CONVERTS RADIX-50 IN W2 TO SIXBIT IN W2
;ALSO USES T1, T2, T3
;CODE INLINE FOR EXTRA SPEED SINCE LINK-10 SPENDS ABOUT 10% OF
;ITS TIME IN THIS LOOP.

R50T6::	TLZ	W2,740000	;CLEAR CODE BITS
	MOVE	T1,W2		;PUT IN RIGHT AC
	SETZ	T3,		;START WITH ZERO
REPEAT 4,<
	IDIVI	T1,50		;GET TABLE INDEX
	SKIPE	T2,R50TAB(T2)	;GET SIXBIT CODE
	LSHC	T2,-6		;LEFT JUSTIFIED IN AC T3
	CAIG	T1,50		;LAST CHARACTER LEFT?
	JRST	R50T6X		;LAST CHAR IN T1>
;END OF REPEAT 4
	IDIVI	T1,50		;SPLIT LAST 2 CHARS IF WE GET THIS FAR
	SKIPE	T2,R50TAB(T2)	;GET FIFTH CHAR
	LSHC	T2,-6		;STORE IT
R50T6X:	SKIPE	T2,R50TAB(T1)	;LAST TIME
	LSHC	T2,-6
	MOVE	W2,T3		;PUT BACK IN W2
	POPJ	P,

DEFINE R50CHR (CHR)<
 IRPC CHR,<
  ''CHR''
>>

R50TAB:	R50CHR	( 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.$% )



SUBTTL	BLOCK TYPE 2 - SYMBOLS (DEFINITION)

;HERE TO SEARCH FOR GLOBAL DEFINITION, CHECK FOR MULTIPLE DEFINITIONS

SY.GSS:	TLOA	W1,PS.GLB!PS.DDT	;SET SUPPRESSED GLOBAL FLAG
SY.GS::	TLO	W1,PS.GLB	;SET GLOBAL FLAG
	TLNN	W1,PS.ENT	;IF ALREADY KNOWN TO BE AN ENTRY SKIP SEARCH
	SKIPN	T1,ENTPTR	;LOAD AOBJN POINTER TO ENTRIES
	JRST	SYGTRY		;NONE
	CAMN	W2,0(T1)	;MATCH?
	TLOA	W1,PS.ENT	;YES, SET FLAG
	AOBJN	T1,.-2		;NO, TRY NEXT
IFN FMXFOR,<
	TLNE	W1,PS.ENT	;ENTRY POINT
	SKIPG	T2,MIXFOR	;AND WANT MIXFOR FEATURE
	JRST	SYGTRY		;NO
	SUB	T1,ENTPTR	;REL POSITION IN ENTRY TABLE
	ADDI	T2,(T1)		;POSITION IN MIXFOR TABLE
	MOVEM	W3,(T2)		;STORE CORRESPONDING VALUE
	POPJ	P,		;AND DEFINE AT LATER DATE
>
SYGTRY:
IFN FTOVERLAY,<
	SKIPE	T1,BG.SCH	;ABLE TO SEARCH OTHER TABLES?
	JRST	SYBTRY		;YES, MUST NOT DO IT
>
	PUSHJ	P,TRYSYM##	;SEE IF ALREADY DEFINED
	  JRST	SY.GS0##	;NO, PUT IT IN
	  JRST	SY.RF##		;UNDEFINED, FILL IN REQUESTS FOR IT
	CAMN	W3,2(P1)	;CHECK VALUE
	POPJ	P,		;SAME SO ALL WELL
	JRST	SY.MDS##	;MULTIPLY DEFINED

IFN FTOVERLAY,<
SYBTRY:	SETZM	BG.SCH		;TURN OFF ABILITY
	PUSHJ	P,TRYSYM##	;SEE IF ALREADY DEFINED
	  JRST	[SETOM	BG.SCH	;PUT IT BACK
		JRST	SY.GS0##]	;NO, PUT IT IN
	  JRST	[SETOM	BG.SCH
		JRST	SY.RF##]	;UNDEFINED, FILL IN REQUESTS FOR IT
	SETOM	BG.SCH
	CAMN	W3,2(P1)	;CHECK VALUE
	POPJ	P,		;SAME SO ALL WELL
	JRST	SY.MDS##	;MULTIPLY DEFINED
>

;ROUTINE TO ADD CONTENTS OF W1, W2, W3 TO LOCAL SYMBOLTABLE
;ALSO USED TO PUT GLOBALS AND OTHER STUFF THERE
;CHECKS FOR DSK OVERFLOW ETC

SY.LSS:	TLOA	W1,PS.LCL!PS.DDT	;SET SUPPRESSED LOCAL FLAGS
SY.LS:	TLO	W1,PS.LCL	;SET LOCAL FLAG
	TRNN	FL,R.SYM	;IN LOCAL SYMBOL MODE
	POPJ	P,		;NO
	AOS	RSYM		;COUNT ONE MORE ITEM IN LOCAL RADIX50 TABLE
	PJRST	LS.ADD##	;YES, STORE IN TABLE

SUBTTL	BLOCK TYPE 2 - LOCAL BLOCK HEADER (FAIL)

;HERE IF SYMBOL IS A BLOCK HEADER
;THE VALUE IS ITS DEPTH
;STORE IN LOCAL SYMBOL TABLE ONLY
;AND LINK THROUGH PREVIOUS BLOCK HEADERS TO NAME POINTER

SY.BH:	TLC	W1,PT.SYM!PT.TTL!PT.BLK	;SET CORRECT FLAGS
	TRNN	FL,R.SYM	;IN LOCAL SYMBOL MODE
	POPJ	P,		;NO
	SKIPN	T1,FBHPTR	;ALREADY SEEN SOME BLOCK HEADERS?
	HRRZ	T1,NAMPTR	;NO, GET POINTER TO LOCAL SYMBOL
	CAMGE	T1,LW.LS	;IN CORE?
	HALT
	SUB	T1,LW.LS	;GET ADDRESS IN CORE
	ADD	T1,LS.LB
	SKIPGE	T2,(T1)		;MUST BE PRIMARY
	TLNN	T2,PT.TTL	;AND A TITLE BLOCK
	JRST	T.5SER		;NO
	MOVE	T2,LSYM		;GET CURRENT VALUE
	HRLM	T2,2(T1)	;STORE PTR
	MOVEM	T2,FBHPTR	;CURRENT POINTER
	AOS	RSYM		;ONE MORE ITEM IN TABLE
	PJRST	LS.ADD##	;PUT IN TABLE
SUBTTL	BLOCK TYPE 2 - SYMBOLS (PARTIAL DEFINITION)

;HERE FOR "DEFINITION" WHEN SYMBOL NOT FULLY DEFINED
;USUALLY FOLLOWED BY GLOBAL REQUEST FOR SYMBOL FIXUP
;NOTE THERE IS A PROBLEM WITH CONFUSION OVER
; RIGHT HALF DEFERED AND SUPPRESSED
; AND RIGHT AND LEFT HALF DEFERED
; THESE CASES LOOK ALIKE
;THEREFORE TREAT AS RIGHT DEFERED AND SUPPRESSED
; BUT IF A LEFT HALF REQUEST FOLLOWS TURN ON LEFT HALF DEFERED ALSO
;THIS CAN ONLY CAUSE PROBLEMS IF SYMBOL IS LOCAL AND NOT LOADED


SY.DGL:	TLO	W1,PS.DDT	;SUPPRESS TO DDT
SY.DGR:	TLO	W1,PS.GLB!PS.UDR
	PUSHJ	P,TRYSYM##	;SEE IF IN TABLE
	  JRST	SY.DG0		;NO, PUT IN
	  JRST	SY.DG1		;ALREADY IN UNDEF TABLE
	SUB	P1,NAMLOC	;REMOVE OFFSET
	HRLZM	P1,LSTSYM	;POINT TO CURRENT DEFINITION
	HRLZM	P1,PARPTR	;SO WE CAN CHECK FOR SAME DEFINITION
	MOVEM	W3,PARVAL	;STORE PARTIAL VALUE TO
	POPJ	P,		;TRAP MULTIPLE DEFINITION ON NEXT PAIR

;HERE TO PUT REQUEST IN GLOBAL TABLE
;USE EXTENDED BLOCK TO HOLD PARTIAL VALUE

SY.DG0:	AOS	USYM		;COUNT IT AS UNDEFINED
	MOVEI	T2,.L*2		;NEED TWO BLOCKS TO HOLD
	PUSHJ	P,GS.GET##	; PARTIAL DEFINITION AND POSSIBLE CHAINED REQUEST
	TLO	W1,PT.EXT	;MARK AS USING EXTENDED TRIPLET
	DMOVEM	W1,0(T1)	;PRIMARY FLAGS & SYMBOL
	SETZM	2(T1)		;NO REQUESTS YET
	MOVSI	T2,S.LST!S.PVS	;PARTIAL VALUE MARKER
	MOVEM	T2,.L+0(T1)	;SECONDARY FLAGS
	DMOVEM	W2,.L+1(T1)	;SYMBOL AGAIN (MAY AS WELL) & PARTIAL VALUE
	PUSH	P,W3		;SAVE PARTIAL VALUE
	MOVE	W3,T1		;FOR EXTENDED SYMBOLS
	SUB	W3,NAMLOC	;W3 CONTAINS POINTER TO EXTENDED TRIPLET
	PUSHJ	P,INSRT##	;PUT IN GLOBAL TABLE
	TLZ	W1,PT.EXT	;NOT REQUIRED IN LOCAL TABLE
	POP	P,W3		;MAKE PARTIAL VALUE "VALUE"
	PJRST	LS.ADD##	;AND PUT IN LOCAL TABLE

;HERE IF "PARTIALLY DEFINED" SYMBOL IS ALREADY IN UNDEF TABLE
;IT MAY HAVE ADDITIVE GLOBAL FIXUPS AS WELL
;COPY OLD DEF TO NEW LOCATION AND ADD SYMBOL TABLE FIXUP REQUEST
;DELETE OLD SYMBOL SPACE

SY.DG1:	MOVE	T1,0(P1)	;GET OLD FLAGS
	TLNN	T1,PS.REQ	;IS IT A REQUESTED SYMBOL?
	JRST	SY.DG2		;NO, SECOND PARTIAL DEFINITION
	MOVEI	T1,.L		;NEED 1 EXTRA TRIPLET
	PUSHJ	P,SY.MOV##	;AND MOVE WHAT WE HAVE
	MOVSI	T2,S.PVS!S.LST	;MARK AS SYMBOL FIXUP
	MOVEM	T2,0(T1)	;STORE FIXUP FLAG
	DMOVEM	W2,1(T1)	;SYMBOL NAME & PARTIAL VALUE
	TLO	W1,PT.EXT	;MARK AS NOW EXTENDED
	IORB	W1,0(P1)	;YES, SET NEW FLAGS
	TLZ	W1,PT.EXT	;CLEAR AS NOT NEEDED BY LOCALS
	SUB	P1,NAMLOC	;GET REL POSITION OF SYMBOL BLOCK
	HRLZM	P1,LSTSYM	;INCASE OTHER DEFINITION DEPENDS UPON IT
	PJRST	LS.ADD##	;AND PUT IN LOCAL TABLE

SY.DG2:	.ERR.	(MS,.EC,V%L,L%W,S%W,ISD,<Inconsistent symbol definition for >)
	.ETC.	(SBX,.EP,,,,W2)
	SETZM	LSTSYM		;SO WE IGNORE SYMBOL FIXUP FOLLOWING
	POPJ	P,
SUBTTL	BLOCK TYPE 2 - SYMBOLS (REQUEST)

;HERE IF GLOBAL REQUEST SEEN

SY.RQ::	TLO	W1,PS.REQ	;SET REQUEST FLAG (BUT NOT PS.UDF)
	PUSHJ	P,TRYSYM	;SEE IF ALREADY IN TABLE
	  JRST	SY.RQ0		;NO, SO PUT IT IN
	  JRST	SY.RU0		;ALREADY UNDEFINED
				;DEFINED, FILL IN CHAIN

;HERE TO FILL IN GLOBAL REQUEST CHAIN
SY.RC0:	MOVE	T2,W3		;GET START OF CHAIN
IFN FTOVERLAY,<
	IOR	W1,0(P1)	;GET FLAGS
	TXNN	W1,PS.BGS	;FROM A BOUND LINK?
	JRST	.+3		;NO
	HRRZ	R,R		;YES, SO NOT RELOCATABLE W.R.T. THIS LINK
	TLZ	W1,PS.REL
>
	JUMPL	W3,SY.RC1	;ADDITIVE FIXUP?
	MOVE	W3,2(P1)	;NO, GET VALUE OF SYMBOL
	JRST	SY.CHR##	;RIGHT-HALF CHAINED FIXUP


;HERE FOR ADDITIVE FIXUP TO ALREADY DEFINED SYMBOL
;SETUP W1 WITH FIXUP FLAGS (FROM W3)

SY.RC1:	TLNN	W1,PS.REL	;ONLY ONE WE NOW CARE ABOUT
	TDZA	W1,W1		;NOT SET
	MOVSI	W1,FS.REL	;INCASE SYMBOL TABLE FIXUP
	MOVEM	W1,SYMFLG	;AND SAVE IT
	TLZ	W3,R5.FXA	;ALWAYS CLEAR
	TLNN	W3,R5.FXL	;LEFT HALF?
	TLOA	W1,FS.FXR	;NO
	TLO	W1,FS.FXL	;YES
	TLZE	W3,R5.FXS	;SYMBOL FIXUP?
	JRST	SY.RC2		;YES
	TLZE	W3,R5.FXC	;MIGHT BE RH CHAINED
	TLC	W1,FS.FXR!FS.FXC	;YES, CHANGE FLAGS
	JRST	SY.AD0##	;JUST CODE

SY.RC2:	TLO	W1,FS.FXS	;YES, SET FLAG
;	JRST	SY.ADS		;FALL INTO CODE
;HERE FOR SYMBOL TABLE FIXUP
SY.ADS:	MOVE	W2,W3		;PUT REQUESTED SYMBOL IN W2
	PUSHJ	P,R50T6		;CONVERT TO SIXBIT
	.JDDT	LNKOLD,SY.ADS,<<CAMN	W2,$SYMBOL>>
	MOVE	W3,W2		;EXPECTED IN W3
	PUSHJ	P,SY.RLS##	;REQUESTING LAST SYMBOL?
	  POPJ	P,		;NO, ASSUME NON-LOADED LOCAL
				;T1 = ADDRESS IN LOCAL TABLE
				;T2 = ADDRESS IN GLOBAL TABLE
	MOVSI	T3,PS.UDR	;ASSUME RIGHT HALF FIXUP
	TLNE	W1,FS.FXL	;LEFT HALF FIXUP?
	TLC	T3,PS.UDF	;CHANGE TO PS.UDL
	TLNE	W1,FS.FXF	;BUT IF FULL WORD
	MOVSI	T3,PS.UDF	;CLEARS BOTH
	JUMPE	T1,SYADS0	;CLEAR FLAG IN LOCAL TABLE IF THERE
REPEAT 0,<			;SEE CCO #43
	MOVE	T4,0(T1)	;GET CURRENT FLAGS
	TLNN	T4,PS.UDF	;ALREADY FULLY DEFINED
	JRST	[SETZ	T1,	;CLEAR FIXUP POINTER
		JRST	SYADS0]		;AND IGNORE IT
>;END CCO #43
	ANDCAM	T3,0(T1)	;CLEAR FLAG IN MEMORY, SET IN ACC
	SKIPE	T4,SYMFLG	;AND EXTRA FLAGS TO SET
	IORM	T4,0(T1)	;PS.REL USUALLY
SYADS0:	JUMPE	T2,SYADS1	;SAME FOR GLOBAL TABLE
	MOVE	T4,0(T2)	;GET CURRENT FLAGS
	TLNN	T4,PS.UDF
	JRST	SYADMD		;ALREADY FULLY DEFINED, CHECK VALUE
	ANDCAM	T3,0(T2)	;IF SET
	SKIPE	T4,SYMFLG
	IORM	T4,0(T2)	;AND EXTRA FLAGS
SYADS1:	JUMPE	T1,SYADSG	;NO LOCAL, ONLY GLOBAL
	PUSH	P,W1		;SAVE FIXUP FLAGS
	PUSH	P,T2		;SAVE T2
	MOVE	T2,W1		;PUT FLAGS IN T2
	DMOVE	W1,0(T1)	;GET FLAGS & SYMBOL WE NOW CARE ABOUT
	HRR	W3,2(P1)	;GET HALF WORD FIXUP VALUE
				;FROM DEFINED SYMBOL
	PUSHJ	P,SY.AST##	;FIXUP EITHER RH OR LH OF SYMBOL IN T1
	POP	P,T2		;RESTORE IT
	POP	P,W1		;AND FIXUP FLAGS
SYADSG:	JUMPE	T2,CPOPJ	;NOT GLOBAL, RETURN
	PUSH	P,W1		;STORE FLAGS UNTIL P1/P2 SETUP
	DMOVE	W1,0(T2)	;FLAGS & SYMBOL
	HRRZ	W3,2(P1)	;HALF WORD VALUE
	TLNN	W1,PT.EXT	;EXTENDED SYMBOL?
	JRST	SYADSS		;NO
	MOVE	T1,.L(T2)	;YES, BUT WE ONLY CARE ABOUT LONG NAMES HERE
	TLNE	T1,S.SYM
	TLNN	T1,S.NAM	;SO IGNORE COMMON, ETC
	JRST	[TLZ	W1,PT.EXT	;NOT EXTENDED NAME
		JRST	SYADSS]		;SO REMOVE FLAG
IFE .EXSYM,<
	.ERR.	(MS,,V%L,L%F,S%F,ESN)>
	HRRZ	W3,T2		;POINT TO SYMBOL
SYADSS:	PUSHJ	P,TRYSYM##	;SETUP P1 & P2
	  HALT			;MUST BE DEFINED
	  JFCL			;
	MOVE	T1,P1		;POINT TO SYMBOL TRIPLET
	POP	P,T2		;FIXUP FLAGS
	PJRST	SY.AS0##	;GO DO THE VALUE FIXUP
				;AND ANY CHAINING DEPENDING UPON THIS SYMBOL

;HERE TO CHECK PARTIAL VALUE WITH DEFINED VALUE
;POINTER TO DEFINED VALUE IN T2
SYADMD:	MOVE	T1,PARPTR	;MAKE SURE THIS IS SAME SYMBOL
	CAME	T1,LSTSYM	;AS LAST DEFINED
	POPJ	P,		;TOO BAD, JUST IGNORE
	MOVE	W3,PARVAL	;GET PARTIAL VALUE
	ADD	W3,2(P1)	;PLUS DEPENDENT SYMBOL VALUE
	CAMN	W3,2(T2)	;SAME AS CURRENT DEFINITION?
	POPJ	P,		;YES, ALL WELL
	MOVE	P1,T2		;NO, GIVE MESSAGE
	PUSHJ	P,SY.MDS##	;SO USER KNOWS SOMETHINGS WRONG
	POPJ	P,		;SO WE KNOW WHO CALLED
SUBTTL	BLOCK TYPE 2 - SYMBOLS (UNKNOWN REQUEST)

;here for global symbol seen for first time
SY.RQ0:	AOS	USYM		;COUNT ONE MORE
	TLZ	W1,PS.REL	;CLEAR SINCE WE WON'T KNOW UNTIL DEFINED
	JUMPGE	W3,INSRT##	;JUMP IF NON-ADDITIVE GLOBAL
				;AND JUST ENTER IN GLOBAL TABLE

;HERE FOR ADDITIVE GLOBAL REQUEST
;FOR SYMBOL NOT YET IN GLOBAL SYMBOL TABLE
;REQUEST MUST BE DEFERED UNTIL SYMBOL IS DEFINED
;PUT SYMBOL IN TABLE WITH REQUEST BIT ON AND ZERO VALUE
;AND PUT GLOBAL REQUEST POINTER IN EXTENDED TRIPLET
;VALUE POINTS TO FIXUP TABLE
;PUT ACTUAL FIXUP REQUEST IN FIXUP AREA AND CHAIN ALL REQUESTS TO
;TOGETHER, SINCE THIS IS FIRST SET POINTER TO ZERO

SY.RQ1:	PUSH	P,W1		;SAVE PRIMARY FLAGS
	PUSHJ	P,SY.RQF	;SET FLAGS IN W1 FROM W3
	  JRST	SY.RQ2		;NOT SYMBOL TABLE FIXUP
	PUSHJ	P,SY.RQS	;CONVERT SYMBOL REQUEST TO POINTER
	  JRST	[SOS	USYM	;NON LOADED LOCAL
		POP	P,W1	;RESTORE W1
		POPJ	P,]	;REDUCE COUNT AND IGNORE
SY.RQ2:	PUSH	P,[0]		;VALUE OF REQUEST (PRIMARY)
	PUSHJ	P,SY.FX0##	;PUT IN FIXUP TABLE
	MOVSI	W1,S.FXP	;EXTENDED TRIPLET FLAG
	PUSHJ	P,GS.FX0##	;LINK FIXUP TO GLOBAL SYMBOL
	POPJ	P,

;HERE TO SET FLAGS IN W1 FROM BITS IN W3
;CLEARS BITS 0-3 OF W3
;CALLED BY
;	MOVE	W3,REQUEST
;	PUSHJ	P,ST.RQF
;
;RETURNS
;+1	NORMAL ADDITIVE GLOBAL
;+2	SYMBOL TABLE FIXUP

SY.RQF:	MOVSI	W1,FP.SGN!FP.SYM!FP.PTR
	TLZ	W3,R5.FXA	;CLEAR ADDITIVE FIXUP BIT ALWAYS
	TLZE	W3,R5.FXL	;LEFT HALF FIXUP?
	TLOA	W1,FS.FXL	;YES
	TLO	W1,FS.FXR	;NO, MUST BE RIGHT HALF
	TLZE	W3,R5.FXS	;SYMBOL TABLE FIXUP?
	JRST	[TLO	W1,FS.FXS	;YES, SET FLAG
		JRST	CPOPJ1]		;RETURN +2
	TLZE	W3,R5.FXC	;MIGHT BE RH CHAINED
	TLC	W1,FS.FXR!FS.FXC	;YES, CHANGE FLAGS
	POPJ	P,		;RETURN +1

;HERE TO CHANGE RADIX50 SYMBOL TABLE FIXUP REQUEST INTO A POINTER
;CALLED BY
;	MOVE	W3,RADIX-50 SYMBOL
;	PUSHJ	P,SY.RQS
;RETURNS
;+1 SYMBOL NOT REQUIRED (NON-LOADED LOCAL)
;+2 W3 IS POINTER (LSTSYM) TO EITHER OR BOTH GLOBAL AND LOCAL DEFINITIONS
;USES T1, T2

SY.RQS:	EXCH	W2,W3		;PUT REQUESTED SYMBOL IN W2
	PUSHJ	P,R50T6		;SIXBITIZE
	.JDDT	LNKOLD,SY.RQS,<<CAMN	W2,$SYMBOL##>>
	EXCH	W2,W3		;PUT THEM BACK
	PUSHJ	P,SY.RLS##	;ARE WE REQUESTING LAST SYMBOL?
	  POPJ	P,		;ASSUME NON-LOADED LOCAL
	JUMPE	T2,CPOPJ1	;NOT A GLOBAL IF T2=0
	MOVSI	T1,PS.UDL	;SET THE FLAG WE COULD NOT DO BEFORE?
	TLNE	W1,FS.FXL	;LEFT HALF REQUEST?
	IORM	T1,0(T2)	;TO FORCE LEFT HALF UNDEF
	JRST	CPOPJ1		;AND STORE REQUEST
SUBTTL	BLOCK TYPE 2 - SYMBOLS (UNDEFINED REQUEST)

SY.RU0:	JUMPE	W3,CPOPJ	;DUMMY REQUEST JUST IGNORE
	JUMPL	W3,SY.RUA	;ADDITIVE GLOBAL REQUEST?
	HRRZ	T3,W3		;START OF CURRENT CHAIN
	HRRZ	T1,2(P1)	;START OF PREVIOUS CHAIN
	MOVEM	W3,2(P1)	;SAVE NEW ADDRESS AS VALUE
	JUMPE	T1,CPOPJ	;JUST DUMMY REQUEST IF ZERO
				;FALL INTO SY.RU1 TO ADD CHAINS

SY.RU1::HRRZ	T2,T3		;GET NEXT LINK
	PUSHJ	P,SEGCHK##	;SETUP ADDRESS FOR CORRECT SEGMENT
	  JRST	SY.PGU		;NOT ALL OF CHAIN IN CURRENT WINDOW
	HRRZ	T3,(T2)		;GET NEXT ADDRESS
	JUMPN	T3,SY.RU1	;NOT FINISHED YET
	HRRM	T1,(T2)		;STORE OTHER CHAIN OVER 0
	POPJ	P,

;HERE WHEN TRYING TO COMBINE TWO GLOBAL REQUEST CHAINS
; BUT WHERE NOT ALL OF CHAIN IS IN CURRENT WINDOW
; DO NOT READ IN REQUIRED WINDOW
; INSTEAD PUT OLD CHAIN IN FIXUP TABLE WITH ADDITIVE GLOBALS ETC
SY.PGU:	HRRZ	W3,T1		;RESET OLD CHAIN POINTER
	TLO	W3,R5.FXC	;SET RIGHT HALF CHAINED BIT
;	JRST	SY.RUA		;HANDLE AS ADDITIVE GLOBAL


;HERE  FOR ADDITIVE GLOBAL REQUEST TO SYMBOL ALREADY UNDEFINED
;IF ADDITIVE GLOBAL EXTENDED FIXUP ALREADY SEEN JUST ADD TO CHAIN
;IF NOT DELETE SIMPLE TRIPLET AND ADD EXTENDED TRIPLET

SY.RUA:	MOVE	W1,0(P1)	;GET FLAGS
	TLNE	W1,PS.FXP	;ALREADY DEFERED FIXUPS?
	JRST	SY.RUB		;YES, JUST ADD TO LIST
	PUSH	P,W1		;SAVE PRIMARY FLAGS
	PUSHJ	P,SY.RQF	;SETUP W1 FROM W3
	  JRST	.+3		;NORMAL RETURN
	PUSHJ	P,SY.RQS	;SYMBOL TABLE FIXUP, SEE IF WE NEED IT
	  JRST	SY.RUX		;RESTORE STACK AND EXIT
	MOVEI	T1,.L		;NEED TO EXPAND
	PUSHJ	P,SY.MOV##	;TO BIGGER AREA
	SUB	T1,NAMLOC	;INCASE WE MOVE
	PUSH	P,T1		;SAVE TO FIXUP  GLOBAL SYMBOL
	PUSHJ	P,SY.FX0##	;PUT REQUEST IN FIXUP TABLE
	MOVSI	W1,S.LST!S.FXP	;SECONDARY FLAGS
	MOVSI	T1,PT.EXT!PS.FXP	;MARK FIXUP IN PRIMARY
	IORM	T1,0(P1)	;SO WE KNOW TO EXPECT ADDITIVE GLOBALS
	POP	P,T1
	ADD	T1,NAMLOC	;FIX IT
	TMOVEM	W1,0(T1)	;PARTIAL VALUE TRIPLET
SY.RUX:	POP	P,W1		;RESTORE W1 (GET STACK BACK IN SHAPE)
	POPJ	P,

;HERE IF FIXUP REQUEST EXISTS ALREADY
;JUST LINK INTO FRONT OF CHAIN

SY.RUB:	MOVEI	T1,0(P1)	;GET PRIMARY TRIPLET
SY.RUC:	ADDI	T1,.L		;GET NEXT TRIPLET
	SKIPG	W1,0(T1)	;GET SECONDARY FLAGS
	JRST	SY.RUH		;NOT THE RIGHT SORT OF EXTENDED TRIPLET
	TLNN	W1,S.FXP	;IS THIS THE ONE
	JRST	SY.RUC		;NO TRY AGAIN
	MOVE	P1,T1		;SAFE TO POINT TO IT NOW
	PUSHJ	P,SY.RQF	;SETUP LH OF W1
	  JRST	.+3		;NORMAL RETURN
	PUSHJ	P,SY.RQS	;SYMBOL TABKE FIXUP, CONVERT TO POINTER
	  POPJ	P,		;NO LOADED LOCAL, IGNORE
	HRR	W1,2(P1)	;GET LINK
	SUB	P1,NAMLOC	;INCASE AREA MOVES
	PUSHJ	P,SY.FX0##	;PUT IN FIXUP AREA
	ADD	P1,NAMLOC	;RELOCATE IT
	HRRM	W3,2(P1)	;FIXUP REQUEST POINTER CHAIN
	POPJ	P,


;HERE IF THERE IS NOT A FIXUP REQUEST SECONDARY TRIPLET
;JUST EXPAND AS IF  NO EXTENDED TRIPLETS

SY.RUH:	.ERR.	(MS,.EC,V%L,L%F,S%F,CNW)
	.ETC.	(STR,,,,,,<SY.RUH>)
SUBTTL	BLOCK TYPE 3 - HIGH SEGMENT INDICATOR

;	----------------
;	!    3 !     1 !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! HIGH ! HIORG !
;	----------------
;	! LOW  ! LOORG !
;	----------------

T.3:	HRRZ	W2,W1		;GET WORD COUNT
	PUSHJ	P,D.IN1##	;GET A WORD (RELOCATION BYTES)
	PUSHJ	P,D.IN1##	;GET DATA WORD
	SOJE	W2,.+4		;DONE UNLESS FORTRAN-10
	MOVE	W2,W1		;SAVE HIGH SEG BREAK AND OFFSET
	PUSHJ	P,D.IN1##	;GET LOW SEG BREAK
	EXCH	W1,W2		;PUT HIGH BACK WHERE EXPECTED
	TLNN	W1,-1		;TEST FOR LEFT HALF SET
	JRST	T.3B		;HISEG PSEUDO-OP IF 0,,400000
	TRO	FL,R.TWSG	;SIGNAL TWOSEG PSEUDO-OP
	TRNE	FL,R.FLS!R.FHS	;ANYTHING SPECIAL TO DO?
	JRST	T.3RC		;YES, ADJUST RC TABLES FOR FORCED HIGH OR LOW
T.3A:	PUSHJ	P,SETRC		;SETUP THE RELOCATION COUNTER
	MOVEI	R,2		;MAKE SURE POINTING TO HIGH SEG
	MOVE	R,@RC.TB
T.3N:	PUSHJ	P,T.3TTL	;GET POINTER TO TTL BLOCK
	MOVE	W3,RC.CV(R)	;GET CURRENT VALUE
	HRLZM	W3,2(T1)	;VALUE IS THIRD WORD
	JRST	LOAD##

;HERE TO GET POINTER TO TITLE BLOCK (SEGMENT INFO) IN LOCAL SYMBOL TABLE
;RETURNS T1 = ABS POINTER
;FATAL ERROR IF NOT IN CORE
;WARNING IF NOT FOUND

T.3TTL:	HLRZ	T1,NAMPTR	;GET REL ADDRESS OF NAME TRIPLET
	CAMGE	T1,LW.LS	;STILL IN CORE (SHOULD BE)
	JRST	T.3ANC		;NO
	SUB	T1,LW.LS
	ADD	T1,LS.LB	;FIX IN CORE
	SKIPL	T2,(T1)		;MUST BE SECONDARY
	TLNN	T2,S.TTL	;AND A TITLE
	JRST	T.3SER
	TLNN	T2,S.SEG	;IS THIS IT?
	JRST	T.3SER		;NO
	POPJ	P,		;RETURN

T.3SER:	POP	P,T1		;GET STACK BACK IN ORDER
	.ERR.	(MS,0,V%L,L%I,S%I,SFU)
	JRST	LOAD##		;TRY TO CONTINUE

T.3ANC:	.ERR.	(MS,,V%L,L%F,S%F,ANC)

;HERE  FROM HISEG PSEUDO-OP
;TEST IF TWO SEGMENTS ALLOWED (IGNORE IF NOT)
;IF YES, SWAP HIGH AND LOW RELOC COUNTERS

T.3B:	TRNE	FL,R.FLS	;FORCED LOW SEG?
	JRST	LOAD##		;YES, JUST USE RC 1
	TRO	FL,R.FHS	;NO, ALLOW 2 (SET FLAG AND DO IT LATER)
	PUSHJ	P,SETRC		;SET 2ND RELOC COUNTER
	TRNN	FL,R.FHS!R.FLS	;NEED TO ADJUST RELOC COUNTERS
	JRST	LOAD##		;NO, JUST RETURN
	MOVEI	R,1		;SET RELOC LOW
	MOVE	T1,SG.TB+2	;GET ADDRESS OF 2ND SEGMENT
	MOVEM	T1,@RC.TB	;AND STORE IN RELOC 1
	MOVE	R,@RC.TB	;RESET R TO POINT TO RC BLOCK
	PUSHJ	P,T.3TTL	;GET POINTER TO TITLE BLOCK
	MOVE	W3,RC.CV(R)	;GET CURRENT VALUE
	HRLZM	W3,2(T1)	;VALUE IS THIRD WORD
	MOVE	R,SG.TB+1	;GET LOW SEG BLOCK
	MOVE	W3,RC.CV(R)	;REAL LOW CURRENT BREAK
	HRLZM	W3,1(T1)	;SO MAP WILL SHOW 0 LENGTH
	JRST	LOAD##		;AND RETURN
	JRST	T.3N		;STORE RC.IV IN TITLE BLOCK FOR MAP



;NOTE WE HAVE ALREADY TAKEN CARE OF FORCED HIGH BY SWAPPING
;RC1 AND RC2 AT T.6RC

T.3RC:	HLRZ	T1,W1		;GET LENGTH OF HIGH SEGMENT CODE
	SUBI	T1,(W1)		;FROM BREAK - ORIGIN
	JUMPE	T1,T.3TST	;NOT AVAILABLE, CANNOT LOAD AS SPECIFIED
	HRRZM	W1,SO.S2	;OFFSET FOR RELOCATION
	MOVEI	T2,RC.INC	;NEED SPACE FOR TEMP RC BLOCK
	PUSHJ	P,DY.GET##
	TRNE	FL,R.FHS	;FORCED HIGH?
	JRST	T.3RC2		;YES
T.3RC1:	MOVEI	R,2		;PUT IN SLOT #2
	HRLM	R,LL.S2		;SET ORIGIN GREATER THAN 256K
	MOVEM	T1,@RC.TB	;IN RELOCATION TABLES (BUT NOT SEGMENT TABLE)
	HRLZ	T2,SG.TB+1	;COPY .LOW.
	HRR	T2,T1		;TO SLOT #2
	BLT	T2,RC.INC-1(T1)
	MOVE	T2,LL.S2	;ADD HISEG OFFSET
	ADDM	T2,RC.IV(T1)	;TO HIGH COUNTERS
	ADDM	T2,RC.CV(T1)
	MOVE	T1,SG.TB+1	;NOW MODIFY RC #1
	HLRZ	T2,W1		;BY LENGTH OF HIGH SEG
	SUBI	T2,(W1)
	ADDM	T2,RC.CV(T1)	;SO WE LOAD IN CORRECT PLACE
				;NOTE THIS SHOULD REALLY BE IN RC.OF
				;BUT IT SAVES TIME AT RB.1 TO DO
				;IT THIS WAY SINCE FORCED LOADING IS THE SPECIAL CASE
	PUSHJ	P,T.3TTL	;GET POINTER TO TITLE BLOCK
	MOVE	R,@RC.TB	;AND TO RELOCATION BLOCK
	MOVE	T2,RC.CV(R)	;GET CURRENT "HIGH" RELOCATION
	SUB	T2,LL.S2	;REMOVE HISEG ORIGIN
	HRLZM	T2,2(T1)	;SO MAP COMES OUT RIGHT
	MOVEI	R,1		;ALSO "LOW" COUNTER IS TOO SMALL
	MOVE	R,@RC.TB	;SINCE LOW CODE IS ON TOP OF HIGH
	MOVE	T2,RC.CV(R)	;GET NEW CURRENT
	HRLZM	T2,1(T1)	;AND REPLACE VALUE SETUP AT T.6
	JRST	LOAD##

T.3RC2:	MOVEI	R,1		;PUT IN SLOT #1
	MOVEM	T1,@RC.TB	;IN RELOCATION TABLES (BUT NOT SEGMENT TABLE)
	HRLZ	T2,SG.TB+2	;COPY .HIGH.
	HRR	T2,T1		;TO SLOT #1
	BLT	T2,RC.INC-1(T1)
	HLRZ	T2,W1		;BY LENGTH OF HIGH SEG
	SUBI	T2,(W1)
	ADDM	T2,RC.CV(T1)	;SO WE LOAD IN CORRECT PLACE
	MOVN	T2,LL.S2	;REMOVE HIGH SEG OFFSET
	ADDM	T2,RC.IV(T1)
	ADDM	T2,RC.CV(T1)	;FROM LOW COUNTERS
	PUSHJ	P,T.3TTL	;GET POINTER TO TITLE BLOCK
	MOVE	R,@RC.TB	;AND TO RELOCATION BLOCK
	MOVE	T2,RC.CV(R)	;GET CURRENT "LOW" RELOCATION
	ADD	T2,LL.S2	;PUT BACK HISEG ORIGIN
	HRLZM	T2,1(T1)	;SO MAP COMES OUT RIGHT
	JRST	LOAD##

T.3TST:	HLRZ	T1,W2		;CHECK FORLENGTH OF LOW SEGMENT
	SUBI	T1,(W2)		;FROM FORTRAN-10
	JUMPG	T1,T.3L		;YES
	JRST	T3HOLD##	;LOAD IT INTO FX CORE UNTIL
				;BLOCK TYPE 5 SEEN
T.3TSO:	.ERR.	(MS,.EC,V%L,L%F,S%F,TSO,<Cannot load a two segment module in one segment >)
	.ETC.	(FSP,0,,,,DC)


;HERE IF LOW SEGMENT LENGTH GIVEN (FORTRAN-10)
;LOAD HIGH SEG ON TOP OF LOW SEG

T.3L:	HLRZ	T1,W2		;GET LOW SEG LENGTH
	CAIL	T1,(W1)		;IS LENGTH LESS THAN HISEG ORIGIN?
	PUSHJ	P,T.3F		;NO, GIVE FATAL ERROR
	HRRZM	W1,SO.S2	;OFFSET FOR RELOCATION
	MOVEI	T2,RC.INC	;NEED SPACE FOR TEMP RC BLOCK
	PUSHJ	P,DY.GET##
	TRNE	FL,R.FHS	;FORCED HIGH?
	JRST	T.3L2		;YES
T.3L1:	MOVEI	R,2		;PUT IN SLOT #2
	HRLM	R,LL.S2		;SET ORIGIN GREATER THAN 256K
	MOVEM	T1,@RC.TB	;IN RELOCATION TABLES (BUT NOT SEGMENT TABLE)
	HRLZ	T2,SG.TB+1	;COPY .LOW.
	HRR	T2,T1		;TO SLOT #2
	BLT	T2,RC.INC-1(T1)
	MOVE	T2,LL.S2
	ADDM	T2,RC.IV(T1)
	ADDM	T2,RC.CV(T1)	;HIGH COUNTERS HAVE OFFSET
	HLRZ	T2,W2		;MODIFY RC #2 BY LENGTH OF LOW SEG
	SUBI	T2,(W2)
	ADDM	T2,RC.CV(T1)	;SO WE LOAD IN CORRECT PLACE
				;NOTE THIS SHOULD REALLY BE IN RC.OF
				;BUT IT SAVES TIME AT RB.1 TO DO
				;IT THIS WAY SINCE FORCED LOADING IS THE SPECIAL CASE
	PUSHJ	P,T.3TTL	;GET POINTER TO TITLE BLOCK
	MOVE	R,@RC.TB	;AND TO RELOCATION BLOCK
	MOVE	T2,RC.CV(R)	;GET CURRENT "HIGH" RELOCATION
	SUB	T2,LL.S2	;REMOVE HISEG ORIGIN
	HRLZM	T2,2(T1)	;SO MAP COMES OUT RIGHT
	JRST	LOAD##

T.3L2:	MOVEI	R,1		;PUT IN SLOT #1
	MOVEM	T1,@RC.TB	;IN RELOCATION TABLES (BUT NOT SEGMENT TABLE)
	HRLZ	T2,SG.TB+2	;COPY .HIGH.
	HRR	T2,T1		;TO SLOT #1
	BLT	T2,RC.INC-1(T1)
	MOVN	T2,LL.S2	;REMOVE OFFSET FROM RC #1
	ADDM	T2,RC.IV(T1)
	ADDM	T2,RC.CV(T1)
	MOVE	T1,SG.TB+2	;NOW MODIFY RC #2
	HLRZ	T2,W2		;BY LENGTH OF HIGH SEG
	SUBI	T2,(W2)
	ADDM	T2,RC.CV(T1)	;SO WE LOAD IN CORRECT PLACE
	PUSHJ	P,T.3TTL	;GET POINTER TO TITLE BLOCK
	MOVEI	R,2		;FOR HIGH SEGMENT RELOCATION
	MOVE	R,@RC.TB	;AND TO RELOCATION BLOCK
	MOVE	T2,RC.CV(R)	;GET CURRENT "LOW" RELOCATION
	HRLZM	T2,2(T1)	;SO MAP COMES OUT RIGHT
	JRST	LOAD##
;HERE TO SET HIGH SEG RELOC COUNTER (.HIGH.)
;CALLED BY
;	MOVE	W1,ORG OF HIGH SEG (0 FOR DEFAULT 400000)
;	PUSHJ	P,SETRC
;ALWAYS RETURNS .+1

SETRC::	HRRZ	W1,W1		;CLEAR HIGH SEG SIZE (IF GIVEN)
	SKIPN	W1		;SKIP IF ADDRESS GIVEN
	MOVEI	W1,400000	;ASSUME 400000 IF NOT
	ANDCM	W1,.PGSIZ	;SET ON PAGE BOUND
	MOVEM	W1,SO.S2	;STORE SOFTWARE ORIGIN
	MOVEI	R,1		;SET R FOR LOW SEGMENT
	MOVE	R,@SG.TB	;GET BLOCK POINTER
	SKIPE	LL.S2		;HAVE WE ALREADY SETUP SEG ORIGIN?
	POPJ	P,		;YES, JUST RETURN
IFE FTENEX,<
;	CAIL	W1,400000	;ERROR IF LESS THAN 128K>
	CAMG	W1,RC.CV(R)	;BUT MUST BE HIGHER THAN LOW SEG
	JRST	T.3F		;TOO LOW
	MOVEI	R,2		;RELOCATION FOR HIGH SEGMENT
	SKIPE	R,@SG.TB	;SEE IF ALREADY SET UP
	JRST	T.3D		;YES, CHECK FOR CONSISTENCY AND RETURN
	MOVEM	W1,LL.S2	;FOR INPUT ROUTINE ONLY
	MOVEI	T2,RC.INC	;HERE TO ALLOCATE SPACE FOR RC BLOCK
	PUSHJ	P,DY.GET##	;IN DYNAMIC AREA
	MOVEI	R,2		;NOW FOR RC TABLE ENTRIES
	SKIPE	@RC.TB		;SLOT ALREADY OCCUPIED?
	JSP	T2,SETRCX	;CLEAR SLOT, SAVE OCCUPANT FOR LATER
	MOVEM	T1,@RC.TB	;GET POINTER INTO TABLE
	MOVEM	T1,@SG.TB
	MOVE	R,T1		;SAFER PLACE FOR POINTER
	AOS	RC.NO		;COUNT ONE MORE
	SOS	RC.FRE		;AND ONE LESS HOLE
	MOVEM	W1,RC.IV(R)	;START OF RELOCATION
	MOVE	T2,['.HIGH.']	;NAME
	MOVEM	T2,RC.NM(R)
	ADDI	W1,.JBHDA	;DON'T FORGET HIGH JOBDATA AREA
	MOVEM	W1,RC.CV(R)	;AS CURRENT RC
	MOVEI	T1,2		;SEGMENT NUMBER
	MOVEM	T1,RC.SG(R)	;IN TABLE  SO WE KNOW WHERE IT IS
	SETZM	RC.OF(R)	;ZERO RELATIVE TO HC.LB
	SETZM	RC.HL(R)
	MOVEI	T1,HC.LB
	MOVEM	T1,RC.LB(R)
	MOVEI	T1,LW.S2	;ADDRESS OF LOWER WINDOW
	MOVEM	T1,RC.WD(R)
	MOVEI	T1,UW.S2	;ADDRESS OF UPPER WINDOW
	MOVEM	T1,RC.PG(R)	;NON-ZERO IF PAGING
	JRST	T.3AA		;NOW SETUP HC AREA

;HERE IF DESIRED RC SLOT IS NOT FREE
;STACK CURRENT CONTENTS AND RETURN
;FIND NEW PLACE FOR CURRENT OCCUPANT LATER

SETRCX:	PUSH	P,@RC.TB	;STACK CURRENT OCCUPANT
	PUSH	P,[SETRCY]	;RET ADDRESS TO STORE ABOVE RC POINTER
	JRSTF	(T2)		;RETURN

SETRCY:	SOSGE	RC.FRE		;ANY FREE SPACE?
	JRST	SETRCF		;NO
	AOS	R,RC.NO		;GET NUMBER
	POP	P,@RC.TB	;STORE IT
	POPJ	P,		;RETURN

SETRCF:	.ERR.	(MS,,V%L,L%F,S%F,RCF)
;NOW TO SETUP HC AREA IF NOT DONE YET
T.3AA:	MOVE	T1,LC.UB	;TOP OF WHAT WE HAVE
	SUB	T1,LC.AB	;GIVES FREE SPACE THERE
	CAIL	T1,2*.IPS	;NEED AT LEAST THIS
	JRST	T.3AB		;GOT IT
	MOVEI	P2,2*.IPS	;NO, SO GET IT
	MOVEI	P1,LC.IX	;IN LOW SEG AREA
	PUSHJ	P,LNKCOR##
	  PUSHJ	P,NO.COR##
	MOVNI	T1,2*.IPS	;BUT LC.AB WAS INCREMENTED
	ADDM	T1,LC.AB	;SO PUT IT BACK AS IT WAS
	ADDM	T1,LC.FR	;AND FREE SPACE THERE
	JRST	T.3AA		;TRY AGAIN

T.3AB:	IDIVI	T1,2*.IPS	;DIVIDE BY 2*128
	LSH	T1,^D35-^L<.IPS>	;BACK INTO WORDS
	MOVE	T3,LC.AB	;WE NEED THIS MUCH
	ADD	T3,T1		;PLUS HALF OF WHATS SPARE
	MOVEM	T3,LC.UB	;FOR UPPER BOUND
	ADDI	T3,1		;ROUND UP TO K BOUND
	MOVEM	T3,HC.LB	;FOR NEW LOWER BOUND
	ADDI	T3,-1(T1)	;ADD IN HALF SPARE
	ADD	T3,T2		;PLUS REMAINDER
	MOVEM	T3,HC.UB	;FOR UPPER
	MOVE	T3,HC.LB
	ADDI	T3,.IPM		;NEED SPACE FOR .JBHDA
	MOVEM	T3,HC.AB	;SO RESERVE IT
IFN FTENEX&FTFORK,<
	MOVE	1,LL.S2		;ORIGIN ADDRESS
	LSH	1,-9			;IN PAGE #
	HRL	1,HC.FRK	;SOURCE FORK IS INFERIOR ONE
	MOVE	2,HC.LB
	LSH	2,-9		;DESTINATION PAGE
	HRLI	2,(1B0)		;CURRENT FORK
	SETZ	3,
	PMAP
>
	POPJ	P,		;RETURN

T.3D:	CAMN	W1,RC.IV(R)	;SAME VALUE?
	POPJ	P,		;YES, JUST RETURN
T.3E:	MOVE	W3,RC.IV(R)	;GET CURRENT VALUE
	.ERR.	(MS,.EC,V%L,L%W,S%W,HSO,<Attempt to change high segment origin from >)
	.ETC.	(OCT,.EC!.EP,,,,W3)
	.ETC.	(STR,.EC,,,,,< to >)
	.ETC.	(OCT,.EP,,,,W1)
	POPJ	P,

T.3F:	.ERR.	(MS,,V%L,L%F,S%F,HSL,<Attempt to set high segment origin too low>)
SUBTTL	BLOCK TYPE 4 - ENTRIES

;	----------------
;	!    4 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!      SYMBOLS !
;	----------------

T.4:	MOVEI	T2,0(W1)	;GET NUMBER OF ENTRIES IN THIS MODULE
	JUMPE	T2,T.4A		;IGNORE 0 ENTRIES
	SKIPN	ENTPTR		;ALREADY SOME ENTRIES FOR THIS MODULE?
	JRST	T.4E		;NO
	HLRO	T1,ENTPTR	;GET -NUMBER
	SUB	T2,T1		;NUMBER WE NEED
	PUSHJ	P,DY.GET##	;GET IT
	HRLZ	T3,ENTPTR	;FORM BLT PTR
	HRR	T3,T1
	HLRO	T4,ENTPTR	;-NUMBER OF WORDS
	MOVM	W3,T4
	ADDI	W3,(T1)		;END OF BLT
	BLT	T3,-1(W3)	;MOVE ALL PREVIOUS ENTRIES
	MOVN	T2,T2		;NEGATE NEW LENGTH
	HRL	T1,T2		;FORM AOBJN POINTER
	EXCH	T1,ENTPTR	;SWAP POINTERS
	HRRZ	T1,T1		;ADDRESS ONLY
	MOVM	T2,T4		;AND LENGTH
	PUSHJ	P,DY.RET##	;GIVE SPACE BACK
	JRST	T.4D		

T.4E:	MOVN	T1,T2
	HRLM	T1,ENTPTR	;LEFT HALF OF AOBJN PTR
	PUSHJ	P,DY.GET##	;GET SPACE
	HRRM	T1,ENTPTR	;FINISH POINTER
	HRRZ	W3,T1		;DON'T NEED W3 FOR ANYTHING
T.4D:	HRLI	W3,(POINT 36)	;SO USE AS DEPOSIT BYTE POINTER
	TRNN	FL,R.LIB	;IN LIBRARY SEARCH MODE
	JRST	T.4B		;NO, JUST STORE SYMBOLS FOR LATER
T.4A:	PUSHJ	P,RB.1		;READ A WORD
	  JRST	LOAD##		;END OF BLOCK
	MOVE	W2,W1		;PUT SYMBOL IN 2ND WORD
	SETZ	W1,		;ZERO FLAGS
	PUSHJ	P,R50T6		;CONVERT TO SIXBIT
	IDPB	W2,W3		;STORE ENTRY
	PUSHJ	P,TRYSYM##	;SEE IF SYMBOL IS IN TABLE
	  JRST	T.4A		;NO, TRY NEXT
	  TRZA	FL,R.LIB!R.INC	;UNDEF, CLEAR SKIP CONTROL
	JRST	T.4A		;DEFINED, DON'T NEED THIS DEFINITION
T.4B:	PUSHJ	P,RB.1
	  JRST	LOAD##		;END OF BLOCK
	MOVE	W2,W1		;PUT IN SYMBOL ACC
	PUSHJ	P,R50T6		;SIXBITIZE
	IDPB	W2,W3		;STORE
	JRST	T.4B		;LOOP


SUBTTL	BLOCK TYPE 5 - END

;			  OR
;	----------------	----------------
;	!    5 ! COUNT !	!    5 ! COUNT !
;	----------------	----------------
;	! BYTE   WORD  !	! BYTE   WORD  !
;	----------------	----------------
;	! HIGH   RELOC !	!  LOW   RELOC !
;	----------------	----------------
;	!  LOW   RELOC !	!  ABS     LOC  !
;	----------------	-----------------

T.5:	SKIPN	POLSTK		;GIVE BACK POLISH STACK IF FINISHED
	JRST	T.5A
	MOVEI	T2,PPDL		;LENGTH OF STACK
	HRRZ	T1,POLSTK	;START OF IT
	ADDI	T1,1		;WAS AN IOWD
	PUSHJ	P,DY.RET##	;RETURN IT
	SETZM	POLSTK		;AVOID CONFUSION
T.5A:
IFN FMXFOR,<
	SKIPG	MIXFOR		;SKIP IF WE STILL HAVE FIXUP TO DO>
	PUSHJ	P,T.5ENT	;RETURN SPACE USED BY ENTRY STORE
	PUSHJ	P,RB.2		;GET BOTH WORDS
	  JRST	[MOVEI	T1,5
		JRST	ILIERR]
	TLNE	W1,-1		;MAKE SURE VALID
	PUSHJ	P,T.5W1		;NOT
	TLNE	W2,-1
	PUSHJ	P,T.5W2		;SAME FOR W2
	SKIPE	W3,LOD37	;COBOL LOCAL SYMBOLS
				;BUT IF THEY'RE LOADED
	SUBI	W3,3		; REMOVE EXTRA 3 OVERHEAD WORDS
	ADD	W3,OWNLNG	;ADD IN ALGOL OWN BLOCK
;	ADD	W3,VARLNG	;ADD IN LVAR BLOCKS
T.5F40::			;ENTRY FROM LNKF40
T.5B:	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,[TRNN	FL,R.TWSG	;YES, BUT WE NEED 2 SEGS
		POPJ	P,
		TRNN	FL,R.HSO	;ONLY WANTED HIGH?
		TDZA	W2,W2		;NO, SO CLEAR HIGH
		SETZ	W1,		;YES, SO CLEAR LOW
		POPJ	P,]
	TRNE	FL,R.FHS!R.FLS	;FORCED TO LOAD HIGH, OR LOW, OR HISEG PSEUDO-OP?
	JRST	T.5FS		;YES, SORT OUT RC TABLES
	TRNE	FL,R.TWSG	;TWO SEGMENTS ARE SPECIAL
	JRST	T.5LS		;AS THERE IS NO ABS RC COUNTER
;	CAMGE	W1,W2		;SINGLE SEGMENT
T.5LSS:	MOVE	W1,W2		;USE LARGER OF REL OR ABS
	ADD	W1,W3		;ADD IN EXTRA OVERHEAD FROM COBOL OR ALGOL
T.5LS:	MOVEI	R,1		;MAKE SURE R = LOW
	MOVE	R,@RC.TB
	CAMGE	W1,RC.HL(R)	;CHECK RELOCATION COUNTER
	MOVE	W1,RC.HL(R)	;USE GREATER
	CAMLE	W1,RC.CV(R)	;NEVER DECREASE
	MOVEM	W1,RC.CV(R)	;FOR NEXT FILE
	SETZM	RC.HL(R)	;CLEAR HIGHEST IN PROGRESS
	CAMLE	W1,HL.S1	;AND HIGHEST ADDRESS IN THIS SEGMENT
	MOVEM	W1,HL.S1
	TRNN	FL,R.TWSG	;TWO SEGMENTS?
	JRST	T.5END		;GET NEXT BLOCK

T.5THS:	MOVEI	R,2		;SET FOR HIGH SEG
	MOVE	R,@RC.TB
	CAMGE	W2,RC.HL(R)	;USE GREATER
	MOVE	W2,RC.HL(R)
	CAMLE	W2,RC.CV(R)
	MOVEM	W2,RC.CV(R)	;FOR NEXT FILE
	SETZM	RC.HL(R)
	MOVE	T1,W2		;GET A COPY
	SUB	T1,LL.S2	;REMOVE OFFSET
	CAMLE	T1,HL.S2	;CHECK HIGHEST ADDRESS IN THIS SEGMENT
	MOVEM	T1,HL.S2	; RESET

T.5END:	HRRZ	T1,NAMPTR	;POINTER TO START OF FILE
	CAMGE	T1,LW.LS	;IN CORE?
	JRST	T.5PAG		;NO, GENERATE FIXUP
	SUB	T1,LW.LS	;REMOVE OFFSET
	ADD	T1,LS.LB	;ADD IN BASE
	SKIPGE	T2,(T1)		;GET PRIMRY  TRIPLET
	TLNN	T2,PT.TTL	;IT BETTER BE A TITLE BLOCK
	JRST	T.5SER		;ERROR
	MOVE	T2,LSYM		;POINT TO END (NEXT FILE)
	HRRM	T2,2(T1)	;FILL IN POINTER
T.5LP:	HLRZ	T1,NAMPTR	;POINTER TO START OF SEG INFO
	CAMGE	T1,LW.LS	;IN CORE?
	JRST	T.5PSG		;NO, GENERATE FIXUP
	SUB	T1,LW.LS	;REMOVE OFFSET
	ADD	T1,LS.LB	;ADD IN BASE
	SKIPL	T2,(T1)		;MUST BE SECONDARY
	TLNN	T2,S.TTL	;AND A TITLE BLOCK AT THAT
	JRST	T.5SER
	TLNN	T2,S.SEG	;SEG BLOCK?
	JRST	T.5LP		;NO
	TRZN	FL,R.FHS	;SLIGHT PROBLEM IF FORCED HIGH
	JRST	.+4		;AND A SINGLE SEG PROG
	HLRZ	T2,1(T1)	;AS PC IN .LOW. IS IN HISEG
	CAMGE	W1,T2		;SO UNLESS LOW PC EQUAL OR GREATER
	SETZB	W1,1(T1)	;ASSUME NO LOW CODE FOR THIS MODULE
	HRRM	W1,1(T1)	;STORE LOW
	TRNN	FL,R.LSO	;LOW SEGMENT ONLY LOADED?
	TRNN	FL,R.TWSG	;WAS THIS A TWO SEG PROG?
	SETZB	W2,2(T1)	;NO, CLEAR HIGH MARKER
	SKIPE	2(T1)		;IF THERE  WAS HIGH SEEN
	HRRM	W2,2(T1)	;STORE HIGH
T.5RET:	SKIPE	UW.LS		;ARE WE PAGING SYMBOLS?
	PUSHJ	P,T.5XPL	;SEE IF ANY TO GO OUT
IFN FMXFOR,<
	SKIPLE	MIXFOR		;NEED TO DO MIXFOR FIXUPS?
	PUSHJ	P,.MXFOR##	;YES>
	TRZ	FL,R.LOD	;DONE WITH END BLOCK NOW
	SKIPN	DCBUF		;SPECIAL INCORE READS DONE?
	JRST	T5FIN##		;YES, RESET INPUT BUFFER
	JRST	T.LOAD##	;SEE IF IN /SEARCH OR NOT
;HERE TO RETURN SPACE USED BY ENTRY STORE

T.5ENT::SKIPN	T1,ENTPTR	;ANY ENTRY SPACE TO RETURN
	POPJ	P,		;NO, UNUSUAL
IFN .EXSYM,<			;LONG SYMBOLS ARE STORE IN SEPARATE BLOCK
				;WITH LENGTH,,POINTER IN ENTPTR TABLE
				;IF LENGTH GREATER THAN 7777 WORDS HALT (FOR NOW)
	MOVE	P1,ENTPTR	;LOAD AOBJN POINTER IN SAFE AC
T5ENT0:	MOVE	T1,0(P1)	;GET SYMBOL OR POINTER
	TLNE	T1,770000	;SYMBOLS ARE LEFT JUSTIFIED
	JRST	T5ENT1		;SO NOT A POINTER
	TLNN	T1,-1		;CHECK FOR SUPER LONG SYMBOL (GT. 7777)
	HALT			;JUST IN CASE?
	HLRZ	T2,T1		;GET LENGTH
	HRRZ	T1,T1		;ADDRESS ONLY
	PUSHJ	P,DY.RET##	;GIVE IT BACK
T5ENT1:	AOBJN	P1,T5ENT0	;LOOP
	MOVE	T1,ENTPTR	;RELOAD POINTER
>;END OF .EXSYM
	HLRO	T2,T1		;GET -LENGTH
	MOVM	T2,T2
	HRRZ	T1,T1		;ADDRESS ONLY
	SETZM	ENTPTR		;CLEAR
	PJRST	DY.RET##	;GIVE BACK AND RETURN

;HERE WHEN RELOCATION COUNTERS ARE NOT CORRECT
;IE. FORCED HIGH, FORCED LOW, OR HISEG TO HIGH SEGMENT

T.5FS:	TRNE	FL,R.TWSG	;DO WE REALLY HAVE 2 SEGMENTS
	JRST	[TRNN	FL,R.FHS		;YES, SO MUST BE FORCED
		JRST	T.5FL		;LOW
		JRST	T.5FH]		;OR HIGH
	TRNN	FL,R.FHS	;HISEG WOULD BE FORCED HIGH
	JRST	T.5LSS		;SINGLE SEGMENT FORCED LOW IS SIMPLE
	MOVEI	R,2		;SET FOR HIGH
	MOVE	T1,SG.TB+2	;FROM SECOND
	MOVEM	T1,@RC.TB	;STORE HIGH WHERE IT SHOULD BE
	MOVEI	R,1		;SET FOR LOW
	MOVE	T1,SG.TB+1	;FROM WHERE IT IS
	MOVEM	T1,@RC.TB	;TO WHERE IT SHOULD BE
	CAMGE	W1,RC.CV(T1)	;SETUP LOWSEG BREAK IF NO REAL ABS CODE
	MOVE	W1,RC.CV(T1)	;SO MAP WILL SHOW ZERO LENGTH
;	TRZ	FL,R.FHS	;CLEAR FORCED HIGH FLAG
	TRO	FL,R.TWSG
	JRST	T.5LS		;AND TREAT AS IF 2 SEG

;HERE FOR FORCED LOW SEGMENT
;HIGH RELOC COUNTER IS INCORRECT

T.5FL:	MOVEI	R,2		;POINT TO HIGH
	MOVE	T1,@RC.TB	;ADDRESS OF RC BLOCK
	MOVEI	T2,RC.INC	;LENGTH
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	MOVE	T1,SG.TB+2	;POINT TO REAL HIGH SEG BLOCK
	MOVEM	T1,@RC.TB	;STORE 0 OR REAL ADDRESS
	MOVEI	R,1		;MAKE SURE R = LOW
	MOVE	R,@RC.TB
	CAMGE	W1,W2		;USE WHICHEVER IS GREATER
	JRST	[CAMGE	W2,RC.HL(R)	;CHECK RELOCATION COUNTER
		MOVE	W2,RC.HL(R)	;USE GREATER
		CAMLE	W2,RC.CV(R)	;NEVER DECREASE
		MOVEM	W2,RC.CV(R)	;FOR NEXT FILE
		SETZM	RC.HL(R)	;CLEAR HIGHEST IN PROGRESS
		CAMLE	W2,HL.S1	;AND HIGHEST ADDRESS IN THIS SEGMENT
		MOVEM	W2,HL.S1
		JRST	T.5FLZ]		;GET NEXT BLOCK
	CAMGE	W1,RC.HL(R)	;CHECK RELOCATION COUNTER
	MOVE	W1,RC.HL(R)	;USE GREATER
	CAMLE	W1,RC.CV(R)	;NEVER DECREASE
	MOVEM	W1,RC.CV(R)	;FOR NEXT FILE
	SETZM	RC.HL(R)	;CLEAR HIGHEST IN PROGRESS
	CAMLE	W1,HL.S1	;AND HIGHEST ADDRESS IN THIS SEGMENT
	MOVEM	W1,HL.S1
T.5FLZ:	HRRZS	LL.S2		;CLEAR FAKE HIGH SEG ORIGIN
	JRST	T.5END		;GET NEXT BLOCK

;HERE FOR FORCED HIGH SEGMENT
;LOW RELOC COUNTER IS INCORRECT

T.5FH:	MOVEI	R,1		;POINT TO LOW
	MOVE	T1,@RC.TB	;ADDRESS OF BLOCK
	MOVEI	T2,RC.INC	;LENGTH
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	MOVE	T1,SG.TB+1	;GET ADDRESS OF REAL LOW RC BLOCK
	MOVEM	T1,@RC.TB	;STORE IN RC TABLE
	MOVEI	R,2		;SET FOR HIGH SEG
	MOVE	R,@RC.TB
	CAMGE	W2,W1		;USE GREATER
	JRST	[CAMGE	W1,RC.HL(R)	;USE GREATER
		MOVE	W1,RC.HL(R)
		CAMLE	W1,RC.CV(R)
		MOVEM	W1,RC.CV(R)	;FOR NEXT FILE
		SETZM	RC.HL(R)
		MOVE	T1,W2		;GET A COPY
		SUB	T1,LL.S2	;REMOVE OFFSET
		CAMLE	T1,HL.S2	;CHECK HIGHEST ADDRESS IN THIS SEGMENT
		MOVEM	T1,HL.S2	; RESET
		JRST	T.5END]
	CAMGE	W2,RC.HL(R)	;USE GREATER
	MOVE	W2,RC.HL(R)
	CAMLE	W2,RC.CV(R)
	MOVEM	W2,RC.CV(R)	;FOR NEXT FILE
	SETZM	RC.HL(R)
	MOVE	T1,W2		;GET A COPY
	SUB	T1,LL.S2	;REMOVE OFFSET
	CAMLE	T1,HL.S2	;CHECK HIGHEST ADDRESS IN THIS SEGMENT
	MOVEM	T1,HL.S2	; RESET
	JRST	T.5END


;HERE TO OUTPUT BOTTOM OF SYMBOL TABLE AND RETURN SPACE
;TO FREE POOL.
;WE KEEP THE LAST PARTIAL BLOCK IN CORE

T.5XPL:	MOVE	T1,LW.LS	;GET LOWER WINDOW PTR
	MOVE	T2,LSYM		;START OF NEXT PROG
	ANDCMI	T2,.IPM
	CAMN	T1,T2		;SAME BLOCK?
	POPJ	P,		;YES, NOTHING TO DO
	HRLZ	P1,T1		;FORM TRANS WORD
	HRRI	P1,-1(T2)	;FIRST,,LAST
	MOVE	T1,P1		;WHERE EXPECTED
	PUSHJ	P,LS.OUT##	;OUTPUT WINDOW
	HRRZI	T1,1(P1)	;HIGHEST +1 =NEW LOWEST
	SUB	T1,LW.LS	;MINUS INITIAL
	ADDM	T1,LW.LS	;NEW INITIAL
	ADD	T1,LS.LB	;NEW INCORE BASE
	SOJA	T1,GBCK.L##	;GIVE IT TO FREE POOL
;HERE TO GENERATE TITLE BLOCK FIXUP IN A LINKED LIST
;FORMAT OF FIXUP IS
;WORD 1		BACK PTR,,FORWARD PTR
;WORD 2		INDEX,,NAMPTR (LH)
;WORD 3		LSYM
;

T.5PAG:	HRRZ	T2,NAMPTR	;AND REL ADDRESS IN SYMBOL TABLE
	HRLI	T2,SPF.TL	;INDEX
	MOVE	W3,LSYM		;VALUE
	MOVEI	R,FS.SS-FX.S0	;SET INDEX
	PUSHJ	P,SY.CHP##	;PUT IN LIST
	JRST	T.5LP		;AND RETURN TO TRY MORE


;HERE TO GENERATE TITLE SEGMENT INFO FIXUP IN A LINKED LIST
;FORMAT OF FIXUP IS
;WORD 1		BACK PTR,,FORWARD PTR
;WORD 2		INDEX,,NAMPTR (RH)
;WORD 3		HIGH LOC,,LOW LOC
;
;ENTER WITH
;W2 = LOW LOC
;W3 = HIGH LOC

T.5PSG:	TRNN	FL,R.LSO	;LOW SEGMENT ONLY LOADED?
	TRNN	FL,R.TWSG	;WAS THIS A TWO SEG PROG?
	SETZ	W2,		;NO, CLEAR HIGH MARKER
	HLRZ	T2,NAMPTR	;REL ADDRESS IN SYMBOL TABLE
	HRLI	T2,SPF.SG	;INDEX
	HRLZ	W3,W3		;HIGH IN LEFT
	HRR	W3,W2		;LOW IN RIGHT
	MOVEI	R,FS.SS-FX.S0	;SET INDEX
	PUSHJ	P,SY.CHP##	;PUT IN LIST
	JRST	T.5RET		;AND RETURN

;HERE WHEN SYMBOL TABLE FOULED UP, SHOULD NEVER HAPPEN
T.5SER:	.ERR.	(MS,0,V%L,L%W,S%W,SFU,<Symbol table fouled up>)
	JRST	T.5RET		;TRY TO CONTINUE

;HERE WHEN PROGRAM BREAK IS INCORRECT, ZERO BREAK AND CONTINUE
T.5W1:	.ERR.	(MS,.EC,V%L,L%W,S%W,PBI,<Program break >)
	.ETC.	(OCT,.EP!.EC,,,,W1)
	.ETC.	(STR,.EC,,,,,< invalid in >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
	SETZ	W1,		;CLEAR AND CONTINUE
	POPJ	P,

T.5W2:	.ERR.	(MS,.EC,V%L,L%W,S%W,PBI)
	.ETC.	(OCT,.EP!.EC,,,,W2)
	.ETC.	(STR,.EC,,,,,< invalid in >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
	SETZ	W2,		;CLEAR AND CONTINUE
	POPJ	P,
SUBTTL	BLOCK TYPE 6 - NAME

;	----------------
;	!    6 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!         NAME !
;	----------------
;	! TYPE ! BLANK !
;	----------------

T.6:	TROE	FL,R.LOD	;SEE IF LAST END WAS SEEN
	PUSHJ	P,EOFTS##	;NO, PREMATURE END OF MODULE
	TRNE	FL,R.FHS	;NEED TO ADJUST THE RELOC TABLES?
	PUSHJ	P,T.6RC		;YES
	PUSHJ	P,RB.2		;READ THE TWO POSSIBLE WORDS
	  JRST	[MOVEI	T1,6
		JRST	ILIERR]
	PUSH	P,W1		;SAVE VALUE
	PUSHJ	P,R50T6		;CONVERT NAME TO SIXBIT
	TRNE	FL,R.LIB!R.INC	;STILL IN /SEARCH MODE OR /INC MODE?
	JRST	T.6INC		;YES, SEE IF WE NEED THIS MODULE
	SKIPE	EXCPTR		;IF ANY /EXCLUDES
	JRST	T.6EXC		;SEE IF NOT WANTED
T.6OK:	MOVEM	W2,PRGNAM	;SAVE SIXBIT NAME
	MOVE	T1,LSYM		;GET WORD COUNT IN SYMBOL TABLE
	MOVEM	T1,NAMPTR	;POINTS TO NAME
	SETZM	FBHPTR		;NO LOCAL BLOCKS YET
	.JDDT	LNKOLD,T.6OK,<<CAMN	W2,$NAME>>
	.ERR.	(MS,.EC,V%L,L%I5,S%I,LMN,<Loading module >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
	AOS	PRGNO		;COUNT THIS PROGRAM
	HLRZ	T1,0(P)		;GET TYPE
	HRRZS	0(P)		;AND CLEAR IT FROM STACK
	MOVEM	T1,CTYPE	;SAVE CURRENT COMPILER & CPU TYPE
	HRRZ	T2,T1		;GET CPU TYPE
	LSH	T2,-^D12	;RIGHT JUSTIFIED (WAS BITS 0-5)
	ANDI	T1,7777		;AND CLEAR FROM COMPILER INDEX
	CAILE	T1,CT.LEN	;CHECK FOR RANGE
	JRST	[SETZ	T1,		;MAKE IT UNKNOWN
		DPB	T1,[POINT 12,CTYPE,35]
		JRST	.+1]
	CAILE	T2,CP.LEN	;SAME FOR CPUS
	JRST	[SETZ	T2,
		DPB	T2,[POINT 6,CTYPE,23]
		JRST	.+1]
	MOVE	T3,PROCSN	;GET LIST OF DIF PROSSORS SEEN
	MOVE	T4,CPUSN	;AND CPUS
	MOVE	P1,T1		;SAFE PLACE
	MOVE	P2,T2
	XCT	CT.NAM##(T1)	;SEE IF ANYTHING SPECIAL TO DO
	MOVE	T3,CT.BIT##(P1)	;GET CORRESPONDING BIT
	MOVE	T4,CP.BIT##(P2)	;ALSO FOR CPU
	IORM	T3,PROCSN	;SIGNAL WE HAVE SEEN THIS ONE
	IORM	T4,CPUSN
	POP	P,T1		;GET BLANK COMMON BACK
	SKIPE	BLCOMM		;SEEN BLANK COMMON BEFORE?
	JRST	T.6BC		;YES
	HRROM	T1,BLCOMM	;NO, SAVE IT NOW (SIGNAL COMMON SET)
	JUMPE	T1,T.6M		;BUT DON'T STORE SYMBOL IF NO COMMON
	MOVSI	W1,PT.SGN!PT.EXT!PT.TTL!PT.FAK	;FAKE TITLE
	MOVE	W2,['BLANK-']	;FOR BLANK COMMON
	SETZ	W3,
	MOVE	T1,CTYPE	;SPECIAL MESSAGE FOR COBOL
	ANDI	T1,7777
	CAIN	T1,CT.CBL
	SALL			;OTHERWISE LITERAL IS A MESS
	JRST	[MOVE	W2,['LIBOL-']
		PUSHJ	P,LS.ADD##
		DMOVE	W2,[SIXBIT /STATIC-AREA/]
		JRST	.+3]
	PUSHJ	P,LS.ADD##
	MOVE	W2,['COMMON']
	MOVSI	W1,S.TTL
	PUSHJ	P,LS.ADD##	;REST OF NAME
	MOVSI	W1,S.TTL!S.LST!S.SEG
	HRRZ	T1,BLCOMM	;GET LENGTH
	MOVEI	R,1		;ASSUME LOW SEG FILE FOR NOW
	MOVE	R,@RC.TB	;PICKUP RELOCATION POINTER
	HRLZ	W2,RC.CV(R)	;GET CURRENT REL COUNTER
	ADD	T1,RC.CV(R)	;GET FINAL
	HRR	W2,T1		;SO MAP CAN WORK OUT LENGTH
	SETZ	W3,		;NO HIGH
	PUSHJ	P,LS.ADD##
	MOVE	W2,['.COMM.']	;NAME OF COMMON
	HRL	W3,BLCOMM	;LENGTH IN LEFT HALF
	HRR	W3,RC.CV(R)	;CURRENT VALUE
	PUSHJ	P,T.COMM	;TEST COMMON
	  JFCL			;NEVER GETS HERE
	HRRZ	P1,@HT.PTR	;SETUP P1 TO POINT TO SYMBOL
	ADD	P1,NAMLOC	;IN CORE
	PUSH	P,.L+2(P1)	;SAVE 2ND TRIPLET INFO
	PUSH	P,.L+1(P1)
	PUSH	P,.L+0(P1)
	TMOVE	W1,0(P1)	;RESET FIRST  SYMBOL TRIPLET
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL TABLE
	POP	P,W1		;GET SECONDARY
	POP	P,W2		;SAME NAME
	POP	P,W3		;LENGTH
	PUSHJ	P,LS.ADD##
	HRRZ	T1,BLCOMM	;GET LENGTH
	ADDM	T1,RC.CV(R)	;AND INCREMENT RELOC COUNTER
	JRST	T.6M

T.6INC:	HRRZ	T1,INCPTR	;ANY /INCLUDES?
	JUMPE	T1,T6INC1	;NO TEMPS, TRY PERMS
	MOVEI	T1,INCPTR	;SCAN INCLUDE TABLE
	PUSHJ	P,T.6SCN
	  JRST	T6INC1		;NOT IN TABLE
	MOVSS	INCPTR		;REMOVE FROM BOTH SIDES OF LIST
	JRST	T6INC2

T6INC1:	HLRZ	T1,INCPTR	;SEE IF ANY PERMS
	JUMPE	T1,T.6POP	;NO
	MOVEI	T1,EXCPTR	;MAKE SURE NOT IN EXCLUDE TABLE
	PUSHJ	P,T.6SCN	;AS IT MIGHT ALSO BE IN PERM INCLUDES
	  CAIA			;NO, CONTINUE SEARCH
	JRST	T.6POP		;YES, SO WE DON'T WANT IT YET
	MOVSS	INCPTR		;SWAP PTR
	MOVEI	T1,INCPTR	;SCAN INCLUDE TABLE
	PUSHJ	P,T.6SCN
	  JRST	[MOVSS	INCPTR		;SWAP BACK
		JRST	T.6POP]		;NOT IN TABLE RETURN
T6INC2:	TRZ	FL,R.LIB!R.INC	;YES, LOAD THIS MODULE
	MOVEI	T1,INCPTR	;NOW REMOVE FROM LIST
	PUSHJ	P,EXCL.0##	;SO WE ONLY LOAD IT ONCE
	MOVSS	INCPTR		;PUT BACK
	MOVEI	T1,INCPTR	;NOW REMOVE FROM LIST
	PUSHJ	P,EXCL.0##	;SO WE ONLY LOAD IT ONCE
	JRST	T.6OK

T.6EXC:	HRRZ	T1,EXCPTR	;SEE IF TEMP
	JUMPE	T1,T6EXC1	;NO, TRY PERM
	MOVEI	T1,EXCPTR	;SEE IF IN EXCLUDE TABLE
	PUSHJ	P,T.6SCN
	  JRST	T6EXC1		;NO, LOAD IT
T6POP1:	TRO	FL,R.LIB	;DO NOT LOAD THIS MODULE
T.6POP:	TRZ	FL,R.LOD	;CLEAR LOADING FLAG SINCE WE'RE NOT
	POP	P,T1		;REMOVE JUNK
	JRST	LOAD##		;AND GET NEXT BLOCK

T6EXC1:	HLRZ	T1,EXCPTR	;SEE IF TEMP
	JUMPE	T1,T.6OK	;NO, LOAD IT
	MOVEI	T1,INCPTR	;SEE IF IN LOCAL INCLUDES
	PUSHJ	P,T.6SCN	; BEFORE TRYING GLOB EXCLUDES
	  CAIA			;NO, SO CONTINUE SEARCH
	JRST	T.6OK		;YES, SO WE WANT IT
	MOVSS	EXCPTR		;SWAP
	MOVEI	T1,EXCPTR	;SEE IF IN EXCLUDE TABLE
	PUSHJ	P,T.6SCN
	  JRST	[MOVSS	EXCPTR		;PUT BACK
		JRST	T.6OK]		;NO, LOAD IT
	MOVSS	EXCPTR		;SWAP BACK
	JRST	T6POP1		;DON'T LOAD RETURN

T.6SCN:	HRRZ	T1,(T1)		;GET POINTER
	JUMPE	T1,CPOPJ	;0 LINK IS END (OR NEVER STARTED)
	ADD	T1,[-.EXC+1,,1]	;FORM AOBJN POINTER
	SKIPN	T2,(T1)		;NOT IN TABLE IF 0
	POPJ	P,		;FAIL RETURN
	CAMN	W2,T2		;TEST
	JRST	CPOPJ1		;OK RETURN
	AOBJN	T1,.-4		;LOOP
	SUBI	T1,.EXC		;BACKUP
	JRST	T.6SCN		;TRY NEXT


;NOW FOR SPECIAL STUFF FOR MAPS ETC
T.6M:	AOS	RSYM		;ONE MORE ITEM FOR HEADER
	MOVSI	W1,PT.SGN!PT.TTL	;SET FLAGS
	MOVE	W2,PRGNAM	;RECOVER NAME
	SETZ	W3,		;POINTER TO END
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL SYMBOL TABLE
	SETZM	LSTSYM		;NOT A REAL SYMBOL SO CLEAR POINTER
	MOVSI	W1,S.TTL!S.SEG	;LOW/HIGH REL COUNTERS
	MOVEI	R,1		;LOW SEG FIRST
	MOVE	R,@RC.TB	;PICKUP RELOCATION POINTER
	HRLZ	W2,RC.CV(R)	;CURRENT VALUE
	MOVEI	R,2		;NOW FOR HIGH
	SKIPN	R,@RC.TB	;PICKUP RELOCATION POINTER
	TDZA	W3,W3		;NO HIGH SEGMENT YET
	HRLZ	W3,RC.CV(R)	;CURRENT VALUE
	MOVE	T1,LSYM		;POINTER TO WHERE IT WILL GO
	HRLM	T1,NAMPTR	;STORE FOR FIXUPS
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.CRE	;GET DATE TIME STUFF
	LDB	W2,[POINT 12,FCRE,35]	;GET LOW 12 BITS OF DATE
	LDB	W3,[POINT 3,FEXT,20]	;GET HIGH 3 BITS
	DPB	W3,[POINT 3,W2,23]	;MERGE THE TWO PARTS
	LDB	W3,[POINT 11,FCRE,23]	;GET TIME
	HRL	W2,W3		;INTO LEFT HALF
	MOVE	W3,CTYPE	;WHO DID CREATION
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.DEV	;DEV & UFD
	MOVE	W2,FSTR		;DEV
	SKIPN	W3,UFDPPN	;UFD
	JRST	.+3		;NO
	TLNN	W3,-1		;FOUND ONE
	MOVE	W3,SFDDIR	;UNLESS FULL PATH
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.NAM	;FILE NAME & EXT
	MOVE	W2,FNAM		;NAME
	HLLZ	W3,FEXT		;EXT
	PUSHJ	P,LS.ADD

	SKIPE	W3,UFDPPN	;WERE THERE SFD'S
	TLNE	W3,-1
	JRST	T.6NS		;NO
	MOVEI	R,SFDDIR+1	;POINT TO SFD
T.6S:	MOVSI	W1,S.TTL!S.SFD	;YES, SIGNAL SFD SEEN
	DMOVE	W2,(R)		;GET SFD
	JUMPE	W2,T.6NS	;END IF 0
T.6SD:	PUSHJ	P,LS.ADD	;OUTPUT IT
	ADDI	R,2
	JUMPN	W3,T.6S		;AND CONTINUE

T.6NS:
IFN FMXFOR,<
	HLRE	T2,ENTPTR	;GET - LENGTH OF ENTRIES
	MOVN	T2,T2		;POSITIVE
	JUMPE	T2,[HRRES MIXFOR	;RESET SWITCH
		JRST	LOAD##]		;AND  IGNORE
	SKIPLE	T1,MIXFOR	;ONLY WANT IF POSITIVE ALREADY
	PUSHJ	P,DY.GET##	;GET TABLE SPACE
	MOVEM	T1,MIXFOR	;STORE POINTER
>
	JRST	LOAD##		;GET NEXT BLOCK

T.6BC:	HRRZ	T2,BLCOMM	;GET COMMON SIZE
	CAIG	T1,(T2)		;IS IT WITHIN SIZE OF PREVIOUS?
	JRST	T.6M		;GET NEXT BLOCK
	.ERR.	(MS,.EC,V%L,L%F,S%F,IBC,<Attempt to increase size of blank common from >)
	.ETC.	(DEC,.EC!.EP,,,,T2)
	.ETC.	(STR,.EC,,,,,< to >)
	.ETC.	(DEC,.EP,,,,T1)


;HERE TO ADJUST THE RELOC TABLES FOR FORCED HIGH SEGMENT LOADING
;SET BY /SEGMENT:HIGH

T.6RC:	SETZ	W1,		;USE DEFAULT VALUE
	SKIPN	SG.TB+2		;ALREADY HIGH SEG SETUP?
	PUSHJ	P,SETRC		;NO, SETUP 2ND RELOC COUNTER
	MOVEI	R,1		;BUT MAKE RELOC 1 POINT TO SEG 2
	MOVE	T1,SG.TB+2
	MOVEM	T1,@RC.TB
	POPJ	P,
SUBTTL	BLOCK TYPE 7 - STARTING ADDRESS

;	----------------
;	!    7 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!  ST. ADDRESS !
;	----------------
;	! SYMBOL FIXUP !
;	----------------

T.7:	TRNE	FL,R.ISA	;IGNORE STARTING ADDRESSES?
	JRST	T.0		;YES
	PUSHJ	P,RB.2		;READ POSSIBLE TWO DATA WORDS
	  JRST	[MOVEI	T1,7
		JRST	ILIERR]
	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,CHKSEG	;YES, SEE IF WANTED
	  SKIPA	T2,PRGNAM	;GET ACTUAL PROG NAME
	JRST	LOAD##		;NOT WANTED
	MOVEM	T2,STANAM	;STORE IT FOR MAP
	EXCH	W1,W2		;PUT SYMBOL IN W2
	JUMPGE	W2,T.7A		;CHECK FOR SYMBOLIC
	LDB	T2,[POINT 4,W2,3]	;CHECK CODE NOT JUST SIGN BIT
	MOVEI	T1,7		;BLOCK TYPE
	CAIE	T2,14		;MUST BE RADIX50 60,
	JRST	T.ERR##		;GIVE ERROR MESSAGE
	PUSHJ	P,R50T6		;SIXBITIZE IT
	PUSH	P,W1		;SAVE CONST.
	MOVSI	W1,PT.SGN!PT.SYM!PS.GLB	;SET SOME REASONABLE FLAGS
	SETZ	W3,		;NO VALUE
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED
	  JRST	T.7B		;NOT EVEN IN TABLE
	  JRST	T.7B		;UNDEFINED, SO STORE IN 6BIT
	POP	P,W1		;RESTORE CONST
	ADD	W1,2(P1)	;ADD VALUE
	SETZ	W2,		;NO SYMBOL NOW
T.7A:	PUSHJ	P,SET.ST	;SET STARTING ADDRESS
	JRST	LOAD##		;GET NEXT BLOCK

T.7B:	PUSHJ	P,SY.RQ		;PUT REQUEST IN SYMBOL TABLE
	POP	P,W1		;RESTORE CONST.
IFN FTOVERLAY,<
	DMOVEM	W1,STADDR	;STORE NAME AS STARTING ADDRESS
	SKIPGE	LNKMAX		;ONLY IF IN ROOT
>
	PUSHJ	P,SET.ST	;DO REST OF STUFF
	JRST	LOAD##		;GET NEXT BLOCK
SET.ST::DMOVEM	W1,STADDR	;STORE AS STARTING ADDRESS
	MOVE	T2,PRGNAM	;GET PROGRAM NAME (FROM TITLE)
	CAME	T2,['FORDDT']	;TEST FOR FORTRAN DEBUGGER
	CAMN	T2,['ALGOBJ']	;TEST FOR ALGOL STARTUP ROUTINE
	POPJ	P,		;AND IGNORE
	SKIPN	T2		;IF REAL NAME IN TITLE
	MOVE	T2,FNAM		;OTHERWISE USE FILE NAME
	MOVE	T1,CTYPE	;GET CURRENT COMPILER TYPE
	MOVEM	T1,MNTYPE	;SAVE AS MAIN PROG TYPE
	SETZB	T1,LODNAM	;CLEAR INITIALLY
	SKIPA	T3,[POINT 6,LODNAM]
SETST0:	IDPB	T1,T3		;STORE VALID CHAR
SETST1:	JUMPE	T2,SETST2	;ALL DONE
	SETZ	T1,
	LSHC	T1,6		;GET NEXT CHAR
	CAIG	T1,'Z'		;SEE IF ALPHA
	CAIGE	T1,'0'
	JRST	SETST1		;NO WAY
	CAIGE	T1,'A'		;OK
	CAIG	T1,'9'
	JRST	SETST0		;YES
	JRST	SETST1		;NO

SETST2:	MOVE	T1,LODNAM	;SEE WHAT WE ENDED UP WITH
	CAMN	T1,['MAIN  ']	;IF JUST FORTRAN OR MACRO MAIN PROG
	SKIPN	T1,FNAM		;USE A NON-ZERO FILE NAME INSTEAD
	POPJ	P,		;NO, USE WHAT WE HAVE
	MOVEM	T1,LODNAM	;ANYTHING IS BETTER THAN MAIN
	POPJ	P,

SUBTTL	BLOCK TYPE 10 - LOCAL DEFINITION

;	----------------
;	!   10 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! ADDR ! VALUE !
;	----------------

T.10:	PUSHJ	P,RB.1		;READ A DATA WORD
	  JRST	LOAD##		;END OF BLOCK
	CAMN	W1,[-1]		;-1 IS MARKER FOR LEFT HALF FIXUP
	JRST	T.10L
	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,CHKSEG	;YES, SEE IF WANTED
	  CAIA			;YES
	JRST	T.10		;NO
	HLRZ	T2,W1		;ADDRESS OF SYMBOL CHAIN
	HRRZ	W3,W1		;VALUE OF SYMBOL
IFN FTOVERLAY,<
	SETZ	P1,		;NOT GLOBAL SYMBOL
>
	PUSHJ	P,SY.CHR##	;SATISFY REQUEST
	JRST	T.10		;LOOP 

T.10L:	PUSHJ	P,RB.1		;GET FIXUP WORD
	  JRST	T.10TS		;SHOULD NOT HAPPEN
	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,CHKSEG	;YES, SEE IF WANTED
	  CAIA			;YES
	JRST	T.10		;NO
	HLRZ	T2,W1		;ADDRESS OF SYMBOL CHAIN
	HRRZ	W3,W1		;VALUE
IFN FTOVERLAY,<
	SETZ	P1,		;NOT GLOBAL SYMBOL
>
	PUSHJ	P,SY.CHL##	;DO LEFT HALF CHAINING
	JRST	T.10

T.10TS:	.ERR.	(MS,.EC,V%L,L%W,S%W,LIT,<Link item type >)
	.ETC.	(OCT,.EC,,,,10)
	.ETC.	(STR,.EC,,,,,< too  short for >)
	.ETC.	(FSP,,,,,DC)
	JRST	LOAD##		;TRY TO CONTINUE

SUBTTL	BLOCK TYPE 11 - POLISH FIXUPS (FAIL)

;	----------------
;	!   11 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! DATA !  DATA !
;	----------------

;THE POLISH FIXUP BLOCK IS STORED IN THE FX AREA
;THE ACTION IS :-
;(1)	READ AND RELOCATE THE FIXUPS
;	STORE THEM IN FX AREA
;(2)	CHECK AND EVALUATE GLOBAL REQUESTS
;	STORE VALUES BACK IN FIXUP
;(3)	IF THERE ARE NO UNDEFINED GLOBAL REQUESTS
;	EVALUATE POLISH AND STORE
;(4)	IF THERE ARE UNDEFINED REQUESTS
;	LINK GLOBAL SYMBOL TO FIXUP AREA AND CONTINUE
;(5)	WHEN LAST UNDEFINED GLOBAL IS DEFINED
;	EVALUATE AND STORE
;(6)	IF STORE ADDRESS IS PAGED TO DSK
;	STORE BACK IN FIXUP AREA AND PROCESS AT END

;HERE TO READ BLOCK AND STORE IN FX AREA
T.11:	HRRZI	T2,2(W1)	;WORD COUNT
	HRLZM	T2,T11FA	;STORE BLOCK SIZE
	PUSHJ	P,FX.GET##	;GET SPACE IN FX AREA
	SUB	T1,FX.LB	;RELATIVE
	MOVE	W2,T1		;SAFE PLACE FOR POINTER
	HRRM	T1,T11FA	;STORE STARTING ADDRESS
	MOVEI	W3,2(W2)	;BYTE POINTER TO START OF FIXUP
	HRLI	W3,(POINT 18)
	MOVEM	W3,T11BP	;STORE INITIAL BYTE POINTER
	SUBI	W3,1		;W3 ALSO POINTS TO GLOBAL COUNT
	HRLI	W1,FP.POL	;SET POLISH FIXUP BIT
	ADDI	W1,2		;ACCOUNT FOR OVERHEAD WORDS
	ADD	W2,FX.LB	;FIX IN CORE
	ADD	W3,FX.LB	;...
	MOVEM	W1,(W2)		;STORE HEADER WORD PLUS SYMBOLS
	SETZM	1(W2)		;CLEAR GLOBAL COUNT
	ADDI	W2,2		;BYPASS
T.11RD:	PUSHJ	P,RB.1		;READ AND RELOCATE 2 HALF WORDS
	  JRST	T.11GC		;FINISHED WITH THIS BLOCK
	MOVEM	W1,(W2)		;STORE
	AOJA	W2,T.11RD	;READ ALL OF BLOCK

;HERE TO COUNT AND EVALUATE GLOBAL REQUESTS
T.11GC:	MOVE	W1,T11BP	;RESET BYTE POINTER
	ADD	W1,FX.LB	;FIX IN CORE
	JRST	T.11G1		;BYPASS FIRST TIME

T.11G0:	IBP	W1		;BYPASS NEXT HALF WORD
T.11G1:	ILDB	T1,W1		;READ HALF WORD
	CAIL	T1,15		;CHECK FOR VALID OPS
	JRST	T.11SP		;SEE IF STORE OP
	CAIL	T1,3		;IF OPERATOR
	JRST	T.11G1		;IGNORE IT
	JUMPE	T1,T.11G0	;IGNORE NEXT HALF WORD
	CAIN	T1,1		;36 BIT VALUE?
	AOJA	W1,T.11G1	;YES, GET NEXT HALF WORD AFTER IT
;HERE IF T1=2, GLOBAL SYMBOL REQUEST
	ILDB	T1,W1		;GET FIRST PART OF SYMBOL
	ILDB	W2,W1		;GET RIGHT HALF PART
	HRL	W2,T1		;FULL SYMBOL IN W2
	PUSHJ	P,R50T6		;CONVERT TO SIXBIT IN W2
	SUB	W1,FX.LB	;INCASE IT MOVES
	SUB	W3,FX.LB	;DITTO
	PUSH	P,W1		;SAVE BYTE POINTER
	MOVSI	W1,PT.SGN!PT.SYM	;SET SOME VALID FLAGS
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED
	  JRST	T.11ND		;NO, NEED TO DEFINE IT
	  JRST	T.11UN		;UNDF, SO JUST AS BAD
	POP	P,W1		;RESTORE BYTE POINTER
	ADD	W1,FX.LB	;ADD CORE OFFSET
	ADD	W3,FX.LB
	SUBI	W1,2		;BACKUP BYTE POINTER
	IBP	W1		;TO POINT TO 2
	MOVEI	T1,1		;CHANGE GLOBAL MARKER INTO 36 BIT VALUE MARKER
	IDPB	T1,W1
	MOVS	T1,2(P1)	;GET VALUE
T.11G2:	IDPB	T1,W1		;STORE IT
	MOVSS	T1
	IDPB	T1,W1		;W1 BACK AS IT WAS
	JRST	T.11G1		;GET NEXT HALF WORD

T.11SP:	CAIL	T1,-3		;SYMBOL FIXUPS?
	JRST	T11SPG		;NO
	CAIGE	T1,-6		;VALID STORE POINTER?
	JRST	T11SPE		;NO
				;IF STORE IS TO SYMBOL TABLE THERE ARE 2 SYMBOLS FOLLOWING
				;1 ACTUAL SYMBOL TO BE FIXED UP
				;2 BLOCK NAME IT IS IN
	ILDB	T1,W1		;YES, GET LEFT PART
	ILDB	W2,W1		;GET RIGHT
	HRL	W2,T1		;FULL SYMBOL
	PUSHJ	P,R50T6		;CONVERT NOW
	SUBI	W1,1		;BACKUP BYTE PTR
	HLRZ	T1,W2		;LEFT HALF
	IDPB	T1,W1
	IDPB	W2,W1		;RIGHT HALF
	ILDB	T1,W1		;YES, GET LEFT PART
	ILDB	W2,W1		;GET RIGHT
	HRL	W2,T1		;FULL SYMBOL
	PUSHJ	P,R50T6		;CONVERT NOW
	SUBI	W1,1		;BACKUP BYTE PTR
	HLRZ	T1,W2		;LEFT HALF
	IDPB	T1,W1
	IDPB	W2,W1		;RIGHT HALF
T11SPG:	SKIPN	(W3)		;ANY UNDEFINED GLOBALS?
	PUSHJ	P,T.11EV	;NO EVALUATE FIXUP
	JRST	LOAD##		;IGNORE FOR NOW

T11SPE:	.ERR.	(MS,.EC,V%L,L%F,S%F,ISO,<Invalid store operator >)
	.ETC.	(OCT,.EP,,,,T1)

;HERE IF GLOBAL SYMBOL NOT IN GLOBAL SYMBOL TABLE YET
;TREAT AS IF ADDITIVE GLOBAL REQUEST
;GET EXTENDED TRIPLET AND POINT TO FIXUP TRIPLET IN FIXUP AREA
;INTURN THIS TRIPLET POINTS TO THE POLISH FIXUP
;NOTE AT THIS POINT W1, W2, AND W3 ARE USED FOR NON-SYMBOL
;STUFF, THEY MUST BE SAVED

T.11ND:	AOS	USYM		;INCREMENT UNDEF COUNT
	PUSH	P,W2		;SAVE ACCS
	PUSH	P,W3
	TLO	W1,PS.REQ	;USUAL FLAGS
	PUSH	P,W1		;SAVE PRIMARY FLAGS
	PUSH	P,[0]		;ZERO VALUE
T.11GS:	MOVSI	W1,S.FXP	;SECONDARY SYMBOL FLAG
	PUSHJ	P,GS.FX0##	;PUT IN GLOBAL TABLE
	MOVSI	W1,FP.SGN!FP.SYM!FP.PTR!FP.POL
	HRRZ	W3,T11FA	;ADDRESS (RELATIVE TO FX.LB) OF POLISH
	PUSHJ	P,SY.FX0##	;NOW PUT INTO  FIXUP TABLE
	PUSHJ	P,SY.GX0##	;LINK TO GLOBAL
T.11GD:	POP	P,W3
	POP	P,W2
	POP	P,W1
	ADD	W1,FX.LB	;RELOCATE AGAIN
	ADD	W3,FX.LB	;...
	AOS	(W3)		;BUMP COUNT OF UNDEFINED SYMBOLS
	MOVS	T1,W2		;PUT SYMBOL IN T1 SWAPPED
	SOJA	W1,T.11G2	;BACKUP BYTE POINTER AND STORE AS SIXBIT
				;OVERWRITING THE RADIX-50


;HERE TO SEE IF FIXUP REQUESTS EXIST FOR THIS  SYMBOL
;IF SO ADD TO CHAIN, IF NOT CREATE CHAINED LIST IN EXTENDED SYMBOL
T.11UN:	PUSH	P,W2		;SAVE ACCS
	PUSH	P,W3
	MOVE	W1,0(P1)	;FLAGS GO IN W1 NOW
	TLNE	W1,PS.FXP	;ALREADY FIXUPS DEFERED?
	JRST	T.11DF		;YES, JUST LINK TO CHAIN
	PUSH	P,W1		;SAVE PRIMARY FLAGS
	PUSH	P,2(P1)		;CURRENT VALUE
	MOVE	T1,P1		;ADDRESS OF ORIGINAL TRIPLET
	MOVEI	T2,.L		;SIZE
	PUSHJ	P,GS.RET##	;GET RID OF IT
	SETZM	@HT.PTR		;CLEAR POINTER TO DELETED SYMBOL
	JRST	T.11GS		;JOIN COMMON CODE

;HERE IF FIXUP REQUEST EXISTS ALREADY
;JUST LINK INTO FRONT OF CHAIN

T.11DF:	ADDI	P1,.L		;LOOK FOR ADDITIVE  GLOBAL REQUEST
	SKIPG	W1,0(P1)	;GET SECONDARY FLAGS
	JRST	T11DFE		;PRIMARY OR NO FLAGS SET
	TLNN	W1,S.FXP	;IS THIS THE ONE
	JRST	T.11DF		;NO TRY AGAIN
	SKIPN	W1,2(P1)	;GET POINTER, BETTER BE NON-ZERO
	JRST	T11DFE
	HRLI	W1,FP.SGN!FP.SYM!FP.PTR!FP.POL
	HRRZ	W3,T11FA	;POINT TO POLISH
	PUSHJ	P,SY.FX0##	;PUT IN FIXUP AREA
	MOVE	T1,@HT.PTR	;FIND RELATIVE ADDRESS OF GLOBAL
	ADD	T1,NAMLOC	;RELOCATE IT
	HRRM	W3,2(T1)	;FIXUP REQUEST POINTER CHAIN
	JRST	T.11GD		;GET NEXT HALF-WORD

T11DFE:	.ERR.	(MS,,V%L,L%F,S%F,ISP)

;HERE TO EVALUATE POLISH FIXUP
T.11EV::SKIPN	W3,POLSTK	;GET STACK POINTER
	PUSHJ	P,T.11PD	;NOT SETUP YET
	MOVEI	T3,100		;INCASE OF ON OPERATOR
	MOVEM	T3,SVSAT
	PUSH	W3,[15]		;FAKE OPERATOR
	MOVE	W2,T11BP	;SETUP READ BYTE POINTER
	ADD	W2,FX.LB	;FIX IN CORE
T.11RP:	ILDB	W1,W2		;READ A HALF-WORD
	TRNE	W1,400000	;STORE OPERATOR?
	JRST	T.11ST		;YES
	CAIGE	W1,2		;0,1,2 ARE OPERANDS
	JRST	T.11OP
	CAIE	W1,2		;2 IS ILLEGAL AT THIS POINT
	CAILE	W1,14		;14 IS HIGHEST OPERATOR
	JRST	T11RPE
	PUSH	W3,W1		;SAVE OPERATOR ON STACK
	MOVE	T3,DESTB-3(W1)	;GET NUMBER OF OPERANDS NEEDED
	MOVEM	T3,SVSAT	;ALSO SAVE IT
	JRST	T.11RP		;BACK FOR MORE

T.11PD:	MOVEI	T2,PPDL		;SIZE REQUIRED
	PUSHJ	P,DY.GET##	;GET SPACE FOR STACK
	MOVEM	T1,POLSTK	;START OF STACK
	MOVEI	W3,-1(T1)	;FORM PUSHDOWN STACK IN W3
	HRLI	W3,-PPDL	;FORM STACK POINTER
	MOVEM	W3,POLSTK	;STORE FOR NEXT TIME
	POPJ	P,


T11RPE:	.ERR.	(MS,.EC,V%L,L%F,S%F,IPO,<Invalid polish operator >)
	.ETC.	(OCT,.EP,,,,W1)
;HANDLE OPERANDS

T.11OP:	MOVE	T1,W1		;GET THE OPERAND TYPE HERE
	ILDB	W1,W2		;THIS IS AT LEAST PART OF THE OPERAND
	MOVE	T2,W1
	JUMPE	T1,T.11P0	;0 IS HALF-WORD OPERAND
	ILDB	W1,W2		;NEED FULL WORD GET 2ND HALF
	HRL	T2,W1		;GET IN RIGHT ACC
	MOVS	T2,T2		;WRONG ORDER
T.11P0:	SETZ	T1,		;VALUE OPERAND
T.11P1:	SOJL	T3,T.11ES	;ENOUGH OPERANDS SEEN
	PUSH	W3,T2		;SAVE VALUE
	HRLI	T1,400000	;PUT IN A VALUE MARKER
	PUSH	W3,T1
	JRST	T.11RP		;GET MORE POLISH

;HERE WHEN WE HAVE ENOUGH OPERANDS FOR THE CURRENT OPERATOR

T.11ES:	SKIPN	SVSAT		;IS IT UNARY
	JRST	T.11UO		;YES, NO NEED FOR 2ND OPERAND
	POP	W3,T1		;POP OFF MARKER
	POP	W3,T1		;AND VALUE
T.11UO:	POP	W3,T3		;OPERATOR
	XCT	OPTAB-3(T3)	;BOTH VALUES JUST XCT
	MOVE	T2,T1		;GET THE CURRENT VALUE
	SKIPG	T3,(W3)		;IS THERE A VALUE  IN THE STACK?
	MOVE	T3,-2(W3)	;YES, THIS MUST BE THE OPERATOR
	MOVE	T3,DESTB-3(T3)	;GET NUMBER OF OPERANDS NEEDED
	MOVEM	T3,SVSAT	;SAVE IT HERE
	SKIPG	(W3)		;WAS THERE AN OPERAND
	SUBI	T3,1		;HAVE ONE OPERAND ALREADY
	JRST	T.11P1		;GO SEE WHAT WE SHOULD DO NOW


;NUMBER OF OPERANDS FOR EACH OPERATOR (LESS 1)
DESTB:	EXP	1,1,1,1,1,1,1,1,0,0,100
;OPERATOR ACTION
OPTAB:	ADD	T1,T2
	SUB	T1,T2
	IMUL	T1,T2
	IDIV	T1,T2
	AND	T1,T2
	IOR	T1,T2
	LSH	T1,(T2)
	XOR	T1,T2
	SETCM	T1,T2
	MOVN	T1,T2

;HERE TO STORE THE FINAL VALUE

T.11ST:	MOVE	T2,-2(W3)	;THIS SHOULD BE THE FAKE OPERATOR
	CAIE	T2,15		;IS IT
	JRST	T11STE		;NO
	HRRZ	T2,(W3)		;GET THE VALUE TYPE
	CAIGE	W1,-3		;SYMBOL TABLE FIXUP?
	PUSHJ	P,T11STF	;YES, DO ALL WORK TO MAKE FIXUPS APPEAR
	  ILDB	T2,W2		;GET THE ADDRESS (IF NOT SYMBOL FIXUP)
	MOVE	W3,-1(W3)	;GET THE VALUE AFTER IGNORING THE FLAG
	PUSHJ	P,@STRTAB+6(W1)	;CALL THE CORRECT FIXUP ROUTINE
				;ALL DONE, NOW GIVE SPACE BACK
	HRRZ	T1,T11FA	;START OF FIXUP AREA
	ADD	T1,FX.LB	;IN REAL CORE
	HLRZ	T2,T11FA	;LENGTH OF AREA
	PUSHJ	P,FX.RET##	;RETURN FIXUP BLOCK
	SETZM	T11FA		;AND CLEAR MARKER
	SETZM	T11BP		;BYTE POINTER ALSO
	POPJ	P,		;RETURN TO GET NEXT BLOCK

;STORE OPERATOR ACTION TABLE
STRTAB:	T11SYF			;-6 FULL WORD SYMBOL FIXUP
	T11SYL			;-5 LEFT HALF SYMBOL FIXUP
	T11SYR			;-4 RIGHT HALF SYMBOL FIXUP
	SY.CHF##		;-3 FULL WORD FIXUP CHAIN
	SY.CHL##		;-2 LEFT HALF FIXUP CHAIN
	SY.CHR##		;-1 RIGHT HALF FIXUP CHAIN
	CPOPJ			;0  NO-OP

T11STE:	.ERR.	(MS,.EC,V%L,L%F,S%F,IPO)
	.ETC.	(OCT,.EP,,,,T2)
;HERE TO DISPATCH FOR SYMBOL TABLE FIXUPS

;T1 = ADDRESS OF TRIPLET TO FIXUP
;T2 = FLAGS (WHICH HALF)
;W3 = VALUE

T11SYR:	MOVSI	T2,FS.FXS!FS.FXR	;SET FIXUP FLAGS
	JRST	SY.AST		;AND DO FIXUP

T11SYL:	MOVSI	T2,FS.FXS!FS.FXL
	JRST	SY.AST

T11SYF:	MOVSI	T2,FS.FXS!FS.FXF
	JRST	SY.AST

T11PSF:	.ERR.	(MS,,V%L,L%W,S%W,PSF,<Polish symbol fixups not yet implemented>)
	SETZ	W1,		;NO-OP
	POPJ	P,		;CONTINUE

T11STF:	PUSH	P,W3		;PUSH 2ND STACK POINTER
	ILDB	T1,W2		;GET REQUIRED SYMBOL
	ILDB	W3,W2
	HRL	W3,T1		;36 BIT SIXBIT SYMBOL
	ILDB	T1,W2		;GET BLOCK HEADER
	ILDB	W2,W2
	HRL	W2,T1		;36 BIT SYMBOL
	PUSHJ	P,T11FBH	;SEE IF LOADED (IN LOCAL TABLE)
	  SETZ	W1,		;NO, JUST IGNORE REQUEST
	POP	P,W3
	JRST	CPOPJ1		;AND ALWAYS SKIP RETURN

;HERE TO SEE IF REQUESTED BLOCK HAS BEEN LOADED FOR THIS PROGRAM

T11FBH:	SKIPN	T1,FBHPTR	;GET POINTER TO BLOCK HEADERS
	POPJ	P,		;NONE LOADED
	HRRZ	T1,NAMPTR	;GET POINTER TO LOCAL SYMBOL
	CAIA			;ALREADY IN T1 FIRST TIME
T11FBL:	HLRZ	T1,2(T1)	;GET POINTER TO BLOCK HEADER
	JUMPE	T1,CPOPJ	;END OF CHAIN
	CAMGE	T1,LW.LS	;IN CORE?
	JRST	T11PSF		;NOT AVAILABLE YET
	SUB	T1,LW.LS	;GET ADDRESS IN CORE
	ADD	T1,LS.LB
	SKIPGE	T2,(T1)		;MUST BE PRIMARY
	TLNN	T2,PT.TTL	;AND A TITLE BLOCK
	JRST	T.5SER		;NO
	CAME	W2,1(T1)	;SEE IF THIS IS THE BLOCK
	JRST	T11FBL		;NOT YET
	MOVE	W2,W3		;PUT SYMBOL WE WANT IN W2
T11FBS:	ADDI	T1,.L		;ADVANCE
	CAML	T1,LS.AB	;MAKE SURE WE DON'T GO TOO FAR
	POPJ	P,		;DIDN'T FIND IT
	SKIPLE	T2,(T1)		;ONLY WANT PRIMARIES (OR 0)
	JRST	T11FBS		;IGNORE ALL SECONDARY STUFF
	JUMPE	T2,.+2		;0 MARKS END
	TLNE	T2,PT.TTL	;STOP AT NEXT BLOCK
	POPJ	P,
	TLNE	T2,PT.SYM	;MUST BE A SYMBOL
	CAME	W2,1(T1)	;YES, BUT IS IT ONE WE WANT?
	JRST	T11FBS		;NO REQUIRED SYMBOL
	SETZ	T2,		;CLEAR GLOBAL SYMBOL PTR
	JRST	CPOPJ1		;OK RETURN
SUBTTL	BLOCK TYPE 12 - LINK (FAIL)

;	----------------
;	!   12 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! DATA   WORDS !
;	----------------

T.12:	SKIPE	LINKTB		;LINK TABLE SETUP ?
	JRST	T.12A		;YES
	MOVEI	T2,LN.12	;SIZE WE NEED
	PUSHJ	P,DY.GET	;GET IT
	HRLI	T1,W2		;PUT INDEX IN
	MOVEM	T1,LINKTB	;SETUP POINTER
	HRLZ	T2,T1		;BLT POINTER
	HRRI	T2,1(T1)
	SETZM	(T1)
	BLT	T2,17(T1)	;CLEAR ALL LINKS

T.12A:	PUSHJ	P,RB.2		;READ 2 WORDS
	  JRST	LOAD##
	TRNE	FL,R.LSO!R.HSO	;SELECTIVE LOADING?
	PUSHJ	P,CHKSEG	;YES, SEE IF WANTED
	  CAIA			;YES
	JRST	T.12		;NO
	JUMPL	W2,T.12E	;THIS IS AN END OF LINK WORD
	SOJL	W2,.+2		;ZERO IS ILLEGAL
	CAIL	W2,LN.12	;IN RANGE
	AOJA	W2,T.12I	;ILLEGAL LINK #
	MOVE	T2,W1		;GET ADDRESS WE NEED
	PUSHJ	P,SEGCHK##	;SEE IF IN CORE
	  JRST	T.12N		;NOT
	HRRZ	T1,@LINKTB	;GET PREVIOUS LINK ADDRESS
	HRRM	T1,(T2)		;STORE INCORE
	HRRM	W1,@LINKTB	;STORE NEW IN LINK TABLE
	JRST	T.12A		;BACK FOR MORE

T.12N:	HRLI	T2,CPF.RR	;NOT IN CORE
	MOVE	W3,W1		;VALUE
	PUSHJ	P,SY.CHP##	;PUT IN FIXUP LIST
	JRST	T.12A		;RERTURN FOR MORE

T.12E:	MOVNS	W2		;GET ENTRY NUMBER
	SUBI	W2,1		;PUT IN RANGE 0-17
	CAIL	W2,LN.12	;IN RANGE?
	AOJA	W2,T.12I	;ILLEGAL
	HRLM	W1,@LINKTB	;SAVE END OF LINK INFO
	JRST	T.12A		;BACK FOR MORE


T.12I:	.ERR.	(MS,.EC,V%L,L%W,S%W,ITT,<Illegal type 12 link number >)
	.ETC.	(OCT,.EP,.EC,,,,W2)
	.ETC.	(STR,.EC,,,,,< in module >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
	JRST	T.12A		;TRY TO CONTINUE
SUBTTL	BLOCK TYPE 13 - LVAR (WEIHER)

;	----------------
;	!   13 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! DATA   WORDS !
;	----------------

T.13:	.ERR.	(MS,0,V%L,L%F,S%F,T13,<LVAR (type 13) code not implemented>)

SUBTTL	BLOCK TYPE 14 - INDEX

;	----------------
;	!   14 ! COUNT !
;	----------------
;	!    4 ! COUNT !
;	----------------
;	!      SYMBOLS !
;	----------------
;	! WORD ! BLOCK !
;	----------------

T.14:	SETZM	DCBUF+2		;READ NEXT BUFFER ON NEXT ILDB
T.14ER:	SKIPN	XBUF		;IF WE HAVE AN INDEX BUFFER
	JRST	LOAD##		;NO, NOT FIRST TIME HERE
	PUSHJ	P,ZXBUF##	;GET RID OF IT
	.ERR.	(MS,,V%L,L%W,S%I,LII,<Library index inconsistent, continuing>)
	JRST	LOAD##		;AND CONTINUE

T.14I:	POP	P,LSTBLK	;SET UP LSTBLK FOR NEXT PROG
	PUSHJ	P,D.IN1##	;READ FIRST WORD
	HLRZ	T1,W1		;BLOCK TYPE ONLY
	CAIE	T1,14		;IS IT AN INDEX?
	JRST	T.14ER		;NO, ERROR
	JRST	T.14J		;DON'T SET FLAG AGAIN

;ENTER HERE IF IN /SEARCH MODE
T.14A:	MOVEI	T2,^D128	;SIZE OF INDEX BUFFER
	PUSHJ	P,DY.GET##	;GET SPACE IN DY AREA
	HRRZM	T1,XBUF		;SIGNAL SPACE AQUIRED
	MOVEI	T1,1		;START ON BLOCK 1 (DSK)
	HRROM	T1,LSTBLK	;BUT INDICATE AN INDEX
	MOVEI	T1,DC		;INPUT CHAN #
	DEVCHR	T1,
	TLNE	T1,(DV.DTA)	;IS IT A DTA?
	HRROS	XBUF		;YES, SET SIGNAL
T.14J:	HRRZ	T1,XBUF		;AUX BUFFER
	HRLI	T1,4400		;MAKE BYTE POINTER
	MOVEM	T1,XBUF+1	;AND SAVE IT
	HRL	T1,DCBUF+1	;INPUT BUFFER
	MOVEI	T2,^D127(T1)	;END OF BUFFER
	BLT	T1,(T2)		;STORE BLOCK
	SETOM	LSTLOD		;AND FAKE LAST PROG READ
T.14B::	ILDB	W3,XBUF+1
	JUMPL	W3,T.14D	;END OF BLOCK IF NEGATIVE
	HRRZ	W3,W3		;WORD COUNT ONLY
	MOVSI	W1,PT.SGN!PT.SYM	;VALID SYMBOL BITS
T.14C:	ILDB	W2,XBUF+1	;GET NEXT SYMBOL
	PUSHJ	P,R50T6		;SIXBITIZE IT
	PUSHJ	P,TRYSYM##
	  CAIA			;NOT IN TABLE, KEEP TRYING
	  SOJA	W3,T.14E	;REQUEST MATCHES
	SOJG	W3,T.14C	;NOT REQUIRED KEEP TRYING
	ILDB	W3,XBUF+1	;GET POINTER WORD
	SKIPN	LSTLOD		;WAS LAST PROG LOADED?
	JRST	T.14B		;NO
	SETZM	LSTLOD		;CLEAR FLAG
	SKIPL	XBUF		;ALWAYS SAVE IF DTA???
	SKIPL	LSTBLK		;SKIP IF LAST BLOCK WAS AN INDEX
	MOVEM	W3,LSTBLK	;SAVE POINTER FOR CALCULATIONS
	JRST	T.14B		;GET NEXT PROG

T.14E:	ADDM	W3,XBUF+1
	ILDB	T1,XBUF+1
	PUSH	P,T1		;SAVE THIS BLOCK
	SKIPE	LSTLOD		;DID WE LOAD LAST  PROG?
	JRST	[SKIPGE	LSTBLK	;WAS LAST BLOCK AN INDEX?
		JRST	NXTBLK	;YES, SO GET NEXT ONE
		POP	P,LSTBLK
		JRST	LOAD##]	;NEXT PROG IS ADJACENT
	SETOM	LSTLOD
	HRRZ	W3,LSTBLK	;GET LAST BLOCK NUMBER
	CAIN	W3,(T1)		;IN THIS BLOCK?
	JRST	THSBLK		;YES
NXTNDX:	SKIPGE	XBUF		;DIFFERENT TEST FOR DTA
	JRST	NXTDTA		;CHECK IF NEXT BUFFER IN CORE
	CAIN	W3,-1(T1)	;NEXT BLOCK?
	JRST	NXTBLK		;YES,JUST DO INPUT
T.14F:	USETI	DC,(T1)		;SET ON BLOCK
	WAIT	DC,		;LET I/O FINISH
	MOVSI	W2,(1B0)	;CLEAR RING USE BIT IF ON
	HRRZ	W3,DCBUF
	IORM	W2,DCBUF	;SET UNUSED RING BIT (HELP OUT MONITOR)
	SKIPL	(W3)
	JRST	NXTBLK		;ALL DONE NOW
	ANDCAM	W2,(W3)		;CLEAR USE BIT
	HRRZ	W3,(W3)		;GET NEXT BUFFER
	JRST	.-4		;LOOP

NXTDTA:	WAIT	DC,		;LET I/O RUN TO COMPLETION
	HRRZ	W3,DCBUF	;GET POINTER TO CURRENT BUFFER
	HLRZ	W3,1(W3)	;FIRST DATA WORD IS LINK
	CAIE	W3,(T1)		;IS IT BLOCK WE WANT?
	JRST	T.14F		;NO
NXTBLK:	IN	DC,
	  JRST	NEWBLK		;IT IS NOW
	JRST	D.ERR##		;EOF OR ERROR

NEWBLK:	MOVE	T1,(P)		;GET CURRENT BLOCK
	JUMPL	T1,T.14I	;JUST READ AN INDEX
	HLRZ	T1,T1		;GET WORD COUNT
	JRST	T.14G		;WORD COUNT WILL BE CORRECT

THSBLK:	SUB	T1,LSTBLK	;GET WORD DIFFERENCE
	MOVS	T1,T1		;INTO RIGHT HALF
T.14G:	ADDM	T1,DCBUF+1
	MOVN	T1,T1
	ADDM	T1,DCBUF+2
T.14H:	POP	P,LSTBLK	;STORE THIS AS LAST BLOCK READ
	JRST	LOAD##

T.14D:	HRRE	T1,W3		;GET BLOCK # OF NEXT INDEX
	JUMPL	T1,EOF1##	;FINISHED IF -1
	PUSH	P,W3		;STACK THIS BLOCK
	HRRZ	W3,LSTBLK	;GET LAST BLOCK
	JRST	NXTNDX		;CHECK IF NEXT BUFFER IN CORE
SUBTTL	BLOCK TYPE 15 - ALGOL OWN

;	----------------
;	!   15 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	! ORIG ! LENGTH!
;	----------------
;	! ADDR ! VALUE !
;	----------------

T.15:	PUSHJ	P,RB.1		;READ 3RD WORD
	  JRST	[MOVEI	T1,15
		JRST	ILIERR]
	MOVEI	R,1		;MUST GO TO LOW SEG
	MOVE	R,@RC.TB	;SO SETUP R
	HLRZ	W2,W1		;ORIGIN OF THIS OWN BLOCK
	MOVE	P3,W2		;COPY FOR ADCHK.
	HRRZM	W1,OWNLNG	;TO FIX RELOC AT END
	MOVE	T1,P3		;GET START 
	ADDI	T1,(W1)		;+END =HIGHEST LOC LOADED
	CAMLE	T1,RC.HL(R)	;BIGGEST YET?
	MOVEM	T1,RC.HL(R)	;YES STORE IT
	EXCH	W2,%OWN		;EXCH WITH PREVIOUS OWN
	HRL	W1,W2		;LAST OWN ADDRESS IN LEFT
				;THIS LENGTH IN RIGHT
	MOVS	W1,W1		;LENGTH,,ADDRESS
	MOVEI	R,1		;SEGMENT #
	PUSHJ	P,ADCHK.##	;MAKE SURE ADDRESSABLE
	CSTORE			;STORE W1

T.15A:	PUSHJ	P,RB.1		;GET FIXUP REQUEST
	  JRST	LOAD##
	HRRZ	W3,W1		;ADDITIVE CONSTANT
	ADD	W3,%OWN		;ADD IN BASE OR ARRAY
	HLRZ	T2,W1		;START OF CHAIN
	PUSHJ	P,SY.CHR##	;CHAIN REQUESTS
	JRST	T.15A


SUBTTL	BLOCK TYPES 16 & 17 REQUESTS

;	----------------
;	!   16 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!    FILE NAME !
;	----------------
;	!          PPN !
;	----------------
;	!       DEVICE !
;	----------------

;BLOCK TYPE 16 - PROGRAN REQUESTS (SAIL)
T.16:	MOVEI	P2,PRGPTR	;LOAD ADDRESS OF LIST OF PROGS TO LOAD
T.16A:	MOVE	P1,P2		;SETUP TEMP PTR
	PUSHJ	P,RB.2		;READ FIRST 2 DATA WORDS
	  JRST	LOAD##		;END OF BLOCK
	MOVE	W3,W1		;STORE PPN IN W3
	PUSHJ	P,RB.1		;READ 3RD DATA WORD
	  SETZ	W1,		;INCASE DEV NOT GIVEN
				;W1 = DEV
				;W2 = FILE
				;W3 = PPN

T.16L:	HRRZ	T1,(P1)		;INITIAL POINTER SETUP
	JUMPE	T1,T.16I	;NO
	MOVE	P1,(P1)		;GET NEXT BLOCK
	CAME	W1,1(P1)	;DEV SAME
	JRST	T.16L		;NO
	CAME	W2,2(P1)	;FILE?
	JRST	T.16L
	CAME	W3,3(P1)	;PPN
	JRST	T.16L		;DIFFERENT
	JRST	T.16A		;SEE IF MORE TO DO

T.16I:	MOVEI	T2,4		;NEED 4 WORDS
	PUSHJ	P,DY.GET	;GET SPACE
	SETZM	(T1)		;CLEAR POINTER
	TMOVEM	W1,1(T1)	;DEVICE, FILE NAME, PPN
	HRRZM	T1,(P1)		;LINK IN
	HRRZS	(P2)		;SIGNAL SOMETHING NEW ON LIST
	JRST	T.16A



;BLOCK TYPE 17 - LIBRARY REQUEST (SAIL)
T.17:	MOVEI	P2,LIBPTR	;POINTER TO LIBRARY REQUESTS
	JRST	T.16A		;READ REST OF BLOCK
SUBTTL	BLOCK TYPE 20 - COMMON ALLOCATION

;	----------------
;	!   20 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!       SYMBOL !
;	----------------
;	!       LENGTH !
;	----------------

COMMENT	* THIS BLOCK CONSISTS OF WORD PAIRS (SAME AS TYPE 2)
	FIRST WORD IS RADIX50 04,SYMBOL
	SECOND WORD IS 0,,COMMON LENGTH
	COMMON NAME MUST BE GLOBAL AND UNIQUE
	IF NOT ALREADY DEFINED LINK DEFINES SYMBOL AND ALLOCATES
	SPACE. IF DEFINED LINK CHECKS FOR TRYING TO INCREASE COMMON
	SIZE, AND GIVES ERROR IF SO
	NOTE... COMMON BLOCKS MUST COME DEFORE ANY DATA BLOCKS
	IE. AFTER BLOCKS 4,6,3 BUT BEFORE 1,2,37,..5
*

T.20:	PUSHJ	P,RB.2		;GET COMMON PAIR
	  JRST	LOAD##		;FINISHED
	MOVS	W3,W1		;VALUE
	PUSHJ	P,R50T6		;CONVERT TO SIXBIT
	PUSHJ	P,T.COMR	;CHECK THIS PAIR
	  JRST	T.20		;ALREADY DEFINED
	HRRZ	P1,@HT.PTR	;SETUP P1 TO POINT TO SYMBOL
	ADD	P1,NAMLOC	;IN CORE
	PUSH	P,.L+2(P1)	;SAVE 2ND TRIPLET INFO
	PUSH	P,.L+1(P1)
	PUSH	P,.L+0(P1)
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL TABLE
	POP	P,W1		;GET SECONDARY
	POP	P,W2		;SAME NAME
	POP	P,W3		;LENGTH
	PUSHJ	P,LS.ADD##	;ALSO IN LOCAL TABLE
	ADDM	W3,RC.CV(R)	;BUMP RELOCATION COUNTER
	JRST	T.20		;GET NEXT SYMBOL

T.COMR::MOVEI	R,1		;ASSUME FIRST SEGMENT
	MOVE	R,@RC.TB	;GET RC BLOCK
	HRR	W3,RC.CV(R)	;CURRENT VALUE
				;FALL INTO T.COMM
;T.COMM TESTS TO SEE IF COMMON ALREADY EXISTS
;IF SO CHECK SIZE
;IF NOT DEFINE (GLOBAL ONLY)
;RETURNS
;+1	COMMON ALREADY DEFINED WITH CORRECT LENGTH
;+2	WAS NOT DEFINED, NOW IS

T.COMM::MOVSI	W1,PT.SGN!PT.SYM!PS.GLB!PS.COM!PS.REL	;SET THE FLAGS
	PUSHJ	P,TRYSYM##	;SEE IF IN TABLE
	  JRST	T.20ND		;NOT IN TABLE
	  JRST	T.20UN		;IN, BUT UNDEF (NOT COMMON)
	MOVE	T1,(P1)		;GET PRIMARY FLAGS
	TLNN	T1,PS.COM	;ALREADY COMMON?
	JRST	T.20NC		;NO, ERROR
	HRRZ	T1,P1		;GET COPY
	ADDI	T1,.L		;NEXT TRIPLET
	MOVE	T2,(T1)		;GET FLAGS
	TLNN	T2,S.COM	;FOUND COMMON BLOCK YET?
	JRST	.-3		;NO
	HLRZ	T2,W3		;GET SIZE WE WANT
	CAMLE	T2,2(T1)	;LESS THAN OR EQUAL TO WHAT WE HAVE?
	JRST	T.20ER		;NO, GIVE ERROR
	MOVE	W3,2(P1)	;SET STARTING ADDRESS OF COMMON
	POPJ	P,		;YES, LEAVE ALONE

T.20ER:	MOVE	T1,2(T1)
	.ERR.	(MS,.EC,V%L,L%F,S%F,TEC,<Trying to expand common >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,< from >)
	.ETC.	(DEC,.EC!.EP,,,,T1)
	.ETC.	(STR,.EC,,,,,< to >)
	.ETC.	(DEC,.EC!.EP,,,,T2)
	.ETC.	(STR,.EC,,,,,< in module >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
T.20NC:	.ERR.	(MS,.EC,V%L,L%F,S%F,SNC,<Symbol >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,,,,,,< already defined, but not as common>)

;HERE TO PUT SYMBOL IN TABLE AND GENERATE SPACE
T.20ND:	TLO	W1,PT.EXT	;TURN ON EXTENDED BIT NOW
	MOVEI	T2,2*.L		;NEEDS TWO TRIPLETS
	PUSHJ	P,GS.GET##	;GET SPACE FOR THEM
	DMOVEM	W1,0(T1)	;FLAGS & NAME
	HRRZM	W3,2(T1)	;VALUE (ADDRESS IN CORE)
	MOVSI	T2,S.COM!S.LST	;SECONDARY FLAGS
	MOVEM	T2,.L+0(T1)	;IN SECONDARY TRIPLET
	MOVEM	W2,.L+1(T1)	;NAME AGGAIN
	HLRZM	W3,.L+2(T1)	;LENGTH OF COMMON ARRAY
	MOVE	W3,T1		;EXPECTS POINTER TO SYMBOL IN W3
	SUB	W3,NAMLOC	;RELATIVE TO  GLOBAL TABLE
	AOS	(P)		;SKIP RET
	PJRST	INSRT##		;PUT IN TABLE


T.20UN:	MOVE	T1,(P1)		;GGET PRIMARY FLAGGS
	TLNE	T1,PS.COM	;ALREADY DEFINED COMMON?
	JRST	T.20NC		;SHOULD NOT HAPPEN
	PUSHJ	P,SY.CHK##	;SEE HOW LONGG CURRENT SYMBOL IS
	ADDI	T2,.L		;EXTRA FOR COMMON TRIPLET
	PUSHJ	P,GS.GET	;GET SPACE
	HRRZ	P1,@HT.PTR	;RESET P1 INCASE CORE MOVED
	ADD	P1,NAMLOC	;MAKE FIXED
	MOVE	T3,(P1)		;GET PRIMARY FLAGS
	TLO	T3,PS.COM!PT.EXT	;NOW COMMON
	MOVEM	T3,(T1)		;STORE
	MOVEM	W2,1(T1)	;SYMBOL NAME
	MOVE	T3,2(P1)	;GET VALUE (CHAIN POINTER)
	MOVEM	T3,2(T1)	;
	MOVSI	T3,S.COM	;SECONDARY FLAG
	CAIG	T2,2*.L		;ONLY COMMON
	TLO	T3,S.LST	;YES, THEN THIS IS LAST TRIPLET
	MOVEM	T3,.L+0(T1)	;STORE COMMON FLAG
	MOVEM	W2,.L+1(T1)	;SYMBOL
	HLRZM	W3,.L+2(T1)	;AND COMMON LENGTH
	HRRZ	W3,W3		;REMOVE LENGTH, JUST LEAVE VALUE
	CAIG	T2,2*.L		;MORE TO MOVE STILL
	JRST	T20UN1		;NO, JUST ADJUST POINTER
	HRLZI	T3,.L(P1)	;FROM
	HRRI	T3,2*.L(T1)	;TO
	HRRZI	T4,(T1)
	ADDI	T4,-1(T2)	;LIMIT
	BLT	T3,(T4)
T20UN1:	SUBI	T2,.L		;LESS TO GIVE BACK
	EXCH	T1,P1		;PUT NEW IN P1
	PUSHJ	P,GS.RET##	;GIVE BACK OLD SYMBOL
	SUB	P1,NAMLOC	;MAKE POINTER RELATIVE
	HRRM	P1,@HT.PTR	;STORE IT
	ADD	P1,NAMLOC	;PUT OFFSET BACK
	AOS	(P)		;SKIP RET
	PJRST	SY.RF##		;AND FIXUP ANY REFERENCES

SUBTTL	BLOCK TYPE 21 - SPARSE DATA (FORTRAN-10)

;	-----------------
;	!    21 ! COUNT !
;	-----------------
;	!  BYTE   WORD  !
;	-----------------
;	! COUNT ! ADDR. !
;	-----------------
;	!  DATA   WORDS !
;	-----------------

COMMENT	*
	THIS BLOCK CONSISTS OF SUB BLOCKS OF FORM
	WORD COUNT,,ADDRESS
	DATA WORDS

	ADDRESS CAN BE EITHER RELOCATABLE OR ABSOLUTE
	DATA MAY BE EITHER ALSO
	CODE IS SIMILAR TO TYPE 1
*

T.21:	PUSHJ	P,RB.1		;READ CNT & LOC
	  JRST	LOAD##		;FINISHED
	JUMPGE	W1,.+3		;NOT SYMBOLIC
	MOVEI	T1,21		;INCASE OF ERROR
	PUSHJ	P,T.1S		;SYMBOLIC IF SIGN BIT ON
	HLRZ	W3,W1		;WORD COUNT
	HRRZ	W1,W1		;ADDRESS ONLY
	MOVE	P3,W1		;START ADDRESS
	ADD	W1,W3		;HIGHEST NEEDED
	PUSHJ	P,T.1AD		;CHECK ADDRESS AND LOAD THIS SUB BLOCK
	JRST	T.21		;LOOP FOR MORE
SUBTTL	BLOCK TYPE 37 - COBOL LOCAL SYMBOLS

;	----------------
;	!   37 ! COUNT !
;	----------------
;	! BYTE   WORD  !
;	----------------
;	!      ADDRESS !
;	----------------
;	! DATA   WORDS !
;	----------------

T.37:	TLNN	FL,L.SYM	;LOADING WITH SYMBOLS?
	JRST	T.0		;NO, IGNORE THIS BLOCK
	HRRZI	W2,-1(W1)	;GET COUNT OF DATA WORDS
	ADDM	W2,LOD37	;COUNT OF BLOCKS LOADED
	JRST	T.1		;LOAD AS DATA


SUBTTL	BLOCK TYPE 776 - RADIX50 SYMBOL FILE

;	----------------
;	!  776 ! COUNT !
;	----------------
;	!    .JBSYM    !
;	----------------
;	!    .JBUSY    !
;	----------------
;	!    SYMBOLS   !
;	----------------

T.776::	HRRZI	R3,1(W1)	;WORD COUNT + HEADER
	MOVEI	T2,LN.IO	;NO. OF WORDS REQUIRED
	PUSHJ	P,DY.GET##	;TO HOLD LOOKUP BLOCK
	MOVEM	T1,IO.PTR+TC	;ON TEMP CHAN
	HRLZI	T3,OPENBL	;SAME AS DC CHAN
	HRRI	T3,(T1)
	ADDI	T2,-1(T1)	;END OF BLT
	BLT	T3,(T2)		;MOVE DATA BLOCK
	MOVEI	T2,.IODPR	;BUT MODE IS DUMP
	MOVEM	T2,I.MOD(T1)
	SETZM	I.BUF(T1)	;ZERO DATA WORDS
	SETZM	I.DVZ(T1)	; NOT REQUIRED
	SETZM	I.RNG(T1)
	MOVSI	T2,(Z TC,)	;CHAN
	MOVEM	T2,I.CHN(T1)
	SETZM	I.SWT(T1)
	MOVEI	T1,TC		;CHAN#
	MOVEM	T1,IO.CHN	;OF NEXT LOOKUP
	PUSHJ	P,DVCHK.##	;MAKE SURE ITS A DSK
	MOVE	T1,IO.CHR	;GET IT
	TXNN	T1,DV.DSK
	JRST	LKPERR##	;WILL DO FOR NOW
	PUSHJ	P,DVOPN.##	;OPEN DEVICE
	LOOKUP	TC,I.RIB(T1)
	  JRST	LKPERR##	;FAILED
	MOVEI	T2,1000		;BUFFER OF ONE PAGE
	PUSHJ	P,DY.GET##
	MOVE	R2,T1		;SAVE ADDRESS
T776A:	MOVE	T1,R3		;NO. OF WORDS LEFT
	IDIVI	T1,1000		;NO. OF PAGES
	LSH	T1,2		;4 BLOCKS PER PAGE
	USETI	TC,1(T1)	;SET ON START
	SKIPN	T2		;ONLY FIRST TIME
	MOVEI	T2,1000		;OTHERWISE USE PAGE
	SUBI	R3,(T2)		;REDUCE WHATS LEFT
	MOVE	R1,T2		;NO.
	MOVN	T1,T2		;-
	HRLZ	T1,T1		;IOWD
	HRRI	T1,-1(R2)
	SETZ	T2,		;END OF IT
	IN	TC,T1		;READ IN
	  CAIA
	HALT
	ADDI	R2,-2(R1)	;POINT TO END
	LSH	R1,-1		;COUNT IN PAIRS
	SKIPN	R3		;LAST IS SPECIAL
	SUBI	R1,1		;SO DON'T LOAD HEADER WORDS
T776B:	DMOVE	W2,0(R2)	;GET SYMBOL PAIR
	LDB	P1,[POINT 4,W2,3]	;TYPE CODE
	PUSHJ	P,R50T6		;SIXBITIZE
	JUMPE	P1,T776T	;TITLE BLOCK
	MOVSI	W1,PT.SGN!PT.SYM
	.JDDT	LNKOLD,T776B,<<CAMN	W2,$SYMBOL>>
	PUSHJ	P,@T.2TAB(P1)	;DO RIGHT THING FOR SYMBOL
T776C:	SUBI	R2,2		;BYPASS SYMBOL PAIR
	SOJG	R1,T776B	;MORE FOR THIS BLOCK?
	JUMPG	R3,T776A	;NO, BUT MORE BLOCKS
	MOVEI	T1,-1(R2)	;BACKUP TO  START OF BLOCK
	MOVEI	T2,1000		;SIZE
	PUSHJ	P,DY.RET##
	PUSHJ	P,DVZAP.##	;RETURN TC BLOCK
	JRST	EOF1##		;END OF SYMBOL FILE

T776T:	AOS	RSYM		;ONE MORE ITEM FOR HEADER
	AOS	PRGNO		;ONE MORE PROGRAM NAME
	.JDDT	LNKOLD,T776T,<<CAMN	W2,$NAME>>
	MOVSI	W1,PT.SGN!PT.TTL	;SET FLAGS
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL SYMBOL TABLE
	SETZM	LSTSYM		;NOT A REAL SYMBOL SO CLEAR POINTER
	MOVSI	W1,S.TTL!S.SEG	;LOW/HIGH REL COUNTERS
	SETZB	W2,W3		;SET BOTH ZERO
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.CRE	;GET DATE TIME STUFF
	LDB	W2,[POINT 12,FCRE,35]	;GET LOW 12 BITS OF DATE
	LDB	W3,[POINT 3,FEXT,20]	;GET HIGH 3 BITS
	DPB	W3,[POINT 3,W2,23]	;MERGE THE TWO PARTS
	LDB	W3,[POINT 11,FCRE,23]	;GET TIME
	HRL	W2,W3		;INTO LEFT HALF
	SETO	W3,		;LINK-10 DID CREATION
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.DEV	;DEV & UFD
	MOVE	W2,FSTR		;DEV
	SKIPN	W3,UFDPPN	;UFD
	JRST	.+3		;NO
	TLNN	W3,-1		;FOUND ONE
	MOVE	W3,SFDDIR	;UNLESS FULL PATH
	PUSHJ	P,LS.ADD

	MOVSI	W1,S.TTL!S.NAM	;FILE NAME & EXT
	MOVE	W2,FNAM		;NAME
	HLLZ	W3,FEXT		;EXT
	PUSHJ	P,LS.ADD

	SKIPE	W3,UFDPPN	;WERE THERE SFD'S
	TLNE	W3,-1
	JRST	T776T2		;NO
	MOVEI	R,SFDDIR+1	;POINT TO SFD
T776T1:	MOVSI	W1,S.TTL!S.SFD	;YES, SIGNAL SFD SEEN
	DMOVE	W2,(R)		;GET SFD
	JUMPE	W2,T776T2	;END IF 0
	PUSHJ	P,LS.ADD	;OUTPUT IT
	ADDI	R,2
	JUMPN	W3,T776T1	;AND CONTINUE

T776T2:	JRST	T776C
SUBTTL	RELOCATION AND BLOCK INPUT - OLD BLOCKS
;ENTER WITH WC = WORD COUNT IN AOBJN FORM
;LEFT HALF NEGATIVE NUMBER OF WORDS LEFT IN BLOCK
;RIGHT HALF NEGATIVE NUMBER OF WORDS IN CURRENT SUB-BLOCK
;RB = BYTE WORD UNLESS END OF SUB-BLOCK, IN WHICH CASE RB WILL BE SET UP

;READS TWO WORDS USING RB.1
;RETURNS FIRST WORD IN W2, SECOND WORD IN W1
RB.2::	PUSHJ	P,RB.1		;READ FIRST WORD OF PAIR
	  POPJ	P,		;ERROR RETURN
	MOVE	W2,W1		;SAVE IT IN W2
	TRNE	WC,377777	;SEE IF SECOND WORD EXISTS
	JRST	RWORD1		;INPUT SECOND WORD OF PAIR AND RETURN
	SETZ	W1, 		;NO,RETURN ZERO
	JRST	CPOPJ1		;BUT GIVE SKIP RETURN

;RETURN WITH R = POINTER TO RELOCATION BLOCK
;W1 = WORD READ FROM BINARY FILE
;ALSO USES T1

RB.1::	TRNN	WC,377777	;TEST FOR END OF BLOCK
	POPJ	P,		;NON-SKIP RETURN
RWORD1:	AOBJN	WC,RWORD2	;JUMP IF NOT CONTROL WORD
	PUSHJ	P,D.IN1##	;GET 1 WORD
	MOVE	RB,W1		;SAVE RELOCATION BITS
	HRLI	WC,-^D18	;RESET WORD COUNT
RWORD2:	PUSHJ	P,D.IN1##	;READ 1 WORD
	SETZ	R,		;CLEAR OLD RELOCATION BITS
	LSHC	R,1		;GET NEXT
	JUMPE	R,RWORD3	;NO RELOCATION REQUIRED
	HLRZ	T1,W1		;GET UNRELOCATED ADDRESS
	TRNN	FL,R.TWSG	;POSSIBLE TWO SEGMENTS?
	JRST	RWORD5		;NO
	MOVE	T2,SO.S2	;GET START OF HIGH SEGMENT
	CAILE	T2,NEGOFF(T1)	;IN HIGH SEG?
	JRST	RWORD5		;NO
	ADDI	R,1		;YES, INC SEG POINTER
	SUB	T1,T2		;REMOVE BASE ADDRESS
RWORD5:	MOVE	R,@RC.TB	;PICKUP POINTER TO DATA BLOCK
	MOVE	T2,RC.CV(R)	;GET CURRENT VALUE
	SUB	T2,RC.IV(R)	;REMOVE BASE ADDRESS
	ADDI	T1,0(T2)	;GET RELOCATED VALUE
	MOVE	T2,RC.SG(R)	;GET SEGMENT #
	ADD	T1,LL.S0(T2)	;MAKE RELATIVE TO SEG ORIGIN
	HRL	W1,T1		;AND REPLACE IT
	MOVSI	R,(1B2)		;CLEAR R BUT REMEMBER RELOCATABLE
				;INCASE RH SIDE NOT (FOR SYMBOL)
RWORD3:	LSHC	R,1		;GET RIGHT RELOCATION
	TRNN	R,-1		;SEE IF RELOCATABLE
	JRST	CPOPJ1		;NOT RELOCATED
	HRRZ	T1,W1		;GET UNRELOCATED ADDRESS
	TRNN	FL,R.TWSG	;POSSIBLE TWO SEGMENTS?
	JRST	RWORD6		;NO
	MOVE	T2,SO.S2	;GET START OF HIGH SEGMENT
	CAILE	T2,NEGOFF(T1)	;IN HIGH SEG?
	JRST	RWORD6		;NO
	ADDI	R,1		;YES, INC SEG POINTER
	SUB	T1,T2		;REMOVE BASE ADDRESS
RWORD6:	HRR	R,@RC.TB	;PICKUP POINTER TO DATA BLOCK
	TLO	R,(1B1)		;MARK RELOCATION
	MOVE	T2,RC.CV(R)	;GET CURRENT VALUE
	SUB	T2,RC.IV(R)	;REMOVE BASE ADDRESS
	ADDI	T1,0(T2)	;GET RELOCATED VALUE
	MOVE	T2,RC.SG(R)	;GET SEGMENT #
	ADD	T1,LL.S0(T2)	;MAKE RELATIVE TO SEG ORIGIN
	HRR	W1,T1		;AND REPLACE IT
CPOPJ1:	AOS	(P)		;SKIP RETURN
CPOPJ:	POPJ	P,

;CHKSEG - ROUTINE TO SEE IF ADDRESS IS REQUIRED OR NOT
;ENTER WITH ADDRESS IN W1
;RETURNS
;+1	REQUIRED
;+2	NOT REQUIRED

CHKSEG:	TRNN	FL,R.TWSG	;MUST BE A TWO SEGMENT PROGRAM
	POPJ	P,
	SKIPE	LL.S2		;AND MUST HAVE SETUP HIGH SEG
	CAMGE	W1,LL.S2	;IN HIGH
	JRST	[TRNN	FL,R.LSO	;WANT LOW?
		AOS	(P)		;NO
		POPJ	P,]
	TRNN	FL,R.HSO	;WANT HIGH?
	AOS	(P)		;NO
	POPJ	P,


ILIERR:	.ERR.	(MS,.EC,V%L,L%F,S%F,LIT)
	.ETC.	(OCT,.EC!.EP,,,,T1)
	.ETC.	(STR,.EC,,,,,< too  short for >)
	.ETC.	(FSP,,,,,DC)

IFN DEBSW,<
$NAME:	.-.		;CHANGE TO REQUIRED SIXBIT PROG NAME
>

OLDLIT:
END

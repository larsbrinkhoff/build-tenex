TITLE	LNKWLD - SWITCH HANDLER & INTERFACE  TO WILD FOR LINK-10
SUBTTL	D.M.NIXON/DMN		8-JUL-74


;***COPYRIGHT 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKWLD
SEARCH	LNKPAR,LNKLOW,C,SCNMAC
EXTERN	LNKFIO,LNKCOR,LNKLOG,LNKMAP

;COMMUNICATION WITH WILD

;INTERN	.TNEWL
;EXTERN	.LKWLD,.NXDTW,E.DFO,.LKERR,.WLDFL

CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==216		;DEC EDIT VERSION



;CALLING SEQUENCE
;PUSHJ P,LNKWLD

;RETURN
;END OF LIST NOTHING LEFT
;ALL I/O SETUP SO SOSGE LOOP WILL GET DATA

;CALLS LNKFIO TO TAKE CARE OF ALL OUTPUT FILE I/O
;OUTPUT FILES MUST BE FIRST IN LIST

;ALSO HANDLES ALL SWITCHES

SEGMENT
SALL

SUBTTL	REVISION HISTORY

;START OF VERSION 1A
;41	ADD LNKFSI MESSAGE
;45	HASH INITIAL SYMBOLS AT ASSEMBLY TIME
;46	ADD KLUDGE FEATURE
;52	ADD ASCII TEXT BLOCK
;54	ADD KIONLY D.P. INST
;60	ADD /VERSION SWITCH
;63	ADD EXTERNAL START ADDRESS IN BLOCK TYPE 7
;65	TENEX SPEEDUPS
;71	MAKE ALL MESSAGES STANDARD FORM
;74	(11389) FIX ILL MEM REF ON FILE/SYSLIB
;103	RESTORE BOTH HALVES OF FL AFTER EDITED LOOKUP ERROR
;105	MAKE BLOCK TYPE 12 WORK
;106	REMOVE HIORG, REPLACE WITH EITHER LL.S2 OR SO.S2
;107	REPLACE KLUDGE BY MIXFOR
;110	ILL MEM REF ON /BASKSPACE:1
;114	MAKE /LOG WORK IF DEVICE NOT 'LOG' OR TTY
;115	MAKE /NOSYMBOLS WORK CORRECTLY
;120	/SYMSEG:HIGH WITH NO HIGH CODE GIVES ILL MEM REF

;START OF VERSION 1B
;122	(11940) ADD COPYP1 TO HANDLE /M/SSA=PROG
;124	ADD /ONLY SWITCH
;132	(12304) FIX TO EDIT 122

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;137	ADD SUPPORT FOR PLOT PACKAGE
;141	TURN ON AND FIX BUGS IN ASCII TEXT BLOCKS
;145	IMPLEMENT /USERLIB & /NOUSERLIB SWITCHES
;153	FIX BUG IN EDITS 122 AND 132
;156	MAKE FOO/DEBUG WORK RIGHT
;161	ADD LANGUAGE SPECIFICATION TO /USERLIB
;167	CHANGE ARGUMENTS TO /OTSEGMENT
;170	MAKE PLOT SWITCH WORK
;201	MAKE FORDDT WORK
;216	(13559) ADD ZSV ERROR CHECK AND MESSAGE
SUBTTL	ENTER HERE  FROM LNKLOD TO GET A FILE TO LOAD

LNKWLD:	SETZM	NULSPC		;CLEAR NULL FILE SPEC FLAG
	SKIPE	P1,F.EDIT	;DID WE JUST DO AN EDIT CORRECTION?
	JRST	MERGE		;YES, BUILD THE TRUE FILE SPEC
IFN .ASBLK,<
	SKIPE	F.ASCI		;READING INCORE TEXT?
	JRST	ASCMRG		;YES
>
	SKIPE	SWFLAG		;CHECK FOR DEFERED SWITCHES FROM LAST FILE
	PUSHJ	P,DEFLSW	;YES, GO DO THEM FIRST
	SKIPE	P1,F.INZR	;GET NEXT FILE SPEC
	JRST	NXTSPC		;YES THERE IS ONE
	SKIPE	GOTO		;NO, BUT SHOULD WE TERMINATE
	JRST	@GOTO		;YES, DO FINAL DEFAULTS ETC.
	JRST	URET		;NO, RETURN TO USER

;HERE TO LOOK FOR SWITCHES
NXTSPC:	HLRZ	P2,F.SWP(P1)	;GET LIST OF GLOBAL SWITCHES
	JUMPE	P2,.+3		;NONE THERE
	PUSHJ	P,XCTGSW	;DO SWITCH
	MOVE	P1,F.INZR	;RELOAD P1
	HRRZ	P2,F.SWP(P1)	;GET LIST OF LOCAL SWITCHES
	JUMPE	P2,.+3		;NONE
	PUSHJ	P,XCTLSW	;DO SWITCH
	MOVE	P1,F.INZR	;RELODE P1 AGAIN
IFN .ASBLK,<
	SKIPE	F.ASCI		;READING INCORE TEXT?
	JRST	ASCRET##	;YES, FINISH IT
>
	SKIPN	NULSPC		;NULL FILE SPEC (SWITCHES ONLY)
	JRST	DEFILL		;NO, REAL FILE SPEC HERE
NOTSPC:	PUSHJ	P,RETFSP	;JUST A DUMMY DATA BLOCK
	  JFCL			;INCASE NON-SKIP RETURN
	JRST	LNKWLD		;INCASE ANY DEFERED SWITCHES

;HERE TO FILL IN DEFAULTS FOR INPUT DEVICE
DEFILL:	MOVE	T3,F.MOD(P1)	;GET MODIFIER WORD
	MOVE	T2,G.DEV	;GET DEFAULT DEVICE
	SKIPE	F.DEV(P1)	;NOT EVEN A FILE SPEC?
	TXNE	T3,FX.NDV	;TEST FOR NO DEVICE SPECIFIED
	MOVEM	T2,F.DEV(P1)
	MOVE	T2,G.NAM	;DEFAULT FILE NAME
	SKIPN	F.NAME(P1)
	MOVEM	T2,F.NAME(P1)
	MOVE	T2,G.EXT	;DEFAULT EXTENSION
	SKIPN	F.EXT(P1)	;EXT SPECIFIED?
	TXNN	T3,FX.NUL	;ONLY REPLACE NULL EXT
	CAIA			;NO IF 0 OR IF GIVEN
	MOVEM	T2,F.EXT(P1)
	MOVE	T1,F.DIR(P1)	;GET SPECIFIED [PPN]
	MOVE	T2,G.DIR	;AND DEFAULT [PPN]
	TXNN	T3,FX.DIR	;SKIP IF DIRECTORY SPECIFIED
	JRST	DEFDIR		;FILL IN FULL DEFAULT DIRECTORY
	TLNN	T2,-1		;IS DEFAULT SPECIFIED?
	HLL	T2,MYPPN	;NO, FILL IN WHAT'S MISSING
	TRNN	T2,-1
	HRR	T2,MYPPN	;SO WE DON'T GET A ZERO LEFT
	TLNN	T1,-1		;PROJ GIVEN?
	HLLM	T2,F.DIR(P1)	;NO, USE DEFAULT
	TRNN	T1,-1		;PROG?
	HRRM	T2,F.DIR(P1)	;NO
	JRST	LDDS

DEFDIR:	JUMPE	T2,LDDS		;NO DEFAULT
	MOVE	T3,F.MODM(P1)	;GET MOD MASK
	TXNE	T3,FX.DIR	;TEST FOR [-]
	JRST	LDDS		;YES, LEAVE DIR ALONE AS ZERO
	HRLI	T2,G.DIR	;FORM BYTE POINTER
	HRRI	T2,F.DIR(P1)
	BLT	T2,F.DIR+2*.FXLND-1(P1)

;HERE TO GET DEVICE AND DO OPEN IF DEVICE DIFFERENT FROM LAST ONE
LDDS:	MOVEI	T2,DC		;GET DATA CHAN
	CAME	T2,IO.CHN	;SAME AS CURRENT?
	SETZM	IO.CHR		;NO, SO DEVCHR MUST BE INVALID
	MOVEM	T2,IO.CHN	;INCASE DEFERED SWITCHES
	MOVE	T2,F.DEV(P1)	;GET DEVICE
	EXCH	T2,FSTR		;MAKE SURE NEW STORED INCASE OF ERROR
	CAMN	T2,FSTR		;SAME AS PREV DEVICE?
	JRST	LDFS		;YES, BYPASS INIT
	SETZM	FILNUM		;START AGAIN ON NEW DEVICE
	PUSHJ	P,DVCHK.##	;SEE IF DEVICE EXISTS AND CAN SUPPORT MODE
	PUSHJ	P,DVOPN.##	;DO OPEN
LDFS:	SKIPN	IO.CHR		;VALID DEVCHR YET?
	PUSHJ	P,DVCHK.##	;NO, GET IT INCASE NULL FILE NAME
	SKIPE	F.NAME(P1)	;IF NO NAME GIVEN?
	JRST	LDFS1		;OK IT WAS
	MOVE	T2,IO.CHR	;GET DEVCHR BIT
	TXNE	T2,DV.DIR	;IF NON-DIRECTORY DEVICE
	JRST	NOTSPC		;NO, SO NOT A FILE SPEC
	AOS	T1,FILNUM	;GET FILE NUMBER
	SETZ	T3,		;RECEIVE IT HERE
	IDIVI	T1,^D10
	ADDI	T2,"0"		;DIGITIZE
	LSHC	T2,-6		;SHIFT IN
	JUMPN	T1,.-4		;UNTIL ALL DONE
	MOVEM	T3,F.NAME(P1)	;SO WE KNOW WHICH FILE IF ERROR
LDFS1:	PUSHJ	P,DVINP.##	;BUILD INPUT SPEC
	PUSHJ	P,DVLKP.##	;AND LOOKUP
	JRST	RETFSP		;RETURN SPACE


REPEAT 0,<
DSKLP:	MOVE	T1,.LKBLK	;DATA FOR WILD
	PUSHJ	P,.LKWLD	;CALL WILD
	  JFCL

.LKBLK:	4,,.+1			;WILD
	F.WLZR,,0
	OPENBL,,LBLOCK
	F.SLEN,,LN.RIB+1
	DC,,0

.TNEWL:	POPJ	P,		;JUST RETURN
>;END OF REPEAT 0
;HERE TO MERGE NEW FILE SPEC WITH PREVIOUS ONE

MERGE:	HLRZ	T1,P1		;GET POINTER TO FLAGS
	MOVE	FL,(T1)		;RESTORE THEM AS THEY WERE
	MOVEI	T2,1		;GIVE BACK SPACE
	PUSHJ	P,DY.RET##
	MOVE	P2,F.INZR	;GET NEW SPEC
	MOVE	T4,F.MOD(P2)	;GET MODIFIER WORD
	MOVE	T1,F.DEV(P1)	;GET OLD DEVICE
	TXNE	T4,FX.NDV	;USER SUPPLIED NEW?
	MOVEM	T1,F.DEV(P2)	;NO, USE PREVIOUS
	SKIPE	F.NAME(P2)	;NEW NAME SUPPLIED?
	JRST	MERGE0		;YES, USE IT
	DGET	T1,F.NAME(P1),F.NAMM(P1)	;NO, USE PREVIOUS & MASK
	DSTORE	T1,F.NAME(P2),F.NAMM(P2)
MERGE0:	MOVE	T1,F.EXT(P1)
	MOVE	T2,F.MOD(P1)	;GET OLD MOD WORD
	TXNE	T2,FX.NUL	;WAS OLD EXT VALID?
	JRST	.+3		;NO, USE NEW ALWAYS
	TXZE	T4,FX.NUL	;SEE IF USER SUPPLIED NEW EXT
	MOVEM	T1,F.EXT(P2)
	TXNN	T4,FX.DIR	;NEW DIRECTORY?
	JRST	[MOVE	T3,F.MODM(P2)	;NO, BUT CHECK FOR [-]
		TXNE	T3,FX.DIR	;WILL BE SET IF SO
		JRST	MERGE1		;YES, SO LEAVE PPN = 0
		HRLZI	T1,F.DIR(P1)	;NO, USE OLD PPN
		HRRI	T1,F.DIR(P2)
		BLT	T1,F.LEN-1(P2)	;COPY SFDS ALSO
		JRST	MERGE1]
	MOVE	T1,F.DIR(P1)	;GET PREVIOUS PPN
	MOVE	T2,F.DIRM(P2)	;AND THIS MASK
	TLNN	T2,-1		;PROJ SPECIFIED?
	HLLM	T1,F.DIR(P2)	;NO, USE PREV
	TRNN	T2,-1		;PROG SPECIFIED?
	HRRM	T1,F.DIR(P2)	;NO
				;** SFDS ** MUST BE RESPECIFIED
MERGE1:	MOVEM	T4,F.MOD(P2)	;STORE MODIFIED MOD WORD
	MOVE	T2,P2		;USER MAY HAVE SUPPLIED EXTRA FILE SPECS
	SKIPN	F.NXT(T2)	;SO LOOK FOR END (0)
	JRST	.+3		;GOT IT
	MOVE	T2,F.NXT(T2)	;NOT YET
	JRST	.-3
	MOVE	T1,F.NXT(P1)	;GET NEXT FILE SPEC
	MOVEM	T1,F.NXT(T2)	;LINK IN CHAIN
				;NOW FOR SWITCHES
				;LINK OLD SWITCHES IN FIRST SO NEW ONES CAN
				;TURN THEM OFF
	HLRZ	T1,F.SWP(P1)	;GET POINTER
	JUMPE	T1,MERGE2	;NONE
	HRRZ	T2,0(T1)	;GET POINTER TO NEXT
	JUMPE	T2,.+3		;GOT LAST
	MOVE	T1,T2		;NO
	JRST	.-3		;KEEP TRYING
	HLLZ	T2,F.SWP(P2)	;GET FIRST NEW SWITCH
	HLLM	T2,0(T1)	;LINK IN
	HLLZ	T1,F.SWP(P1)	;GET START OF CHAIN
	HLLM	T1,F.SWP(P2)	;POINT TO NEW CHAINED LIST
MERGE2:				;NOW FOR AFTER SWITCHES
	HRRZ	T1,F.SWP(P1)	;GET POINTER
	JUMPE	T1,MERGE3	;NONE
	HRRZ	T2,0(T1)	;GET POINTER TO NEXT
	JUMPE	T2,.+3		;GOT LAST
	MOVE	T1,T2		;NO
	JRST	.-3		;KEEP TRYING
	HRRZ	T2,F.SWP(P2)	;GET FIRST NEW SWITCH
	HRRM	T2,0(T1)	;LINK IN
	HRRZ	T1,F.SWP(P1)	;GET START OF CHAIN
	HRRM	T1,F.SWP(P2)	;POINT TO NEW CHAINED LIST
MERGE3:	MOVEI	T1,0(P1)	;NOW REMOVE OLD
	MOVEI	T2,F.LEN
	PUSHJ	P,DY.RET##
	SETZM	F.EDIT		;SO WE DON'T LOOP
	JRST	LNKWLD		;NOW TRY IT
SUBTTL	HERE FOR ASCII TEXT BLOCK

;ENTER HERE TO MERGE ASCII TEXT BLOCK WITH CURRENT COMMAND TREE
;THERE ARE TWO POSSIBILITIES
;IF THE FIRST BLOCK HAS NO FILE SPEC, THEN THE SWITCHES APPLY TO
;THE CURRENT FILE BEING LOADED AS IF THEY HAD BEEN TYPED AFTER
;THE FILE NAME IN THE COMMAND LINE
;IF A FILE SPEC IS SEEN THEN THE NEW TREE IS ADDED TO THE IN CORE
;ONE AFTER THE CURRENT FILE, THE GLOBAL SWITCHES OF THIS  DO NOT
;APPLY TO THE CURRENT FILE BEING LOADED

IFN .ASBLK,<
ASCMRG:	SKIPE	P1,F.INZR	;ANYTHING TO DO
	SKIPE	F.NAME(P1)	;ANY SWITCHES FOR THIS FILE?
	JRST	ASCRET##	;NO, RETURN TO FIXUP LISTS AND STACK
	MOVSS	F.SWP(P1)	;FIRST MAKE THE SWITCHES LOCAL
	JRST	NXTSPC		;YES, DO THEM NOW

>;END IFN .ASBLK
;HERE TO RETURN FILE SPACE TO POOL
;CALLS DY.RET WITH
;T1 = ADDRESS 
;T2 = LENGTH
RETFSP:	MOVE	T2,F.NXT(P1)	;GET NEXT BLOCK
	MOVEM	T2,F.INZR	;ADVANCE POINTER
	HRRZ	T1,P1		;SET ADDRESS
	MOVEI	T2,F.LEN	;SET LENGTH
	PUSHJ	P,DY.RET##	;GIVE BACK SPACE

;HERE TO HANDLE DEFERED SWITCHES
;SWITCHES ARE LINKED TO SWFLAG
;SKIP RETURNS ALWAYS

DEFGSW:	HLRZ	P2,SWFLAG	;GET SWITCHES BEFORE FILE NAME FIRST
	JUMPE	P2,CPOPJ1	;NONE, GIVE UP FOR NOW
	HRRZ	T1,(P2)		;GET NEXT ADDRESS
	HRLM	T1,SWFLAG	;REMOVE FROM LIST
	MOVE	T2,2(P2)	;GET VALUE
	PUSHJ	P,@1(P2)	;RETURN TO SWITCH ACTION
	HRRZ	T1,P2		;ADDRESS OF SWITCH BLOCK
	HLRZ	T2,(P2)		;SIZE
	PUSHJ	P,DY.RET##	;RESTORE SPACE TO POOL
	JRST	DEFGSW		;SEE IF ANY MORE

;HERE FOR DEFERED SWITCHES AFTER FILE NAME
;THEY GET EXECUTED JUST BEFORE NEXT FILE SPEC IS FOUND

DEFLSW:	HRRZ	P2,SWFLAG	;GET SWITCHES AFTER FILE NAME
	JUMPE	P2,CPOPJ	;NONE, GIVE UP
	HRRZ	T1,(P2)		;GET NEXT ADDRESS
	HRRM	T1,SWFLAG	;REMOVE FROM LIST
	MOVE	T2,2(P2)	;GET VALUE
	PUSHJ	P,@1(P2)	;RETURN TO SWITCH ACTION
	HRRZ	T1,P2		;ADDRESS OF SWITCH BLOCK
	HLRZ	T2,(P2)		;SIZE
	PUSHJ	P,DY.RET##	;RESTORE SPACE TO POOL
	JRST	DEFLSW		;SEE IF ANY MORE

;HERE TO GIVE GOOD RETURN ALL DONE WITH LNKFIO FOR NOW
URET1:	AOS	(P)		;SKIP RETURN
URET:	MOVE	T1,MAPSW	;SEE IF A MAP TO DO
	CAIN	T1,$MAPNOW	;ONLY CASE WE CARE ABOUT
	PJRST	LNKMAP		;YES
	POPJ	P,

;USUAL RETURN SEQUENCE
CPOPJ1:	AOS	(P)	;SKIP RETURN
CPOPJ:	POPJ	P,

;HERE TO HANDLE SWITCHES

;GLOBAL SWITCHES (LHS)
XCTGSW:	DMOVE	T1,1(P2)	;GET TOKEN # & VALUE
	HLRZ	T1,XCTSWT(T1)	;GET JUMP ADDRESS
	PUSHJ	P,(T1)		;DO SWITCH ACTION
	HRRZ	T1,P2		;SETUP ADDRESS OF THIS SWITCH
	HLRZ	T2,(P2)		;AND SIZE
	HRRZ	P2,(P2)		;GET NEXT SWITCH
	PUSHJ	P,DY.RET##	;RETURN SPACE
	HRLM	P2,F.SWP(P1)	;POINT TO NEW LINK (IN CASE REQUIRED)
	JUMPN	P2,XCTGSW	;XCT THIS SWITCH
	POPJ	P,		;RETURN END OF GLOBAL SWITCH CHAIN



;LOCAL SWITCHES (RHS)

XCTLSW:	DMOVE	T1,1(P2)	;GET TOKEN # & VALUE
	HRRZ	T1,XCTSWT(T1)	;GET JUMP ADDRESS
	PUSHJ	P,(T1)		;DO SWITCH ACTION
	HRRZ	T1,P2		;SETUP ADDRESS OF THIS SWITCH
	HLRZ	T2,(P2)		;AND SIZE
	HRRZ	P2,(P2)		;GET NEXT SWITCH
	PUSHJ	P,DY.RET##	;RETURN SPACE
	HRRM	P2,F.SWP(P1)	;POINT TO NEW SWITCH
	JUMPN	P2,XCTLSW	;XCT THIS SWITCH
	POPJ	P,		;RETURN END OF GLOBAL SWITCH CHAIN




;HERE TO STORE SWITCHES THAT CAN NOT BE EXECUTED UNTIL FILE IS OPENED
;THE SWITCHES ARE STORED IN LINKED LISTS ANCHORED TO SWFLAG
;SWITCHES BEFORE FILE NAME ARE IN LEFT HALF
;SWITCHES AFTER FILE NAME IN RIGHT HALF

STRGSW:	POP	P,1(P2)		;STORE RETURN OVER TOKEN #
	POP	P,T1		;REMOVE RETURN ADDRESS
	MOVEI	T2,SWFLAG	;START OF LIST
	MOVE	T1,T2		;SAVE LAST ADDRESS
	HLRZ	T2,(T1)		;GET FIRST LINK ADDRESS
	JUMPE	T2,[HRLM P2,(T1)	;LINK FIRST ONE TO LEFT HALF
		JRST	STRGS1]		;REST TO RIGHT HALF
	MOVE	T1,T2		;SAVE LAST
	HRRZ	T2,(T1)		;REST OF ADDRESS FROM RIGHT HALH
	JUMPN	T2,.-2		;LOOK FOR END OF LIST
	HRRM	P2,(T1)		;LINK THIS BLOCK IN
STRGS1:	MOVE	T1,P2		;SAVE ADDRESS
	HRRZ	P2,(P2)		;GET NEXT SWITCH BLOCK
	HLLZS	(T1)		;SET END OF CHAIN
	JUMPN	P2,XCTGSW	;HANDLE THIS ONE
	POPJ	P,		;END OF GLOBAL SWITCHES

;HERE FOR SWITCHES AFTER FILE NAME

STRLSW::POP	P,1(P2)		;STORE RETURN OVER TOKEN #
	POP	P,T1		;REMOVE RETURN ADDRESS
	MOVEI	T2,SWFLAG	;START OF LIST
	MOVE	T1,T2		;SAVE LAST ADDRESS
	HRRZ	T2,(T1)		;GET LINK ADDRESS
	JUMPN	T2,.-2		;LOOK FOR END OF LIST
	HRRM	P2,(T1)		;LINK THIS BLOCK IN
	MOVE	T1,P2		;SAVE ADDRESS
	HRRZ	P2,(P2)		;GET NEXT SWITCH BLOCK
	HLLZS	(T1)		;SET END OF CHAIN
	JUMPN	P2,XCTLSW	;HANDLE THIS ONE
	POPJ	P,		;END OF GLOBAL SWITCHES


SUBTTL	DISPATCH TABLE FOR SWITCHES

;XCTSWT IS A TABLE OF DISPATCH ADDRESSES FOR SWITCHES
;ONE WORD PER TOKEN #
;LHS=GLOBAL , RHS=LOCAL

DEFINE SWMAC (A,B,C,D,E,F,G,H,I)<
 IF1,<BLOCK 1>
 IF2,<
  IFNDEF %'B,<EXTERN %'B>
  IFNB <G>,<
   IFNDEF .'B,<EXTERN .'B>
   XWD	.'B,%'B
  >
  IFB  <G>,<
   XWD	%'B,%'B
>>>
;***** MUST USE XWD NOT ,, SINCE ".COMMON" IS A PSEUDO-OP IN MACRO.50
EXTERN	.REQUEST		;SO IS .REQUEST
XCTSWT:	SWTCHS

SUBTTL SWITCH ACTION

%COMNM:	SIXBIT	\DEFINED-BY-SWITCH\	;AVOID FORWARD REFERENCE AT DMOVE

%COMMON:
	PUSHJ	P,STRLSW	;WAIT TIL FILE IS LOADED
.COMMON:
	PUSHJ	P,.SAVE4##	;PRESERVE P1-P4
	SKIPN	W2,T2		;SYMBOL
	MOVE	W2,['.COMM.']	;BLANK COMMON IF NULL
	MOVS	W3,3(P2)	;LENGTH OF COMMON
	PUSHJ	P,T.COMR##	;STORE IN GLOBAL TABLE
	  POPJ	P,		;WAS ALREADY THERE
	MOVSI	W1,PT.SGN!PT.EXT!PT.TTL!PT.FAK
	MOVE	W2,%COMNM	;FIRST 6 CHARS
	MOVE	W3,LSYM		;POINT TO WHERE FIRST TRIPLET WILL GO
	ADDI	W3,4*.L		;THEN TO LAST
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL TABLE
	MOVSI	W1,S.TTL!S.LST	;EXTENDED TITLE
	DMOVE	W2,%COMNM+1	;REST OF NAME
	PUSHJ	P,LS.ADD##
	HRRZ	P1,@HT.PTR	;SETUP P1 TO POINT TO SYMBOL
	ADD	P1,NAMLOC	;IN CORE
	PUSH	P,.L+2(P1)	;SAVE 2ND TRIPLET INFO
	PUSH	P,.L+1(P1)
	PUSH	P,.L+0(P1)
	TMOVE	W1,0(P1)	;RESET FIRST  SYMBOL TRIPLET
	PUSHJ	P,LS.ADD##	;PUT IN LOCAL TABLE
	POP	P,W1		;GET SECONDARY
	POP	P,W2		;SAME NAME
	POP	P,W3		;LENGTH
	MOVE	T1,SG.TB+1	;GET LOW SEG RELOC TABLE
	ADDM	W3,RC.CV(T1)	;BUMP CURRENT RC
	PJRST	LS.ADD##	;STORE AND RETURN

%CORE:
	CAIG	T2,^D256	;IN WORDS ALREADY?
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;GET HIGHEST ADD
	CAMLE	T2,.JBREL	;NEVER DECREASE
	CORE	T2,		;EXPAND
	  POPJ	P,		;FAILED, TOO BAD
	.ERR.	(MS,.EC,V%L,L%I,S%I,EXP)
	.ETC.	(COR,.EP,,,,.JBREL)
	MOVE	T2,.JBREL	;NEW TOP OF CORE
	MOVEI	T1,HG.TAB	;START AT TOP
	SKIPN	TAB.LB(T1)	;AND FIND AREA IN USE
	SOJA	T1,.-1		;WILL FIND ONE EVENTUALLY
	MOVEM	T2,TAB.UB(T1)	;GIVE TOP AREA ALL FREE SPACE
	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	SETZB	P1,P2		;INDICATE JUST SHUFFLING
	PUSHJ	P,LNKCOR##	;NOW ADJUST ALL AREAS
	  JFCL			;NEVER FAILS
	POPJ	P,		;RETURN


%COUNTER:
	PUSHJ	P,STRLSW	;WAIT TIL FILE LOADED
.COUNTER:
	SETZ	T1,
	PUSHJ	P,.TYOCH##	;ONLY ON TTY
	PUSH	P,T1		;SAVE IT
	MOVEI	R1,1		;START AT 1 (COUNTER .LOW.)
	MOVEI	T1,[ASCIZ \[LNKRLC Reloc. CTR.	initial value	current value (octal)]
\]
	PUSHJ	P,.TSTRG##	;OUTPUT HEADER
COUNT1:	SKIPN	R2,@RC.TB	;SEE IF ANYTHING THERE?
	JRST	COUNT3		;NO
	PUSHJ	P,.TTABC##
	MOVE	T1,RC.NM(R2)	;GET NAME
	PUSHJ	P,.TSIXN##	;YES
	PUSHJ	P,.TTABC##	;TAB TO SEPARATE
	PUSHJ	P,.TTABC##
COUNT2:	MOVE	T1,RC.IV(R2)	;INITIAL VALUE
	PUSHJ	P,.T6OCT##
	PUSHJ	P,.TTABC##
	PUSHJ	P,.TTABC##
	MOVE	T1,RC.CV(R2)	;CURRENT VALUE
	PUSHJ	P,.T6OCT##
	PUSHJ	P,.TCRLF##	;CLOSE LINE
	CAMGE	R1,RC.NO	;ALL DONE?
	AOJA	R1,COUNT1	;NO
COUNT3:	POP	P,T1		;GET BACK TYPE  OUT ROUTINE
	PJRST	.TYOCH##	;RETURN

%CPU:
	MOVE	T1,CPUTBL-1(T2)	;GET VALUE (KA10=0, KI10=1)
	MOVEM	T2,CPUTGT	;STORE TARGET CPU
	POPJ	P,

;HERE FOR /DEBUG

.DEBUG:
	MOVEM	T2,DEBUGSW	;SIGNAL DEBUG START AND STORE TYPE
	SETOM	EXECSW		;AND SIGNAL EXECUTION REQUIRED
.TEST:
	SOSN	T1,2(P2)	;NEED TO MAKE SPECIAL CASE CHECKS
	SKIPE	T1,DDEBUG	;TRY DEFAULT
	SUBI	T1,1		; FOR COBDDT AND FORDDT
	LSH	T1,-1		; SINCE THEY MUST BE LOADED AFTER THE
	MOVE	T1,DEBTBL(T1)	; MAIN PROGRAM
	CAME	T1,['FORDDT']
	CAMN	T1,['COBDDT']
	JRST	SPCDDT		;ITS A SPECIAL DDT
DEBUG1:	MOVEI	T2,F.LEN	;GET A BLOCK OF SPACE FOR FILE SPECS
	PUSHJ	P,DY.GET##	;IN DYNAMIC AREA
	HRRM	P1,(T1)		;LINK INTO LIST TO DO
	HRRM	T1,F.INZR	;PUT DEBUG FIRST
	HRLZ	T2,(P2)		;GET## NEXT SWITCH
	HLLM	T2,1(P1)	;FIX LIST OF SWITCHES TO DO
	MOVE	P1,T1		;FORGET OTHER FILE SPEC FOR NOW
	MOVSI	T1,'SYS'
	MOVEM	T1,F.DEV(P1)	;COMES FROM SYS
	SKIPN	T1,2(P2)	;GET TOKEN
	SKIPE	T1,DDEBUG	;TRY DEFAULT
	SUBI	T1,1
	LSH	T1,-1		;CUT IN HALF
	MOVE	T1,DEBTBL(T1)	;PICK UP REQUIRED PROG
	MOVEM	T1,F.NAME(P1)	;STORE NAME
	SETOM	F.NAMM(P1)	;AND MASK
	MOVSI	T1,'REL'	;ASSUME EXT 
	HLLOM	T1,F.EXT(P1)	;AND MASK
	SUB	P,[2,,2]	;ADJUST STACK
	MOVE	T1,P2		;ADDRESS OF SWITCH BLOCK
	HLRZ	T2,(P2)		;SIZE
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	MOVSI	T1,L.SYM	;MAKE LOCAL SYMBOLS DEFAULT
	IORM	T1,FLAGS
	PUSHJ	P,.LOCALS	;TURN ON LOAD LOCAL SYMBOLS
	MOVE	T1,F.NAME(P1)	;SEE IF ITS FORDDT
	CAME	T1,['FORDDT']	;SINCE IT NEED ITS SYMBOLS
	PUSHJ	P,%NOLOCAL	;BUT NOT FOR THIS FILE
	TRZ	FL,R.LIB	;TURN OFF LIB SEARCH MODE
IFE FTENEX,<
	JRST	LNKWLD		;AND TRY AGAIN
>

SPCDDT:	SKIPN	MNTYPE		;HAVE WE LOADED A MAIN PROGRAM YET?
	SKIPN	F.NAME(P1)	; OR NO PROGRAM IN THIS SPEC
	JRST	DEBUG1		;YES, SO ITS OK TO LOAD ???DDT
	AOS	2(P2)		;PUT BACK TOKEN VALUE
	HRRZ	T1,(P2)		;GET NEXT SWITCH
	HRLM	T1,F.SWP(P1)	;INTO TABLE
	HRRZ	T1,F.SWP(P1)	;GET NEXT RHS SWITCH
	HRRM	T1,(P2)		;LINK IN
	HRRM	P2,F.SWP(P1)	;AND IN SWITCH LIST
	HLRZ	P2,F.SWP(P1)	;GET NEXT LHS SWITCH
	POP	P,T1		;GET RETURN OFF STACK
	JUMPN	P2,XCTGSW	;DO IT
	POPJ	P,		;ALL DONE

%DEBUG:
%TEST:
	HLRZ	T2,0(P2)	;GET SPACE FOR SWITCH
	ADDI	T2,F.LEN	;AND FILE SPEC
	PUSHJ	P,DY.GET##	;IN DYNAMIC AREA
	HLLZ	T2,(P2)		;GET LENGTH
	MOVEM	T2,F.LEN(T1)	;STORE IN SWITCH
	DMOVE	T2,1(P2)	;GET REST OF SWITCH
	DMOVEM	T2,F.LEN+1(T1)
	MOVEI	T2,F.LEN(T1)	;ADDRESS OF SWITCH BLOCK
	MOVSM	T2,F.SWP(T1)	;STORE AS GLOBAL
	HRRZ	T2,(P1)		;GET NEXT BLOCK
	MOVEM	T2,(T1)		;PUT DEBUG BEFORE IT
	HRRM	T1,(P1)		;LINK DEBUG IN
	POPJ	P,		;RETURN
;HERE FOR TENEX DDT
IFN FTENEX,<
	MOVSI	T1,100001
	HRROI	T2,[ASCIZ	/<SUBSYS>UDDT.SAV/]
	GTJFN
	  JRST	TXDDTR		;FAILED
	PUSH	P,T1		;DDT JFN
	MOVEI	T1,400000	;LINK-10 EV
	GEVEC
	POP	P,T1
	PUSH	P,T2
	HRLI	T1,400000	;THIS FORK
	GET
	MOVEI	T1,400000
	GEVEC			;DDT'S EV
	MOVE	T3,LC.LB	;OFFSET
	MOVEM	T2,.JBDDT(T3)
	POP	P,T2
	SEVEC			;RESTORE LINK-10'S EVEC
	TRO	FL,L.SYM	;SHOULD BE ON BY DEFAULT
	SETOM	NULSPC
	SETZM	F.NAME(P1)
	JRST	LNKWLD		;FORGET DDT REQUEST AND GET NEXT FILE

TXDDTR:	.ERR.	(MS,,V%L,L%W,S%I,DTX,<DDT10X not available, using DEC DDT>)
	JRST	LNKWLD		;LOAD IT
>

;TABLE OF NAMES OF DEBUGGING AIDS
DEFINE KEYMAC (A,B)<
 IFIDN <A><DEB>,<
  .ZZ==-1
  IRP B,<
   IFGE .ZZ,<
    IFN .ZZ&1,<
     IFNB <B>,<
	SIXBIT	\B\
     >
     IFB <B>,<
	SIXBIT	\DDT\
   >>>
   .ZZ==.ZZ+1
 >>
 PURGE .ZZ
>

DEBTBL:	KEYWORDS


;HERE FOR /DDEBUG

%DDEBUG::
	SUBI	T2,1		;IGNORE DEFAULT
	MOVEM	T2,DDEBUG	;SAVE VALUE
	POPJ	P,
%DEFINE:
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVSI	W1,PT.SGN!PT.SYM
	SKIPN	W2,T2		;GET SYMBOL
	JRST	ZSVERR		;ZERO IS INVALID
	MOVE	W3,3(P2)	;AND VALUE
	PJRST	SY.GS##		;DEFINE SYMBOL

%ENTRY:
	PUSHJ	P,STRLSW	;WAIT TIL AFTER FILE LOADED
.ENTRY:
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVE	P2,HT.PRM	;GET INDEX INTO HASH TABLE
	SETZ	T1,
	PUSHJ	P,.TYOCH##	;TYPE-OUT ON TTY ONLY
	PUSH	P,T1		;SAVE IT
	PUSH	P,[-1]		;MARKER FOR NO ENTRIES
ENTRY1:	SKIPN	P3,@HT.PTR	;GET POINTER TO SYMBOL
	JRST	ENTRY3		;NO POINTER, NO SYMBOL
	ADD	P3,GS.LB	;ADD IN BASE
	MOVE	T1,0(P3)	;GET FLAGS
	TLNE	T1,PT.SYM	;WE ONLY WANT SYMBOLS
	TLNN	T1,PS.ENT	;SEE IF AN ENTRY
	JRST	ENTRY3		;NO
	AOSE	(P)		;FIRST TIME
	JRST	ENTRY2		;NO
	MOVEI	T1,ENTHDR
	PUSHJ	P,.TSTRG##	;YES, OUTPUT HEADER LINE
	MOVEI	T1,ENTMES
	PUSHJ	P,.TSTRG##
ENTRY2:	PUSHJ	P,.TTABC##
	MOVE	T1,1(P3)	;GET SYMBOL
	PUSHJ	P,.TSIXN##	;SIXBIT WORD
	PUSHJ	P,.TTABC##	;TAB
	MOVE	T1,2(P3)	;VALUE
	PUSHJ	P,.TOCTW##	;IN OCTAL
	PUSHJ	P,.TCRLF##	;NEW LINE
ENTRY3:	SOJGE	P2,ENTRY1	;LOOP IF MORE SYMBOLS TO LOOK AT
	SKIPL	(P)		;-1 IF NONE SEEN
	JRST	ENTRY4
	MOVEI	T1,ENTHDR
	PUSHJ	P,.TSTRG##
	MOVEI	T1,[ASCIZ	\No \]
	PUSHJ	P,.TSTRG##	;FAILED TO FIND ANY
	MOVEI	T1,ENTMES	;REST OF MESSAGE
	PUSHJ	P,.TSTRG##
ENTRY4:	POP	P,T1		;CLEAR STACK
	POP	P,T1		;RESTORE OLD TYPE-OUT ROUTINE
	PJRST	.TYOCH##	;AND RETURN

ENTHDR:	ASCIZ	\[LNKLSS \
ENTMES:	ASCIZ	\Library Search Symbols (Entry points)]
\
%ESTIMATE:
	MOVEM	T2,FEST		;STORE ESTIMATED LENGTH
	SKIPE	T1,IO.CHN	;WE MAY BE TOO LATE
	SKIPL	T1,IO.PTR(P1)	;FILE OPENED YET?
	POPJ	P,		;YES, GIVE IT UP
	MOVEM	T2,I.EST(T1)	;NO, STORE IN ENTER BLOCK
	POPJ	P,

%ERRORLEVEL:
	MOVEM	T2,ERRLVL	;STORE ERROR LEVEL
	POPJ	P,

%EXECUTE:
	SETOM	EXECSW		;SIGNAL EXECUTION REQUIRED
	POPJ	P,

%FRECORE:
	MOVEM	T2,FRECOR
	POPJ	P,

%FOROTS:
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;CAN ONLY SET IN ROOT LINK
>
	SETZM	FORLIB		;FOROTS IS ZERO OR POSITIVE
	POPJ	P,

%FORSE:
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;CAN ONLY SET IN ROOT LINK
				; AND NOT EVEN THEN IF OVERLAYS WANTED
>
	SETOM	FORLIB		;FORSE IS NEGATIVE
IFN FMXFOR,<
	SETZM	MIXFOR		;CAN NOT MIX F40 & F-10 & USE FORSE
>
	POPJ	P,

%GO:
	MOVEI	T1,GO##		;GET ADDRESS TO RETURN TO
IFN FTOVERLAY,<
	SKIPL	LNKMAX		;ANY OVERLAYS SEEN?
	MOVEI	T1,LINKGO##	;YES, DO FINAL STUFF
>
	MOVEM	T1,GOTO		;SIGNAL TERMINATION AFTER THIS LINE ENDS
	POPJ	P,		;RETURN

%HASHSIZE:
	CAMG	T2,HT.PRM	;SEE IF BIGGER THAN CURRENT SIZE
	POPJ	P,		;NO, LEAVE WELL ALONE
	MOVEM	T2,HASHSZ	;STORE NEW HASH SIZE
	SETZM	HSPACE		;CAUSE REHASH TO TAKE PLACE
	POPJ	P,

;INCLUDE/EXCLUDE SWITCHES
;HAVE STORED LIST OF PERM,,TEMP NAMES
;PERMANENT NAMES LAST UNTIL CLEARED OR END OR LINK
;TEMP NAMES ARE CLEARED AT END OF FILE

.EXCLUDE:
	MOVSS	EXCPTR		;SWAP PTR TO PUT PERMANENT PART INTO RH
	MOVSS	INCPTR
	PUSHJ	P,%EXCLUDE	;STORE NAME
	MOVSS	EXCPTR		;SWAP BACK
	MOVSS	INCPTR
	MOVEI	T1,INCPTR
	PJRST	EXCL0		;REMOVE FROM TEMP ALSO

%EXCLUDE:
	SKIPN	W2,T2		;GET SYMBOL IN SAFE PLACE
	JRST	ZSVERR		;ZERO IS INVALID
	MOVEI	T1,EXCPTR	;GET INITIAL POINTER
	PUSHJ	P,INCL0		;ADD THIS SYMBOL TO TABLE
	MOVEI	T1,INCPTR
	PJRST	EXCL0		;AND REMOVE FROM OTHER TABLE

.INCLUDE:
	MOVSS	EXCPTR		;SWAP PTR TO PUT PERMANENT PART INTO RH
	MOVSS	INCPTR
	PUSHJ	P,%INCLUDE	;STORE NAME
	MOVSS	EXCPTR		;SWAP BACK
	MOVSS	INCPTR
	MOVEI	T1,EXCPTR
	PJRST	EXCL0		;REMOVE FROM TEMP ALSO

%INCLUDE:
	TRO	FL,R.INC	;TURN ON SPECIAL /INC MODE
	SKIPN	W2,T2		;GET SYMBOL IN SAFE PLACE
	JRST	ZSVERR		;ZERO IS INVALID
	MOVEI	T1,INCPTR	;GET INITIAL POINTER
	PUSHJ	P,INCL0		;ADD THIS SYMBOL TO TABLE
	MOVEI	T1,EXCPTR
	PJRST	EXCL0		;AND REMOVE FROM OTHER TABLE

INCL0:	HRRZ	T2,(T1)		;ANYTHING THERE?
	JUMPE	T2,INCNXT	;FIRST TIME
INCL1:	HRRZ	T1,(T1)		;GET POINTER TO NEXT BLOCK
	ADD	T1,[-.EXC+1,,1]	;FORM AOBJN PTR
INCL2:	SKIPN	T2,(T1)		;NOT IN TABLE IF ZERO
	SOJA	T1,INCL3	;JUST ENTER
	CAMN	W2,T2		;MATCH?
	POPJ	P,		;YES, SO ALREADY THERE
	AOBJN	T1,INCL2	;TRY NEXT
	SUBI	T1,.EXC		;BACKUP
	HRRZ	T2,(T1)		;IF ZERO THIS IS END
	JUMPN	T2,INCL1	;TRY AGAIN
;	JRST	INCNXT		;GET NEW BLOCK

INCNXT:	PUSH	P,T1		;AND WHERE WE ARE
	MOVEI	T2,.EXC		;SIZE WE NEED
	PUSHJ	P,DY.GET##	;IN DYNAMIC AREA
	POP	P,T2		;BACK POINTER
	HRRM	T1,(T2)		;LINK TO NEW
	HRLZM	T2,(T1)		;AND BACK TO OLD
INCL3:	MOVEM	W2,1(T1)	;AND STORE  THIS NAME
	POPJ	P,
EXCL.0::			;ENTRY FROM T.6
EXCL0:	HRRZ	T2,(T1)		;ANYTHING THERE?
	JUMPE	T2,CPOPJ	;NO
EXCL1:	HRRZ	T1,(T1)		;GET POINTER TO NEXT BLOCK
	ADD	T1,[-.EXC+1,,1]	;FORM AOBJN PTR
EXCL2:	SKIPN	T2,(T1)		;NOT IN TABLE IF ZERO
	POPJ	P,		;RETURN
	CAMN	W2,T2		;MATCH?
	JRST	EXCL3		;YES, SO REMOVE
	AOBJN	T1,EXCL2	;TRY NEXT
	SUBI	T1,.EXC		;BACKUP
	HRRZ	T2,(T1)		;IF ZERO THIS IS END
	JUMPE	T2,CPOPJ
	JRST	EXCL1		;TRY AGAIN

EXCL3:	HLRO	T2,T1		;GET NUMBER LEFT IN BLOCK
	ADDI	T2,.EXC		;AND SO NUMBER USED
	MOVN	T2,T2
	ADDI	T2,(T1)		;BACKUP TO LINK POINTER
	HRRZ	T3,(T2)		;NULL LINK IS END
	JUMPE	T3,EXCL4	;GOT IT
	HRRZ	T2,(T2)		;GET NEXT POINTER
	JRST	.-3		;LOOP

EXCL4:	SKIPN	2(T2)		;IF ONLY ONE NAME IN BLOCK
	JRST	EXCL5		;DELETE BLOCK ALSO
	ADD	T2,[-.EXC+1,,1]	;FORM AOBJN POINTER
	SKIPE	(T2)		;LOOK FOR NULL 
	AOBJN	T2,.-1		;OR END
	MOVE	T3,-1(T2)	;GET THIS MODULE NAME
	MOVEM	T3,(T1)		;OVERWRITE PREV ONE
	SETZM	-1(T2)		;AND DELETE  THIS
	POPJ	P,

EXCL5:	MOVE	T3,1(T2)	;GET ONLY NAME IN BLOCK
	MOVEM	T3,(T1)		;OVERWRITE OLD
	MOVE	T1,T2		;GET POINTER TO BLOCK TO DELETE
	HLRZ	T2,(T1)		;GET BACK LINK
	HLLZS	(T2)		;BREAK LINK
	MOVEI	T2,.EXC		;BLOCK SIZE
	PJRST	DY.RET##	;RETURN BLOCK




%LOGLEVEL:
	MOVEM	T2,LOGLVL	;STORE LOG FILE MESSAGE LEVEL
	POPJ	P,

%MAXCORE:
	CAIG	T2,^D256	;IN WORDS ALREADY
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;GET HIGHEST ADDRESS
	MOVE	T1,DY.AB	;SEE HOW MUCH WE ABSOLUTELY NEED
	ADD	T1,GS.AB
	SUB	T1,GS.LB	;+GLOBAL AREA
	ADD	T1,FX.AB
	SUB	T1,FX.LB	;+FIXUPS
	ADDI	T1,2*.IPS	;SYMBOLS + LOW CODE
	SKIPE	HC.LB
	ADDI	T1,.IPS		;+ HIGH CODE
	CAMG	T2,T1		;GIVE WARNING
	JRST	MAXERR		;AND IGNORE IF TOO SMALL
	MOVEM	T2,MAXCOR	;STORE MAXIMUM INCORE SIZE
	CAIG	T2,%HISEG-1	;WILL IT CAUSE OVERFLOW INTO HIGH SEG?
	POPJ	P,		;NO
	MOVEI	T2,%HISEG-1	;YES, SET TO MAX ALLOWED
	MOVEM	T2,MAXCOR
	.ERR.	(MS,.EC,V%L,L%W,S%W,MTB,<MAXCOR too big, >)
	.ETC.	(COR,.EC!.EP,,,,T2)
	.ETC.	(STR,,,,,,< used>)
	POPJ	P,

MAXERR:	IOR.	T1,.PGSIZ	;UPPER BOUND ON MIN SIZE
	.ERR.	(MS,.EC,V%L,L%W,S%W,MTS,<MAXCOR too small, at least >)
	.ETC.	(COR,.EC!.EP,,,,T1)
	.ETC.	(STR,,,,,,< is required>)
	POPJ	P,

%MPSORT:
	MOVEM	T2,MAPSRT	;SAVE TYPE REQUIRED
	POPJ	P,
;	JRST	@MPSTBL-1(T2)	;DISPATCH TO RIGHT FUNCTION
%NOINITIAL:
IFN FTOVERLAY,<
	SKIPL	LNKMAX		;CAN ONLY SET IN ROOT LINK
	POPJ	P,		;JUST IGNORE, ITS TOO LATE
>
	MOVE	T1,GSYM		;GET CURRENT COUNT OF GLOBAL SYMBOLS
	MOVE	T2,LSYM		;AND LOCALS
	CAMN	T1,@GS.LB	;TEST AGAINST INITIAL
	CAME	T2,@LS.LB	;FOR BOTH GLOBAL & LOCAL
	JRST	TDS		;TOO LATE TO CHANGE NOW
;RESET GLOBAL SPACE
	MOVE	T1,GS.LB	;GET BASE OF GLOBALS
	SETZM	(T1)		;CLEAR FIRST WORD
	HRL	T2,T1
	HRRI	T2,1(T1)	;FORM BLT PTR
	BLT	T2,@GS.PT	;UP TO FREE SPACE
	ADDI	T1,1		;PRE-ALLOCATE FIRST WORD
	HRRZ	T2,HT.PTR	;START OF SPACE FOR HASH TABLE
	SUBI	T2,(T1)		;LENGTH OF ORIGINAL SYMBOL TRIPLETS
	PUSHJ	P,GS.RET##	;RETURN IT
	SETZM	GSYM		;NO SYMBOLS  NOW
	MOVEI	T1,I.PRM	;INITIAL SYMBOLS
	IMULI	T1,.HS%		;HOW MUCH TO FILL
	IDIVI	T1,^D100
	MOVEM	T1,HSPACE	;HASH TABLE FULL ENOUGH AT THIS POINT

;NOW FOR LOCAL SYMBOLS
	MOVE	T1,LS.LB	;GET BASE
	SETZM	(T1)		;CLEAR FIRST WORD
	HRL	T2,T1
	HRRI	T2,1(T1)	;FORM BLT PTR
	BLT	T2,@LS.PT	;CLEAR UPTO FREE SPACE
	MOVEI	T2,1		;PRE-ALLOCATE FIRST WORD
	MOVEM	T2,(T1)
	MOVEM	T2,LSYM
	ADDI	T1,1
	MOVEM	T1,LS.PT	;NEW FREE SPACE POINTER
	SUB	T1,LS.AB	;- FREE SPACE
	MOVMM	T1,LS.FR	;+
	POPJ	P,

TDS:	.ERR.	(MS,,V%L,L%W,S%W,TDS,<Too late to delete initial symbols>)
	POPJ	P,

.LOCALS:
	TLO	FL,L.SYM	;LOAD WITH LOCAL SYMBOLS
%LOCALS:
	TRO	FL,R.SYM	;LOAD WITH LOCAL SYMBOLS (1 FILE ONLY)
	SKIPN	NOSYMS		;IF /NOSYM FALL INTO .NOLOCAL
	POPJ	P,

.NOLOCAL:
	TLZ	FL,L.SYM	;DON'T LOAD LOCAL SYMBOLS
%NOLOCAL:
	TRZ	FL,R.SYM	;DON'T LOAD LOCAL SYMBOLS (1 FILE ONLY)
	POPJ	P,

.NOSEARCH:
	TLZ	FL,L.LIB	;OUT OF LIBRARY SEARCH MODE
%NOSEARCH:
	TRZ	FL,R.LIB	;OUT OF LIBRARY SEARCH MODE (1 FILE ONLY)
	POPJ	P,

.NOSTART:
	TLO	FL,L.ISA	;IGNORE STARTING ADDRESSES
%NOSTART:
	TRO	FL,R.ISA	;IGNORE THIS STARTING ADDRESS
	POPJ	P,

%NOSYMBOL:
	SETOM	NOSYMS		;DON'T WANT ANY SYMBOL TABLES
	SETZM	SYMFRM		;DON'T WANT
	SETZM	SYMSEG		;...
	HRRZ	T1,IO.PTR+%SC	;INCASE /SYMBOL
	JUMPE	T1,.NOLOCAL	;NO, BUT CLEAR FLAGS
	SETZM	IO.PTR+%SC	;SO WE DON'T OUTPUT THEM
	MOVEI	T2,F.LEN	;GIVE BACK SPACE
	PUSHJ	P,DY.RET##
	JRST	.NOLOCAL	;AND CLEAR JUST INCASE

%OTSEGMENT:
	SUBI	T2,1		;DEFAULT IS 0
	CAILE	T2,2		;NEW ARGS ARE 1 & 2
	SUBI	T2,2		;ALLOW FOR LOW & HIGH
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;CAN ONLY SET IN ROOT LINK
>
	MOVEM	T2,OTSEG	;STORE INDEX TO EITHER LC OR HC
	POPJ	P,

%PATCHSIZE:
	MOVEM	T2,PATSPC	;SAVE PATCH SIZE
	POPJ	P,

%REQUIRE:
	PUSHJ	P,.SAVE4	;SAVE P1-P4
	MOVSI	W1,PT.SYM!PT.SGN	;SOME FLAGS
	SKIPN	W2,T2		;PUT SYMBOL IN  EXPECTED AC
	JRST	ZSVERR		;ZERO IS INVALID
	SETZ	W3,		;ZERO VALUE FOR DUMMY REQUEST
	PJRST	SY.RQ##		;PUT IN REQUEST

%RUNCORE:
	CAIG	T2,^D256	;IN WORDS ALREADY
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;HIGHEST ADDRESS
	MOVEM	T2,RUNCOR	;STORE SIZE FOR RUN UUO
	SKIPN	T2,3(P2)	;HIGH SEG SPECIFIED?
	POPJ	P,		;NO
	CAIG	T2,^D256	;IN WORDS ALREADY
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;HIGHEST ADDRESS
	MOVEM	T2,RUNCOR+1	;STORE SIZE FOR RUN UUO
	POPJ	P,

%RUNAME:
	MOVEM	T2,RUNAME	;STORE CORE IMAGE NAME
	POPJ	P,

.SEARCH:
	TLO	FL,L.LIB	;ENTER LIBRARY SEARCH MODE
%SEARCH:
	TRO	FL,R.LIB	;ENTER LIBRARY SEARCH MODE (1 FILE ONLY)
	POPJ	P,

IFN FMXFOR,<
%MIXFOR:
	SETOM	MIXFOR		;SET REQUEST FOR MIXFOR
	POPJ	P,

%NOMIXFOR:
	SETZM	MIXFOR		;CLEAR REQUEST FOR MIXFOR
	POPJ	P,
>
%NEWPAGE:
	PUSHJ	P,STRLSW	;WAIT TIL FILE IS LOADED
.NEWPAGE:
	HRRZ	R1,HYLTBL-1(T2)	;GET SEGMENT #
	MOVE	R1,@SG.TB	;POINT TO DATA BLOCK
	SKIPN	T1,RC.CV(R1)	;GET CURRENT VALUE
	POPJ	P,		;NOT YET SETUP!
	ADDI	T1,777
	ANDCMI	T1,777		;NEXT PAGE BOUND
	MOVEM	T1,RC.CV(R1)	;WRITE IT BACK
	POPJ	P,

$HYLLOW==1		;LOW SEG
$HYLHIGH==2		;HIGH SEG

.ONLY:
	PUSHJ	P,SETONL	;SET UP T1 AND T2
	TLZ	FL,(T1)		;CLEAR THESE FLAGS
	TLOA	FL,(T2)		;AND SET THESE
				;SKIP NEXT INST.
%ONLY:
	PUSHJ	P,SETONL
	TRZ	FL,(T1)		;CLEAR
	TRO	FL,(T2)		;SET
	POPJ	P,

SETONL:	HLRZ	T1,ONLTAB-1(T2)	;GET FLAGS TO CLEAR
	HRRZ	T2,ONLTAB-1(T2)	;AND SET
	POPJ	P,

;	CLEAR		SET
ONLTAB:	R.HSO!R.LSO,,	0	;0
	R.HSO,,		R.LSO	;1
	R.LSO,,		R.HSO	;2

.SEGMENT:
	PUSHJ	P,SETSEG	;SET UP T1 AND T2
	TLZ	FL,(T1)		;CLEAR THESE FLAGS
	TLOA	FL,(T2)		;AND SET THESE
				;SKIP NEXT INST.
%SEGMENT:
	PUSHJ	P,SETSEG
	TRZ	FL,(T1)	;CLEAR
	TRO	FL,(T2)		;SET
	POPJ	P,

SETSEG:	HLRZ	T1,SEGTAB-1(T2)	;GET FLAGS TO CLEAR
	HRRZ	T2,SEGTAB-1(T2)	;AND SET
IFN FTOVERLAY,<
				;***** TEMP PATCH *****
	SKIPL	LNKMAX		;CAN ONLY SET IN ROOT LINK
	CAIN	T2,R.FLS	;BUT CAN SET FORCED LOW SEG
	CAIA			;LEAVE AS IS
	SETZB	T1,T2		;OTHERWISE IT CAUSES GREAT CONFUSION
				;***** FIND BETTER FIX LATER *****
>
	POPJ	P,

;	CLEAR		SET
SEGTAB:	R.FLS!R.FHS,,R.FNS	;0
	R.FNS!R.FHS,,R.FLS	;1
	R.FNS!R.FLS,,R.FHS	;2

%SET:
	PUSHJ	P,STRLSW	;WAIT TIL FILE LOADED
.SET:
	DMOVE	W2,2(P2)	;SYMBOL & VALUE
	MOVEI	R1,1		;START AT 1 (.LOW.)
	TLNN	W3,770000	;SYMBOLIC IF LEFT JUSTIFIED
	JRST	SET1		;NO, MUST BE OCTAL
	MOVSI	W1,PT.SGN!PT.SYM	;SET SOME FLAGS (NOT PT.EXT)
	EXCH	W2,W3		;PUT SYMBOL IN W2 & SAVE W3
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED
	  JRST	SETU		;NOT DEFINED
	  JRST	SETU
	MOVE	W2,W3		;RECOVER W2
	MOVE	W3,2(P1)	;GET VALUE
SET1:	SKIPN	R2,@RC.TB	;GET POINTER TO IT
	JRST	SET3		;NON-LEFT, JUST INSERT
	CAME	W2,RC.NM(R2)	;ALREADY THERE?
	JRST	SET2		;NO
	CAMN	W3,RC.CV(R2)	;YES, BUT SAME VALUE?
	POPJ	P,		;YES, GIVE UP
	MOVE	R,R2		;SETUP RC POINTER
	CAML	W3,RC.CV(R2)	;NO, BUT ARE WE TRYING TO DECREASE VALUE?
	JRST	SET4		;NO, OK TO INCREASE IT

	MOVE	W1,RC.CV(R2)	;GET VALUE
	.ERR.	(MS,.EC,V%L,L%W,S%W,DRC,<Decreasing relocation counter >)
	.ETC.	(SBX,.EC!.EP,,,,W2)
	.ETC.	(STR,.EC,,,,,< from >)
	.ETC.	(OCT,.EC!.EP,,,,W1)
	.ETC.	(STR,.EC,,,,,< to >)
	.ETC.	(OCT,.EP,,,,W3)
	JRST	SET4		;AND CONTINUE

SET2:	CAMG	R1,RC.NO	;CHECKED ALL WE'VE SET UP?
	AOJA	R1,SET1		;NO
SET3:	CAMN	W2,['.HIGH.']	;THIS IS SPECIAL
	JRST	[MOVE	W1,W3		;AS IT CAUSES HIGH SEG TO APPEAR
		PJRST	SETRC##]
	SOSGE	RC.FRE		;ANY FREE SLOTS
	PUSHJ	P,SETE		;NO, ALL USED 
	AOS	RC.NO		;GET NEXT FREE
	MOVEI	T2,RC.INC	;SIZE WE WANT
	PUSHJ	P,DY.GET##	;GET IT
	MOVEM	T1,@RC.TB	;STORE POINTER
	MOVE	R,T1		;R POINTS TO RC BLOCK
SET4:	MOVEI	T1,1		;ASSUME LOW SEG
	SKIPE	LL.S2		;DO WE HAVE A CHOICE?
	CAMGE	W3,LL.S2	;YES, BUT IN HIGH SEG?
	JRST	SET5		;NOT HIGH SEG
	ADDI	T1,1		;HIGH = 2
	CAME	W2,['.HIGH.']	;THIS IS SPECIAL (FOR NOW)
	SUB	W3,LL.S2	;REMOVE OFFSET
SET5:	MOVEM	T1,RC.SG(R)	;SEGMENT NUMBER
	EXCH	R,T1		;SWAP, PUT SEG # IN R
	MOVE	R,@SG.TB	;GET POINTER TO  RC TABLE (.LOW. OR .HIGH.)
	MOVEM	W2,RC.NM(T1)	;NAME
	CAME	W2,['.LOW. ']	;DON'T RESET INITIAL VALUE IF .LOW.
	MOVEM	W3,RC.IV(T1)	;INITIAL VALUE
	MOVEM	W3,RC.CV(T1)	;ALSO CURRENT
	MOVE	T2,RC.LB(R)	;BASE OF AREA
	MOVEM	T2,RC.LB(T1)
	DGET	T2,RC.WD(R),RC.PG(R)	;LOWER CORE WINDOW & UPPER CORE WINDOW
	DSTORE	T2,RC.WD(T1),RC.PG(T1)
	POPJ	P,

SETU:	.ERR.	(MS,.EC,V%L,L%F,S%F,RCU,<Relocation counter >)
	.ETC.	(SBX,.EC!.EP,,,,W3)
	.ETC.	(STR,.EC,,,,,< undefined, set to >)
	.ETC.	(SBX,.EP,,,,W2)

SETE:	.ERR.	(MS,,V%L,L%F,S%F,RCF,<Relocation counter table full>)
%SEVERITY:
	MOVEM	T2,SEVLVL	;SAVE SEVERITY LEVEL
	POPJ	P,

.START:
	TLZ	FL,L.ISA	;BACK TO READING STARTING ADDRESSES
	TLNE	T2,770000	;CHECK FOR SYMBOLIC ADDRESS
	JRST	STARTS		;IS SYMBOLIC
%START:
	TRZ	FL,R.ISA	;FOR THIS FILE ONLY
	JUMPE	T2,CPOPJ	;SPECIAL IF ADDRESS GIVEN
	CAIN	T2,.C		;CHECK FOR DEFAULT ARG
	POPJ	P,		;AND IGNORE IT
	TLNN	T2,770000	;SYMBOLIC IS LEFT JUSTIFIED
	JRST	STARTO		;OCTAL ONLY
	PUSHJ	P,STRLSW	;WAIT TIL FILE IS LOADED INCASE IT CONTAINS ADDRESS
	MOVE	T2,2(P2)	;GET SYMBOL AGAIN
STARTS:	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVE	W2,T2		;SYMBOL
	SETZB	W1,W3		;NO VALUE
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED
	  JRST	STARTU		;NO
	  JRST	STARTU		;UNDEFINED
	MOVE	T2,2(P1)	;GET VALUE
STARTO:	MOVEM	T2,STADDR	;USE THIS AS STARTING ADDRESS
	SETZB	T2,STADDR+1	;CLEAR ADDRESS
	PJRST	.NOSTART	;AND IGNORE ALL OTHER  STARTING ADDRESSES

STARTU::.ERR.	(MS,.EC,V%L,L%W,S%W,USA,<Undefined start address >)
	.ETC.	(SBX,.EP,,,,W2)
	POPJ	P,

%SYMSEG:
	SUBI	T2,1		;DEFAULT IS 1
IFN FTOVERLAY,<
	SKIPL	LNKMAX		;LOADED ANY OVERLAYS?
	CAIE	T2,$SEGHIGH	;CANNOT LOAD SYMBOLS IN HIGH SEG
	JRST	%SYMSG		;NO
	.ERR.	(MS,,V%M,L%W,S%W,SLS,<Symbols must be in low segment>)
	movei	t2,$seglow	;put them in low seg
%symsg:>
	MOVEM	T2,SYMSEG	;STORE INDEX TO EITHER LC OR HC
	CAIN	T2,$SEGHIGH	;WANT SYMBOLS IN HIGH SEGMENT?
	SKIPE	HC.LB		;YES, IS IT SET UP YET?
	POPJ	P,		;ALL OK
	SETZ	W1,		;USE DEFAULT ORIGIN
	PUSHJ	P,.SAVE4##	;SAVE THE P'S
	PJRST	SETRC##		;AND SET UP THE HIGH SEGMENT

%SYSORT:
	JRST	@SYSTBL-1(T2)	;DISPATCH TO RIGHT FUNCTION
	POPJ	P,

%VERBOSITY:
	MOVE	T2,VERTBL-1(T2)	;GET VALUE
	MOVEM	T2,VERLVL	;SAVE VERBOSITY LEVEL
	POPJ	P,

$VERSHORT==V%S
$VERMEDIUM==V%M
$VERLONG==V%L
%UNDEFINED:
	PUSHJ	P,STRLSW	;WAIT TIL AFTER FILE IS LOADED
.UNDEFINED:
	PUSHJ	P,.SAVE4##	;INCASE WE NEED THEM
	SETZ	T1,		;ON TTY ONLY
	PUSHJ	P,.TYOCH##	;INITIALIZE
	PUSH	P,T1		;STORE OLD
	MOVEI	T1,[ASCIZ	\[LNKUGS \]
	MOVEI	P2,"]"
UNDEF1::PUSHJ	P,.TSTRG##	;TYPE IDENTIFIER
	MOVE	P1,USYM		;GET NUMBER OF UNDEFS IN A PRESERVED AC
	SKIPE	T1,P1		;WHERE SCAN EXPECTS NUMBER
	PUSHJ	P,.TDECW##	;TYPE NO. UNLESS 0
	MOVE	T1,P1		;GET UNDEFS AGAIN
	CAILE	T1,2		;LEAVE 0 OR 1 ALONE
	MOVEI	T1,2		;SET INDEX TO 0,1, OR 2
	MOVE	T1,UNDTAB(T1)	;GET ADDRESS
	PUSHJ	P,.TSTRG##	;OUTPUT MESSAGE
	SKIPE	T1,P2		;GET TERMINATOR
	PUSHJ	P,.TCHAR##	;CLOSE IF "]"
	PUSHJ	P,.TCRLF##	;AND CR-LF
	JUMPE	P1,UNDF3	;DONE IF NONE LEFT
	SKIPA	P2,HT.PRM	;GET INDEX INTO HASH TABLE
UNDF1:	SKIPN	P3,@HT.PTR	;GET POINTER TO SYMBOL
	JRST	UNDF2		;NO POINTER, NO SYMBOL
	ADD	P3,GS.LB	;ADD IN BASE
	MOVE	T1,0(P3)	;GET FLAGS
	TLNE	T1,PT.SYM	;WE ONLY WANT SYMBOLS
	TLNN	T1,PS.UDF!PS.REQ	;SEE IF UNDEFINED STILL
	JRST	UNDF2		;NO
	PUSHJ	P,.TTABC##	;OFFSET EACH LINE
	MOVE	T1,1(P3)	;GET SYMBOL
	PUSHJ	P,.TSIXN##	;SIXBIT WORD
	PUSHJ	P,.TTABC##	;TAB
	MOVE	T1,2(P3)	;VALUE
	PUSHJ	P,.TOCTW##	;IN OCTAL
	PUSHJ	P,.TCRLF##	;NEW LINE
IFE DEBSW,<			;IF DEBUGGING SCAN ALL OF TABLE
	SOJLE	P1,UNDF3	;DONE IF NO MORE UNDFS
				;INCASE COUNT OFF>
UNDF2:	SOJGE	P2,UNDF1	;LOOP IF MORE SYMBOLS TO LOOK AT
UNDF3:	POP	P,T1		;RESTORE OLD TYO ROUTINE
	PJRST	.TYOCH##


UNDTAB:	[ASCIZ	/No undefined global symbols/]
	[ASCIZ	/ undefined global symbol/]
	[ASCIZ	/ undefined global symbols/]

%SYSLIBRARY:
	PUSHJ	P,STRLSW	;WAIT TIL FILE IS LOADED
.SYSLIBRARY:
	SOJE	T2,SYSLB1	;DEFAULT ACTION IF INDEX WAS 1
	MOVE	T1,LIBTBL(T2)	;GET REQUIRED BIT
	IORM	T1,PROCSN	;AND FAKE AS IF THAT PROCESSOR SEEN
	ANDCAM	T1,NOLIBS	;AND TURN OFF THIS BIT INCASE /NOSYSL
	POPJ	P,		;AND RETURN
				;WILL LOAD AT DEFAULT TIME
SYSLB1:	PUSHJ	P,.SAVE4##	;PRESERVE P1-P4
	PUSH	P,FL		;SAVE FLAGS
	PUSH	P,F.INZR	;AND CURRENT
	PUSH	P,F.NXZR	;AND PENDING FILE SPECS
	SETZM	F.INZR		;CLEAR LIST
	SETZM	F.NXZR		;SO WE JUST LOAD DEFAULTS
	PUSH	P,GOTO		;SAVE INCASE EOL SEEN
	PUSH	P,[LODTST##]	;FAKE RETURN TO LOAD ROUTINE
	PUSHJ	P,LIBRARY##	;LOAD DEFAULT LIBS
	POP	P,GOTO		;RESTORE EOL INTERCEPT
	POP	P,F.NXZR	;RESTORE PENDING FILE SPECS
	POP	P,F.INZR
	POP	P,FL		;AS WE WERE
	POPJ	P,

%NOSYSLIBRARY:
	SOSE	T2		;DEFAULT ACTION IF WAS 1
	SKIPA	T1,LIBTBL(T2)	;NO
	SETO	T1,		;YES, TURN THEM ALL OFF
	IORM	T1,NOLIBS	;DON'T WANT THESE DEFAULT LIBS
	POPJ	P,

%USERLIBRARY:
	MOVEI	T2,F.LEN	;SPACE TO STORE FILE SPEC
	PUSHJ	P,DY.GET##
	ADDI	T2,-1(T1)	;END OF BLT
	HRLZI	T3,1(P1)	;FROM
	HRRI	T3,1(T1)	;TO
	BLT	T3,(T2)		;ALL EXCEPT FIRST WORD
	SOS	T2,2(P2)	;GET TYPE (LESS 1)
	MOVEM	T2,1(T1)	;SAVE IN SWITCH FIELD
	EXCH	T1,USEPTR	;POINT TO LATEST ENTRY
	MOVEM	T1,@USEPTR	;AND LINK IT IN
ZFPOPJ:	HRLZI	T1,2(P1)
	HRRI	T1,3(P1)
	SETZM	2(P1)
	BLT	T1,F.LEN-1(P1)	;ZERO FILE SPEC
	POPJ	P,

%NOUSERLIBRARY:
	MOVEI	T1,USEPTR	;START OF CHAIN
NOUSE1:	HRL	T1,T1		;SAVE LAST
	HRR	T1,(T1)		;GET NEXT
	TRNN	T1,-1		;0 IS END
	JRST	ZFPOPJ		;NOT FOUND
	SKIPN	F.NAME(P1)	;SPECIAL IF NO FILE NAME
	JRST	NOUSE3		;AS IT MEANS DELETE ALL
	DMOVE	T2,F.DEV(T1)	;GET DEV & FILE
	CAMN	T2,F.DEV(P1)
	CAME	T3,F.NAME(P1)
	JRST	NOUSE1		;NOT SAME
	MOVE	T2,F.EXT(T1)
	MOVE	T3,F.DIR(T1)
	CAMN	T2,F.EXT(P1)
	CAME	T3,F.DIR(P1)
	JRST	NOUSE1
	MOVEI	T3,F.DIR+2(T1)	;NOW FOR SFDS
	MOVEI	T4,F.DIR+2(P1)
	HRLI	T4,-5
NOUSE2:	MOVE	T2,(T3)
	CAME	T2,(T4)
	JRST	NOUSE1		;DIFFERENT
	ADDI	T3,2		;GET NEXT
	ADDI	T4,1
	AOBJN	T4,NOUSE2	;NOT YET DONE
	MOVE	T2,(T1)		;NOW REMOVE IT BUT FIRST
	MOVS	T1,T1		; LINK IN NEXT PTR
	MOVEM	T2,(T1)
	HLRZ	T1,T1
	MOVEI	T2,F.LEN
	PUSHJ	P,DY.RET##
	JRST	ZFPOPJ		;AND DELETE FILE SPEC

NOUSE3:	MOVE	T2,(T1)		;NOW REMOVE IT BUT FIRST
	MOVS	T1,T1		; LINK IN NEXT PTR
	MOVEM	T2,(T1)
	HLRZ	T1,T1
	MOVEI	T2,F.LEN
	PUSHJ	P,DY.RET##
	SKIPE	USEPTR		;ANY MORE?
	JRST	%NOUSERLIB	;YES
	JRST	ZFPOPJ		;NO, DELETE FILE SPEC
%VALUE:
	PUSHJ	P,STRLSW	;WAIT TIL FILE LOADED
.VALUE:
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVSI	W1,PT.SGN!PT.SYM	;SET FLAGS
	SKIPN	W2,T2		;SYMBOL
	JRST	ZSVERR		;ZERO IS INVALID
	SETZB	W3,T1		;VALUE 0 UNLESS LONG SYMBOL
	PUSHJ	P,.TYOCH##	;INIT TTY
	PUSH	P,T1		;SAVE OLD ROUTINE
	MOVEI	T1,[ASCIZ	\[LNKVAL	\]
	PUSHJ	P,.TSTRG##
	MOVE	T1,W2		;SYMBOL
	PUSHJ	P,.TSIXN##	;IN SIXBIT
	PUSHJ	P,.TTABC##	;SEPARATED BY TAB
	PUSHJ	P,TRYSYM##	;SEE IF IN TABLE
	  JRST	UNVALU		;SYMBOL UNKNOWN
	  JRST	UDVALU		;SYMBOL UNDEFINED
	MOVE	T1,2(P1)	;GET VALUE
	PUSHJ	P,.TOCTW##	;TYPE IN OCTAL
	MOVE	T1,0(P1)	;GET PRIMARY FLAGS
	TLNE	T1,PS.COM	;COMMON?
	JRST	CMVALU		;YES
	MOVEI	T1,[ASCIZ /	defined]/]
VALOUT:	PUSHJ	P,.TSTRG##	;AND DEFINED MESSAGE
	PUSHJ	P,.TCRLF##	;FINISH WITH A CR-LF
	POP	P,T1		;RESTORE OLD
	PJRST	.TYOCH##

CMVALU:	MOVEI	T1,[ASCIZ	/	common, length	/]
	PUSHJ	P,.TSTRG##
	MOVE	T1,.L+2(P1)	;LENGTH
	PUSHJ	P,.TDECW##	;IN DECIMAL
	MOVEI	T1,[ASCIZ	\ (decimal)]\]
	JRST	VALOUT		;INFORM USER

UNVALU:	MOVEI	T1,[ASCIZ	/unknown]/]
	JRST	VALOUT

UDVALU:	MOVE	T1,2(P1)	;GET VALUE
	PUSHJ	P,.TOCTW##	;IN OCTAL
	MOVEI	T1,[ASCIZ	/	undefined]/]
	JRST	VALOUT

%VERSION:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED
	MOVE	T2,2(P2)	;GET VALUE
	SKIPE	T1,IO.CHN	;GET CURRENT CHAN#
	CAIN	T1,DC		;IF 0 OR INPUT CHAN
	JRST	[MOVEM	T2,VERNUM	;STORE VERSION NUMBER
		POPJ	P,]		;IN CORE
	MOVE	T1,IO.PTR(T1)	;IF OUTPUT SPEC
	MOVEM	T2,I.VER(T1)	;SAVE IN DATA BLOCK
	POPJ	P,


SUBTTL	OUTPUT DEVICE SWITCHES

%SAVE:
	MOVSI	T1,'HGH'	;STORE NON-SHARABLE EXTENSION
	JRST	SSAVE
%SSAVE:
	MOVSI	T1,'SHR'	;SHARABLE HIGH SEG EXT
SSAVE:	PUSHJ	P,COPYP1	;MAKE A NEW DATA BLOCK
	HLR	T1,F.EXT(P1)	;INCASE USER SUPPLIED LOW EXT
	MOVEM	T1,SSEXT	;SAVE REAL EXT FOR LATER
	CAIN	T2,.NULARG	;CHECK FOR MISSING ARG
	JRST	SSAVE1		;/SAVE:FOO ONLY
	CAIG	T2,^D256	;IN WORDS ALREADY
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;
	MOVEM	T2,SAVCOR	;SIZE OF SAVE FILE
SSAVE1:	SKIPN	T2,3(P2)	;HIGH ARG ALSO
	JRST	SSAVE2		;NO
	CAIG	T2,^D256	;IN WORDS ALREADY
	LSH	T2,^D10		;NO, ASSUME K
	SUBI	T2,1		;
	MOVEM	T2,SAVCOR+1	;SIZE OF SAVE FILE
SSAVE2:	HLLOM	T1,F.EXT(P1)	;STORE DEFAULT EXT
	MOVE	T1,F.NAME(P1)	;GET REAL NAME
	MOVEM	T1,SSNAME	;AND SAVE IT
	PUSHJ	P,DVOUT.##	;SETUP DATA BLOCK
	  %VC,,.IODPR		;USE DUMP MODE
	PJRST	RESTP1		;RETURN THIS BLOCK NOW

%SYMBOL:
	SKIPE	NOSYMS		;IF NOT WANTED
	PJRST	DEFRET		;DON'T DO IT
	PUSHJ	P,COPYP1	;MAKE A NEW DATA BLOCK
	MOVE	T1,SYMTBL-1(T2)	;GET FLAG
	MOVEM	T1,SYMFRM	;SHOW WHICH ONE
	MOVSI	T1,'SYM'	;FILE EXT
	MOVEM	T1,F.EXT(P1)
	PUSHJ	P,DVOUT.##	;SET UP DATA BLOCK
	  %SC,,.IODPR
	PJRST	RESTP1

$SYMRADIX50==-1
$SYMTRIPLET==+1

%XPN:
	PUSHJ	P,COPYP1	;MAKE A NEW DATA BLOCK
	MOVSI	T1,'XPN'	;EXPANDED SAVE FILE
	MOVEM	T1,F.EXT(P1)	;IE CORE IMAGE
	PUSHJ	P,DVOUT.##	;SETUP DATA BLOCK
	  %XC,,.IODPR
	PJRST	RESTP1

%MAP:
	PUSHJ	P,COPYP1	;MAKE A NEW DATA BLOCK
	MOVE	T1,MAPTBL-1(T2)	;GET CODE
	MOVEM	T1,MAPSW	;SAVE IT
	JUMPGE	T1,MAPOK	;-1 NOT YET AVAILABLE
	.ERR.	(MS,0,V%L,L%I,S%I,IMA,<Incremental maps not yet available>)
MAPOK:	MOVSI	T1,'MAP'	;DEFAULT EXT
	SKIPN	F.EXT(P1)	;ALREADY SET
	HLLOM	T1,F.EXT(P1)	;NO
	PUSHJ	P,DVOUT.##	;SET UP DATA BLOCK
	  MC,,.IOASC
	PJRST	RESTP1		;RETURN, BUT DON'T LOAD THIS FILE

;ROUTINE COPYP1 - COPIES THE DATA BLOCK POINTED TO BY P1 TO A NEW BLOCK
;STORES THE OLD P1 IN LH P1 AND NEW BLOCK PTR IN RH P1

COPYP1::PUSH	P,T1		;SAVE EXT
	PUSH	P,T2		;SAVE ARG
	MOVEI	T2,F.LEN	;LENGTH OF A DATA BLOCK
	PUSHJ	P,DY.GET##
	HRL	T1,P1		;FORM BLT PTR
	MOVE	P1,T1		;SETUP P1 TO SAVE OLD AND POINT TO NEW
	ADDI	T2,-1(T1)	;END OF BLT
	BLT	T1,(T2)		;COPY BLOCK
	POP	P,T2		;RESTORE ARG
	POP	P,T1		;...
	POPJ	P,

;ROUTINE RESTP1 - DELETES DATA BLOCK POINTED TO BY P1
;AND RESTORES THE OLD P1

RESTP1::HRRZ	T1,P1		;ADDRESS OF BLOCK
	MOVEI	T2,F.LEN	;LENGTH OF IT
	HLRZ	P1,P1		;RESTORE P1
	SETOM	NULSPC		;FAKE A NULL BLOCK (SAME AS DEFRET)
	PJRST	DY.RET##	;GIVE BACK AND RETURN

%LOG:
	PUSHJ	P,.SAVE2##	;GET A SAFE AC BUT NOT P1
	PUSHJ	P,COPYP1	;MAKE A NEW DATA BLOCK
	SETZ	P2,		;ZERO IF NOT ALREADY A LOG FILE
	SKIPN	LOGSUB		;NON-ZERO IF LOG DEVICE OTHER THAN TTY
	SKIPE	LOGTTY		;OR TTY AS LOG
	SETO	P2,		;-1 FOR ALREADY A LOG DEV
	MOVSI	T1,'LOG'	;DEFAULT EXT
	SKIPN	F.EXT(P1)	;UNLESS ALREADY SET
	HLLOM	T1,F.EXT(P1)
	PUSHJ	P,DVOUT.##
	  %RC,,.IOASC
	PUSHJ	P,DVNAM.##	;MAKE SURE NAME IS SETUP
	SKIPL	LOGTTY		;IS CURRENT LOG DEVICE USERS TTY?
	JRST	LOG2		;NO
	MOVE	T1,IO.CHR	;GET DEVCHR WORD
	TXNN	T1,DV.TTA	;IS IT USERS TTY
	JRST	LOG1		;NO, TELL USER WHERE NEW LOG IS AT
LOG0:	MOVEI	T1,%RC		;DON'T NEED THIS BLOCK NOW
	MOVEM	T1,IO.CHN
	PUSHJ	P,DVZAP.##	;SO REMOVE IT
	JRST	RESTP1		;AND RETURN

LOG1:	PUSHJ	P,LOG99		;OUTPUT INFO MESSAGE
	SETZM	LOGTTY		;CLEAR IT
	HLRZ	T1,LOWSUB	;GET LOG SUB ADDRESS
	MOVEM	T1,LOGSUB	;POINT TO IT
	PUSHJ	P,.TYOCH##	;INITIALIZE
	JRST	LOG4		;AND DO REST OF SETUP

LOG2:	MOVE	T1,IO.CHR	;DEVCHR WORD FOR NEW LOG DEV
	TXNN	T1,DV.TTA	;WANTS TTY FOR LOG?
	JRST	LOG3		;NO
	PUSHJ	P,DVCHN.##	;POINT T1 TO DATA BLOCK
	SETZM	I.EXT(T1)	;CLEAR .LOG EXT FOR MESSAGE
	SKIPE	P2		;IF THERE WAS ALREADY A LOG FILE
	PUSHJ	P,LOG5		; GIVE MESSAGE
	SETZM	LOGSUB		;CLEAR OLD LOG OUTPUT ROUTINE
	SETOM	LOGTTY		;SIGNAL TO USE TTY
	HRRZ	T1,LOWSUB	;GET IT
	PUSHJ	P,.TYOCH##	;INITIALIZED
	JUMPL	P2,LOG2A	;BEEN INITIALIZED ONCE
	.ERR.	(MS,0,V%L,L%I,S%I,LFI,<LOG file initialization>)
	PJRST	LOG0		;AND REMOVE DATA BLOCK

LOG2A:	.ERR.	(MS,0,V%L,L%I,S%I,LFC,<LOG file continuation>)
	PJRST	LOG0
LOG3:	SKIPN	IO.PTR+RC	;ALREADY A LOG FILE?
	JRST	LOG4		;NO
	MOVE	T1,IO.PTR+RC	;YES, GET CURRENT PTR
	MOVE	T2,IO.PTR+%RC	;AND NEW PTR
	MOVE	T3,I.DEV(T2)	;GET DEVICE
	CAMN	T3,I.DEV(T1)	;SEE IF SAME
	JRST	RESTP1		;YES, DO RENAME AT END
	MOVE	T4,I.DEV(T1)	;NOW TRY PHYSICAL NAMES
	DEVNAM	T3,		;SINCE LOGICAL = PHYSICAL IS OK
	  JRST	LOG4A		;UUO FAILED
	DEVNAM	T4,
	  JRST	LOG4A
	CAME	T3,T4		;DO WE NOW MATCH?
	JRST	LOG4A		;NO
	MOVE	T3,I.DEV(T1)	;MAKE DEVICES THE SAME
	MOVEM	T3,I.DEV(T2)	;FOR RENAME CODE
	JRST	RESTP1		;AND DO IT LATER

LOG4A:	PUSHJ	P,LOG5		;OUTPUT MESSAGE AND DELETE I/O BLOCK
LOG4:	MOVE	T1,IO.PTR+%RC	;GET NEW PTR
	MOVEM	T1,IO.PTR+RC
	SETZM	IO.PTR+%RC
	MOVSI	T2,(Z RC,)	;GET CHAN#
	MOVEM	T2,I.CHN(T1)
	MOVEI	T1,RC		;SETUP AGAIN
	MOVEM	T1,IO.CHN
	PUSHJ	P,DVCHK.##	;GET DEVCHR WORD
	PUSHJ	P,DVOPN.##	;OPEN
	PUSHJ	P,DVENT.##	;ENTER FILE NAME
	HLRZ	T1,LOWSUB	;GET ADDRESS OF OUTPUT ROUTINE
	MOVEM	T1,LOGSUB	;SAVE IT FOR LOG FILE
	PUSHJ	P,.TYOCH##	;LET SCAN KNOW
	JUMPL	P2,LOG4B	;BEEN INITIALIZED
	.ERR.	(MS,0,V%L,L%I,S%I,LFI)
	JRST	RESTP1		;AND RETURN

LOG4B:	.ERR.	(MS,0,V%L,L%I,S%I,LFC)
	PJRST	RESTP1

LOG5:	PUSHJ	P,LOG99		;OUTPUT MESSAGE
	RELEASE	RC,
	MOVEI	T1,RC
	MOVEM	T1,IO.CHN	;FOR I/O ROUTINES
	PJRST	DVZAP.##	;REMOVE ALL TRACES OF IT

LOG99:	.ERR.	(MS,.EC,V%L,L%I,S%I,CLF,<Closing LOG file, continuing on >)
	.ETC.	(FSP,,,,,%RC)
	POPJ	P,
SUBTTL	DEVICE ACTION SWITCHES

.BACKSPACE:
	PUSHJ	P,STRGSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/BACKSPACE/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTBSF.	;FORM INST
	MOVE	T2,2(P2)	;GET REPEAT COUNT (VALUE)
	PUSHJ	P,CHKLSW	;SEE IF CHAN OPEN
	XCT	T1		;BACKSPACE 1 FILE
	SOJG	T2,.-1
	PJRST	MTAPE0

%BACKSPACE:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/BACKSPACE/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTBSF.	;FORM INST
	MOVE	T2,2(P2)	;GET REPEAT COUNT (VALUE)
	PUSHJ	P,CHKRSW	;SEE IF CHAN OPEN
	XCT	T1		;BACKSPACE 1 FILE
	SOJG	T2,.-1		;LOOP, ALWAYS DO ONCE
	PJRST	MTAPE0		;WAIT FOR POSITIONING TO FINISH

.REWIND:
	PUSHJ	P,STRGSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/REWIND/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTREW.	;FORM INST
	SETZ	T2,
	PUSHJ	P,CHKLSW
	XCT	T1		;REWIND
	JRST	MTAPE0		;WAIT FOR POSITIONING TO FINISH

%REWIND:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/REWIND/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTREW.	;FORM INST
	SETZ	T2,
	PUSHJ	P,CHKRSW
	XCT	T1		;REWIND
	JRST	MTAPE0		;WAIT FOR POSITIONING TO FINISH

.SKIP:
	PUSHJ	P,STRGSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/SKIP/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTSKF.	;FORM INST
	MOVE	T2,2(P2)	;GET REPEAT COUNT (VALUE)
	PUSHJ	P,CHKLSW
	XCT	T1		;SKIP 1 FILE
	SOJG	T2,.-1		;LOOP, ALWAYS DO ONCE
	JRST	MTAPE0		;WAIT FOR POSITIONING TO FINISH

%SKIP:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/SKIP/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTSKF.	;FORM INST
	MOVE	T2,2(P2)	;GET REPEAT COUNT (VALUE)
	PUSHJ	P,CHKRSW
	XCT	T1		;SKIP 1 FILE
	SOJG	T2,.-1		;LOOP, ALWAYS DO ONCE
	JRST	MTAPE0		;WAIT FOR POSITIONING TO FINISH

%UNLOAD:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED (AFTER FILE ONLY)
	MOVEI	T2,[ASCIZ	/UNLOAD/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,.MTUNL.	;FORM INST
	SETZ	T2,
	PUSHJ	P,CHKRSW
	XCT	T1		;UNLOAD FILE
	POPJ	P,

.MTAPE:
	PUSHJ	P,STRGSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/MTAPE/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	MOVE	T2,2(P2)	;GET KEYWORD VALUE
	IOR	T1,MTPTBL-1(T2)	;GET FUNCTION
	SETZ	T2,
	PUSHJ	P,CHKLSW
	XCT	T1		;MTAPE CH,#
	JRST	MTAPE0

%MTAPE:
	PUSHJ	P,STRLSW	;WAIT TIL FILE INITED
	MOVEI	T2,[ASCIZ	/MTAPE/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	MOVE	T2,2(P2)	;GET KEYWORD VALUE
	IOR	T1,MTPTBL-1(T2)	;GET FUNCTION
	SETZ	T2,
	PUSHJ	P,CHKRSW
	XCT	T1		;MTAPE CH,#
MTAPE0:	HRRI	T1,0		;MTWAT.
	XCT	T1		;WAIT FOR POSITIONING TO FINISH
	POPJ	P,

;TABLE OF MTAPE FUNCTIONS
DEFINE KEYMAC (A,B)<
 IFIDN <A><MTP>,<
  IRP B,<
   .'B:	EXP B
>>>

MTPTBL:	KEYWORDS
	SALL

%ZERO:
	PUSHJ	P,STRGSW	;WAIT TIL FILE INITED (BEFORE FILE ONLY)
	MOVEI	T2,[ASCIZ	/ZERO/]
	PUSHJ	P,DNSCHK	;GET CHAN#
	IOR	T1,[UTPCLR]	;FORM INST
	SETZ	T2,
	PUSHJ	P,CHKLSW
	XCT	T1		;ZERO DIRECTORY (DTA ONLY)
	POPJ	P,

DNSCHK:	SKIPN	T1,IO.CHN	;GET LAST CHAN#
	JRST	DNSERR		;NO CHAN# NO DEVICE!
	MOVE	T1,IO.PTR(T1)	;POINT TO DATA BLOCK
	MOVE	T1,I.SCN(T1)	;GET SCAN MODIFIER WORD
	TXNE	T1,FX.NDV	;SEE IF DEVICE SPECIFIED
	JRST	DNSERR		;NO, DON'T ALLOW DSK BY DEFAULT
	HRLZ	T1,IO.CHN	;GET LAST I/O CHAN INITED
	LSH	T1,5		;INTO AC FIELD
	POPJ	P,		;RETURN WITH CHAN# SETUP IN T1

DNSERR:	.ERR.	(MS,.EC,V%L,L%F,S%F,DNS,<Device not specified for />)
	.ETC.	(STR,.EP,,,,T2)

CHKLSW:	MOVE	T3,IO.CHN	;GET CHAN
	SKIPL	IO.PTR(T3)	;NOT INITED YERT
	POPJ	P,		;YES, JUST RET
	PUSH	P,T2		;STACK
	PUSH	P,T1
	MOVEI	T2,3		;NEED 3 WORDS
	PUSHJ	P,DY.GET##
	POP	P,1(T1)		;STACK UUO
	POP	P,2(T2)		;STACK COUNT
	MOVE	T2,IO.CHN	;SEE WHO FOR
	MOVE	T2,IO.PTR(T2)
	MOVE	T3,I.SWT(T2)	;GET SWITCHES TO DO
	TLNN	T3,-1
	JRST	[HRLM	T1,I.SWT(T2)
		JRST	POPJP]
	HLRZ	T2,T3		;ALREADY SWITCHES TO DO
	MOVE	T3,(T2)		;GET END OF LIST
	TLNE	T3,-1
	JRST	.-3		;NOT YET
	MOVEM	T1,(T2)
POPJP:	POP	P,(P)
	POPJ	P,

CHKRSW:	MOVE	T3,IO.CHN	;GET CHAN
	SKIPL	IO.PTR(T3)	;NOT INITED YET
	POPJ	P,
	PUSH	P,T2		;STACK
	PUSH	P,T1
	MOVEI	T2,3		;NEED 3 WORDS
	PUSHJ	P,DY.GET##
	POP	P,1(T1)		;STACK UUO
	POP	P,2(T2)		;STACK COUNT
	MOVE	T2,IO.CHN	;SEE WHO FOR
	MOVE	T2,IO.PTR(T2)
	MOVE	T3,I.SWT(T2)	;GET SWITCHES TO DO
	TRNN	T3,-1
	JRST	[HRRM	T1,I.SWT(T2)
		JRST	POPJP]
	HRRZ	T2,T3		;ALREADY SWITCHES TO DO
	MOVE	T3,(T2)		;GET END OF LIST
	TRNE	T3,-1
	JRST	.-3		;NOT YET
	MOVEM	T1,(T2)
	JRST	POPJP
SUBTTL	DISPATCH TABLE FOR KEY WORDS

DEFINE KEYTBL (K)<
 IRP K,<
  DEFINE KEYMAC (A,B)<
   IFIDN <K><A>,<
    A'TBL:
    IRP B,<
     EXP $'A'B
  >>>
  KEYWORDS
>>

KEYTBL	<CPU,DEF,HYL,LIB,MAP,MPS,SYM,SYS,VER>

$LIBANY==$LIBDEFAULT
SUBTTL	MAP CONTENTS

%CONTENT:
	CAIN	T2,1		;DEFAULT VALUE?
	JRST	[MOVE	T1,CONTAB	;YES, GET IT
		MOVEM	T1,MAPCON	;SET IT
		POPJ	P,]		;AND RETURN
	ROT	T2,-1		;CUT IN HALF
	MOVE	T1,CONTAB(T2)	;GET SWITCH TO CHANGE
	JUMPL	T2,[ANDCAM T1,MAPCON	;UNSET
		POPJ	P,]
	IORM	T1,MAPCON	;SET
	POPJ	P,

DEFINE  KEYMAC (A,B)<
 IFIDN <A><CON>,<
  IRP B,<
   IFN %%&1,<
    C%'B
   >
   %%==%%+1
>>>

	%%==0			;INITIAL VALUE
CONTAB:	C%DEFAULT		;DEFAULT VALUE IS FIRST
	KEYWORDS

	SALL
	PURGE	%%
SUBTTL	SET DEFAULT FILE SPECS.
;NOTE: THIS SWITCH MUST BE LAST EXECUTED
;IF IT IS NOT, RECHAIN SWITCHES SO THAT IT IS
;DEFERED SWITCHES WILL NOT BE EXECUTED
;THEREFORE /SKIP ETC. WILL HAVE NO EFFECT
;CONTROL FINALLY RETURNS TO LNKFIO TO GET NEXT FILE SPEC.

.DEFAULT:
	POP	P,T1		;REMOVE RETURN ADDRESS
	HRRZ	T2,(P2)		;GET NEXT LINK
	HRLM	T2,F.SWP(P1)	;LINK IN
	EXCH	P2,T2		;SETUP TO XCT NEXT SWITCH
	HLLZS	(T2)		;CLEAR LINK ADDRESS
	MOVEI	T3,F.SWP(P1)	;ADDRESS OF RIGHT HALF CHAIN
	MOVE	T1,T3		;SAVE LAST
	HRRZ	T3,(T1)		;GET NEXT ADDRESS
	JUMPN	T3,.-2		;LOOP TIL END OF CHAIN
	HRRM	T2,(T1)		;LINK IN
	JUMPN	P2,XCTGSW	;XCT NEXT GLOBAL SWITCH IF ANY
	POPJ	P,		;OTHERWISE RETURN

%DEFAULT:
	POP	P,T1		;REMOVE RETURN ADDRESS
	HRRZ	T2,(P2)		;GET NEXT ADDRESS IN CHAIN
	HRRM	T2,F.SWP(P1)	;LINK IN
	JUMPE	T2,DEFAULT	;LAST IF ZERO
	EXCH	P2,T2		;SETUP TO XCT NEXT SWITCH
	HLLZS	(T2)		;CLEAR LINK ADDRESS
	HRRZ	T3,P2		;GET CURRENT LINK ADDRESS
	MOVE	T1,T3		;SAVE LAST
	HRRZ	T3,(T1)		;GET NEXT ADDRESS
	JUMPN	T3,.-2		;LOOP TIL END OF CHAIN
	HRRM	T2,(T1)		;LINK LAST IN
	JRST	XCTLSW		;AND XCT FIRST SWITCH IN CHAIN

DEFAULT:
	MOVE	T2,2(P2)	;LOAD T2 FROM VALUE AGAIN
	JRST	@DEFTBL-1(T2)	;DISPATCH TO RIGHT FUNCTION
;DEFAULT

$DEFINPUT:
	HLLZM	FL,FLAGS	;SAVE AS DEFAULT GLOBAL FLAGS
	MOVE	T2,F.MOD(P1)	;GET MODIFIER WORD
	MOVE	T1,F.DEV(P1)	;GET NEW DEVICE
	TXNN	T2,FX.NDV	;IGNORE NULL DEVICE (DSK BY DEFAULT)
	MOVEM	T1,G.DEV
	SKIPN	T1,F.NAME(P1)	;NEW FILE?
	JRST	.+4		;NO
	MOVEM	T1,G.NAM
	MOVE	T1,F.NAMM(P1)	;AND MASK
	MOVEM	T1,G.NAMM
	MOVE	T1,F.EXT(P1)	;EXT AND MASK
	TXNN	T2,FX.NUL	;IGNORE NULL BUT  SET ZERO IF FILE.
	MOVEM	T1,G.EXT
	SKIPN	T1,F.BFR(P1)	;/BEFORE?
	MOVEM	T1,G.BFR
	SKIPN	T1,F.SNC(P1)	;/SINCE
	MOVEM	T1,G.SNC
	TXNN	T2,FX.DIR	;DIRECTORY
	JRST	[MOVE	T2,F.MODM(P1)	;NO, BUT MIGHT BE [-]
		TXNN	T2,FX.DIR	;IF THIS BIT SET
		JRST	DEFRET		;NO, LEAVE [DIR] AS IT WAS
		SETZM	G.DIR		;CLEAR FIRST WORD
		MOVE	T1,[G.DIR,,G.DIR+1]
		JRST	.+3]		;AND FULL PATH
	MOVSI	T1,F.DIR(P1)	;FROM ...
	HRRI	T1,G.DIR	;...TO
	BLT	T1,G.DIR+2*LN.DRB-1	;UNTIL
	JRST	DEFRET		;ALL DONE

$DEFOUTPUT:
	MOVE	T2,F.MOD(P1)	;GET MODIFIER WORD
	MOVE	T1,F.DEV(P1)	;GET NEW DEVICE
	TXNN	T2,FX.NDV	;IGNORE NULL DEVICE (DSK BY DEFAULT)
	MOVEM	T1,O.DEV
	SKIPN	T1,F.NAME(P1)	;NEW FILE?
	JRST	.+4		;NO
	MOVEM	T1,O.NAM
	MOVE	T1,F.NAMM(P1)	;AND MASK
	MOVEM	T1,O.NAMM
	MOVE	T1,F.EXT(P1)	;EXT AND MASK
	TXNN	T2,FX.NUL	;IGNORE NULL BUT  SET ZERO IF FILE.
	MOVEM	T1,O.EXT
	SKIPN	T1,F.BFR(P1)	;/BEFORE?
	MOVEM	T1,G.BFR
	SKIPN	T1,F.SNC(P1)	;/SINCE
	MOVEM	T1,G.SNC
	TXNN	T2,FX.DIR	;DIRECTORY
	JRST	[MOVE	T2,F.MODM(P1)	;NO, BUT MIGHT BE [-]
		TXNN	T2,FX.DIR	;IF THIS BIT SET
		JRST	DEFRET		;NO, LEAVE [DIR] AS IT WAS
		SETZM	O.DIR		;CLEAR FIRST WORD
		MOVE	T1,[O.DIR,,O.DIR+1]
		JRST	.+3]		;AND FULL PATH
	MOVSI	T1,F.DIR(P1)	;FROM ...
	HRRI	T1,O.DIR	;...TO
	BLT	T1,O.DIR+2*LN.DRB-1	;UNTIL
;	JRST	DEFRET		;ALL DONE

DEFRET:	SETOM	NULSPC		;FAKE NULL BLOCK
	POPJ	P,		;RETSPC WILL RETURN IT
SUBTTL	MAP SORTING
$MPSALPHABETICAL:
$MPSNUMERICAL:
	.ERR.	(MS,0,V%L,L%I,S%I,MSN,<MAP sorting not yet implemented>)
$MPSUNSORTED:
	POPJ	P,

;SYMBOL SORTING
$SYSALPHABETICAL:
$SYSNUMERICAL:
	.ERR.	(MS,0,V%L,L%I,S%I,SSN,<Symbol table sorting not yet implemented>)
$SYSUNSORTED:
	POPJ	P,

;ERROR MESSAGES

ZSVERR::.ERR.	(MS,0,V%M,L%W,S%W,ZSV,<Zero switch value illegal>)
	POPJ	P,

.ERNYI::ASCIZ	\NYI \
	ASCIZ	\Not yet implemented - /\

WLDLIT:
END

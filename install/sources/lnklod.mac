TITLE LNKLOD - LOAD MODULE FOR LINK-10
SUBTTL	D.M.NIXON/DMN		12-JUL-74


;***COPYRIGHT 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKLOD
SEARCH	LNKPAR,LNKLOW,C,SCNMAC
EXTERN	LNKSCN,LNKCOR,LNKWLD,LNKLOG,LNKF40,LNKMAP,LNKXIT



CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==220		;DEC EDIT VERSION



VERSION


;LOCAL ACC DEFINITIONS
INTERN	R,RB,WC

R=R1		;CURRENT RELOCATION COUNTER
RB=R+1		;RELOCATION BYTE WORD
WC=R3		;WORD COUNT

SALL
SEGMENT

SUBTTL	REVISION HISTORY

;START OF VERSION 1A
;44	ADD ASCIZ TEXT BLOCK
;45	HASH INITIAL SYMBOLS AT ASSEMBLY TIME
;46	ADD KLUDGE FEATURE
;52	ADD ASCII TEXT BLOCK
;54	ADD KIONLY D.P. INST.
;61	ADD STORE CODE IN FX AREA FOR TWOSEG FORCED HIGH/LOW
;63	STORE MULTIPLY-DEFINED SYMBOLS IN SYMBOL TABLE FOR MAP
;75	ADD ROUTINE TO ADDRESS CHECK A SINGLE WORD
;101	FIXES FOR FAIL CODE WITH UNDEF GLOBALS IN BLOCK 11
;102	ADD TEST FOR END BLOCK NOT SEEN BEFORE EOF
;106	REMOVE HIORG, REPLACE WITH LL.S2 OR SO.S2 AS REQUIRED
;107	REPLACE KLUDGE BY MIXFOR
;111	MAKE MIXFOR WORK EVEN IF NOT IN SEARCH MODE
;112	CHECK PER FILE /SEARCH SWITCH @LODTST
;113	MAKE MIXFOR KNOW ABOUT ARRAY REFERENCES IN ARGS
;115	MAKE /NOSYMS WORK CORRECTLY

;START OF VERSION 1B
;117	(12058) ADD MISSING POPJ P, AT FORKI+2
;130	(12315) PREVIOULY REQUESTED COMMON IS NOT PUT IN LOCAL SYMBOL TABLE CORRECTLY

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;143	ADD TEST FOR /INCLUDE MODE
;145	IMPLEMENT USER LIBRARIES
;147	TURN ON MIXFOR FEATURE
;152	FIX LOOP IF /NOINIT AND UNDEF SYMBOLS
;157	(12640) ONLY PRINT FSI MESSAGE IF /FORSE GIVEN EXPLICITLY
;161	ADD LANGUAGE SPECIFICATION TO /USERLIB
;163	IF /ONLY IS ON DON'T LOAD F-10 CODE INTO LOW SEG BY DEFAULT
;164	MAKE CPU TEST OF REL FILES MORE GENERAL
;166	READ BACK RADIX50 SYMBOL FILES
;167	CHANGE ARGS TO /OTS SWITCH
;172	(13243) BUG IF MORE THAN 1 BLOCK TYPE 16 (OR 17) SEEN
;173	TEST ASCIZ BLOCK TYPE FOR VALID FIRST CHAR
;174	FIX BUGS IN RELOCATABLE OVERLAYS
;176	MAKE START BLOCK (7) BE TWO WORDS LONG
;200	LOAD REENTRANT OVERLAY HANDLER
;204	FIX CORE EXPANSION BUG IN SYMBOL TABLE FIXUPS
;206	FIX RH CHAINED GLOBAL IF NOT ALL OF CHAIN IN CORE
;210	(13461) MORE OF #172, HANDLE TYPE 16 CORRECTLY
;220	HANDLE COMMON REFERENCED BEFORE BEING DEFINED CORRECTLY
SUBTTL	LOAD CONTROL

;ENTER HERE FROM LNKSCN
;LNKWLD READS A FILE SPEC FROM LIST POINTED TO BY F.INZR
;NON-SKIP RETURN IS END OF LIST
;SKIP RETURN WITH DEVICE INITED AND FILE OPEN OR ENTERED

LNKLOD:	JFCL	.+1		;IN CASE CCL ENTRY
IFN .ASBLK,<
	SKIPE	F.ASCI		;READING INCORE TEXT?
	JRST	LNKWLD##	;YES, SEE IF ANY SWITCHES FOR CURRENT SPEC
>
	HLLZ	FL,FLAGS	;RESET GLOBAL DEFAULTS
	.ERR.	(MS,0,V%L,L%I,S%I,LDS,<LOAD segment>)
LODNXT:	HLR	FL,FL		;CLEAR TEMP FLAGS AND SET FROM GLOBAL ONES
	PUSHJ	P,Z.INEX	;CLEAR LOCAL INCLUDE/EXCLUDE STORAGE
	PUSHJ	P,LNKWLD	;GET NEXT FILE SPEC
	  JRST	LNKSCN		;LIST EMPTY GET MORE
LODTST::JFCL			;INCASE FROM /SYSLIB
	HRRM	FL,FLAGS	;SAVE LOCAL FLAGS AT START OF FILE
	SETZM	OWNLNG		;CLEAR ALGOL OWN BLOCK LENGTH
	SETZM	LOD37		;COBOL LOCAL SYMBOL SIZE
;	SETZM	VARLNG		;BLOCK TYPE 13 LVARS
	TRNN	FL,R.LIB!R.INC	;IN LIBRARY SEARCH MODE OR /INC MODE?
	JRST	LOAD		;NO
	SKIPN	USYM		;ANY UNDEFINED SYMBOLS
	SKIPE	INCPTR		;OR SOME INCLUDES STILL TO DO?
	CAIA			;YES
	JRST	EOF1		;NO, GET NEXT FILE
	SKIPE	XBUF		;YES, INDEX IN CORE FOR THIS FILE?
	JRST	T.14B##		;YES, USE IT TO FIND PROG TO LOAD
	JRST	LOAD

T.LOAD::HRR	FL,FLAGS	;RESTORE LOCAL FLAGS
	TRNE	FL,R.LIB!R.INC	;IN LIBRARY SEARCH MODE OR /INC MODE?
	JRST	LODTST		;YES,
;	JRST	LOAD

SUBTTL	READ BLOCK TYPE AND DISPATCH

;LOAD READS THE FIRST WORD OF A BLOCK
;IT PUTS THE LENGTH (NEGATIVE) IN WC AND DISPATCHES TO HANDLING ROUTINE

LOAD::	PUSHJ	P,D.IN1		;READ ONE WORD
	MOVNI	WC,400000(W1)	;GET NEG BLOCK LENGTH
	HLRZ	T1,W1		;GET BLOCK TYPE
	CAIG	T1,377		;IS IT OLD BLOCK TYPES
	JRST	LNKOLD##	;YES, HANDLE THERE
	CAIG	T1,003777	;IN RANGE FOR NEW?
	CAIGE	T1,1000		;
	JRST	T.ERR1		;NO
	JRST	LNKNEW##	;YES


;UNKNOWN BLOCK TYPES

T.ERR1:
IFN .ASBLK,<
	CAIL	T1,(<ASCII /   />&<-1,,0>)
	CAILE	T1,(<ASCII /zzz/>&<-1,,0>)
	CAIA			;NO
	JRST	LNKASC##	;VALID ASCIZ BLOCK
>
	CAIN	T1,400		;TEST FOR OLD FORTRAN BLOCK
	JRST	T.400##		;IT WAS
	CAIN	T1,401		;OLD MANTIS CODE
	JRST	T.401##		;YES
T.ERR::	CAIN	T1,776		;RADIX50 SYMBOL FILE?
	JRST	T.776##		;YES
	.ERR.	(MS,.EC,V%L,L%F,S%F,ILI,<Illegal link item type >)
	.ETC.	(OCT,.EP!.EC,,,,T1)
	.ETC.	(STR,.EC,,,,,< for >)
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM)
	.ETC.	(STR,.EC,,,,,< in >)
	.ETC.	(FSP,0,,,,DC)

SUBTTL	CLEAR INCLUDE/EXCLUDE STORAGE

Z.INEX::HRRZ	T1,INCPTR	;GET FIRST
	JUMPE	T1,Z.EXIN	;NONE
	MOVE	T2,(T1)		;GET NEXT
	HRRM	T2,INCPTR	;RESET
	MOVEI	T2,.EXC		;STANDARD SIZE
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	JRST	Z.INEX		;LOOP

Z.EXIN:	HRRZ	T1,EXCPTR	;SAME LOOP AS ABOVE
	JUMPE	T1,CPOPJ	;ALL DONE
	MOVE	T2,(T1)
	HRRM	T2,EXCPTR
	MOVEI	T2,.EXC
	PUSHJ	P,DY.RET##
	JRST	Z.EXIN
SUBTTL	ADDRESS CHECK A SINGLE WORD

;HERE TO MAKE SURE LOCATION IS IN CORE
;ENTER WITH ADDRESS IN P3
;RETURNS NEW ADDRESS (MAYBE) IN P3
;MAY USE P2 (IF PAGING)
;CALLED BY
;	MOVE	P3,ADDRESS
;	MOVEI	R,SEGMENT NO.
;	PUSHJ	P,ADCHK.##

ADCHK.::
IFN FTOVERLAY,<
	CAIN	R,1		;LOW SEG
	SUB	P3,PH.ADD	;REMOVE LINK ORIGIN
	SKIPE	RT.LB		;RELOCATION TABLE SETUP?
	PUSHJ	P,RT.P3##	;YES, SET BYTE PTR
>
	MOVE	P2,P3		;GET A COPY
	SKIPE	PAG.S0(R)	;PAGING?
	JRST	ADCHK2		;YES, SEE IF IN CORE
	ADD	P2,LC.LB-1(R)	;RELOCATE RELATIVE ADDRESS
	CAMG	P2,LC.AB-1(R)	;WILL IT FIT IN EXISTING SPACE?
	JRST	ADCHK1		;YES
	SUB	P2,LC.AB-1(R)	;GET EXTRA REQUIRED
	PUSHJ	P,LNKCOR##	;TRY TO GET MORE SPACE
	  JRST	ADCHK2		;FAILED BUT MUST BE ON DSK
	SUB	P3,LW.S0(R)	;INCASE WE DUMPED CORE FOR FIRST TIME
ADCHK1:	ADD	P3,LC.LB-1(R)	;FINALLY FIX IN CORE
	POPJ	P,		;RETURN WITH P3 SETUP

ADCHK2:	PUSHJ	P,@[EXP PG.LSG,PG.HSG]-1(R)
	JRST	ADCHK1		;NOW TRY
	
SUBTTL	PAGING CORE CONTROL

;HERE TO CHECK TO SEE IF LOW SEG ADDRESS IS INCORE
;IF NOT CHANGE CORE WINDOW TO INCLUDE NEW ADDRESS

PG.LSG::CAMGE	P3,LW.S1	;IS LOWER ADDRESS IN CORE
	PUSHJ	P,PG.LSD	;NO, MOVE WINDOW DOWN
	CAMLE	P2,UW.S1	;AND UPPER ALSO
	PUSHJ	P,PG.LSU	;NO, NEED TO MOVE WINDOW UP
	SUB	P3,LW.S1	;REMOVE BASE
	POPJ	P,		;AND CONTINUE

;HERE FOR LOW SEG TO MOVE DOWN

PG.LSD:	PUSH	P,R		;SAVE R
	MOVEI	R,LC.IX		;INDEX TO LOW SEG
	JRST	PG.SD		;GENERAL MOVER DOWN


PG.LSU:	PUSH	P,R		;SAVE R
	MOVEI	R,LC.IX		;INDEX TO LOW SEG
	JRST	PG.SU		;GENERAL MOVER UP
;HERE TO MOVE WINDOW DOWN
;FIRST OUTPUT THE WINDOW, THEN READ BACK WHAT WE NEED
;READ BACK ONLY THE SMALLER OF LN.WD OR HALF CURRENT SIZE
;WE CAN ALWAYS EXPAND IF NEED BE

PG.SD:	HRLZ	T1,LW.S0(R)	;SETUP CONTROL WORD
	HRR	T1,UW.S0(R)	;FIRST,,LAST WORD TO MOVE
	PUSHJ	P,@[EXP LC.OUT##,HC.OUT##]-1(R)
	MOVE	T1,P3		;LOWER ADDRESS WE NEED
	ANDCMI	T1,.IPM		;MAKE INTO BLOCK BOUND
	EXCH	T1,LW.S0(R)	;RESET WINDOW
	SUB	T1,UW.S0(R)	;OLD BASE - OLD UPPER
	MOVM	T1,T1		;+LENGTH -1
	ADDI	T1,1		;+LENGTH
	SETZ	T2,		;EXTRA TO GIVE BACK
	CAIG	T1,LN.WD	;LENGTH LESS THAN 1 WINDOW?
	JRST	PG.SD1		;NOTHING WE CAN DO
	CAIG	T1,2*LN.WD	;BETWEEN 1 AND 2 WINDOWS?
	JRST	[MOVEI	T2,-LN.WD(T1)	;YES, GIVE BACK THE DIFF
		ANDCMI	T2,.IPM		;ON A BLOCK BOUND
		JRST	PG.SD0]
	MOVE	T2,T1		;GET LENGTH OF AREA
	LSH	T2,-1		;CUT IN HALF
	ANDCMI	T2,.IPM		;GIVE THIS MUCH BACK
PG.SD0:	SUBI	T1,(T2)		;ONLY THIS MUCH NOW
PG.SD1:	ADD	T1,LW.S0(R)	;GET US TO END
	SUBI	T1,1		;UPPER WORD IS 1 LESS THAN NEXT BLOCK
	MOVEM	T1,UW.S0(R)
	SOSGE	T1,T2		;EXTRA TO GIVE BACK
	JRST	PG.SD2		;NOTHING TO DO
	ADD	T1,TAB.LB(R)	;FIX IN CORE
	PUSHJ	P,GBCK.L##	;GIVE BACK TO NEXT LOWER
PG.SD2:	HRLZ	T1,LW.S0(R)	;RESET CONTROL WORD
	HRR	T1,UW.S0(R)	; TO DESIRED AREA
	PUSHJ	P,@[EXP LC.IN##,HC.IN##]-1(R)
	PJRST	FIXUP		;FIXUP ALL POSSIBLE CORE CHAINS
			
;HERE TO MOVE WINDOW UP IN CORE
;DUMP LOWER PART OF WINDOW, BLT DOWN AND READ IN TOP PART
;THIS PART IS MOST LIKELY ZERO
PG.SU:	PUSHJ	P,FR.CNT##	;SEE HOW MUCH FREE SPACE WE HAVE
	ADD	T1,UW.S0(R)	;IF WE GIVE IT ALL TO THIS AREA
	CAMG	P2,T1		;WILL IT NOW FIT?
	JRST	PG.SX		;YES, JUST EXPAND

;SEE IF BY GIVING AWAY LESSER OF LN.WD OR HALF OF EXISTING AREA
;WE CAN FIT THIS REQUEST IN, IF SO
;DELETE LOWER PART (WRITE OUT FIRST)
;IF NOT GET RID OF IT ALL VIA PG.LSD

	MOVE	T2,UW.S0(R)	;TOP OF AREA
	SUB	T2,LW.S0(R)	;MINUS BOTTOM
	ADDI	T2,1		;GET EVEN
	LSH	T2,-1		;HALF
	ANDCMI	T2,.IPM		;KEEP IN BLOCKS
	CAILE	T2,LN.WD	;USE THE LESSER
	MOVEI	T2,LN.WD
	ADD	T1,T2		;ADD TO PREVIOUS ACCUMULATION
	CAMLE	P2,T1		;WIL IT NOW FIT?
	JRST	PG.SD		;NO, DON'T WASTE TIME, REMOVE IT ALL
	PUSH	P,T2		;SAVE THE EXCESS
	HRRZ	T1,LW.S0(R)	;CURRENT LOWEST
	ADDI	T1,-1(T2)	;HIGHEST TO GET RID OF
	HRL	T1,LW.S0(R)	;TRANS WORD
	PUSHJ	P,@[EXP LC.OUT##,HC.OUT##]-1(R)
	POP	P,T1		;GET EXCESS BACK
	ADDM	T1,LW.S0(R)	;NEW LOWER BOUND
	ADD	T1,TAB.LB(R)	;ADD BASE IN CORE
	SUBI	T1,1		;HIGHEST LOC TO GIVE AWAY
	PUSHJ	P,GBCK.L##	;GIVE EXCESS AWAY
	JRST	PG.SU		;SHOULD NOW FIT (AFTER A SHUFFLE

;HERE TO EXPAND CORE BY AS MUCH AS WE NEED
;ALSO CHECK INCASE OVERFLOW FILE ALREADY CONTAINS  THE NEW AREA
;IF SO READ IT IN

PG.SX:	PUSH	P,P1		;SAVE ACCS USED BY LNKCOR
	PUSH	P,P2
	MOVEI	P1,(R)		;WHO WE WANT TO EXPAND
	SUB	P2,UW.S0(R)	;BY HOW MUCH
	PUSHJ	P,LNKCOR##	;GET IT
	  PUSHJ	P,NO.COR##	;NOT POSSIBLE
	POP	P,P2		;RESTORE
	POP	P,P1
	MOVE	T1,TAB.AB(R)	;HIGHEST BLOCK IN CORE
	SUB	T1,TAB.LB(R)	;LENGTH OF INCORE AREA
	ADD	T1,LW.S0(R)	;LENGTH FROM ORIGIN
	EXCH	T1,UW.S0(R)	;IS NEW UPPER BOUND
	CAML	T1,HB.S0(R)	;HOWEVER IF EVEN BIGGER HAS BEEN SEEN?
	JRST	RPOPJ		;NO, RESTORE R AND RETURN
	HRLZI	T1,1(T1)	;IT MUST BE ON THE DSK
	HRR	T1,UW.S0(R)	;SO SETUP TRANSFER REQUEST
	PUSHJ	P,@[EXP LC.IN##,HC.IN##]-1(R)
	PJRST	FIXUP		;AND DO ANY FIXUPS
;SIMILARLY FOR HIGH SEG

PG.HSG::CAMGE	P3,LW.S2	;SAME AS FOR LOW SEG
	PUSHJ	P,PG.HSD
	CAMLE	P2,UW.S2
	PUSHJ	P,PG.HSU
	SUB	P3,LW.S2	;REMOVE BASE
	POPJ	P,		;CONTINUE

;HERE TO CHANGE WINDOW TO HIGH SEG
;HERE TO MOVE WINDOW DOWN
;FIRST OUTPUT THE WINDOW, THEN READ BACK WHAT WE NEED
PG.HSD:	PUSH	P,R		;SAVE R
	MOVEI	R,HC.IX		;INDEX TO HIGH
	JRST	PG.SD		;MOVE DOWN


;HERE TO MOVE WINDOW UP IN CORE
;DUMP LOWER PART OF WINDOW, BLT DOWN AND READ IN TOP PART
;THIS PART IS MOST LIKELY ZERO
PG.HSU:	PUSH	P,R		;SAVE R
	MOVEI	R,HC.IX		;INDEX TO HIGH
	JRST	PG.SU		;MOVE UP
;HERE TO SEE IF ANY FIXUPS CAN BE DONE FOR LOW SEG JUST READ IN
;MUST NOT CHANGE P1-P4 & MUST SAVE R
;USES T1-T4


FIXUPL:	PUSH	P,R		;NEED TO SAVE IT
	MOVEI	R,LC.IX		;LOAD INDEX TO LOW
	JRST	FIXUP		;DO THE FIXUPS

;HERE TO SEE IF ANY FIXUPS CAN BE DONE FOR HIGH SEG JUST READ IN
;MUST NOT CHANGE P1-P4 & MUST SAVE R
;USES T1-T4

FIXUPH:	PUSH	P,R		;NEED TO SAVE IT
	MOVEI	R,HC.IX


FIXUP:	PUSHJ	P,CHKCHN	;SEE IF ANYTHING TO DO
RPOPJ:	POP	P,R		;RESTORE R
	POPJ	P,



;CHKCHN - SEE IF ANY FIXUPS EXIST FOR THE NEW CORE WINDOW
;IF SO LINK THEM INTO FXT.S0
;AND DO THEM
;R=2*N+1 FOR LOW, R=2*N+2 FOR HIGH
;DESTROYS R
;USES T1-T4

CHKCHN:	SKIPN	FX.S0(R)	;ANYTHING TO DO?
	POPJ	P,		;NO
	SETZM	FXT.S0		;CLEAR TEMP PTR
	HRRZ	T1,FX.S0(R)	;GET PTR TO LOWEST
	ADD	T1,FX.LB	;+OFFSET
	HRRZ	T2,1(T1)	;GET ADDRESS
	SUB	T2,LL.S0(R)	;REMOVE ORIGIN
	HLRZ	T1,FX.S0(R)	;PTR TO HIGHEST
	ADD	T1,FX.LB	;+OFFSET
	HRRZ	T3,1(T1)	;ADDRESS
	SUB	T3,LL.S0(R)	;REMOVE ORIGIN
	CAMG	T2,UW.S0(R)	;IS LOWEST ADDRESS TOO HIGH?
	CAMGE	T3,LW.S0(R)	;OR HIGHEST TOO LOW?
	POPJ	P,		;YES, JUST GIVE UP
				;MAKE QUICK TEST INCASE ALL CHAIN IN CORE
				;IN WHICH CASE WE NEED NOT CHASE THE CHAIN
	CAML	T2,LW.S0(R)	;IS LOWEST ADDRESS .GT. LOW WINDOW?
	CAMLE	T3,UW.S0(R)	;AND HIGHEST ADDRESS .LE. HIGH WINDOW
	JRST	.+5		;NO, DO THE SLOW WAY
	MOVE	T1,FX.S0(R)	;GET POINTER WORD
	MOVEM	T1,FXT.S0	;MOVE IT ALL OVER
	SETZM	FX.S0(R)	;REMOVE FROM LIST TO CONSIDER
	JRST	FXTLUP		;AND DO IT

	MOVEI	T1,FX.S0(R)	;GET INITIAL PTR
				;START AT BACK SINCE MOST USUAL CASE
				;IS TO READ FILE BACKWARDS
CHKCHL:	HLRZ	T1,(T1)		;GET NEXT
	JUMPE	T1,CPOPJ	;NOTHING TO DO
	ADD	T1,FX.LB	;OFFSET
	HRRZ	T2,1(T1)	;GET ADDRESS
	SUB	T2,LL.S0(R)	;REMOVE ORIGIN
	CAMLE	T2,UW.S0(R)	;INCORE?
	JRST	CHKCHL		;NO, LOOP
	HRRZ	T3,(T1)		;GET FORWARD LINK
	JUMPE	T3,[MOVEI T3,FX.S0(R)	;IF ZERO THIS IS TOP OF CHAIN
		JRST	CHKCHM]	;SO WE CAN FIXUP
	HRL	T3,T3		;STORE UNRELOCATED IN LEFT HALF
	ADD	T3,FX.LB	;RELOCATED IN RIGHT
	HLLZS	(T1)		;CLEAR FORWARD PTR OF REMOVED PART
CHKCHM:	SUB	T1,FX.LB	;-OFFSET
	MOVSM	T1,FXT.S0	;TEMP PTR TO HIGHEST TO DO
	ADD	T1,FX.LB	;+OFFSET
CHKCHH:	HLRZ	T1,(T1)		;GET NEXT
	JUMPE	T1,[MOVEI T1,FX.S0(R)	;GET FIRST IF
		JRST	CHKFIN]	;REACHED END OF CHAIN
	ADD	T1,FX.LB	;+OFFSET
	HRRZ	T2,1(T1)	;ADDRESS
	SUB	T2,LL.S0(R)	;REMOVE ORIGIN
	CAML	T2,LW.S0(R)	;STILL IN COREE?
	JRST	CHKCHH		;YES
	MOVE	T2,T1		;GET ABS ADDRESS
	SUB	T2,FX.LB	;REMOVE OFFSET
	HRL	T1,T2		;STORE LINK IN LEFT HALF FOR LATER
CHKFIN:	HRRZ	T2,(T1)		;GET 1ST FIXUP WE CAN DO
	HRRM	T2,FXT.S0	;STORE IN PTR
	ADD	T2,FX.LB	;RELOCATE IN FIXUP BLOCK
	HRRZS	(T2)		;AND CLEAR BACK LINK
				;NOW CLOSE PTRS OVER HOLE
	HLRM	T3,(T1)		;LINK TOP TO BOTTOM
	HLLM	T1,(T3)		;AND BOTTOM TO TOP

;NOW TO EXECUTE THE FIXUPS
;STORE R IN LEFT OF FXT.S0 (NOT USED FOR CHAIN PROCESSING)
FXTLUP:	SOS	FXC.S0(R)	;COUNT 1 LESS
	HRRZ	T1,FXT.S0	;GET NEXT PTR
	JUMPE	T1,CPOPJ	;ALL DONE FOR THIS LIST
	ADD	T1,FX.LB	;+OFFSET
	PUSH	P,1(T1)		;GET ADDRESS (EXPECTED IN T2)
	MOVE	W3,2(T1)	;VALUE
	HRRZ	T2,(T1)		;NEXT PTR
	HRRM	T2,FXT.S0	;STORED
	MOVEI	T2,3		;SIZE OF BLOCK
	PUSHJ	P,FX.RET##	;RESTORE NOW (INCASE REQUIRED AGAIN)
	POP	P,T2		;ADDRESS IN T2
	HLRZ	T1,T2		;GET INDEX
	HRRZ	T2,T2		;OUT OF T2
	HRLM	R,FXT.S0	;SAVE R SINCE IT WILL POINT TO DATA BLOCK ON RETURN
	PUSHJ	P,@CHNTAB(T1)	;GO TO RIGHT ROUTINE
	HLRZ	R,FXT.S0	;RESTORE R
	JRST	FXTLUP		;AND CONTINUE

DEFINE X (A)<
	EXP	PFF.'A
>

CHNTAB:	CFIXUPS
;ROUTINE TO FIND HIGHEST LOCATION TO FIXUP IN EITHER LOW OR HIGH SEG
;CALLED BY
;	PUSHJ	P,FHA.L/FHA.H
;RETURNS
;T1 = HIGHEST LOC, 0 IF NONE TO DO
;USES T1

FHA.L:	TDZA	T1,T1		;INDEX BY 0 FOR LOW
FHA.H:	MOVEI	T1,1		;1 FOR HIGH
	HLRZ	T1,FX.S1(T1)	;GET PTR TO HIGHEST LOC IN THIS CHAIN
	JUMPE	T1,CPOPJ	;NOTHING THERE
	ADD	T1,FX.LB	;+OFFSET
	HRRZ	T1,1(T1)	;GET VALUE THERE
	POPJ	P,		;RETURN
;ROUTINE TO READ OVERFLOW FILES BACKWARDS AND DO ALL POSSIBLE CODE FIXUPS

COR.FX::SKIPN	FX.S1		;SEE IF ANY LOW SEG FIXUPS
	SKIPE	FX.S2		;OR HIGH
	CAIA			;YES
	POPJ	P,
	PUSH	P,R		;SAVE R
	.ERR.	(MS,0,V%L,L%I,S%I,FCF,<Final core fixups>)
CORFXL:				;HERE FOR LOW SEGMENT
	PUSHJ	P,FHA.L		;FIND ADDRESS
	JUMPE	T1,CORFXH	;TRY HIGH
	IORI	T1,.IPM		;ROUNDED UP TO BLOCK BOUND
	MOVEI	R,LC.IX		;SET INDEX
	PUSHJ	P,RDBACK	;READ IN REQUIRED CORE IMAGE
				;AND DO ALL FIXUPS WE CAN
	JRST	CORFXL		;TRY AGAIN

CORFXH:				;HERE FOR HIGH
	PUSHJ	P,FHA.H		;SEE IF ANY HIGH
	JUMPE	T1,CORFXT	;TEST TO SEE IF ANY MORE LOW
	SUB	T1,LL.S2	;REMOVE ORIGIN
	IORI	T1,.IPM
	MOVEI	R,HC.IX		;SET INDEX FOR HIGH
	PUSHJ	P,RDBACK	;READ IN AND FIXUP
	JRST	CORFXH		;LOOP

CORFXT:	PUSHJ	P,FHA.L		;ANY LOW
	JUMPN	T1,CORFXL	;YES, RECYCLE
	POP	P,R		;RESTORE R
	POPJ	P,		;RETURN



;HERE TO DO ACTUAL READ BACK
;ENTER WITH 
;R = 1 FOR LOW
;R = 2 FOR HIGH

RDBACK:	EXCH	T1,UW.S0(R)	;SWAP WITH CURRENT TO SET NEXT UPPER
	HRL	T1,LW.S0(R)	;WRITE OUT CURRENT IMMAGE
	PUSHJ	P,@[EXP LC.OUT##,HC.OUT##]-1(R)
	MOVE	T1,UW.S0(R)	;NOW FIND BOTTOM
	ADD	T1,TAB.LB(R)
	SUB	T1,TAB.AB(R)	;FOR NEW LW.S0(R)
	MOVEM	T1,LW.S0(R)	;SET BASE
	JUMPGE	T1,RDBCK1	;OK IF NOT TOO MUCH
	ADDM	T1,TAB.AB(R)	;TOO MUCH, CUT BACK TOP
	SETZM	LW.S0(R)	;WINDOW NOW ALL IN CORE
	MOVE	T1,TAB.LB(R)	;TOP WE WILL FILL
	HRLI	T1,1(T1)	;FORM BLT PTR
	HRRI	T1,2(T1)
	SETZM	-1(T1)		;AND CLEAR UP TO .UB
	BLT	T1,@TAB.UB(R)	;SO WE DON'T LEAVE JUNK BEHIND
RDBCK1:	HRLZ	T1,LW.S0(R)	;NOW FOR READIN
	HRR	T1,UW.S0(R)
	PUSHJ	P,@[EXP LC.IN##,HC.IN##]-1(R)
	PJRST	@[EXP FIXUPL,FIXUPH]-1(R)	;AND DO FIXUPS
;HERE TO DO PAGE FAULT FIXUPS

;ADDITIVE FIXUPS
PFF.AR:	JUMPE	T2,CPOPJ	;DONE IF ZERO
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	HRRZ	T1,(T2)		;GET RIGHT HALF VALUE
	ADD	T1,W3		;PLUS DEFINED SYMBOL
	HRRM	T1,(T2)		;STORE NEW VALUE
	POPJ	P,

PFF.AL:	JUMPE	T2,CPOPJ	;DONE IF ZERO
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	HLRZ	T1,(T2)		;GET LEFT HALF VALUE
	ADD	T1,W3		;PLUS DEFINED SYMBOL
	HRLM	T1,(T2)		;STORE NEW VALUE
	POPJ	P,

PFF.AF:	JUMPE	T2,CPOPJ	;DONE IF ZERO
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	ADDM	T1,W3		;PLUS DEFINED SYMBOL
	POPJ	P,

ANCERR:	.ERR.	(MS,,V%L,L%F,S%F,ANC,<Address not in core>)

;REPLACEMENTS

;RIGHT HALF
PFF.RR:	JUMPE	T2,CPOPJ
	PUSHJ	P,SEGCHK
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	HRRM	W3,(T2)		;JUST REPLACE WHATS THERE
	POPJ	P,

;LEFT HALF
PFF.RL:	JUMPE	T2,CPOPJ
	PUSHJ	P,SEGCHK
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	HRLM	W3,(T2)
	POPJ	P,

PFF.RF:	JUMPE	T2,CPOPJ	;DONE IF ZERO
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	MOVEM	W3,(T2)		;REPLACE VALUE
	POPJ	P,
SUBTTL	LOCAL SYMBOL STORE

;ROUTINE TO ADD CONTENTS OF W1, W2, W3 TO LOCAL SYMBOLTABLE
;ALSO USED TO PUT GLOBALS AND OTHER STUFF THERE
;CHECKS FOR DSK OVERFLOW ETC


;THIS IS WHERE IT ALL GETS DONE

LSADDX:	PUSHJ	P,LS.XPN	;NEED TO EXPAND FIRST
LS.ADD::MOVE	T1,LSYM		;GET SYMBOL TABLE POINTER
	HRRM	T1,LSTSYM	;STORE REL POINTER TO NEXT SYMBOL
	TLNN	W1,PS.GLB	;IF NOT GLOBAL
	HRRZS	LSTSYM		;CLEAR SPURIOUS GLOBAL POINTER
	MOVEI	T2,.L		;ALWAYS SINGLE TRIPLET
	MOVE	T1,LS.FR	;NUMBER OF WORDS FREE
	SUBI	T1,(T2)		;WE NEED SOME MORE FOR THIS ENTRY
	JUMPL	T1,LSADDX	;NOT ENOUGH
	MOVEM	T1,LS.FR	;STORE NEW COUNT
	MOVE	T1,T2		;SAME NUMBER OF WORDS
	ADDM	T2,LSYM		;COUNT EXTRA WORDS
	ADDB	T1,LS.PT	;NEW ACTUAL BOUND
	TMOVEM	W1,-3(T1)	;FLAGS, NAME, VALUE
	POPJ	P,

;HERE IF WE HAVE TO EXPAND

LS.XPN:	PUSHJ	P,.SAVE2##	;SAVE PRESERVED ACCS
	PUSH	P,T2		;SAVE WORD COUNT
	MOVEI	P1,LS.IX	;LOCAL SYMBOL AREA
	MOVE	P2,T2		;NUMBER OF WORDS REQUIRED
	SUB	P2,LS.FR	;LESS WHAT WE HAVE
	PUSHJ	P,LNKCOR	;GENERAL CORE EXPANDER
	  PUSHJ	P,NO.COR##	;CANNOT EXPAND ANY MORE
	POP	P,T2
	POPJ	P,

;HERE TO ADD EXTENDED SYMBOL TRIPLETS (COMMON FOR INSTANCE)
LSADE1:	PUSHJ	P,LS.XPN	;NO ENOUGH SPACE
LS.ADE:	MOVE	T1,LSYM		;SYMBOL TABLE PTR.
	HRRM	T1,LSTSYM	;REL PTR. TO NEXT SYMBOL
	TLNN	W1,PS.GLB	;IF NOT GLOBAL
	HRRZS	LSTSYM		;CLEAR PTR.
	MOVE	T1,LS.FR	;NUMBER OF WORDS FREE
	SUBI	T1,(T2)		;WHAT WE NEED FOR THIS ENTRY
	JUMPL	T1,LSADE1	;NO ENOUGH
	MOVEM	T1,LS.FR	;STORE NEW COUNT
	ADDM	T2,LSYM		;COUNT EXTRA WORDS
	MOVE	T1,LS.PT	;FIRST FREE LOCATION
	ADDB	T2,LS.PT	;TOP OF SYMBOL
	HRL	T1,P1		;SOURCE
	BLT	T1,-1(T2)	;MOVE
	POPJ	P,
SUBTTL	GLOBAL SYMBOL STORE

;HERE WHEN SYMBOL MUST BE PUT IN TABLE
;POINTERS IN P1 _ P4
;SYMBOL STILL IN W1, W2, W3

SY.GS0::PUSHJ	P,INSRT		;PUT CURRENT SYMBOL IN GLOBAL TABLE
	MOVEI	T2,.L		;ONLY 3 WORDS LONG
IFN FTOVERLAY,<
	TXNN	W1,PS.BGS	;A BOUND SYMBOL?
>
	SKIPE	NOSYMS		;NOT IN LOCAL IF NOT WANTED
	POPJ	P,
	PJRST	LS.ADD		;PUT IN LOCAL SYMBOL FILE

INSRT::	SKIPE	@HT.PTR		;IS THERE A ZERO IN TABLE
	JRST	INSRTF		;NO, ERROR, SHOULD NEVER HAPPEN

INSRT0:	AOS	GSYM		;COUNT SYMBOL
	SOS	HSPACE		;AND DECREMENT SPACE IN HASH TABLE
	.JDDT	LNKLOD,INSRT0,<<CAMN W2,$SYMBOL>>	;ARE WE LOOKING FOR THIS SYMBOL?
	TLNE	W1,PT.EXT	;LONG SYMBOL?
	JRST	INSRTL		;YES, JUST MOVE POINTERS
	MOVEI	T2,.L		;NUMBER OF WORDS REQUIRED
	PUSHJ	P,GS.GET##	;GO GET THEM
	TMOVEM	W1,0(T1)	;STORE TRIPLET SYMBOL
INSRT1:	SUB	T1,NAMLOC	;GET OFFSET TO NAMTAB
	HRL	T1,P3		;HASH TOTAL IN LEFT HALF
	MOVEM	T1,@HT.PTR	;HASH TOTAL,,REL ADDRESS OF SYMBOL
	TLNE	W1,PS.GLB	;DEFINING A GLOBAL?
	HRLZM	T1,LSTSYM	;YES, STORE POINTER TO IT
	POPJ	P,		;RETURN


;HERE IF SYMBOL IS EXTENDED
;SYMBOL IS ALREADY IN CORE POINTER NEED ADJUSTING AND W3 RESET

INSRTL:	MOVE	T1,W3		;W3 POINTS TO INCORE BLOCK
	ADD	T1,NAMLOC	;RELATIVE TO GS.LB
	MOVE	W3,2(T1)	;RESTORE W3 (VALUE)
	JRST	INSRT1		;PUT IN HASH TABLE

INSRTF:	.ERR.	(MS,0,V%L,L%F,S%F,SIF,<Symbol insert failure, non-zero hole found>)
SUBTTL	SATISFY GLOBAL REQUESTS

;HERE TO SATISFY GLOBAL REQUESTS WITH DEFINED VALUE
;FLAGS IN W1
;VALUE IN W3
;ALL CHAINED REQUESTS ARE RIGHT-HALF FIXUPS

SY.RF::	SOSGE	USYM		;DECREMENT UNDEFINED GLOBAL COUNT
	PUSHJ	P,DUZERR	;BUT NOT TOO FAR
	IORM	W1,0(P1)	;SEE WHAT WE HAVE IN FLAGS
	MOVSI	W1,PS.UDF!PS.REQ	;DON'T NEED THESE NOW
	ANDCAB	W1,0(P1)	;SO CLEAR FROM MEMORY
	MOVE	T2,2(P1)	;PICKUP ADDRESS
	MOVEM	W3,2(P1)	;STORE VALUE
	PUSHJ	P,SY.CHR	;CHAIN THROUGH RIGHT HALF
	MOVEI	T2,.L		;STORE SYMBOL BEFORE WE LOSE IT
	TLNE	W1,PS.COM	;IF COMMON NEED TWO TRIPLETS
	JRST	[ADDI	T2,.L
		PUSHJ	P,LS.ADE	;STORE MULTIPLE WORD
		JRST	.+2]		;SKIP NEXT INST.
	PUSHJ	P,LS.ADD	;IN LOCAL TABLE
	TLNN	W1,PS.FXP	;ANY FIXUPS TO BE DONE FOR THIS SYMBOL?
	POPJ	P,		;NO
	JRST	SY.RF1		;YES

DUZERR:	.ERR.	(MS,,V%L,L%F,S%F,DUZ,<Decreasing undefined symbol count below zero>)
SUBTTL	SATISFY ADDDITIVE GLOBALS

;HERE FOR ADDITIVE GLOBALS
;THE ADDDITIVE GLOBAL REQUESTS ARE STORED IN LINKED LISTS IN AREA FX
;THE INITIAL POINTER TO THEM IS IN AN EXTENDED TRIPLET IN AREA GS

SY.RF1:	HRRZ	P1,@HT.PTR	;SETUP P1 AGAIN
	ADD	P1,NAMLOC	;ABSOLUTE
SY.RF2:	HLRZ	T1,0(P1)	;GET FLAGS AGAIN
	TRNN	T1,PS.REL	;IF THIS SYMBOL IS RELOCATABLE
	TDZA	T1,T1		;NO
	ANDI	T1,PS.REL	;ALL SYMBOLS DEPENDING UPON IT ARE ALSO
	MOVSM	T1,SYMFLG	;STORE INCASE SYMBOL TABLE FIXUPS
SYRF2A:	ADDI	P1,.L		;POINT TO  EXTENDED SYMBOL
	MOVE	T1,0(P1)	;GET FLAGS
	JUMPL	T1,CPOPJ	;FINISHED IF PRIMARY SYMBOL
	TLNN	T1,S.FXP	;THIS TRIPLET A FIXUP REQUEST?
	JRST	SYRF2A		;NO, TRY NEXT
	MOVE	T1,P1		;REMEMBER WHERE WE ARE
	SUB	T1,NAMLOC
	PUSH	P,T1		;SO WE CAN DELETE FIXUP REQUEST WHEN DONE
	MOVE	P1,2(P1)	;GET POINTER TO FIXUP
SY.RF3:	PUSH	P,P1		;SAVE ADD OF FIXUP BLOCK
	ADD	P1,FX.LB	;IN CORE
	MOVE	W1,(P1)		;GET FLAGS AND NEXT POINTER
	TLNE	W1,FP.POL	;POLISH FIXUP (TYPE 11)?
	JRST	[PUSHJ	P,SY.PF0	;YES, SEE IF FIXUP CAN BE DONE
		JRST	SY.RF4]		;AND DELETE THIS REQUEST
	EXCH	W3,2(P1)	;SWAP VALUE WITH REQUEST
	PUSHJ	P,SY.ADG	;DO THIS FIXUP
SY.RF4:	POP	P,P1		;RESTORE P1
	ADD	P1,FX.LB	;INCASE CORE MOVED
	MOVE	W3,2(P1)	;RESTORE W3
	MOVE	T1,P1		;FINISHED WITH IT NOW
	MOVEI	T2,.L
	PUSHJ	P,FX.RET##	;RETURN SPACE
	HRRZ	P1,W1		;GET NEXT REL POINTER
	JUMPE	P1,SY.RF5	;ZERO MARKS END OF CHAIN
	TLNE	W1,FP.SYM
	JRST	SY.RF3		;DO THIS ONE
ISPERR:	.ERR.	(MS,,V%L,L%F,S%F,ISP,<Incorrect symbol pointer>)

SY.RF5:	POP	P,P1
	ADD	P1,NAMLOC	;INCASE MOVED
	MOVSI	W1,PS.FXP	;FLAG TO CLEAR
	MOVSI	T1,S.LST	;INCASE STILL EXTENDED
	SKIPG	-.L(P1)		;ARE WE POINTING AT PRIMARY?
	TLOA	W1,PT.EXT	;YES, DELETE EXTENDED FLAG ALSO
	IORM	T1,-.L(P1)	;NO, MARK SECONDARY AS LAST
	MOVEI	T1,(P1)
	MOVEI	T2,.L
	PUSHJ	P,GS.RET##	;GIVE BACK TRIPLET
	HRRZ	P1,@HT.PTR	;RESTORE POINTER TO PRIMARY
	ADD	P1,NAMLOC
	ANDCAM	W1,0(P1)	;CLEAR FLAGS IN PRIMARY
	POPJ	P,
;HERE FOR ADDITIVE GLOBAL REQUEST WITH VALUE ALREADY DEFINED

SY.ADG:	TLNN	W1,FS.FXS	;SYMBOL TABLE FIXUP?
	JRST	SY.AD0		;NO
	OR	W1,SYMFLG	;STORE EXTRA FLAGS (PS.REL)
	JRST	SY.STF		;YES

;HERE TO FILL IN SINGLE ADDITIVE GLOBAL REQUEST

SY.AD0::
IFN FTOVERLAY,<
	MOVE	T1,0(P1)	;GET INCORE FLAGS
	TRNE	T1,PS.RBG	;FROM A RELOCATABLE LINK?
	PUSHJ	P,RT.FX##	;YES, STORE FIXUP FOR RELOCATION
>;END OF IFN FTOVERLAY
	HRRZ	T2,W3		;GET REL ADDRESS OF FIXUP
	PUSHJ	P,SEGCHK	;GET CORE LOCATION
	  JRST	SY.ADP		;OUT ON DSK (PAGED)
	TLNE	W1,FS.FXL	;LEFT HALF FIXUP?
	JRST	SY.ADL		;YES
	TLNE	W1,FS.FXF	;OR FULL WORD?
	JRST	SY.ADF		;YES
SY.ADR:
IFN FTOVERLAY,<
	TLNE	W1,FS.REL	;RELOCATABLE?
	TXO	R,1B1		;YES, RESET BIT IN R
	PUSHJ	P,SY.ADT	;RELOCATABLE OVERLAY?
	JFCL	RT.T2R##	;YES, SET RELOC BIT  CORRECTLY
>
	HRRZ	T1,(T2)		;GET RIGHT HALF VALUE
	ADD	T1,2(P1)	;PLUS DEFINED SYMBOL
	HRRM	T1,(T2)		;STORE NEW VALUE
	POPJ	P,

SY.ADL:
IFN FTOVERLAY,<
	TLNE	W1,FS.REL	;RELOCATABLE?
	TXO	R,1B0		;YES, RESET BIT IN R
	PUSHJ	P,SY.ADT	;RELOCATABLE OVERLAY?
	JFCL	RT.T2L##	;YES, SET RELOC BIT  CORRECTLY
>
	HLRZ	T1,(T2)		;GET LEFT HALF VALUE
	ADD	T1,2(P1)	;PLUS DEFINED SYMBOL
	HRLM	T1,(T2)		;STORE NEW VALUE
	POPJ	P,

SY.ADF:
IFN FTOVERLAY,<
	TLNE	W1,FS.REL	;RELOCATABLE?
	TXO	R,3B1		;YES, RESET BITS IN R
	PUSHJ	P,SY.ADT	;RELOCATABLE OVERLAY?
	JFCL	RT.T2F##	;YES, SET RELOC BIT  CORRECTLY
>
	MOVE	T1,(T2)		;GET FULL WORD VALUE
	ADD	T1,2(P1)	;PLUS DEFINED SYMBOL
	MOVEM	T1,(T2)		;STORE NEW VALUE
	POPJ	P,

;HERE WHEN REQUIRED ADDRESS IS NOT IN CORE
;STORE AS A FIXUP REQUEST FOR ADDITIVES, EITHER RH ,LH, OR FULL
;ENTER WITH R = 1 (LOW), OR R = 2 (HIGH)
;W1 = FIXUP FLAGS
;W3 = ADDITIVE REQUEST
;2(P1) = SYMBOL VALUE

;PUT T2 =W3 AND W3 = 2(P1)

SY.ADP:	MOVE	T2,W3		;EXPECTS ADDRESS IN T2
	MOVE	W3,2(P1)	;TRUE VALUE IN W3
	TLNE	W1,FS.FXR	;RIGHT HALF FIXUP?
	HRLI	T2,CPF.AR	;YES
	TLNE	W1,FS.FXL	;LEFT HALF FIXUP
	HRLI	T2,CPF.AL	;YES
	TLNE	W1,FS.FXF	;FULL WORD?
	HRLI	T2,CPF.AF	;YES
	TLNE	W1,FS.FXC	;RIGHT HALF CHAINED?
	HRLI	T2,CPF.CR	;YES
	PJRST	SY.CHP		;LINK IN

IFN FTOVERLAY,<
SY.ADT:	SKIPN	RT.LB		;IS IT RELOCATABLE
	POPJ	P,		;NO
	PUSH	P,P1		;SAVE SYMBOL TABLE PTR
	MOVSI	P1,(Z @)	;TURN ON @ IN STACK
	IORM	P1,-1(P)	;THERE MUST BE AN EASIER WAY?
	SETZ	P1,		;SIGNAL NOT A SYMBOL FIXUP
	HRRZ	T2,W3		;RESET ADDRESS
	PUSHJ	P,@-1(P)	;GO TO CORRECT ROUTINE
	POP	P,P1		;RESTORE
	HRRZ	T2,W3		;RESET ADDRESS
	PUSHJ	P,SEGCHK	;GET CORE LOCATION
	  HALT	.		;CAN NOT HAPPEN
	POPJ	P,		;AND RETURN
>
;HERE FOR SYMBOL TABLE FIXUP
;CALLED BY
;	MOVE	W1,FLAGS
;	MOVE	W3,SYMBOL TABLE POINTER (LSTSYM TYPE)
;				GLOBAL,,LOCAL
;	PUSHJ	P,SY.STF
;USES T1 - T4

SY.STF::MOVSI	T2,PS.UDR	;ASSUME RIGHT HALF FIXUP
	HRRZ	T1,W3		;GET LOCAL ADDRESS
	HLRZ	T2,W3		;AND GLOBAL
	JUMPE	T2,SYSTFL		;NO GLOBAL FIXUP REQUIRED
	ADD	T2,NAMLOC	;RELOCATE
	MOVE	T3,0(T2)	;GET FLAGS
	TLNN	T3,PT.OTH	;NOT SYMBOL?
	JRST	SYSTFL		;YES IT IS
	TLNN	T3,PO.IND	;INDIRECT POINTER PERHAPS?
	PUSHJ	P,ISPERR	;NO???
	HRL	W3,2(T2)	;RESET REAL POINTER
	MOVE	T1,T2		;POINTER IN T1
	MOVEI	T2,.L		;AND GET RID OF THIS DUMMY BLOCK
	PUSHJ	P,GS.RET##
	JRST	SY.STF		;TRY AGAIN

SYSTFL:	MOVSI	T3,PS.UDR	;ASSUME RIGHT HALF FIXUP
	TLNE	W1,FS.FXL	;LEFT HALF FIXUP?
	TLC	T3,PS.UDF	;CHANGE TO PS.UDL
	JUMPE	T1,SYSTF0	;CLEAR FLAG IN LOCAL TABLE IF THERE
	CAMGE	T1,LW.LS	;IS THIS PART OF TABLE STILL IN CORE?
	JRST	SYSTFX		;NO PUT IN FIXUP TABLE
	ADD	T1,LS.LB	;RELOCATE
	SUB	T1,LW.LS	;REMOVE WINDOW BASE
	MOVE	T4,T3		;GET A COPY OF FLAG (USED LATER SO DON'T DESTROY)
	ANDCAB	T4,0(T1)	;CLEAR FLAG IN MEMORY, SET IN ACC
	TLZ	T4,PS.REQ	;HOPE WE CAN CLEAR THIS FLAG NOW
	TLNN	T4,PS.UDF	;WE CAN IF SYMBOL IS NOW DEFINED
	ANDM	T4,0(T1)	;YES, SO CLEAR IN MEMORY
	MOVSI	T4,PS.REL	;INCASE RELOCATABLE (USUALLY IS)
	TLNE	W1,FS.REL	;WAS IT
	IORM	T4,0(T1)	;YES, SO MAKE THIS ONE ALSO
SYSTF0:	SPUSH	<W3,W2,W1>	;SAVE CURRENT SYMBOL INFO INCASE MORE FIXUPS FOR IT
	JUMPE	T2,SYSTF3	;SAME FOR GLOBAL TABLE
	.JDDT	LNKLOD,SYSTF0,<<MOVE	T4,1(T2)>,<CAMN	T4,$SYMBOL>>
	ANDCAB	T3,0(T2)	;CLEAR FLAG IN MEMORY, SET IN ACC
	MOVSI	T4,PS.REQ	;HOPE WE CAN CLEAR THIS FLAG NOW
	TLNN	T3,PS.UDF	;WE CAN IF SYMBOL IS NOW DEFINED
	ANDCAM	T4,0(T2)	;YES, SO CLEAR IN MEMORY
	MOVSI	T4,PS.REL	;INCASE RELOCATABLE (USUALLY IS)
	TLNE	W1,FS.REL	;WAS IT
	IORM	T4,0(T2)	;YES, SO MAKE THIS ONE ALSO
SYSTF3:	JUMPE	T1,SYSTF1	;NO LOCAL, ONLY GLOBAL
	DMOVE	W1,0(T1)	;GET FLAGS & SYMBOL WE NOW CARE ABOUT
	HRRZ	W3,2(P1)	;GET HALF WORD FIXUP VALUE
				;FROM DEFINED SYMBOL
	PUSH	P,T2		;BETTER SAVE T2
	MOVE	T2,-1(P)	;GET W1 FLAGS 
	PUSHJ	P,SY.AST	;FIXUP EITHER RH OR LH OF SYMBOL IN T1
	POP	P,T2		;RESTORE IT
SYSTF1:	SKIPN	T1,T2		;GET POINTER TO GLOBALS
	JRST	SYSTF2		;NOT GLOBAL
	DMOVE	W1,0(T1)	;FLAGS & SYMBOL
	HRRZ	W3,2(P1)	;HALF WORD VALUE
	MOVE	P1,T1		;NOW DONE WITH DEFINED SYMBOL
	MOVE	T2,0(P)		;W1 FLAGS
	PUSHJ	P,SY.AS0	;GO DO THE VALUE FIXUP
				;AND ANY CHAINING DEPENDING UPON THIS SYMBOL
SYSTF2:	SPOP	<W1,W2,W3>	;RESTORE OLD SYMBOL
	POPJ	P,

;HERE TO PUT LOCAL SYMBOL FIXUP IN TO FIXUP TABLE TO BE DONE LATER
SYSTFX:	SUB	T2,NAMLOC	;REMOVE OFFSET INCASE CORE MOVES
	PUSH	P,T2		;SAVE THE GLOBAL POINTER
	PUSH	P,T3		;AND FLAGS
	PUSHJ	P,SY.STP	;PUT IN TABLE
	POP	P,T3
	POP	P,T2
	ADD	T2,NAMLOC	;PUT BACK OFFSET
	SETZ	T1,		;NO LOCAL POINTER NOW
	JRST	SYSTF0		;AND
;HERE FOR POLISH FIXUPS CAUSED BY A BLOCK TYPE 11
;CONTAINING ONE OR MORE UNDEFINED GLOBAL SYMBOLS
;REPLACE THE NOW DEFINED SYMBOL BY ITS VALUE
;IF MORE UNDEFS EXIST GIVE UP
;IF ALL SYMBOLS ARE DEFINED DO FIXUP

SY.PF0:	MOVE	T4,2(P1)	;GET REL ADDRESS OF POLISH BLOCK
	ADD	T4,FX.LB	;ADD BASE
	HRLI	T4,(POINT 18)	;FORM BYTE POINTER
	ADDI	T4,2		;BYPASS HEADER AND GLOBAL COUNT
	SKIPA	T3,T4		;USE T3 AS CURRENT, T4 AS INITAL
SYPF1:	IBP	T3		;BYPASS NEXT HALF WORD
SYPF2:	ILDB	T1,T3		;READ HALF WORD
	CAIL	T1,15		;CHECK FOR VALID OPS
	POPJ	P,		;IGNORE, ALL GLOBALS NOT YET DEFINED.
	CAIL	T1,3		;IF OPERATOR
	JRST	SYPF2		;IGNORE IT
	JUMPE	T1,SYPF1	;IGNORE NEXT HALF WORD
	CAIN	T1,1		;36 BIT VALUE?
	AOJA	T3,SYPF2	;YES, GET NEXT HALF WORD AFTER IT
;HERE IF T1=2, GLOBAL SYMBOL REQUEST
	ILDB	T1,T3		;GET FIRST PART OF SYMBOL
	HRLZ	T2,T1		;STORE LEFT HALF PART OF SYMBOL
	ILDB	T1,T3		;GET RIGHT HALF PART
	HRR	T2,T1		;FULL SYMBOL IN W2
	CAME	T2,W2		;IS THIS THE SYMBOL NOW DEFINED?
	JRST	SYPF2		;NO
	SUBI	T3,2		;BACKUP BYTE POINTER
	IBP	T3		;TO POINT TO 2
	MOVEI	T1,1		;CHANGE GLOBAL MARKER INTO 36 BIT VALUE MARKER
	IDPB	T1,T3
	MOVS	T1,W3		;GET VALUE
	IDPB	T1,T3		;STORE IT
	MOVSS	T1
	IDPB	T1,T3		;T3 BACK AS IT WAS
	SOSE	-1(T4)		;ALL UNDEFS NOT DEFINED?
	JRST	SYPF2		;NO, GET NEXT HALF WORD

;NOW TO EVALUATE POLISH FIXUP
;USE T.11EV (IN LNKOLD)
;THIS USES W1, W2, W3 FOR NON-SYMBOL USE
	SPUSH	<W1,W2,W3>	;SAVE SYMBOL ACCS
	MOVEM	T4,T11BP	;SETUP BYTE POINTER
	HRRZI	T1,-2(T4)	;START ADDRESS OF BLOCK
	SUB	T1,FX.LB	;REL TO FX AREA
	HRL	T1,0(P1)	;BLOCK LENGTH
	MOVEM	T1,T11FA
	PUSHJ	P,T.11EV##	;EVALUATE
	SPOP	<W3,W2,W1>	;RESTORE ACCS
	POPJ	P,
;HERE TO GENERATE LOCAL SYMBOL  FIXUP IN A LINKED LIST
;FORMAT OF FIXUP IS THE SAME AS ALL OTHER PAGED FIXUPS
;WORD 1		BACK PTR,,FORWARD PTR
;WORD 2		INDEX,,SYMPTR
;WORD 3		VALUE
;
;CALLED BY
;	MOVE	W1,DEFINING SYMBOL FLAGS
;	MOVE	W3,SYMBOL PTR
;	MOVE	P1,PTR TO DEFINING SYMBOL
;	PUSHJ	P,SY.STP
;DESTROYS R

SY.STP:	PUSH	P,W3		;SAVE SYMBOL PTRS
	HRRZ	T2,W3		;AND REL ADDRESS IN SYMBOL TABLE
	TLNE	W1,FS.REL	;WAS DEFINING SYMBOL RELOCATSBLE?
	JFCL			;YES
	MOVE	W3,2(P1)	;FIXUP VALUE FROM ORIGINAL SYMBOL DEF
	TLNE	W1,FS.FXR	;RIGHT HALF FIXUP?
	HRLI	T2,SPF.AR	;YES
	TLNE	W1,FS.FXL	;LEFT HALF FIXUP?
	HRLI	T2,SPF.AL	;YES
	TLNE	W1,FS.FXF	;FULL WORD FIXUP?
	HRLI	T2,SPF.AF	;YES
	MOVEI	R,FS.SS-FX.S0	;LOAD INDEX
	SUB	P1,FX.LB	;REMOVE OFFSET INCASE CORE MOVES
	PUSHJ	P,SY.CHP	;LINK INTO LIST
	ADD	P1,FX.LB	;...
	POP	P,W3		;RESTORE W3
	POPJ	P,
SUBTTL	ADDRESS CHAINS (RH, LH, FULL WORD)

;FIXUP CHAINING OF SYMBOLS
;ENTER WITH 
;W3 = VALUE
;T2 = ADDRESS OF CHAIN (REL TO PROG ORIGIN)

;RIGHT HALF
SY.CHR::JUMPE	T2,CPOPJ	;DONE IF ZERO LINK
IFN FTOVERLAY,<
	SKIPE	RT.LB		;RELOCATABLE OVERLAY?
	PUSHJ	P,RT.T2R##	;YES, SET RELOC BIT  CORRECTLY
>
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  JRST	[HRLI	T2,CPF.CR	;PAGE NOT IN CORE
		JRST	SY.CHP]		;CHAIN REQUESTS TOGETHER
	HRL	T2,(T2)		;GET NEXT LINK
	HRRM	W3,(T2)		;FILL IN VALUE
	HLRZS	T2		;SETUP FOR NEXT
	JRST	SY.CHR		;DO IT

;LEFT HALF
SY.CHL::JUMPE	T2,CPOPJ	;DONE IF ZERO LINK
IFN FTOVERLAY,<
	SKIPE	RT.LB		;RELOCATABLE OVERLAY?
	PUSHJ	P,RT.T2L##	;YES, SET RELOC BIT  CORRECTLY
>
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  JRST	[HRLI	T2,CPF.CL	;PAGE NOT IN CORE
		JRST	SY.CHP]		;CHAIN REQUESTS TOGETHER
	HLL	T2,(T2)		;GET NEXT LINK
	HRLM	W3,(T2)		;FILL IN VALUE
	HLRZS	T2		;SETUP FOR NEXT
	JRST	SY.CHL		;DO IT

;FULL WORD 
SY.CHF::JUMPE	T2,CPOPJ	;DONE IF ZERO LINK
IFN FTOVERLAY,<
	SKIPE	RT.LB		;RELOCATABLE OVERLAY?
	PUSHJ	P,RT.T2F##	;YES, SET RELOC BIT  CORRECTLY
>
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  JRST	[HRLI	T2,CPF.CF	;PAGE NOT IN CORE
		JRST	SY.CHP]		;CHAIN REQUESTS TOGETHER
	HRL	T2,(T2)		;GET NEXT LINK
	MOVEM	W3,(T2)		;FILL IN VALUE
	HLRZS	T2		;SETUP FOR NEXT
	JRST	SY.CHF		;DO IT

;FULL WORD REPLACEMENT 
RP.CHF::JUMPE	T2,CPOPJ	;DONE IF ZERO
	PUSHJ	P,SEGCHK	;SETUP INCORE ADDRESS
	  PUSHJ	P,ANCERR	;WE ONLY GET HERE WHEN PAGE IS IN CORE
	MOVEM	W3,(T2)		;REPLACE VALUE
	POPJ	P,

;NOW FOR EQUIVALENT DEFINITIONS
;CHAINED FIXUPS
PFF.CR==SY.CHR		;SAME ROUTINES
PFF.CL==SY.CHL
PFF.CF==SY.CHF

;HERE IF REQUIRED ADDRESS NOT INCORE
;DO NOT READ PAGE BACK IN, JUST STORE  REQUEST IN FX TABLE
;FILL IN LATER WHEN ENOUGH TO JUSTIFY READING PAGE BACK
;FIXUPS ARE STORED IN DOUBLLY  LINKED LIST IN ASCENDING ORDER
;POINTER IS 	PTR TO HIGHEST ADD,,PTR TO LOWEST ADD
;THE NULL LINK IS 0
;DATA BLOCK IS
;	BACKWARD PTR,,FORWARD PTR
;	FIXUP ADDRESS IN USER CORE
;	FIXUP VALUE

;CALLED BY
;	MOVEI	R,TABLE OFFSET (REL TO FX.S0)
;	MOVE	T2,REL ADDRESS OF FIXUP
;	MOVE	W3,VALUE OF FIXUP
;	PUSHJ	P,SY.CHP

SY.CHP::HRRZ	R,R		;CLEAR RELOCATION BITS
	CAILE	R,FS.SS-FX.S0	;VALIDATE INDEX
	PUSHJ	P,INVIDX	;INVALID INDEX
	PUSH	P,T2		;SAVE ADDRESS
	MOVEI	T2,3		;NEED 3 WORD BLOCK
	PUSHJ	P,FX.GET##	;IN FIXUP AREA
	POP	P,T2		;REL ADDRESS (TO SEGMENT) OF REQUEST
	MOVEM	T2,1(T1)	;STORE IN BLOCK
	MOVEM	W3,2(T1)	;AND VALUE
	SUB	T1,FX.LB	;REMOVE SET
	HRRZ	T2,T2		;ADDRESSES ARE ONLY 18 BITS
	AOS	FXC.S0(R)	;INCREMENT COUNT OF FIXUPS PER SEGMENT

;NOW TO LINK IN CHAIN, HERE WITH
;R = OFFSET TO INITIAL POINTER
;T1 = ADDRESS (REL TO FX.LB) OF THIS BLOCK
;T2 = VALUE (ADDRESS REL TO SEG OF FIXUP)
;USES T3, T4 AS POINTERS


SY.FP0:	SKIPE	FX.S0(R)	;VIRGIN CHAIN?
	JRST	SY.FP1		;NO
	HRL	T1,T1		;BOTH ENDS POINT TO SAME LOC
	MOVEM	T1,FX.S0(R)	;STORE LINK
	POPJ	P,		;RETURN


INVIDX:	POP	P,T1		;GET LOCATION
	HRRZS	T1		;CLEAR FLAGS
	.ERR.	(MS,.EC,V%L,L%F,S%F,IVC,<Index validation check failed at >)
	.etc.	(oct,.ep,,,,t1)
;HERE IF CHAIN ALREADY SETUP
SY.FP1:	HLRZ	T3,FX.S0(R)	;GET PTR TO TOP OF CHAIN
	ADD	T3,FX.LB	;ADD IN OFFSET
	SETZ	T4,		;PREV PTR WAS START OF CHAIN
	JRST	SY.FP4		;FIRST TIME THROUGH LOOP

SY.FP2:	HRLZ	T4,T4		;SAVE LAST IN LEFT HALF
	HRR	T4,T3		;SAVE THIS IN RIGHT
	HLRZ	T3,(T4)		;GET NEXT LOWER
	JUMPE	T3,SY.FX6	;END IF ZERO
	ADD	T3,FX.LB	;ADD IN OFFSET
SY.FP4:	HLL	T2,1(T3)	;GET INDEX SO COMPARE WILL WORK
	CAML	T2,1(T3)	;FIND ADDRESS SMALLER THAN WHAT WE HAVE
	JRST	SY.FP3		;YES, LINK INTO LIST
	JRST	SY.FP2		;NO, TRY AGAIN

SY.FX6:	HRLM	T1,(T4)		;ADD TO END
	HRRM	T1,FX.S0(R)	;AND TO INITIAL PTR
	SUB	T4,FX.LB	;-OFFSET
	ADD	T1,FX.LB	;+OFFSET
	HRRZM	T4,(T1)		;FORWARD LINK
	POPJ	P,

SY.FP3:	TRNN	T4,-1		;START OF CHAIN IF 0 ADDRESS
	JRST	SY.FP5		;YES, USE PREV POINTERS
	HRRM	T1,(T3)		;FWD PTR IN NEXT LOWER
	HRLM	T1,(T4)		;BKW PTR IN NEXT HIGHER
	ADD	T1,FX.LB	;ADD OFFSET
	SUB	T4,FX.LB	;REMOVE OFFSET
	SUB	T3,FX.LB	;FROM ADJACENT BLOCKS
	HRRM	T4,(T1)		;STORE IN LINK ADDRESS
	HRLM	T3,(T1)
	POPJ	P,

;HERE IF NEW ADDRESS IS BIGGEST YET
SY.FP5:	HRRM	T1,(T3)		;LINK BACK IN CHAIN
	HRLM	T1,FX.S0(R)	;AND INITIAL PTR
	ADD	T1,FX.LB	;FIX
	SUB	T3,FX.LB	;REMOVE OFFSET
	HRLZM	T3,(T1)		;BACKWARDS PTR
	POPJ	P,
SUBTTL	MULTIPLY DEFINED GLOBAL

;HERE IF MULTIPLY DEFINED GLOBAL SYMBOL
;ENTER WITH W1, W2, W3 CONTAIN NEW SYMBOL
;P1 IS POINTER TO OLD SYMBOL
;USES T1

SY.MDS::
IFN FTOVERLAY&0,<
	MOVE	T1,0(P1)	;GET FLAGS
	TXNE	T1,PS.BGS	;WAS FIRST DEFINITION FROM BOUND LINK?
	JRST	SY.BMD		;YES, SO USE NEW DEFINITION
>
	MOVE	T1,0(P1)	;GET CURRENT FLAGS
	TLON	T1,PS.MDF	;FLAG IT MULTIPLY DEFINED
	AOS	MSYM		;AND COUNT ONE MORE IF NEW
	MOVEM	T1,0(P1)
	MOVE	T1,2(P1)	;CURRENT VALUE
	.ERR.	(MS,.EC,V%L,L%F,S%W,MDS,<Multiply-Defined Global symbol >)
	.ETC.	(SBX,.EC!.EP,,,,W2)	;SYMBOL IN W2
	.ETC.	(STR,.EC,,,,,<, in module >)
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM)
	.ETC.	(STR,.EC,,,,,<
	defined value = >)
	.ETC.	(OCT,.EC!.EP,,,,T1)	;CURRENT VALUE
	.ETC.	(STR,.EC,,,,,<, this value = >)
	.ETC.	(OCT,.EP,,,,W3)		;IN W3
	SETZM	LSTSYM		;SO WE DON'T DO FIXUPS?
	TLO	W1,PS.MDF	;STORE FLAG IN LOCAL DEFINITION
	PJRST	LS.ADD		;AND PUT IN LOCAL TABLE

;HERE IF MULTIPLE DEFINITION IS WITH A BOUND LINK
IFN FTOVERLAY&0,<
SY.BMD:	TXNN	T1,PS.RBG	;RELOCATABLE ALSO?
	JRST	[MOVEM	W1,0(P1)	;NO
		JRST	SY.RF]		;FILL IN REFS NOW
	HALT
>
;HERE TO FILL IN PARTIAL VALUE SYMBOL (SYM1=SYM2)
;PRIMARY VALUE IS USUAL CHAINED REFERENCES
;SECONDARY VALUE IS ADDITIVE VALUE OF PARTIAL DEFINITION
;THERE MAY ALSO BE ADDITIVE GLOBAL FIXUPS REQUIRED

;CALLED BY
;	MOVE	T1,ADDRESS OF GLOBAL TO FIXUP
;	MOVE	T2,FLAGS FOR FIXUP TYPE
;	MOVE	W3,FIXUP VALUE
;	PUSHJ	P,SY.AS0

SY.AS1:	TLNE	T3,S.LST	;IF LAST TRIPLET
	JRST	SY.AS4		;GIVE UP

SY.AS0::ADDI	T1,.L		;GET NEXT TRIPLET
	MOVE	T3,(T1)		;GET FLAGS
	JUMPL	T3,SY.AS4	;JUST INCASE
	TLNN	T3,S.PVS	;IS THIS THE ONE WE WANT
	JRST	SY.AS1		;NO, TRY AGAIN
	PUSHJ	P,SY.AST	;FIXUP VALUE
	TLNE	W1,PS.UDF	;IF STILL UNDEFINED
	JRST	SY.AS4		;GIVE UP
	SOSGE	USYM		;ONE LESS UNDEFINED THEN
	PUSHJ	P,DUZERR	;BUT NOT TOO FAR
	MOVSI	T3,PS.REQ	;IF NOW FULLY DEFINED
	ANDCAM	T3,0(P1)	;CLEAR GLOBAL REQUEST FLAG IF SET
	MOVE	W3,2(T1)	;GET FIXUP VALUE (TEMP STORAGE ONLY)
	MOVE	T3,0(T1)	;AND FLAGS
	PUSH	P,T2		;SAVE T2 NOW (SAVES AN INST)
	TLNN	T3,S.LST	;LAST BLOCK
	PUSHJ	P,SY.AS5	;NO, GIVE BACK THE MIDDLE FIRST
	MOVEI	T2,.L		;GIVE IT BACK
	PUSH	P,T1		;SAVE ADDRESS
	PUSHJ	P,GS.RET##
	POP	P,T1		;GET BACK POINTER
	POP	P,T2
	MOVE	T3,-.L(T1)	;GET FLAGS
	JUMPL	T3,SY.AS2	;REACHED PRIMARY
	MOVSI	T3,S.LST	;SET THIS IS LAST TRIPLET NOW
	IORM	T3,-.L(T1)
	JRST	SY.AS3		;AND FINISH OFF


;HERE TO MOVE UP THE SECONDARY TRIPLETS
SY.AS5:	HRLZI	T2,.L(T1)	;NEXT TRIPLET
	HRRI	T2,0(T1)	;THIS TRIPLET
	ADDI	T1,.L		;POINT TO NEXT
	BLT	T2,-1(T1)	;MOVE IT UP
	SKIPG	T2,0(T1)	;GET FLAGS
	PUSHJ	P,ISPERR
	TLNN	T2,S.LST	;GOT THERE YET
	JRST	SY.AS5		;NO, TRY AGAIN
	POPJ	P,
SY.AS2:	MOVSI	T3,PT.EXT!PS.FXP	;REMOVE EXTENDED TRIPLET FLAG
	ANDCAM	T3,-.L(T1)	;SINCE WE DON'T HAVE IT NOW
SY.AS3:	EXCH	W3,2(P1)	;GET VALUES RIGHT WAY ROUND
				;AND FIXUP ALL REQUESTS
	MOVE	T2,W3		;GET START OF CHAIN
	MOVE	W3,2(P1)	;GET VALUE OF SYMBOL
	PUSHJ	P,SY.CHR	;RIGHT-HALF CHAINED FIXUP
	TLNN	W1,PS.FXP	;ANY FIXUPS TO BE DONE?
SY.AS4:	POPJ	P,		;NO
	PJRST	SY.RF2		;YES, DO ALL ADDITIVE FIXUPS

;HERE TO FIXUP PARTIAL VALUE EITHER RH OR LH
;ENTER WITH
;	T1 = PTR TO CURRENT EXTENDED TRIPLET
;	T2 = FLAGS (WHICH HALF TO FIXUP)
;	W3 = ADDITIVE VALUE

SY.AST::TLNE	T2,FS.FXR	;RIGHT HALF?
	JRST	SY.ASR		;YES
	TLNE	T2,FS.FXL	;LEFT HALF?
	JRST	SY.ASL		;YES
SY.ASF:	MOVE	T3,2(T1)	;GET CURRENT VALUE
	ADD	T3,W3		;ADD, IGNORE CARRY
	MOVEM	T3,2(T1)	;STORE VALUE BACK
	POPJ	P,

SY.ASR:	HRRZ	T3,2(T1)	;GET CURRENT VALUE
	ADDI	T3,(W3)		;IGNORE CARRY
	HRRM	T3,2(T1)	;STORE VALUE IN RIGHT
	POPJ	P,

SY.ASL:	HLRZ	T3,2(T1)	;GET CURRENT VALUE
	ADDI	T3,(W3)		;IGNORE CARRY
	HRLM	T3,2(T1)	;STORE BACK
	POPJ	P,

SUBTTL	SYMBOL ROUTINES

;HERE TO MOVE A SYMBOL TO ANOTHER (LARGER) AREA
;GENERALLY TO ADD EXTENDED TRIPLETS

;CALLED BY
;	MOVE	T1,EXTRA REQUIRED
;	MOVE	P1,ABS LOC OF PRIMARY
;	MOVE	P2,REL OFFSET OF PRIMARY
;	PUSHJ	P,SY.MOV
;RETURNS
;P1 = NEW ABS ADDRESS
;T1 = LAST SYMBOL TRIPLET IN USE

SY.MOV::PUSH	P,T1		;SAVE EXTRA
	PUSHJ	P,SY.CHK	;SEE HOW MUCH WE ALREADY HAVE
	EXCH	T2,0(P)		;SWAP SO WE SAVE LENGTH
	ADD	T2,0(P)		;THIS IS HOW MUCH WE WANT
	PUSHJ	P,GS.GET##	;GET IT
	HRRZ	P1,@HT.PTR	;RESET P1(INCASE CORE MOVED)
	ADD	P1,NAMLOC	;FIX IN CORE
	HRLZ	T2,P1		;MOVE FROM
	HRR	T2,T1		; TO
	MOVE	T3,T1		;UPTO
	ADD	T3,0(P)		;END
	BLT	T2,-1(T3)
	EXCH	P1,T1		;SWAP
	MOVE	T2,0(P)		;FINISHED WITH OLD AREA
				;UNLESS THERE ARE PARTIAL VALUE FIXUPS
	MOVE	T3,0(T1)	;GET FLAGS
	TLNN	T3,PT.EXT	;EXTENDED?
	JRST	SYMOV2		;NO DON'T WASTE TIME
	MOVE	T3,T1		;YES, MIGHT BE PARTIAL VALUES
SYMOV1:	ADDI	T3,.L		;ADVANCE TO NEXT SECONDARY
	SKIPGE	T4,0(T3)	;GET SECONDARY FLAGS
	JRST	SYMOV2		;DONE
	TLNE	T4,S.PVS	;ONLY WANT PARTIAL VALUE
	JRST	.+4		;YES, MUST SAVE A POINTER TO NEW BLOCK
	TLNN	T4,S.LST	;IF LAST TRIPLET WE ARE FINISHED
	JRST	SYMOV1		;NO TRY AGAIN
	JRST	SYMOV2		;NOTHING WORTH SAVING HERE

	MOVSI	T4,PT.SGN!PT.OTH!PO.IND	;SET FLAGS
	MOVEM	T4,0(T1)	;IN MEMORY
	MOVE	T4,P1		;GET NEW POINTER
	SUB	T4,NAMLOC	;MINUS OFFSET
	MOVEM	T4,2(T1)	;AS VALUE
	ADDI	T1,.L		;ADDVANCE
	SUBI	T2,.L
SYMOV2:	PUSHJ	P,GS.RET##	;SO GIVE IT BACK
	MOVE	T1,P1		;ABS ADDRESS
	SUB	T1,NAMLOC	;MAKE REL
	HRRM	T1,@HT.PTR	;RESET POINTER
	POP	P,T2		;GET LENGTH BACK
	MOVE	T1,P1
	ADD	T1,T2		;POINT TO END
	MOVSI	T3,S.LST	;WILL NOT BE LAST NOW, SO REMOVE FLAG
	SKIPL	-.L(T1)		;BUT NOT IF PRIMARY
	ANDCAM	T3,-.L(T1)
	POPJ	P,

;HERE TO COUNT THE NUNBER OF TRIPLETS IN A SYMBOL
;ENTER WITH P1 = ADDRESS (ABS)
;RETURN T2 = LENGTH
;USES T1
;STOPS ON EITHER LAST TRIPLET (S.LST) OR NEXT PRIMARY (PT.SGN)

SY.CHK::SKIPGE	T1,0(P1)	;SEE IF PRIMARY
	TLNE	T1,PT.EXT	;YES, BUT IS SYMBOL EXTENDED?
	JRST	SYCHK1		;MUST COUNT EXTENDED
	MOVEI	T2,.L		;THE EASY WAY TO GET LENGTH
	POPJ	P,		;JUST RETURN

SYCHK1:	HRRZ	T2,P1		;COPY STARTING ADDRESS
	JUMPGE	T1,SYCHK2	;JUMP IF SECONDARY ON ENTRY
	ADDI	T2,.L		;GET FIRST SECONDARY
SYCHK2:	SKIPGE	T1,0(T2)	;MAKE SURE NOT PRIMARY
	PUSHJ	P,ISPERR	;SHOULD NEVER HAPPEN
	ADDI	T2,.L		;ADVANCE PAST
	TLNN	T1,S.LST	;LAST TRIPLET?
	JRST	SYCHK2		;NOT YET
	SUBI	T2,(P1)		;YES, GET LENGTH
	POPJ	P,

;HERE TO RETURN OLD SYMBOL AREA BACK TO POOL
;MAY BE ANY LENGTH (MULTIPLE OF .L)
;ENTER WITH P1 = ADDRESS OF SYMBOL IN CORE
;USES T1, T2

SY.RET::PUSHJ	P,SY.CHK	;SEE HOW LONG IT IS
	HRRZ	T1,P1		;GET START ADDRESS
	SETZM	@HT.PTR		;DELETE IN SYMBOL TABLE
	PJRST	GS.RET##	;RETURN IT
;HERE TO SETUP T2 TO POINT TO INCORE ADDRESS
;ENTER WITH T2 = RELATIVE ADDRESS
;SETS UP RHS OF R, LEAVES RELOC BITS IN LHS
;RETURNS
;+1	ADDRESS NOT IN CORE (PAGING ONLY)
;+2	ADDRESS IN CORE AND T2 POINTS TO IT

SEGCHK::HRRI	R,2		;ASSUME IN HIGH SEG
	SKIPE	LL.S2		;MUST BE LOW IF ONLY ONE SEGMENT
	CAMGE	T2,LL.S2	;IN HIGH SEGMENT
	SOJA	R,.+2		;NO, IN LOW SEG
	SUB	T2,LL.S2	;REMOVE OFFSET
	SKIPE	PAG.S0(R)	;PAGING TO DSK?
	JRST	SEGCK1		;YES, CHECK IF ADDRESS IN CORE
	.JDDT	LNKLOD,SEGCHK,<<CAMN	T2,$LOCATION>>	;ABOUT TO STORE IN MONITORED LOCATION?
IFN FTOVERLAY,<
	TRNN	R,-2		;LOW SEG ONLY
	SUB	T2,PH.ADD	;REMOVE ORIGIN INCASE ABS ADDRESSES
>

SEGCKR:	HRR	R,@SG.TB
	ADD	T2,@RC.LB(R)
	JRST	CPOPJ1		;SKIP RETURN

;HERE WHEN PAGING TO DSK
;IF ADDRESS IS IN CORE POINT T2 TO IT
;OTHERWISE  LEAVE T2 ALONE AND JUST RETURN
SEGCK1:	CAML	T2,LW.S0(R)	;HIGHER THAN LOW BOUND?
	CAMLE	T2,UW.S0(R)	;BUT LOWER THAN HIGH BOUND?
	JRST	[ADD	T2,LL.S0(R)	;NO, SO PUT BACK ORIGIN
		POPJ	P,]		;NO, SO NOT IN CORE
	SUB	T2,LW.S0(R)	;REMOVE BASE ADDRESS
	JRST	SEGCKR		;GIVE OK RETURN




;HERE TO PUT REQUEST IN GLOBAL SYMBOL TABLE
;ENTER WITH
;W1 = SECONDARY TRIPLET FLAGS
;W2 = SYMBOL NAME
;W3 = FIXUP VALUE (NOT USED)
;+0(P) = RETURN ADDRESS
;-1(P) = VALUE OF PRIMARY TRIPLET
;-2(P) = FLAGS FOR PRIMARY TRIPLET
;
;NOTE, REMOVES 3 ITEMS FROM STACK

GS.FX0::MOVEI	T2,2*.L		;NEED EXTENDED SYMBOL
	PUSHJ	P,GS.GET##	;GET SPACE FOR SYMBOL
	TLO	W1,S.LST	;SIGNAL AS LAST TRIPLET
	TMOVEM	W1,.L(T1)	;STORE SECONDARY TRIPLET FLAGS, NAME, VALUE
	MOVE	W1,-2(P)	;GET PRIMARY FLAGS
	TLO	W1,PS.FXP!PT.EXT	;MARK ADDITIVE REQUESTS IN FIXUP TABLE
	MOVE	W3,-1(P)	;GET VALUE FROM STACK
	TMOVEM	W1,0(T1)	;STORE FLAGS, NAME, VALUE
	MOVE	W3,T1		;POINT TO INCORE BLOCK
	SUB	W3,NAMLOC	;INCASE IT MOVES
	PUSH	P,W3		;SAVE VALUE INCASE CORE MOVES
	PUSHJ	P,INSRT		;PUT IN GLOBAL TABLE
	POP	P,W3		;GET ADDRESS BACK (RELATIVE TO GX.LB)
	POP	P,T2		;GET RETURN ADDRESS
	SUB	P,[2,,2]	;REMOVE JUNK FROM STACK
	JRSTF	@T2		;AND RETURN


;HERE TO LINK FIXUP TRIPLET TO CURRENT GLOBAL TRIPLET
;ENTER WITH FIXUP ADDRESS (RELATIVE TO FX.LB)
;IN W3 (SET BY SY.FX0)
;AND GLOBAL ADDRESS (RELATIVE TO GX.LB)
;IN P2
;NOTE BOTH TABLES MAY MOVE

SY.GX0::HRRZ	T1,@HT.PTR	;FIND OUT WHERE GLOBAL TRIPLET
	ADD	T1,NAMLOC	;IS IN CORE
	HRRZM	W3,.L+2(T1)	;FIXUP POINTER TO FIXUP LIST
	POPJ	P,
;HERE TO PUT SYMBOL INTO FIXUP TABLE
;ENTER WITH
;W1 = FLAGS
;W2 = SYMBOL
;W3 = VALUE
;RETURN WITH
;W3 = POINTER TO LOCATION RELATIVE TO FX.LB

SY.FX0::MOVEI	T2,.L		;SPACE IN 3 WORD CHUNKS
	PUSHJ	P,FX.GET##	;SPECIAL SPACE GETTER
	TMOVEM	W1,0(T1)	;STORE FIXUP REQUEST
	MOVE	W3,T1		;PUT ADDRESS IN W3
	SUB	W3,FX.LB	;MAKE IT RELATIVE TO ORIGIN
	POPJ	P,		;RETURN

;HERE TO SEE IF SYMBOL REQUESTED FOR SYMBOL TABLE FIXUP WAS LAST
;SYMBOL DEFINED (NOT FULLY DEFINED OF COURSE)
;CALLED BY
;	MOVE	W3,SYMBOL
;	PUSHJ	P,SY.RLS
;RETURNS
;+1	NOT LAST SYMBOL DEFINED
;+2	LAST SYMBOL DEFINED
;T1=	ADDRESS OF SYMBOL IN LOCAL TABLE
;T2=	ADDRESS OF SYMBOL IN GLOBAL TABLE

SY.RLS::HRRZ	T1,LSTSYM	;GET LOCAL ADDRESS
	JUMPE	T1,.+3		;LEAVE ZERO ALONE
	ADD	T1,LS.LB	;RELOCATE
	SUB	T1,LW.LS	;BUT REMOVE WINDOW BASE
	HLRZ	T2,LSTSYM	;AND GLOBAL
	SKIPE	T2
	ADD	T2,NAMLOC	;RELOCATE
	JUMPE	T1,[JUMPE T2,CPOPJ	;NO LOCALS, TRY GLOBAL
		CAME	W3,1(T2)	;IF IN GLOBAL TABLE
		POPJ	P,		;NO MATCH
		JRST	SYRLSM]		;GOT IT HERE
	CAME	W3,1(T1)	;SAME?
	POPJ	P,		;NO
SYRLSM:	MOVE	W3,LSTSYM	;YES, SET POINTER IN W3
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,
SUBTTL	COMPILER SPECIFIC ROUTINES

DEFINE X(A,B)<
 IF1,<BLOCK	1>
 IF2,<
  IFDEF B'NAM,<
	PUSHJ	P,B'NAM
  >
  IFNDEF B'NAM,<
	PUSHJ	P,CPUTST
>>>
CT.NAM::PROCESSORS

DEFINE X(A,B)<
	B'BIT
>
CT.BIT::	PROCESSORS

CP.BIT::	CPUS
SALL

;CALLED BY	PUSHJ	P,xxxNAM
;
;ENTER WITH
;T1 = INDEX TO CT.TAB
;T2 = INDEX TO CP.TAB
;T3 = PROCSN (CT.BIT)
;T4 = CPUSN (CP.BIT)
;-1(P) = BLANK COMMON

;HERE IF ALGOL MAIN PROGRAM - SETS THIS AS PROGRAM NAME
ALGNAM:	SKIPN	-1(P)		;SEE IF BLANK COMMON SET
	JRST	CPUTST		;USES COMMON SIZE AS MAIN PROG MARKER.
	SETZM	-1(P)		;CLEAR COMMON SIZE
	MOVEM	W2,LODNAM	;SAVE NAME
	MOVEM	T1,MNTYPE	;AND SAVE ALGOL AS MAIN PROG TYPE
	JRST	CPUTST

F40NAM:
IFN FTOVERLAY,<
 IFN FMXFOR,<
	SKIPN	MIXFOR		;ALLOWED TO MIX?
	JRST	.+3		;YES
 >
	SKIPE	OVERLW		;SEEN /OVERLAY?
	JRST	F40OVE		;YES
>
IFN FMXFOR,<
	SKIPE	MIXFOR		;WANT TO MIX F40 & F-10?
	JRST	[HRRZS	MIXFOR		;YES
		JRST	CPUTST]
>
	TXNN	T3,FORBIT	;CAN NOT HAVE BOTH
	POPJ	P,
	JRST	F40ERR		;ERROR
IFN FTOVERLAY,<
F40OVE:	.ERR.	(MS,.EC,V%L,L%F,S%F,FOV,<Cannot overlay F40 compiled code in >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
>

CBLNAM:	JUMPE	T3,CPUTST	;OK FIRST TIME
	TXNE	T3,CBLBIT	;OR IF COBOL ALREADY SEEN
	JRST	CPUTST
	.ERR.	(MS,0,V%L,L%F,S%F,CMF,<Cobol module must be loaded first>)
;FORTRAN-10

FORNAM:
IFN FMXFOR,<
	SKIPE	MIXFOR		;DO WE NEED MIXFOR FEATURE?
	JRST	FORKLG		;YES>
	TXNN	T3,F40BIT
	JRST	FORCPU		;SEE IF WE CARE ABOUT CPU
F40ERR:	.ERR.	(MS,0,V%L,L%F,S%F,FON,<Cannot mix F40 and FORTRAN-10 compiled code>)

IFN FMXFOR,<
FORKLG:	HRRZS	MIXFOR		;MAKE IT POSITIVE>
FORCPU:	PUSHJ	P,CPUTST	;TEST IF CAN LOAD WITH CURRENT PROGS
	MOVE	T1,OTSEG	;DID USER SPECIFY NON-REENT OTS?
	SOJE	T1,CPOPJ	;YES, SO LOAD TWO SEG CODE IN TWO SEGMENTS
IFN FTOVERLAY,<
	SKIPGE	LNKMAX		;ONLY IF WE ARE IN ROOT TEST
>
	SKIPN	HC.LB		; IF ANY HIGH LOADED
	TRNE	FL,R.FNS!R.FLS!R.FHS!R.LSO!R.HSO	;ANY REASON TO KEEP SEGMENTS DISTINCT?
	POPJ	P,		;EITHER USER HAS SPECIFIED WHICH, OR ALREADY LOADED HIGH
				;IN EITHER CASE RIGHT THING HAPPENS
	TRO	FL,R.FLS	;NO, SO FORCE LOW SEGMENT
	POPJ	P,		;SO FOROTS WILL BE SHAREABLE

DEFINE X(A,B)<
	EXP	CPU'B
>
CPUUNK==CPOPJ			;RUNS ON ANY CPU
CPUTBL:	CPUS

CPUTST:	JRST	@CPUTBL(T2)	;DISPATCH TO RIGHT TEST

CPUKI:	TXNE	T3,KABIT
	JRST	CPUERR		;CAN NOT MIX
	POPJ	P,		;OK

CPUKA::	TXNN	T3,KIBIT	;CANNOT HAVE BOTH KA10 AND KI10
	POPJ	P,		;OK
CPUERR:	.ERR.	(MS,0,V%L,L%F,S%F,KIA,<Cannot mix KI10 and KA10 compiled code>)

SUBTTL	MIXFOR FEATURE

IFN FMXFOR,<
.MXFOR::MOVE	R2,ENTPTR	;GET AOBJN POINTER TO NAMES
	MOVE	R3,MIXFOR	;GET POINTER TO ADDRESSES
MXFOR1:	HRRZ	P4,(R3)		;GET ENTRY ADDRESS
	JUMPE	P4,MXFOR5	;IGNORE 0 (F-10 MAIN PROG)
	PUSHJ	P,ADCKMX	;GET WORD IT POINTS TO
	MOVS	T1,T1		;SHOULD BE ONLY LEFT HALF
	CAIE	T1,(JFCL)	;F-10 MAIN
	CAIN	T1,015000	;F40 MAIN (RESET.)
	JRST	MXFOR5		;YES, IGNORE
	MOVEI	R,1		;ALWAYS STORE IN LOW SEGMENT
	MOVE	R,@RC.TB	;SINCE JSA CODE IS INPURE
	MOVEI	P2,4		;NEED 4 WORDS
	PUSHJ	P,MXFCOR	;GET CORE FOR FIXUP
	MOVSI	W1,(CAIA)	;SKIP IF PUSHJ, DON'T IF JSA
	CSTORE			;STORE IN CORE
	MOVSI	W1,(PUSHJ 17,)	;PUSHJ 17,.MXFOR##
	ADDI	P3,1		;INCREMENT DEPOSIT POINTER
	CSTORE
	ADDI	P3,1		;FOR PUSHJ 17,.SAV15##
	CSTORE
	MOVSI	W1,(JRST)	;JUMP TO ENTRY POINT
	HRR	W1,(R3)		;ADDRESS OF ENTRY
	ADDI	P3,1
	CSTORE
	MOVSI	W1,PT.SGN!PT.SYM!PS.ENT	;SET PS.ENT TO BYPASS TEST AT SY.GS
	MOVE	W2,(R2)		;SYMBOL
	MOVEI	W3,-3(P3)	;NEW VALUE OF ENTRY POINT
	SUB	W3,LC.LB	;MINUS OFFSET
	PUSHJ	P,SY.GS##	;DEFINE ENTRY NOW
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['.MXFOR']	;NOW FOR REQUEST
	ADDI	W3,1		;ADDRESS FOR PUSH P,.MXFOR
	PUSHJ	P,SY.RQ##
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['.SAV15']
	ADDI	W3,1
	PUSHJ	P,SY.RQ##
	HRRZ	P4,(R3)		;GET ADDRESS OF UNMODIFIED ENTRY POINT
	PUSHJ	P,ADCKMX	;ADDRESS CHECK INCASE ON DSK
	TLC	T1,(JUMP)	;F40 SUBROUTINE HAS ARG OPCODE HERE
	JUMPN	T1,MXFOR6	;NO, NON-ZERO IS FORTRAN-10
;HERE FOR F40 CODE

MXFOR2:	PUSHJ	P,ADCKL1	;GET NEXT WORD
	TLC	T1,(JRST)	;SEE IF END OF ARGS
	TLNN	T1,-1		;BY JRST 2M
	JRST	MXFR2A		;YES
	TLC	T1,035016	;JRST XOR PUSH 0(16)
	TLNE	T1,-1		;LOOK FOR PUSH 0,N(16)
	JRST	MXFOR2		;NO
	PUSH	P,T1		;SAVE ADDRESS
	MOVE	T1,RC.CV(R)	;GET NEXT FREE LOC
	HRLI	T1,(JRST)	;JRST [CODE]
	MOVEM	T1,(P3)		;STORE
	MOVEI	P2,3		;NEED 3 WORDS
	PUSHJ	P,MXFCOR	;FROM FREE CORE
	POP	P,W1		;GET ADDRESS
	HRLI	W1,(MOVEI 1,@(16))	;GET ADDRESS IN AC 1
	CSTORE
	MOVE	W1,[PUSH 0,1]	;STACK IT
	ADDI	P3,1
	CSTORE
	HRRZI	W1,1(P4)	;GET ADDRESS TO RETURN TO
	HRLI	W1,(JRST)
	ADDI	P3,1
	CSTORE
	AOJA	P4,MXFOR2	;TRY AGAIN

MXFR2A:	HRRZ	P4,(R3)		;GET ADDRESS OF UNMODIFIED ENTRY POINT
	SUBI	P4,1		;BACKUP 1
	PUSHJ	P,ADCKMX	;MAKE SURE ITS IN CORE
	MOVE	P4,(P3)		;SHOULD BE JRST 2M
	TLC	P4,(JRST)	;MASK LEFT 18 BITS
	TLNE	P4,-1		;ALL ZERO
	JRST	MXFERR		;NO, SO GIVE UP
MXFOR3:	PUSHJ	P,ADCKMX	;GET NEXT DATA WORD
	TLC	T1,(JRA 16,(16))	;LOOK FOR RETURN INST
	TLNE	T1,-1		;
	AOJA	P4,MXFOR3	;NOT YET, INCR AND TRY AGAIN
	MOVSI	T1,(POPJ 17,)	;CHANGE TO POPJ RETURN
	MOVEM	T1,(P3)
	PUSHJ	P,ADCKL1	;GET NEXT DATA WORD
				;INCASE MULTIPLE RETURNS
	TLC	T1,(ADD 16,)	;COMPILED CODE IS ALWAYS ADD 16,TEMP#
	TLNE	T1,-1		;WHERE TEMP# CONTAINS NUMBER OF RETURN
	JRST	MXFOR5		;SINGLE RETURN ONLY
	PUSHJ	P,ADCKL1	;GET NEXT WORD
	TLC	T1,(JRA 16,@(16))	;MULTIPLE RETURN HAS INDIRECT BIT ON
	TLNE	T1,-1
	JRST	MXFERR		;ERROR
	MOVSI	T1,(SOJA 16,)	;CHANGE INST TO SOJA 16,.JRA16##
MXFOR4:	MOVEM	T1,(P3)
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['.JRA16']
	MOVE	W3,P4		;LOCATION
	PUSHJ	P,SY.RQ##	;REQUEST CHAINED FIXUP
MXFOR5:	ADDI	R3,1		;GO ON TO NEXT
	AOBJN	R2,MXFOR1	;IF THERE IS ONE
	MOVE	T1,MIXFOR	;ADDRESS OF MIXFOR BLOCK
	HLRE	T2,ENTPTR	;-LENGTH OF IT
	MOVM	T2,T2		;+LENGTH
	PUSHJ	P,DY.RET##	;RESTORE
	SETOM	MIXFOR		;RESET MIXFOR CONTROL
	PJRST	T.5ENT##	;RESTORE AND RETURN

;HERE IF FORTRAN-10, TEST FOR MULTIPLE RETURN

MXFOR6:	PUSHJ	P,ADCKMX	;LOAD DATA WORD
	TLC	T1,(JRST)	;LOOK FOR FIRST JRST OUT OF PROLOGUE
	TLNE	T1,-1
	AOJA	P4,MXFOR6	;NOT YET
	SKIPA	W1,T1		;STORE ADDRESS OF INST AFTER EPILOGUE
MXFOR7:	PUSHJ	P,ADCKMX	;GET NEXT DATA WORD
	TLC	T1,(POP 17,(17))	;LOOK FOR WHERE MULTIPLE RETURN
	TLNN	T1,-1		;CLEARS THE STACK
	JRST	MXFOR8		;FOUND IT, WE NEED TO KEEP THIS ON STACK
	TLC	T1,(POP 17,(17))	;PUT INST BACK AS IT WAS
	TLC	T1,(HRRM 1,(17))	;INCASE NEWER FORM OF RETURM
	JUMPE	T1,[MOVEI T1,-2		;YES, SO STORE RETURN
		HRRM	T1,(P3)		;AT RIGHT PLACE ON STACK
		JRST	MXFOR5]		;AND TRY NEXT
	CAIGE	P4,(W1)		;DON'T GO TOO FAR
	AOJA	P4,MXFOR7	;BUT LOOK FAR ENOUGH
	JRST	MXFOR5		;CANNOT FIND MULTIPLE RETURN

MXFOR8:	MOVSI	T1,(JFCL)	;REPLACE POP BY NOOP
	MOVEM	T1,(P3)
MXFOR9:	PUSHJ	P,ADCKMX	;GET NEXT DATA WORD
	TLC	T1,(JRST @(16))	;LOOK FOR MULTIPLE RETURN
	TLNN	T1,-1
	JRST	[MOVSI	T1,(JRST)	;FOUND IT
		JRST	MXFOR4]		;REPLACE BY JRST .JRA16##
	CAIGE	P4,(W1)		;GONE TOO FAR?
	AOJA	P4,MXFOR9	;NOT YET
;	JRST	MXFERR		;SHOULD HAVE FOUND IT BY NOW

;HERE IF SUBROUTINE IS NOT STANDARD FORM
MXFERR:	.ERR.	(MS,.EC,V%L,L%W,S%W,FSF,<Fortran subroutine >)
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM)
	.ETC.	(STR,,,,,,< not in expected form, MIXFOR fixup not done>)
	JRST	MXFOR5		;TRY NEXT

MXFCOR:	MOVE	P3,RC.CV(R)	;GET CURRENT RELOC COUNTER
	ADDB	P2,RC.CV(R)	;NEW RELOC COUNTER
	CAMLE	P2,HL.S1	;RESET HIGHEST LOCATION COUNTER
	MOVEM	P2,HL.S1	;
	CAMLE	P2,HC.S1	;AND HIGHEST DATA LOADED COUNTER
	MOVEM	P2,HC.S1
	SKIPE	PAG.S1		;PAGING?
	JRST	MXFPAG		;YES, SEE IF IN CORE
	ADD	P2,LC.LB	;RELOCATE RELATIVE ADDRESS
	CAMG	P2,LC.AB	;WILL IT FIT IN EXISTING SPACE?
	JRST	MXFINC		;YES
	SUB	P2,LC.AB	;GET EXTRA REQUIRED
	MOVEI	P1,LC.IX	;AREA REQUIRED TO EXPAND
	PUSHJ	P,LNKCOR##	;TRY TO GET MORE SPACE
	  JRST	MXFPAG		;FAILED, BUT MUST BE ON DSK BY NOW
	SUB	P3,LW.S1	;INCASE WE DUMPED CORE FOR FIRST TIME
MXFINC:	ADD	P3,LC.LB	;FINALLY FIX THIS INCASE CORE MOVED
	POPJ	P,

MXFPAG:	PUSHJ	P,PG.LSG	;TEST IF IN CORE
	JRST	MXFINC		;NOW IN CORE

;HERE TO ADDRESS CHECK FIXUP LOCATION
;ENTER WITH ADDRESS (REL) IN P4
;RETURN WITH ABS ADDRESS IN P3
;CONTENTS OF P3 IN T1
;
ADCKL1:	ADDI	P4,1		;GET NEXT LOCATION
ADCKMX:	MOVE	P2,P4		;GET UPPER ADDRESS REQUIRED
	MOVE	P3,P4		;AND LOWER
	SKIPE	PAG.S1		;PAGING?
	PUSHJ	P,PG.LSG	;YES, MAKE SURE IN CORE
	ADD	P3,LC.LB	;FIXUP ADDRESS IN CORE
	MOVE	T1,(P3)		;GET CONTENTS
	POPJ	P,

>;END IFN FMXFOR
SUBTTL	STORE CODE IN FX AREA

T3HOLD::MOVEI	T2,.IPS		;STORE CODE IN INTERNAL PAGES
	PUSHJ	P,DY.GET##	;FIRST BLOCK IN DY, REST IN FX
	MOVE	T2,[3,,1]	;BLOCK HEADER
	MOVEM	T2,1(T1)	;FOR RE-READ
	MOVEM	W1,3(T1)	;STORE HIGH SEG ORIGIN
	MOVEI	W2,3(T1)	;POINT TO NEXT FREE LOC
	HRLI	W2,-.IPS+3	;AOBJN WORD FOR THIS BLOCK
	PUSH	P,T1		;SAVE ORIGIN
T3HEDR:	PUSHJ	P,D.IN1		;GET NEXT HEADER
	HLRZ	T1,W1		;GET TYPE
	CAIN	T1,5		;NEED END BLOCK
	JRST	T5FND		;FOUND IT
	PUSHJ	P,FXHOLD	;HOLD CODE IN FX AREA
	JRST	T3HEDR		;AND CONTINUE

;HERE TO STORE BLOCK IN CORE (FX)
;ENTER WITH W1 = FIRST DATA WORD

FXHOLD:	HRRZ	T1,W1		;GET WORD COUNT
	JUMPE	T1,CPOPJ	;IGNORE 0
	CAIG	T1,^D18		;ONLY 1 SUB BLOCK
	AOJA	T1,FXHLD0	;YES
	IDIVI	T1,^D18		;NO, COUNT NO.
	IMULI	T1,^D19		;ADD RELOCATION WORD
	JUMPE	T2,FXHLD0	;NO REMAINDER
	ADDI	T1,1(T2)	;ADD REMAINDER + BYTE WORD
FXHLD0:	SKIPA	W3,T1		;NO OF WORDS IN THIS BLOCK
FXHLD1:	PUSHJ	P,D.IN1		;GET NEXT WORD
	AOBJP	W2,FXHLD3	;RAN OUT OF SPACE
FXHLD2:	MOVEM	W1,(W2)		;STORE IT
	SOJGE	W3,FXHLD1	;LOOP FOR ALL OF BLOCK
	POPJ	P,		;GET NEXT BLOCK

FXHLD3:	SUBI	W2,.IPS		;BACKUP POINTER TO START OF BLOCK
	CAMGE	W2,FX.LB	;IS LIST IN FX OR DY
	TLOA	W2,-1		;IN DY
	SUB	W2,FX.LB	;IN FX, REMOVE OFFSET
	MOVEI	T2,.IPS		;GET NEXT BLOCK
	PUSHJ	P,FX.GET##	;IN FIXUP AREA
	TLZN	W2,-1		;WAS IT IN DY
	ADD	W2,FX.LB	;NO, PUT BACK OFFSET
	EXCH	T1,W2		;NEW POINTER IN W2, OLD IN T1
	MOVE	T2,W2		;COPY IT
	SUB	T2,FX.LB	;REMOVE OFFSET
	SUB	T2,LW.FX	;INCASE PAGING
	MOVEM	T2,(T1)		;FIXUP POINTER
	HRLI	W2,-.IPS	;FORM AOBJN POINTER
	AOBJN	W2,FXHLD2	;STORE CURRENT WORD IN NEW BLOCK

;HERE WHEN END BLOCK FOUND

T5FND:	MOVEI	T1,2		;ONLY STORE FIRST 3 WORDS
	PUSHJ	P,FXHLD0
	PUSH	P,W1		;SAVE HIGH SEG BREAK
	PUSHJ	P,FXHLD1	;FINISH OFF BLOCK
	POP	P,W1		;DATA WORD BACK
				;NOW GET FIRST BLOCK BACK
	POP	P,W2
	HRRZ	T1,3(W2)	;GET HISEG ORIGIN
	CAIG	W1,(T1)		;IS THERE ANY HIGH SEG CODE?
	JRST	[SETZM 1(W2)		;NO HIGH SEG
		SETZM	3(W2)		;SO REMOVE BLOCK TYPE 3
		JRST	T5FND1]		;AND LOAD REST INTO 1 SEG
	HRLM	W1,3(W2)	;NOW WE HAVE A VALID BREAK
T5FND1:	PUSH	P,DCBUF		;STACK REAL BUFFER HEADER
	PUSH	P,DCBUF+1
	PUSH	P,DCBUF+2
	MOVEI	T1,.IPS-1	;MAX NO. OF WORDS IN BUFFER
	MOVEM	T1,DCBUF+2
	HRRM	W2,DCBUF+1	;NEW BUFFER HEADER
	SETZM	DCBUF		;SIGNAL INCORE
	JRST	LOAD		;AND TRY AGAIN

;HERE TO GET NEXT BUFFER
;MOVE IT FROM FX AREA TO DY AREA (FIXED ADDRESS)

FXREAD:	PUSHJ	P,.PSH4T##	;NEED SOME TEMP ACCS
	HRRZ	T1,DCBUF+1	;GET FINAL BYTE POINTER
	SUBI	T1,.IPS-1	;BACKUP
	HRRM	T1,DCBUF+1
	MOVEI	T2,.IPS-1	;NO OF WORDS IN BUFFER
	MOVEM	T2,DCBUF+2
	SKIPN	T1,(T1)		;GET FIRST WORD (POINTER)
	HALT
	SKIPE	PAG.FX		;PAGING?
	HALT
	ADD	T1,FX.LB	;ADD IN BASE
	HRRZ	T2,DCBUF+1	;ADDRESS OF FIXED DY AREA ARRAY
	HRLZ	T3,T1		;FROM
	HRR	T3,T2		;TO
	BLT	T3,.IPS-1(T2)	;UNTIL
	MOVEI	T2,.IPS		;NOW GIVE BACK
	PUSHJ	P,FX.RET##
	PUSHJ	P,.POP4T##	;RESTORE T1-T4
	JRST	D.IN1		;AND CONTINUE READ

;HERE WHEN ALL DONE
T5FIN::	PUSHJ	P,FX.GBC##	;GARBAGE COLLECT FX AREA
	HRRZ	T1,DCBUF+1	;WHERE WE ARE NOW
	ADD	T1,DCBUF+2	;+ WHATS LEFT
	SUBI	T1,.IPS-1	;BACKUP
	SKIPE	(T1)		;BETTER HAVE FINISHED
	HALT
	MOVEI	T2,.IPS		;GIVE BLOCK BACK
	PUSHJ	P,DY.RET##
	POP	P,DCBUF+2
	POP	P,DCBUF+1
	POP	P,DCBUF
	JRST	T.LOAD		;GET NEXT BLOCK
	
SUBTTL	HERE TO TERMINATE LOAD

GO::	PUSHJ	P,LIBRARY	;LOAD DEFAULT LIBS
	SKIPN	W2,STADDR+1	;IS START ADDRESS STILL SYMBOLIC?
	JRST	GOUSYM		;NO
	MOVSI	W1,PT.SGN!PT.SYM
	PUSHJ	P,TRYSYM##	;SEE IF DEFINED BY NOW
	  JRST	GOSTER		;CANNOT HAPPEN
	  JRST	GOSTER		;UNDEFINED
	MOVE	T1,2(P1)	;GET VALUE
	ADDM	T1,STADDR	;CALCULATE VALUE
	SETZM	STADDR+1	;NOW KNOWN
GOUSYM:	SKIPN	USYM		;STILL SOME UNDEFS?
	JRST	LODXIT		;NO, GIVE UP
	MOVSI	W1,PT.SGN!PT.SYM	;MIGHT BE ALGOL REFERENCE
	MOVE	W2,['%OWN  ']
	SETZ	W3,
	PUSHJ	P,TRYSYM##	;SEE IF PENDING REQUEST
	  CAIA			;NOT IN TABLE
	  JRST	DEFOWN		;YES, NEEDS DEFINING
	JRST	LODXIT		;EXIT

GOSTER:	PUSHJ	P,STARTU##	;UNDEFINED MESSAGE
	SETZM	STADDR		;CLEAR ADDRESS
	SETZM	STADDR+1	;...
;	JRST	LODXIT
;HERE TO EXIT
;GO EITHER TO LNKMAP OR LNKXIT

LODXIT:	SKIPE	USYM		;ANY UNDEFINED SYMBOLS?
	PUSHJ	P,[PUSHJ P,.SAVE4##	;INCASE WE NEED THEM
		SETZ	T1,		;ON TTY ONLY
		PUSHJ	P,.TYOCH##	;INITIALIZE
		PUSH	P,T1		;STORE OLD
		MOVEI	T1,[ASCIZ	\?LNKUGS \]	;FATAL FOR BATCH
		SETZ	P2,		;NO TERMINATOR
		PJRST	UNDEF1##]	;AND JOIN OUTPUT ROUTINE
	RELEASE	DC,		;CLOSE INPUT I/O
	MOVEI	T1,DC		;FINISHED WITH INPUT BUFFERS NOW
	MOVEM	T1,IO.CHN
	PUSHJ	P,DVRET.##	;RETURN TO FREE POOL
	SETZM	IO.PTR+DC	;FORGET ABOUT IT
	PUSHJ	P,LODFIX	;DO ALL FIXUPS WE NEED
	MOVE	T1,MAPSW	;SEE IF WE NEED A MAP
	CAME	T1,[$MAPEND]	;AT THE END
	JRST	LNKXIT		;NO
	JRST	LNKMAP		;YES

LODFIX::SKIPN	W1,LINKTB	;ANY BLOCK TYPE 12 LINKS?
	JRST	B12NOT		;NO
	HRLI	W1,-LN.12	;FORM AOBJN WORD
B12LUP:	HLRZ	T2,(W1)		;GET END ADDRESS
	JUMPE	T2,B12END	;NONE
	HRRZ	W3,(W1)		;LAST ADDRESS
	PUSHJ	P,SEGCHK	;GET IN CORE ADDRESS
	  JRST	[HRLI	T2,CPF.RR	;NOT IN CORE
		PUSHJ	P,SY.CHP	;SO PUT IN FIXUP LIST
		JRST	B12END]		;AND RETURN FOR NEXT
	HRRM	W3,(T2)		;STORE IN CORE
B12END:	AOBJN	W1,B12LUP	;LOOP FOR ALL ITEMS
	HRRZ	T1,LINKTB	;ADDRESS OF TABLE
	MOVEI	T2,LN.12	;LENGTH
	PUSHJ	P,DY.RET##	;GIVE IT BACK
B12NOT:	SKIPN	P1,PRGPTR	;ANY BLOCK TYPE 16 TO RETURN?
	JRST	B16NOT		;NO
B16RET:	MOVEI	T1,(P1)		;ADDRESS
	MOVEI	T2,4		;SIZE
	HRRZ	P1,(P1)		;NEXT
	PUSHJ	P,DY.RET##	;RETURN SPACE
	JUMPN	P1,B16RET	;LOOP
B16NOT:	PJRST	COR.FX		;FIXUP ALL CODE CHAINS

LIBRARY::
	POP	P,T1		;RESTACK TOP 2 ITEMS
	EXCH	T1,(P)		;SO WE RETURN TO MAIN CALLER
	PUSH	P,T1		;UNTIL ALL LOADED
IFN FTOVERLAY,<
	SKIPE	OVERLW		;SEEN /OVERLAY?
	SKIPL	LNKMAX		;AND STILL IN ROOT?
	JRST	PRGTST		;NO
	TDO	FL,[L.LIB,,R.LIB]	;FORCE LIBRARY SEARCH MODE
	PUSHJ	P,QREENT	;WANT REENTRANT VERSION?
	  CAIA			;NO, LOAD AS IS
	TRO	FL,R.FLS	;YES, FORCE LOW SEG
	MOVEI	T2,F.LEN	;GET SPACE
	PUSHJ	P,DY.GET##	;FOR FILE SPEC
	MOVSI	T3,'SYS'	;DEFAULT DEVICE
	MOVE	T4,['OVRLAY']	;FILE NAME
	DSTORE	T3,F.DEV(T1),F.NAME(T1)
	MOVSI	T3,'REL'
	SETOM	F.NAMM(T1)	;SET MASK
	HLLOM	T3,F.EXT(T1)
	PUSHJ	P,LNKPRG	;PUT IN LIST
;	JRST	PRGTST
>
PRGTST:	SKIPG	PRGPTR		;ANYTHING TO DO HERE
	JRST	LIBTST		;NO, SEE IF ANY LIBRARIES
	TDZ	FL,[L.LIB,,R.LIB]	;INCASE WE WERE IN SEARCH MODE
	PUSH	P,P1		;NEED AN ACC
	MOVE	P1,PRGPTR	;GET START
PRGTS1:	SKIPGE	(P1)		;WANT THIS ONE?
	JRST	PRGTS2		;NO, ALREADY LOADED
	MOVEI	T2,F.LEN	;GET SPACE FOR DATA BLOCK
	PUSHJ	P,DY.GET##
	MOVE	T2,P1		;GET POINTER TO TYPE 16 BLOCK
	PUSHJ	P,PRGLIB	;TRANSFORM AND LINK IN
	HRROS	(P1)		;MARK AS LOADED
PRGTS2:	HRRZ	P1,(P1)		;GET NEXT ADDRESS
	JUMPN	P1,PRGTS1	;NOT DONE YET IF NON-ZERO
	HRROS	PRGPTR		;MARK WHOLE LIST DONE
	POP	P,P1
	PUSHJ	P,NXTLIB	;SETUP RETURN ADDRESS
	JRST	PRGTST		;SEE IF WE LOADED ANY MORE TYPE 16 BLOCKS

LIBTST:	SKIPN	LIBPTR		;ANY LIBRARIES
	JRST	USETST		;NO TRY USER DEFAULT LIBRARY(S)
	SKIPN	USYM		;YES, BUT ANY NEED FOR THEM
	JRST	REMLIB		;NO REMOVE THE SPACE THEY OCCUPY
	TDO	FL,[L.LIB,,R.LIB]	;GET INTO LIBRARY SEARCH MODE
	MOVEI	T2,F.LEN	;GET SPACE FOR DATA BLOCK
	PUSHJ	P,DY.GET##
	MOVE	T2,LIBPTR	;GET POINTER TO TYPE 17 BLOCK
	PUSHJ	P,PRGLIB	;TRANSFORM AND LINK IN
	MOVE	T1,LIBPTR	;GET POINTER BACK
	MOVE	T2,(T1)		;GET NEXT ADDRESS
	MOVEM	T2,LIBPTR	;AND STORE IT (ZERO IS END)
	MOVEI	T2,4		;GIVE BACK BLOCK
	PUSHJ	P,DY.RET##
	SKIPN	LIBPTR		;NOT DONE YET IF NON-ZERO
	PUSHJ	P,NXTLIB
	JRST	PRGTST		;INCASE WE LOADED ANY MORE TYPE 16 OR 17

;HERE FOR USER DEFINED DEFAULT LIBRARIES

USETST:	SKIPE	USYM		;ANY UNDEFS LEFT?
	SKIPG	USEPTR		;ANY LIBRARIES
	JRST	DEFTST		;NO, TRY SYSTEM DEFAULTS
	HRROS	USEPTR		;ONLY ONCE THOUGH
	PUSH	P,P1		;NEED A SAFE ACC
	MOVE	P1,USEPTR	;TO HOLD PTR TO LIST
USETS1:	MOVX	T1,1B0
	MOVN	T2,1(P1)	;GET LANGUAGE TYPE
	JUMPE	T2,USETS2	;ALWAYS WANTED
	LSH	T1,(T2)		;SHIFT INTO POSSITION
	TDNN	T1,PROCSN	;HAVE WE LOADED THIS TYPE?
	JRST	USETS3		;NO, GIVE IT A MISS
USETS2:	MOVEI	T2,F.LEN	;SPACE WE NEED
	PUSHJ	P,DY.GET##	;FOR LOOKUP BLOCK
	ADDI	T2,-1(T1)	;END OF BLT
	MOVEI	T3,2(T1)	;BYPASS FIRST 2 WORDS
	HRLI	T3,2(P1)	;BLT PTR
	BLT	T3,(T2)		;MOVE TO TEMP BLOCK
	PUSHJ	P,LNKPRG	;PUT IN LIST
USETS3:	HRRZ	P1,(P1)		;GET NEXT
	JUMPN	P1,USETS1	;DO IT
	POP	P,P1
;	JRST	DEFTST		;NOW FOR SYSTEM DEFAULT LIBS
DEFTST:	SKIPN	USYM		;ANYTHING TO DO?
	JRST	TPOPJ		;NO, REMOVE TOP RETURN
	TDO	FL,[L.LIB,,R.LIB]	;MAKE SURE
	PUSHJ	P,DEFLOD	;YES, TRY DEFAULT LIBS
	PUSHJ	P,NXTLIB
	SKIPN	PRGPTR		;SEE IF WE LOADED ANYMORE 16
	SKIPE	LIBPTR		;OR 17 BLOCKS
	JRST	PRGTST		;YES, CYCLE AGAIN
	SKIPE	PROCSN		;DID WE LOAD ANYTHING?
	JRST	DEFTST		;YES, TRY AGAIN
	MOVSI	W1,PT.SGN!PT.SYM	;FLAGS
	MOVE	W2,['%OWN  ']	;SYMBOL
	SETZ	W3,		;TRY AGAIN FOR %OWN
	PUSHJ	P,TRYSYM##
	  CAIA			;NOT IN TABLE
	  JRST	DEFOWN		;UNDEFINED
DEFXIT:	SETZM	GOTO		;BACK TO NORMAL SCANNING
	HRRZS	USEPTR		;BACK AS IT WAS
TPOPJ:	POP	P,T1		;REMOVE TOP RETURN
	POPJ	P,		;RETURN TO REAL CALLER

DEFOWN:	MOVE	W3,%OWN		;GET BASE
	PUSHJ	P,SY.GS##	;DEFINE
	JRST	DEFXIT


NXTLIB:	POP	P,GOTO		;STORE RETURN ADDRESS
	JRST	LNKWLD		;AND LOAD THIS

PRGLIB:	DMOVE	T3,1(T2)	;GET DEVICE & FILE NAME
	DSTORE	T3,F.DEV(T1),F.NAME(T1)
	SETOM	F.NAMM(T1)	;SET MASK
	MOVSI	T3,'REL'	;ASSUMED EXT IS REL
	HLLOM	T3,F.EXT(T1)	;WITH -1 MASK
	MOVE	T3,3(T2)	;GET PPN
	MOVEM	T3,F.DIR(T1)
				;NOW TO LINK INTO LIST
LNKPRG:	SKIPN	F.INZR		;FIRST TIME?
	JRST	FSTPRG		;YES
	MOVE	T2,F.NXZR	;GET CURRENT
	MOVEM	T1,(T2)		;STORE FORWARD POINTER
	MOVEM	T1,F.NXZR	;AND POINT TO IT
	POPJ	P,


FSTPRG:	MOVEM	T1,F.INZR	;SET FIRST POINTER
	MOVEM	T1,F.NXZR	;AND CURRENT
	POPJ	P,

DEFLOD:	MOVE	T1,NOLIBS	;GET MASK OF PROCESSORS NOT TO LOOK AT
	ANDCAM	T1,MNTYPE	;CLEAR THEM
	ANDCAM	T1,PROCSN
	SKIPE	@GS.LB		;LOAD JOBDAT UNLESS LOADED ORIGINALLY BY DEFAULT
	JRST	DEFLD2		; OR IF BEEN THROUGH LOOP ONCE ALREADY
	MOVE	P1,['JOBDAT']
	PUSHJ	P,LOAD1		;LOAD JOBDAT
	SETOM	@GS.LB		; BUT ONLY ONCE
DEFLD2:	SKIPN	T1,MNTYPE	;GET COMPILER OF MAIN PROG
	JRST	DEFLD1		;NO MAIN PROG (MAYBE 2ND TIME ROUND)
	ANDI	T1,7777		;REMOVE CPU BITS
	MOVE	T2,CT.BIT(T1)	;GET CORRESPONDING BIT
	ANDCAM	T2,PROCSN	;REMOVE FROM LIST TO LOOK AT
	PUSHJ	P,@MNTBL(T1)	;DO WHAT WE HAVE TO FOR IT
	SETZM	MNTYPE		;CLEAR INCASE MORE TYPE 16 ! 17
DEFLD1:	SKIPN	T1,PROCSN	;GET LIST OF OTHER  PROCS SEEN
	POPJ	P,		;ALL DONE
	JFFO	T1,.+1		;GET LEADING BIT
	MOVE	T1,CT.BIT(T2)	;GET BIT
	ANDCAM	T1,PROCSN	;CLEAR IT
	PUSHJ	P,@PRCTBL(T2)	;DO ACTION FOR THIS PROCESSOR
	JRST	DEFLD1		;LOOP


;HERE TO SEE IF LIBRARY IS ALREADY REQUESTED
;IF NOT PUT IN LIST OF FILES TO LOAD (IN SEARCH MODE)
;ENTER WITH P1 = SIXBIT \FILE.NAME\

LOAD1:	SKIPN	T1,F.INZR	;GET BASE OF LIST
	JRST	LOAD2		;NO LIST NO REQUESTS YET
	CAMN	P1,F.NAME(T1)	;ALREADY IN LIST
	POPJ	P,		;YES JUST RETURN
	MOVE	T1,F.NXT(T1)	;GET NEXT POINTER
	JUMPN	T1,.-3		;TRY IT
LOAD2:	MOVEI	T2,F.LEN	;GET SPACE
	PUSHJ	P,DY.GET##	;FOR DATA BLOCK
	MOVSI	T2,'SYS'	;ALL DEFAULT LIBS LIVE ON SYS (FOR NOW)
	MOVEM	T2,F.DEV(T1)
	MOVEM	P1,F.NAME(T1)	;STORE NAME
	SETOM	F.NAMM(T1)		;SET MASK
	MOVSI	T2,'REL'	;DEFAULT EXT IS REL
	HLLOM	T2,F.EXT(T1)
	PJRST	LNKPRG		;PUT IN LIST AND RETURN

REMLIB:	SKIPN	T1,LIBPTR	;GET SPACE TO REMOVE
	JRST	DEFXIT		;ALL DONE
	MOVE	T2,(T1)		;GET NEXT BLOCK
	HRRZM	T2,LIBPTR	;RESET POINTER
	MOVEI	T2,4		;SIZE OF BLOCK
	PUSHJ	P,DY.RET##	;GIVE IT BACK
	JRST	REMLIB		;LOOP

DEFINE X(A,B)<
 IF1,<
	BLOCK 1
 >
 IF2,<
  IFDEF B'.L0,<
	EXP	B'.L0
  >
  IFNDEF B'.L0,<
	EXP	CPOPJ
>>>
;HERE FOR TABLE FOR MAIN COMPILER
MNTBL:	PROCESSORS

;HERE FOR ALL OTHER PROCESSORS SEEN
DEFINE X(A,B)<
 IF1,<
	BLOCK	1
 >
 IF2,<
  IFDEF B'.L1,<
	EXP	B'.L1
  >
  IFNDEF B'.L1,<
	EXP	CPOPJ
>>>

PRCTBL:	PROCESSORS
	SALL
;HERE TO DO SPECIAL ACTION FOR SOME PROCESSORS

F40.L0:	SKIPL	FORLIB		;SEE WHICH LIBRARY WE WANT
	JRST	FORL00		;NEW FOROTS
IFN FMXFOR,<
	MOVE	T1,PROCSN	;GET LIST OF PROCESSORS SEEN
	TXNE	T1,FORBIT	;HAVE WE SEEN ANY FORTRAN-10 CODE?
	JRST	FOR.L2		;YES, NEED FOROTS THEN?
>
	PUSHJ	P,QREENT	;SEE IF WE WANT REENT OTS
	  JRST	F40L11		;NO
	MOVE	P1,['IMP40 ']	;LOAD REENT PART
	PUSHJ	P,LOAD1	
F40.L1:	SKIPL	FORLIB		;WANT FOROTS?
	JRST	FORL00		;YES
F40L11:	MOVE	P1,['LIB40 ']	;AND NON-RENT PART
	PJRST	LOAD1

FOR.L0:	SKIPL	FORLIB		;TEST TO SEE IF USER GAVE /FORSE
	JRST	FORL00		;NO
IFN FMXFOR,<
FOR.L2:>
IFL .FORLB,<
	AOSE	FORLIB		;SEE IF SET BY SWITCH OR DEFAULT
	JRST	FORL02		;DEFAULT, DON'T PRINT MESSAGE
>
	.ERR.	(MS,0,V%L,L%W,S%W,FSI,<FORTRAN-10 requires FOROTS, /FORSE switch ignored>)
FORL02:	SETZM	FORLIB		;IGNORE STUPID USER REQUEST
FORL00:	IFN FMXFOR,<
	MOVE	T1,PROCSN	;GET PROCESSORS SEEN
	SKIPE	MIXFOR		;IF WE DON'T WANT MIXFOR FIXUP
	TXNN	T1,F40BIT	;OR NO F40 CODE LOADED
	JRST	FORL01		;DON'T NEED FORJAK
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['FORSE.']	;GET IT BY REQUESTING FORSE
	SETZ	W3,
	PUSHJ	P,SY.RQ##	;GENERATE REQUEST
FORL01:>
	PUSHJ	P,QREENT	;SEE IF WE WANT REENT OTS
	  JRST	FOR.L1		;NO
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['FOROT%']	;SPECIAL SYMBOL
	MOVEI	W3,400000+.JBHDA	;VALUE
	PUSHJ	P,SY.GS##	;DEFINE IT
FOR.L1:	SKIPL	FORLIB		;TEST FOR USER SCREW-UP
	JRST	FORL10		;NO
	.ERR.	(MS,0,V%L,L%W,S%W,FSI)
	SETZM	FORLIB
FORL10:	MOVE	P1,['FORLIB']	;COMMON LIBRARY
	PJRST	LOAD1

CBL.L0:
CBL.L1:	MOVE	P1,['LIBOL ']
	PJRST	LOAD1

ALG.L0:	PUSHJ	P,QREENT	;SEE IF WE WANT REENT VERSION
	  JRST	ALG.L2		;NO
	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['%SHARE']
	SETZ	W3,
	PUSHJ	P,SY.RQ##	;PUT IN REQUEST
ALG.L1:	SKIPE	LODNAM		;SEE THE MAIN PROGRAM YET?
	JRST	ALG.L2		;YES
	.ERR.	(MS,,V%L,L%W,S%W,AMP,<ALGOL main program not loaded>)
ALG.L2:	MOVE	P1,['ALGLIB']
	PJRST	LOAD1

NLI.L0:
NLI.L1:	MOVSI	W1,PT.SGN!PT.SYM
	MOVE	W2,['%NELGO']	;DEFINE SYMBOL
	SETZ	W3,		;WITH ZERO VALUE
	PUSHJ	P,SY.RQ##	;PUT IN REQUEST FOR IT
	MOVE	P1,['LIBNEL']	;AND SPECIAL LIBRARY
	JRST	LOAD1		;NOW LOAD IT

BCL.L0:
BCP.L1:	MOVE	P1,['BCPLIB']
	PJRST	LOAD1

QREENT:	SKIPE	T1,OTSEG	;HAS USER DECIDED WHICH WAY TO LOAD?
	SOJE	T1,QPOPJ	;YES, T1 = 1 FOR NON-SHAREABLE
	SKIPE	HL.S2		;ANY HIGH STUFF SEEN?
QPOPJ:	POPJ	P,		;CAN NOT USE REENT OTS
	HRLZ	T1,HL.S1	;GET HIGHEST ADDRESS
	JUMPL	T1,QPOPJ	;NOT SHAREABLE IF .GT. 128K
	AOS	(P)		;REENT OTS
	POPJ	P,
SUBTTL	COMMON I/O ROUTINES

D.IN2::	PUSHJ	P,D.IN1		;GET A WORD
	MOVE	W2,W1		;IN W2
D.IN1::	SOSGE	DCBUF+2		;ANYTHING IN BUFFER?
	JRST	D.INP		;NO DO INPUT
	ILDB	W1,DCBUF+1	;GET NEXT WORD
	POPJ	P,

D.INP::	SKIPN	DCBUF		;IF 0 THEN READING FROM CORE
	JRST	FXREAD		;GET NEXT BUFFER
	IN	DC,		;INPUT NEXT BUFFER
	  JRST	D.IN1		;AND RETURN
D.ERR::	STATZ	DC,IO.EOF	;EOF?
	JRST	EOF		;YES
	PUSH	P,[DC]		;SAVE CHAN#
	.ERR.	(ST,0,V%L,L%F,S%F,EID,<Error on input device>)


EOF::	TRZE	FL,R.LOD	;ENS BLOCK SEEN?
	PUSHJ	P,EOFTS		;NO GIVE WARNING
	POP	P,(P)		;POP OFF RETURN
EOF1::	SKIPE	XBUF		;USING INDEXED LIBRARY
	PUSHJ	P,ZXBUF		;YES, GET RID OF IT
	JRST	LODNXT		;GET NEXT FILE

EOFTS::	.ERR.	(MS,.EC,V%L,L%W,S%W,NEB,<No end block seen for >)
	.ETC.	(SBX,.EP,,,,PRGNAM)
	MOVEI	R,1		;NOW TRY TO FIXUP RELOC TABLES
	MOVE	R,@RC.TB	;DO LOW SEG FIRST
	MOVE	T1,RC.HL(R)	;HIGHEST LOC SEEN
	CAMLE	T1,RC.CV(R)	;GREATER THAN CURRENT?
	MOVEM	T1,RC.CV(R)	;STORE HIGHEST
	SETZM	RC.HL(R)	;CLEAR IN EITHER CASE
	MOVEI	R,2		;NO FOR HIGH SEGMENT
	SKIPN	R,@RC.TB
	JRST	CPOPJ		;NO HIGH SEG
	MOVE	T1,RC.HL(R)	;HIGHEST LOC SEEN
	CAMLE	T1,RC.CV(R)	;GREATER THAN CURRENT?
	MOVEM	T1,RC.CV(R)	;STORE HIGHEST
	SETZM	RC.HL(R)	;CLEAR IN EITHER CASE
	POPJ	P,

;HERE TO REMOVE XBUF (FAKE BUFFER USED FOR LIBRARY INDEX)

ZXBUF::	HRRZ	T1,XBUF		;ADDRESS IN CORE
	MOVEI	T2,^D128	;SIZE
	SETZM	XBUF		;DONE WITH IT NOW
	PJRST	DY.RET##	;GIVE SPACE BACK AND RETURN

IFN DEBSW,<
$LOCATION::	0		;STORE ADDRESS TO BREAK ON
$SYMBOL::	0		;STORE 6BIT SYMBOL TO BREAK ON
>
LITLOD:
END	LNKLOD

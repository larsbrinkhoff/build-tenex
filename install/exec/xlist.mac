;LIST/TYPE <FILE GROUP DESCRIPTOR>

;FLAGS USED, IN AC F
;B0  END OF FILE
;B1  OUTPUT FILE OPEN
;B2  ;B3
;B4  TERMINAL DOES NOT HAVE FORM FEED
;B5  WIDTH HAS BEEN SET  
;B6  MULTIPLE COPIES SPECIFIED
;B7  PRETTYPRINT
;B8  POSSIBLE FIXUP IN PRETTY PRINT
;B9  PROCEDING LINE NOT COMMENT
;B10 CONFIRM INDIVIDUAL FILES
;B11 INDICATE FORMFEED (^L)
;B12 INDICATE NULLS W/^@
;B13 NO PAGE NUMBERS
;B14 PAUSE BEFORE EACH PAGE(TYPE ONLY)
;B15 SOURCE IS TTY, TERMINATE ON ^Z
;B16 DETACH BEFORE LISTING
;B17 LOGOUT AFTER LISTING
;AC F RH CONTAINS OUTPUT DEST
;	0 TTY
;	1 LPT:
;	2 LPA: (80 COL PRTR)
;	3 LPB: (SPECIAL FORMS PRINTER)
;	4 DSK: (OUTPUT FILE SPECIFIED BY OUTPUT SUBCMD)

;LIST/TYPE...   STORAGE

;IN XPRIV.MAC:
;GHEAD		0 OR BYTE POINTER TO SUBCOMMAND-GIVEN HEADING
;HEAD		0 OR PTR TO HEAD BEING USED FOR THIS FILE, INCL "PAGE "
;HEDLNO		# LINES IN HEADING, INCL EOLS BEFORE AND AFTER
;SPCG		0 FOR SINGLE SPACING, 1 FOR DOUBLE, ETC
;WIDTH		PAGE WIDTH IN COLUMNS
;LENGTH		PAGE LENGTH IN LINES
		; = LAST LINE AT WHICH TO BREAK PAGE IF NO ^L
;L35		FIRST LINE AT WHICH TO BREAK PAGE IN ABSENCE OF ^L
;L50		PREFERRED LINE AT WHICH TO BREAK PAGE
;PAGENO		PAGE NUMBER
;PAGEN1		SUBPAGE NUMBER
;NCOPYS		BYTE POINTER TO COPIES STRING
;BESPTR		POINTER TO BEST PLACE IN OUTBUF YET SEEN TO BREAK PAGE
;BESCOR		"SCORE" ASSOCIATED WITH BESPTR
;BESLNO		LINE # AT BESPTR
;BESCNT		NUMBER OF CHARACTERS TO BEST POINTER
;LISTP		TEMPORAY STORAGE FOR P
;PPRINT		POINTER TO BLOCK OF WORDS SPECIFYING PAGES TO LIST,
		;EACH WORD BEING XWD MIN,MAX, 0 TERMINATING BLOCK.
;CSBUFP		;CMD STR BUFF PTR TO CSBUF

;THE PAGE BUF1 (DEFINED IN XDEF.MAC) IS INPUT BUFFER
INBUF==BUF1
INBUFL==<BUF1+1000-INBUF>*5		;LENGTH, LEAVING SPACE FOR NULL

;OUTPUT BUFFER IS BUF2 AND FOLLOWING PAGES

;AC'S
;CHR (DEFINED IN XDEF)		;CHARACTER READ FROM INBUF
;CNO AND LNO SPECIFY POSITION ON PAGE OF LAST CHARACTER IN OUTBUF
CNO==BB		;COLUMNS LEFT IN LINE
LNO==CC		;LINES LEFT ON PAGE
INPTR==DD		;BYTE PTR TO INPUT BUFFER
OUTPTR==EE		;BYTE PTR TO OUTPUT BUFFER
OCNT==FF		;NUMBER OF CHARACTERS IN BUFFER
;CNT (DEFINED IN XDEF)		;NUMBER OF CHARACTERS REMAINING IN INBUF

;LIST/TYPE  ENTRY POINTS

.TYPE:	HRLZI	F,B10+B11	;SET TTY,FORMFEEDS,NOCONFIRMATION
	MOVE	A,COJFN		;GET CHARACTERISTICS
	RFMOD			;OF CONTROLLING TTY
	LDB	A,[POINT 7,2,17] ;GET TERM WIDTH
	CAIGE	A,5		;REASONABLE?
	MOVEI	A,377777	;NO, DO NO FOLDING
	MOVEM	A,WIDTH
	LDB	A,[POINT 7,2,10] ;GET TERM LENGTH
	CAIG	A,^D10		;REASONABLE LENGTH?
	MOVEI	A,^D10		;NO, SET MIN(SAVE PAPER)
	MOVEM	A,LENGTH
	JRST	LIST1

..PRIN:	MOVEI	F,2		;CLEAR FLAGS,SET LPA:
	MOVEI	A,^D72		;SET DEFAULT LENGTH WIDTH
	MOVEM	A,WIDTH
	MOVEI	A,^D60
	MOVEM	A,LENGTH
	JRST	LIST1

.LIST:	MOVEI	F,1		;CLEAR FLAGS, SET LPT:
	MOVEI	A,^D132		;SET DEFAULT LENGTH WIDTH
	MOVEM	A,WIDTH
	MOVEI	A,^D60
	MOVEM	A,LENGTH

LIST1:	NOISE	(FILE)
	SETZM	GHEAD
	SETZM	SPCG
	MOVEI	A,[XWD 1,777777
		   0]
	MOVEM	A,PPRINT
	CALL	$INFG		;INPUT FILE GROUP
	JRST	[		;R1: SUBCOMMANDS REQUIRED
		CONFIRM
		SUBCOM	$LIST
		JRST	.+2]
	CONFIRM

;LIST/TYPE...	  PRE-FIRST-FILE INITIALIZATION

;DETERMINE LINE "35"=FIRST LINE AT WHICH PAGE BREAK CAN OCCUR
	MOVE	B,LENGTH		;PAGE LENGTH, PERHAPS CHANGED FROM 60
	IMULI	B,7		;...BY SUBCOMMAND
	IDIVI	B,^D12
	SUB	B,LENGTH	;CALUCULATE LINES LEFT
	MOVMS	B		;MAKE POSITIVE
	MOVEM	B,L35

;DETERMINE LINE "50"=OPTIMUM PAGE BREAK POINT (NOW ACTUALLY 55)
	MOVE	B,LENGTH
	IMULI	B,11
	IDIVI	B,12
	SUB	B,LENGTH	;CALUCULATE LINES LEFT
	MOVMS	B		;MAKE POSITIVE
	MOVEM	B,L50
	TLNE	F,B7		;IS IT PRETTY PRINT
	TLO	F,B11		;YES THE FORM FEED WILL NOT BE INDICATED

;GET JFN FOR OUTPUT DEVICE OR FILE
LISTOP:	TLZN	F,B16		;DETACH BEFORE LISTING?
	JRST	LIST1D		;NO
	ETYPE	< DETACHING JOB %J
>;
	DTACH



LIST1D:	TRNN	F,-1		;IS IT TTY OUTPUT
	TLNN	F,B10		;CONFIRMING FILES
	SKIPA			;YES
	JRST	LIST1C+1	;NO SKIP FILE MESSAGE
	TLZ	F,B0+B2+B3+B9+B15	;CLEAR PER FILE FLAGS
	MOVE	A,COJFN		;GET TTY JFN
	HRRZ	B,@INIFH1	;GET FILE JFN
	SETZM	C		;INDICATE DEFAULT OPTIONS FOR JFNS
	JFNS			;PUT OUT FILE NAME
	TLNN	F,B10		;CONFIRMING INDIVIDUAL FILES
	JRST	LIST1F		;YES GO CONFIRM
LIST1C:	PRINT	TAB		;PRINT A TAB
	HRRZ	A,@INIFH1	;GET JFN FROM JFN STACK
	MOVEI	B,1B19		;SET FOR READ
	CALL	$OPEN7		;OPEN FOR ASCII
	DVCHR
	LDB	E,[POINT 9,B,17] ;DEVICE TYPE FOR HEDING BELOW
	CAIN	E,12		;IS IT A TTY?
	TLO	F,B15		;YES,SET ^Z FLAG
	CALL	LSTHDG		;SET UP PAGE HEADING
	CALL	LSTFL		;OUTPUT FILE
	TRNN	F,-1		;IS IT TTY OUTPUT
	JRST	LIST1A+1	;YES SKIP FILE MESSAGES
	MOVE	A,COJFN		;GET TTY JFN
	MOVE	B,PAGECT	;NUMBER OF PAGES PRINTED
	HRLI	C,120007	;SEVEN CHARACTER PADDED ON THE LEFT
	HRRI	C,^D10		;BASE 10
	NOUT
	SKIP			;ERROR RETURN
	TYPE	< PAGE(S)
>
LIST1A:	HRRZ	A,OUTDSG	;GET JFN OF OUTPUT
	TRNE	F,3		;IS IT A LPT
	CLOSF			;YES RELEASE JFN
	SKIP			;ERROR RETURN
LIST1B:	CALL	GNFIL		;GET NEXT FILE (MOVES INFL1)
	SKIPA			;NO MORE FILES GET OUT
	JRST	LIST1D		;LOOP BACK FOR ANOTHER FILE

;CLEAN UP,UNMAP STORAGE PAGES BUF1 TO 767
LIST1E:	CALL	UNMDIR		;FOUND IN X3CMD.MAC
	CALL	RLJFNS		;RELEASE JFNS
	TLNN	F,B17		;LOGOUT AFTER?
	JRST	CMDIN4		;NO-GO BACK TO CMD INPUT
	SETO	A,		;YES,LOGOUT SELF
	LGOUT
	CALL JERR	;IT DIDN'T WORK



LIST1F:	TYPE	(  Y OR N? )	;PROMPT FOR CONFIRMATION
	MOVE	A,CIJFN		;SET UP TO GET RESPONSE
	RFMOD			;GET CURRENT MODE OF TTY
	MOVE	C,B		;SAVE IT
	IORI	2,170000	;TURN ON ALL WAKEUP BITS
	SFMOD			;SET MODE WORD
	BIN			;GET CHARACTER
	TRZ	B,40		;INSURE UPPER CASE
	MOVE	CHR,B		;SAVE IT
	MOVE	B,C		;RESET WAKEUP BITS
	SFMOD
	CAIN	CHR,"N"		;IS IT NO
	JRST	[PRINT	EOL	;PUT OUT CRLF
		JRST	LIST1B]	;SKIP FILE
	CAIN	CHR,"Y"		;YES
	JRST	LIST1C		;GO PRINT IT
	JRST	LIST1F		;INVALID RESPOSE TRY AGAIN
;END OF LIST/PRINT/TYPE (MAIN OF COURSE)


;LIST/TYPE SUBCOMMAND TABLE AND ROUTINES

$LIST:		TABLE
		T CONFIRM,EOLOK+LPROK+ALTCON,..CONF
		T COUNT,EOLOK+LPROK+ALTCON
		TE DETACH,LPROK+INVIS,..DETA
		T DOUBLESPACE,ONEWD,..DOUB
		T FORMFEEDS,ONEWD+EOLOK+ALTCON,.FFEED
		TE HEADING
		T INDICATE,LPROK+EOLOK+ALTCON,..INDI
		T LENGTH,,..LENG
		TE LOGOUT,LPROK+INVIS,...LOG
		TE NO,LPROK,...NO
		T OUTPUT,CONMAN+LPROK,..OUTP
		T PAGES
		T PAPER,,.PAPER
		TE PAUSE,LPROK
		T PRETTYPRINT,+ONEWD+ALTCON,.PRTTY
		T SPACING
		T WIDTH
		TEND

$PAPER:		TABLE	;OPTIONS FOR PAPER SUBCMD
		T NARROW,ONEWD+ALTCON
		T SPECIAL,INVIS+ONEWD+ALTCON,.SPCUL
		T WIDE,ONEWD+ALTCON
		TEND

$NOLST:		TABLE		;OPTIONS FOR NO COMMAND
		T CONFIRMATION,EOLOK+LPROK+ALTCON,.NCONF
		T FORMFEEDS,EOLOK+LPROK+ALTCON,.IGNOR
		T PAGE,EOLOK+LPROK+ALTCON,..PAGE
		TEND





..CONF:	NOISE	(INDIVIDUAL FILES)
	CONFIRM
	TLZ	F,B10
	RET


.NCONF:	NOISE	(OF INDIVIDUAL FILES)
	CONFIRM
	TLO	F,B10		;SET BIT TO INDICATE CONFIRMATION NOT REQUIRED
	RET


.COUNT:	NOISE	(PAGES ONLY NO PRINTING)
	CONFIRM
	MOVE	B,[POINT 7,[ASCIZ /NIL:/],-1]
	CALL	$GTJFN
	TLO	F,B10		;DO NOT REQUIRE CONFIRMATION
	HRRI	F,4		;SET FLAG TO INDICATE NOT LPT: OR TTY:
	RET



..DETA:	NOISE	(BEFORE LISTING)
	CONFIRM
	TLO	F,B16+B10	;DO NOT REQUIRE CONFIRMATION IF DETATCHING
	RET

..DOUB:	MOVEI	A,1
	JRST	SPAC2

.FFEED:	ALLOW	TSPC+TALT+TEOL
	CONFIRM
	TLO	F,B11
	RET

;LIST/TYPE SUBCOMMANDS...

;HEADING: TAKE TEXT TO CR OR ALT MODE, COMMENT OK AFTER ALT MODE,
;CR TERMINATING "HEADING" MEANS NONE.
;CARRIAGE RETURNS CAN BE PUT IN HEADING WITH ^V OR &.

.HEADI:	MOVE	A,[POINT 7,[0]]
	TRNE	CBT,TEOL
	JRST	[	CONFIRM
		JRST	HEADI1]
	CALL	CSTR
	CAIN	TRM,FORMF
	JRST	.+5
	CAIE	CHR,EOL
	CAIN	CHR,ALTM
	JRST	.+2
	JRST	MORE
	ALTYPE	( )
	CONFIRM
		;COPY TEXT TO CSBUF: CAN'T USE "BUFFF" CAUSE IT CHANGES CONTCH
		;TO SPACE, LOWER CASE TO UPPER, HAS LENGTH LIMIT.
	MOVE	A,CSBUFP
	MOVE	B,.BFP
	MOVE	C,CNT
	SOJLE	C,.+3
	ILDB	D,B
	IDPB	D,A
	SOJG	C,.-2
	SETZ	C,
	IDPB	C,A	;NULL BYTE TERMINATES
	EXCH	A,CSBUFP
HEADI1:	MOVEM	A,GHEAD
	RET

;LIST/TYPE SUBCOMMANDS...

.IGNOR:	NOISE	(IN OUTPUT FILE)
	TLZ	F,B11		;IGNOR FORMFEEDS AND INDICATE BY ^L
	ALLOW	TSPC+TALT+TEOL
	CONFIRM
	RET

..INDI:	UNOI	[ASCIZ /NULLS BY ^@/]
	ALLOW	 TSPC+TALT+TEOL
	CONFIRM
	TLO	F,B12
	RET

..LENG:	NOISE	(OF PAGE IS)
	CALL	DECIN
		JRST CERR
	ALLOW	TALT+TSPC+TEOL
	CAIG	A,^D10
	JRST	CERR
	HRRZ	B,F		;GET OUTPUT DEVICE NO.
	CAIE	B,0		;IF TTY  SKIP.
	CAIL	B,3		;IF LPT OR LPA SKIP
	JRST	..LEN1		;IF OTHER THAN LPT OR LPA ANY LENGTH OK
	CAILE	A,^D60		;IS LENGTH LESS THAN OR EQUAL 60
	JRST	[TYPE	(60 IS MAXIMUM LENGTH)
		JRST	CERR]	;NO.  THEN GIVE ERROR
..LEN1:	CONFIRM
	MOVEM	A,LENGTH
	RET

...LOG:	NOISE	(AFTER LISTING)
	CALL	INFER
	JRST	.+2
	ERROR	<NOT LEGAL IN INFERIOR EXEC>
	CONFIRM
	TLO	F,B17
	RET

...NO:	TLZ	Z,BAKFF+PUNCF+NEOLF	;RESET FLAGS
	KEYWD	$NOLST
	T	PAGE,,..PAGE
	JRST	CERR
	JRST	(KWV)


;NO SUBCOMMAND ROUTINES
..PAGE:	NOISE	(NUMBERS)
	CONFIRM
	TLO	F,B13
	RET

..OUTP:	NOISE	(TO FILE)
	MOVE	A,[XWD 2,[ASCIZ /LST/]]		;DEFAULT: SOURCE NAME, .LST
	CALL	COUTFN
		JRST CERR
	ALLOW	TALT+TSPC+TEOL
	CONFIRM
	MOVEM	A,OUTDSG
	HRRI	F,4		;SET DSK: DONT TOUCH FLAGS (LH)
	MOVEI	A,^D132	;SET DEFAULT WIDTHS AND LENGTH
	TLNN	F,B5
	MOVEM	A,WIDTH
	JRST	.WIDE1

;LIST/TYPE SUBCOMMANDS...

;PAGES N,N-N,N-N,N...
;EACH NUMBER MUST BE GREATER THAN OR EQUAL TO LAST

.PAGES:	MOVEI	D,1		;LARGEST NUMBER YET SEEN
	AOS	B,CSBUFP	;BUILD BLOCK OF XWD MIN,MAX IN STRING BUFFER
PAGE1:	TLO	Z,DASHF		;MAKES "-" A FIELD TERMINATOR
	CALL	DECIN
	 JRST	CERR
	CAIL	A,(D)
	CAILE	A,-1
	JRST	CERR
	HRL	C,A
	MOVE	D,A
	CAIE	TRM,"-"
	JRST	PAGE2
	CALL	DECIN
	 JRST	CERR
	CAIL	A,(D)
	CAILE	A,-1
	JRST	CERR
	MOVE	D,A
PAGE2:	HRR	C,A
	MOVEM	C,(B)
	TRNE	CBT,TCOM
	AOJA	B,PAGE1
	ALLOW	TALT+TSPC+TEOL
	TLZ	Z,DASHF
	CONFIRM
	SETZM	1(B)		;0 ENDS BLOCK
	ADDI	B,2
	EXCH	B,CSBUFP	;UPDATE CSBUFP AND RESET B
	HRRZM	B,PPRINT	;SO PPRINT POINTS TO THE BEGINNING
	RET

;LIST/TYPE	SUBCOMMANDS...

.PAPER:	TLZ	Z,BAKFF+PUNCF+NEOLF	;MAKE SURE FLAGS OFF
	TRNN	F,3		;TEST TO SEE IF LPT TYPE DEVICE
	JRST	CERR		;DO NOT ALLOW SPECIAL SETUP ON OTHERS
	KEYWD	$PAPER
	T WIDE			;DEFAULT TO LPT:
	JRST	CERR		;BAD INPUT
	JRST	(KWV)		;DISPATCH TO ROUTINE BELOW

;ROUTINES TO DO ARGUMENT FCTNS

.NARRO:	HRRI	F,2		;PRESERVE FLAGS, SET LPA:
	ALLOW	TALT+TSPC+TEOL
	CONFIRM
	MOVEI	A,^D80		;SET DEFAULTS
	CAML	A,WIDTH		;IS CURRENT WIDTH GREATER THAN 80
	JRST	.WIDE1		;NO  THEN LEAVE IT ALONE
	MOVEI	A,^D72		;DEFAUL WIDTH 72
	MOVEM	A,WIDTH
	TLNN	F,B5		;HAS WIDTH BEEN SET
	JRST	.WIDE1		;NO THEN DO NOT TELL USER YOU CHANGED IT
	TYPE	(WIDTH HAS BEEN REDUCED TO 72)	;NOTIFY OF CHANGE
	JRST	.WIDE1

.SPCUL:	HRRI	F,3		;THIS IS THE ONLY PLACE TO SET LPB:
	SKIPA
.WIDE:	HRRI	F,1		;PRESERVE FLAGS, SET LPT:
	ALLOW	TALT+TSPC+TEOL
	CONFIRM
	MOVEI	A,^D132		;SET DEFAULTS
	TLNN	F,B5		;HAS WIDTH BEEN SET
	MOVEM	A,WIDTH		;NO SET TO 132
	HRRZ	B,A		;GET OUTPUT DEVICE TYPE
	CAIN	B,3		;IS IT LPT OR LPA
	RET			;NO RETURN
.WIDE1:	MOVEI	A,^D60
	CAML	A,LENGTH	;HAS THE LENGTH BEEN SET TO OVER 60
	RET			;NO
	MOVEM	A,LENGTH	;YES RESET TO 60
	TYPE	(LENGTH HAS BEEN REDUCED TO 60)	;NOTIFY USER
	RET

;LIST/TYPE SUBCOMMANDS...

.PAUSE:	NOISE	(BEFORE EACH PAGE)
	CONFIRM
	TRNE	F,17		;ANYTHING OTHER THAN TTY?
	JRST	[TYPE(OUTPUT NOT TO TTY)
		JRST CERR]
	TLO	F,B14
	RET

.SPACI:	CALL	DECIN
	 JRST	CERR
	ALLOW	TALT+TSPC+TEOL
	JUMPLE	A,CERR		;STORE SPACING 
	CAIL	A,10
	JRST	CERR
	SOS	A
SPAC2:	CONFIRM
	MOVEM	A,SPCG
	RET

.WIDTH:	CALL	DECIN
	 JRST	CERR
	ALLOW	TALT+TSPC+TEOL
	CAIG	A,^D15		;LESS SCREWS UP TITLE SETUP CODE
	JRST	CERR
	CONFIRM
	CAMLE	A,WIDTH		;ELSE DOUBLE FOLDOVER ON TTY OR BAD NEWS
	JRST	[TYPE(TOO WIDE--WON'T FIT) ;FOR LPT
		JRST CERR]
	MOVEM	A,WIDTH
	TLO	F,B5		;SET FLAG TO SAY WIDTH SET
	RET

;PRETTYPRINT

.PRTTY:	TLO	F,B7		;SET B7
	ALLOW	TALT+TSPC+TEOL
	CONFIRM
	RET

;LIST/TYPE...
;HERE TO LIST NEXT FILE IN LIST

LSTFL:	TLOE	F,B1		;IS FILE OPEN
	JRST	LSTFL0		;YES DO NOT OPEN
	XCT	[CALL	[MOVE A,COJFN	;TTY
			MOVEM A,OUTDSG
			RFCOC		;DOES IT WANT FORM FEEDS
			TRNN	B,B6
			TLO	F,B4	;YES SET FLAG
			RET]
		CALL	$LPT		;LPT: (132 COL PRTR)
		CALL	$LPA		;LPA: (80 COL PRTR)
		CALL	$LPB		;LPB: (SPECIAL FORMS PRTR)
		MOVE	A,OUTDSG](F)	;GET JFN FROM OUTPUT SUBCMD
	MOVEI	B,1B20		;SET B FOR WRITE
	CALL	$OPEN7		;NOW OPEN IT FOR 7 BIT ASCII
	TRNE	F,3		;IS IT A LPT
	TLZ	F,B1		;RESET FLAG TO OPEN FOR NEXT FILE
LSTFL0:	MOVEM	P,LISTP		;SAVE STACK POINTER FOR RETURN
	MOVEI	A,GCHEOF		;EOF PSI DISPATCH
	MOVEM	A,EOFDSP
		;INIT CHARACTER POSITION, PAGE #, BUFFERS, ETC
	MOVE	OUTPTR,[POINT	7,BUF2]
	MOVEM	OUTPTR,BESPTR	;SET OUT PUT POINTER TO FIRST OF PAGE
	MOVEI	A,1
	MOVEM	A,PAGENO	;SET PAGE NO TO 1
	SETZB	CNT,PAGEN1	;SET INPUT CHARACTER COUNT TO ZERO
	SETZB	OCNT,BESCNT	;SET OUPUT CHARACTER COUNTS TO 0
	SETZM	PAGECT		;SET PHYSICAL PAGE NUMBER TO ZERO
	MOVE	LNO,LENGTH	;GET NUMBER OF LINES LEFT
	MOVEM	LNO,BESLNO	;SET BEST LINE NUMBER TO FRONT OF BUFFER
	MOVE	CNO,WIDTH	;GET CHARACTERS LEFT
LSTFL1:	CALL	LSTTOP		;LIST TOP OF PAGE
	RET			;END OF FILE
	CALL	LSKIP		;SKIP PAGE
	CALL	LISTPG		;PRINT PAGE
	JRST	LSTFL1		;DO NEXT PAGE

;LIST/TYPE...   TOP OF PAGE LOOP.  DETERMINE WHETHER PAGE WILL PRINT.

LSTTOP:	HLRZ	A,@PPRINT	;MIN OF GROUP OF PAGES TO PRINT
	CAIN	A,0		;IF NO MORE PAGES RETURN
	RET			;END OF PAGES TO PRINT BLOCK, DONE THIS FILE
	AOS	(P)		;SET UP TO DO SKIP RETURN
	CAMLE	A,PAGENO
	RET			;SKIP PAGE
	HRRZ	A,@PPRINT	;MAX OF SAME GROUP
	CAMGE	A,PAGENO
	JRST	[	AOS PPRINT	;BEYOND THIS GROUP, GET NEXT
		JRST	LSTTOP]
;PRINT PAGE. FIRST HEADING AND PAGE NUMBER
LSTHED:	AOS	PAGECT		;ENTRY	TO JUST PRINT HEADING
	SUB	OCNT,BESCNT	;ANY LEFT OVER FROM LAST PAGE
	MOVE	B,BESPTR	;GET POINTER
	MOVE	D,B		;SET UP D INCASE NOTHING TO CHECK
LSTP2F:	SOJL	OCNT,LSTP2G	;ANY LEFT TO PRINT
	MOVE	D,B		;SAVE POINTER
	ILDB	C,B		;GET CHARACTER
	CAIE	C,CR		;CHECK OVER CR AND FORMFEEDS
	CAIN	C,FORMF
	JRST	LSTP2F		;GET NEXT CHARACTER
	CAIN	C,LF		;AND LINE FEEDS
	JRST	[AOS	LNO	;PUSH LINE NUMBER BACK UP
		JRST	LSTP2F]	;GET NEXT CHARACTER
	AOS	OCNT		;SET COUNT BACK
	JRST	LSTP2E		;GO SET UP POINTERS
LSTP2G:	MOVE	C,OCNT		;SAVE CHARACTER COUNT
LSTP2K:	CALL	GETC		;CHECK FIRST CHARACTERS FOR FORM FEEDS
				;LINE FEEDS AND CARRIAGE RETURNS
	JRST	LSTP2H		;PRINTABLE CHARACTER
	CAIN	CHR,FORMF	;FORMFEED
	JRST	LSTP2K		;YES CHECK NEXT CHARACTER
	JRST	LSTP2J		;CHECK FOR LF,CR AND EOL'S
LSTP2I:	CALL	GETC		;FORM FEEDS ONLY ON FIRST CHARACTER
	JRST	LSTP2H		;PRINTABLE CHARACTER
LSTP2J:	CAIE	CHR,LF		;LINEFEED
	CAIN	CHR,CR		;CARRIAGE RETURN
	SKIPA
	CAIN	CHR,EOL		;END OF LINE
	JRST	LSTP2I
LSTP2H:	MOVEM	C,OCNT		;RESTORE CHARACTER COUNT
	MOVE	OUTPTR,[POINT	7,BUF2]	;RESTORE OUTPTR
	MOVE	A,INPTR		;BACKUP INPTR ONE CHARTER
	BKJFN
	SKIP			;ERROR RETURN
	MOVEM	A,INPTR
	AOS	CNT		;SET CHARACTER COUNT BACK ONE
LSTP2E:	TLNE	F,B14
	CALL	PAUSE		;PAUSE BEFORE EACH PAGE REQUESTED
LSP2A:	MOVE	A,OUTDSG
	SKIPN	B,HEAD		;HEADING STRING, INCL "PAGE "
	JRST	LSTP2C		;NO HEADING OR PAGE #'S AT ALL
	TLNN	F,B4		;IS IT TTY WITHOUT FORM FEED
	JRST	LSTP2A		;N0
	MOVEI	B,CR		;PUT OUT CR/LF
	BOUT
	MOVEI	B,LF
	BOUT
	SOS	LNO		;COUNT LINE
LSTP2A:	SETZ	C,
	MOVE	B,HEAD		;HEADING STRING INCLUDING "PAGE"
	SOUT
	TLNE	F,B13
	JRST	LSTP2B		;NO PAGE #
	MOVE	B,PAGENO
	MOVEI	C,^D10
	NOUT			;PAGE	NO
	 CALL	JERRC
	SKIPN	B,PAGEN1
	JRST	LSTP2B
	MOVEI	B,":"
	BOUT
	MOVE	B,PAGEN1
	NOUT
	 CALL	JERRC
LSTP2B:	MOVE	C,SPCG
	ADDI	C,3		;SPACING + 2 EOLS
	MOVEI	B,CR		;PUT OUT CR/LF
	BOUT
LSTP2D:	MOVEI	B,LF
	BOUT
	SOJG	C,LSTP2D
	SUB	LNO,HEDLNO	;ACCOUNT LINES IN TITLE, INCL EOLS B4 AND AFTER
LSTP2C:	MOVEM	D,B		;RESET BEST POINTER
	MOVN	C,OCNT		;GET NEGATVE NUMBER OF CHARACTERS
	SKIPGE	C,C		;IF NO CHARACTERS SKIP SOUT
	SOUT
	MOVEM	OUTPTR,BESPTR	;SET UP FOR NEW PAGE
	SETZB	OCNT,BESCNT
	MOVEM	LNO,BESLNO
	AOS	(P)		;DO SECOND SKIP RETURN
	RET



CHKHED:	AOS	PAGEN1		;BUMP SUBPAGE NUMBER
	CALL	LSTHED		;LIST TOP OF NEXT PAGE
	SKIP			;SHOULD NEVER GET HERE
	AOS	PAGENO		;BUMP PAGE NUMBER
	SETZM	PAGEN1		;ZERO SUBPAGE NUMBER
	MOVEM	OUTPTR,BESPTR	;SET UP FOR NEW PAGE
	SETZB	OCNT,BESCNT	;ZERO CHARACTER COUNTS
	MOVE	LNO,LENGTH	;SET ENTIRE PAGE TO FILL
	MOVEM	LNO,BESLNO	;REST BEST LINE NUMBER
	RET

;LIST/TYPE...   SKIP PAGE

LSKIP:		;SKIP INITIAL ^L.
	CALL GETC		;GET CHAR FROM INBUF
	JRST	LSKIP1		;IF PRINTABLE GO GET ANOTHER CHARACTER
	CAIN	CHR,FORMF	;IF CONTROL CHARACTER SEE IF FORM FEED
	JRST	LSKIP		;FORM FEED
LSKIP1:	CALL	GETC		;SKIP PAGE
	JRST	LSKIP1		;PRINTABLE GET ANOTHER CHARACTER
	CAIE	CHR,FORMF
	JRST	LSKIP1		;NOT FORM FEED GET ANOTHER CHARACTER
	AOS	(P)		;SKIP RETURN
	AOS	PAGENO
	MOVE	OUTPTR,[POINT 7,BUF2]	;RESET POINTERS
	SETZB	OCNT,BESCNT
	MOVE	LNO,LENGTH
	RET




LSTPGE:	MOVE	A,OUTDSG	;GET JFN OF OUTPUT 
	MOVE	B,[POINT 7,BUF2]	;GET START OF OUTPUT BUFFER
	MOVEM	B,OUTPTR	;RESET OUTPUT POINTER
	MOVN	C,BESCNT	;ONLY PUT OUT CHARACTERS TO BEST BREAK POINT
	AOSE	C		;DO NOT PUT OUT LAST LINE FEED
	SOUT			;PUT OUT PAGE
	SUB	LNO,BESLNO	;UPDATE LINES LEFT
	ADD	LNO,LENGTH
	MOVEI	B,FORMF		;SKIP TO NEW PAGE
	TLNE	F,B4		;IF IT DOESNT HAVE FORM FEED REPLACE WITH LINE FEED
	MOVEI	B,LF
	BOUT
	TLNN	F,B7		;PRETTY PRINT
	RET			;NO
	MOVNI	B,B0		;SET SCORE OF BEST PLACE YET SEEN TO BREAK
	MOVEM	B,BESCOR	;PAGE TO MINUS INFINITY
	RET

;    LISTPG  ROUTINE TO BREAK OUTPUT INTO PAGES

LSTPG1:	SOJE	CNO,LSTPG5	;ANY ROOM LEFT ON LINE
LISTPG:	CALL	GETC		;GO GET A CHARACTER
	JRST	LSTPG1		;PRINTABLE CHARACTER
LSTPG2:	CAIN	CHR,11		;IS IT A TAB
	JRST	LSTTAB		;YES
	CAIN	CHR,CR		;CHECK CONTROL CHARACTERS
	JRST	LSTCR		;IS IS  A CARRAIGE RETURN
	CAIN	CHR,EOL		;IS IT AN EOL
	JRST	LSTEOL
LSTPG3:	CAIN	CHR,LF		;LINE FEED?
	JRST	LSTLF
	CAIN	CHR,FORMF	;FORM FEED?
	JRST	LSTFRF
	CAIN	CHR,10		;BACKSPACE?
	JRST	LSTBS
	TLNN	F,B12		;^@ PRINTED FOR NULLS
	JUMPE	CHR,LISTPG	;NO.  IGNORE NULLS
LSTPG4:	CAIGE	CNO,2		;ROOM ENOUGH FOR TWO CHARACTERS
	JRST	[CALL	LSTFD2	;NO FOLD LINE
		IBP	OUTPTR	;BUMP POINTER
		JRST	.+1]
	MOVEI	B,"^"		;PUT OUT UP-ARROW
	DPB	B,OUTPTR
	ORI	CHR,100		;CONVERT CONTROL CHAR TO PRINTABLE CHAR
	IDPB	CHR,OUTPTR
	AOS	OCNT		;COUNT BUFFER
	SOS	CNO		;DECREMENT CHARACTER COUNT
	JRST	LSTPG1		;GO GET NEXT CHARACTER

LSTPG5:	CALL	LSTFLD		;FOLD LINE
	JRST	LSTPG6		;NEXT CHARACTER PRINTABLE
	IDPB	CHR,OUTPTR	;PUT CHARACTER BACK IN OUTPUT BUFFER
	JRST	LSTPG2		;GO PROCESS IT

LSTPG6:	IDPB	CHR,OUTPTR	;INSERT CHARACTER IN BUFFER
	JRST	LSTPG1		;GO GET NEXT CHARACTER

LSTCR:	MOVE	CNO,WIDTH	;TOTAL WIDTH OF LINE LEFT
	JRST	LISTPG		;GO GET NEXT CHARACTER

LSTEOL:	MOVEI	B,CR		;PUT OUT CR/LF INSTEAD OF EOLS
	MOVE	CNO,WIDTH	;RESET NUMBER OF CHARACTERS LEFT IN LINE
	DPB	B,OUTPTR	;PUT CR IN BUFFER
	MOVEI	CHR,LF		;GET READY TO DO LINE FEED
	IDPB	CHR,OUTPTR	;PUT FIRST LF IN BUFFER
	AOS	OCNT		;UPDATE CHARACTER COUNT

LSTLF:	CALL	LSTLFS		;GO PUT IN RIGHT NUMBER OF LF'S
	JRST	LISTPG		;PAGE NOT FULL YET
	AOS	PAGEN1		;BUMP SUBPAGE NUMBER
	RET			;RETURN FROM PRINTING A PAGE

LSTLFS:	MOVE	C,SPCG		;GET NUMBER OF LINES/LF
	CAILE	LNO,0		;IF ALREADY PAST END OF PAGE
	TLNE	F,B7		;PRETTY PRINT
	JRST	LSTLF2		;GO PUT ALL OF LF'S IN BUFFER
	SUBI	LNO,1(C)	;SUBTRACT NUMBER OF LF'S
	JUMPLE	LNO,LSTLF4	;WILL THAT PUT US PAST END
	ADD	OCNT,C		;NO ADD THEM TO THE BUFFFER
	SKIPE	C,C		;SPECIAL TEST FOR ONLY ONE LF
LSTLF1:	IDPB	CHR,OUTPTR
	SOJG	C,LSTLF1	;FINISHED YET
	TLNE	F,B7		;PRETTY PRINT
	JRST	LSTPP		;YES UGH!!!!!!!!!!!!!!!!!
	MOVEM	LNO,BESLNO	;YES UPDATE BEST BREAK POINTERS
	MOVEM	OCNT,BESCNT
	MOVEM	OUTPTR,BESPTR
	RET

LSTLF2:	SUBI	LNO,1(C)	;ALREADY OVER SO PUT IN ALL LF'S
	ADD	OCNT,C		;UPDATE BUFFER COUNT
	SKIPE	C,C		;SPECIAL TEST FOR ONLY ONE LF
LSTLF3:	IDPB	CHR,OUTPTR	;PUT THEM IN THE BUFFER
	SOJG	C,LSTLF3	;FINISHED
	TLNE	F,B7		;PRETTY PRINT
	JRST	LSTPP		;YES UGH!!!!!!!!!!!
	CALL	LSTPGE		;YES GO LIST THE PAGE
	AOS	(P)		;DO SKIP RETURN
	RET

LSTLF4:	MOVEM	OCNT,BESCNT	;UPDATE NECESSARY BEST COUNT POINTERS
	MOVEM	LNO,BESLNO
	MOVEM	OUTPTR,BESPTR
	TLO	F,B8		;INDICATE BEST BREAK ALRADY FOUND
	MOVNI	B,B0		;SET SCORE OF BEST PLACE SEEN TO BREAK
	MOVEM	B,BESCOR	;TO MINUS INFINITY
	JRST	LSTPP		;DISCARD BLANK LINES BETWEEN HERE AND THERE

LSTFRF:	MOVEI	B,CR		;PUT OUT CARRIGE RETURN
	DPB	B,OUTPTR
	TLNN	F,B11		;ARE WE PAGEING FOR FORM FEEDS
	JRST	LSTFF2		;NO PAGE EJECTS
	JUMPGE	LNO,LSTFF1	;ARE WE ALREADY OVER A PAGE
	IDPB	CHR,OUTPTR	;PUT FORM FEED IN BUFFER
	AOS	OCNT		;CONT FORMFEED
	CALL	LSTPGE		;YES  LIST TO BET BREAK SO FAR
	CALL	CHKHED		;LIST TOP OF NEXT PAGE
	RET

LSTFF1:	SETZB	LNO,BESLNO	;FAKE BOTTOM OF PAGE
	MOVEM	OCNT,BESCNT	;UPDATE BEST COUNT POINTER
	CALL	LSTPGE		;LIST PAGE
	SETZM	PAGEN1		;RESET SUBPAGE NUMBER
	AOS	PAGENO		;BUMP PAGE NUMBER
	SETZB	OCNT,BESCNT	;SET COUNT TO ZERO
	RET

LSTFF2:	SETZM	PAGEN1		;RESET SUBPAGE NUMBER
	AOS	PAGENO		;BUMP PAGE NUMBER
	MOVE	C,SPCG		;GET NUMBER OF LF FOR SPACING
	SUBI	LNO,2(C)	;SUBTRACT FOR SEPERATOR
	JUMPLE	LNO,LSTFF7	;WILL THIS PUT US OVER PAGE
	ADDI	LNO,1(C)	;THESE WILL BE SUBTRACTED LATTER
	MOVEI	D,2		;GO THROGH TOP PART OF LOOP 3 TIMES
	MOVEI	CHR,177		;SET UP SEPERATOR
	TRNN	F,3		;LPT: DEVICE
	MOVEI	CHR,"_"		;NO DO NOT USE RUBOUT
	MOVEI	C,^D10		;SET UP FOR NOUT
	HRLI	C,^D9		;PUT OUT 9 CHARACTERS
LSTFF3:	MOVE	CNO,WIDTH	;RESET CHARACTERS LEFT IN LINE
	CAILE	CNO,^D132		;INCASE OF INFINITE WIDTH MAKE WIDTH 132
	MOVEI	CNO,^D132
	MOVEI	B,CR		;PUT OUT CRLF
	IDPB	B,OUTPTR
	MOVEI	B,LF		;SET UP FOR LINEFEED
	IDPB	B,OUTPTR
	SOJE	D,LSTFF6	;FINISHED
	ADDI	OCNT,2(CNO)	;ADD IN CHARACTERS
	SUBI	CNO,17		;SAVE 15 CLOUMNS FOR PAGE NO
	TRNN	F,3		;ADD IN EXTRA 177'S IF LPT:
	SKIPA
	ADDI	OCNT,(CNO)
LSTFF4:	TRNN	F,3		;MUST PUT OUT TWO 177'S TO GET ONE
	SKIPA			;BUT ONLY ONE _
	IDPB	CHR,OUTPTR	;PUT OUT SEP CHARACTER
	IDPB	CHR,OUTPTR	;PUT OUT SEP CHARACTER
	SOJG	CNO,LSTFF4	;FULL LINE
	MOVE	A,[POINT 7,[ASCII / PAGE /]]	;PUT OUT PAGE
	MOVEI	CNO,6		;6 CHARACTERS
LSTFF5:	ILDB	B,A		;GET CHARACTER
	IDPB	B,OUTPTR	;AND PUT IT OUT
	SOJG	CNO,LSTFF5	;FINISHED
	MOVE	B,PAGENO	;PUT OUT PAGE NO
	MOVE	A,OUTPTR
	NOUT			;C SET UP ABOVE FOR 10 CHARACTERS
	SKIP			;ERROR RETURN
	MOVEM	A,OUTPTR	;FIX UP POINTER
	JRST	LSTFF3		;DO NEXT LINE
LSTFF6:	ADDI	OCNT,2		;COUNT CRLF
	MOVEI	CHR,LF		;SET UP FOR LINEFEEDS
	CALL	LSTLFS		;PUT IN RIGHT NUMBER OF LINE FEEDS
	JRST	LISTPG		;GO GET NEXT CHARACTER
	RET			;PAGE FULL
LSTFF7:	AOS	OCNT		;PUT ALL AHARACTERS IN
	SETZB	LNO,BESLNO	;NO USE PUTTING IN LF FOLLOWED BY FORM FEED
	MOVEM	OCNT,BESCNT	;UPDATE ONLY NECESSARY BEST COUNT POINTERS
	CALL	LSTPGE		;LIST THE PAGE
	RET

LSTBS:	MOVE	A,OUTPTR	;BACK THING UP
	BKJFN
	SKIP			;SHOULD NEVER GET HERE
	MOVEM	A,OUTPTR
	SOS	OCNT		;SUBTRACT FROM OUT CHAR. COUNT
	AOS	CNO		;PUT ONE CHARACTER BACK IN LINE
	CALL	GETC		;CHECK FOR ANOTHER BACK SPACE
	JRST	LSTBS1		;PRINTABLE
	CAIN	CHR,10		;CONTROL. IS IT BACK SPACE
	JRST	LSTBS		;YES TAKE CARE OF IT
LSTBS1:	MOVEI	A,CR		;GO BACK TO BEGINNING OF LINE
	DPB	A,OUTPTR
	MOVE	A,WIDTH		;CALCULATE NUMBER OF CHARACTERS IN LINE
	SUB	A,CNO
	JUMPLE	A,LSTBS4	;WE CANNOT BACK INTO NEXT LINE
	ADDI	OCNT,1(A)	;COUNT CR AND SPACES
	MOVEI	B," "		;DO SPACES
LSTBS2:	IDPB	B,OUTPTR
	SOJG	A,LSTBS2	;FINISHED
LSTBS3:	IDPB	CHR,OUTPTR	;PUT LAST CHARACTER BACK IN BUFFER
	CAIGE	CHR,40		;WAS IT A CONTROL CHARACTER
	JRST	LSTPG2		;YES GO CHECK IT OUT
	JRST	LSTPG1		;PRINTABLE NEED TO DO NOTHING ELSE
LSTBS4:	MOVE	CNO,WIDTH	;FULL LINE LEFT
	AOS	OCNT		;COUNT CR
	JRST	LSTBS3		;GO FINISH


LSTTAB:	SUB	CNO,WIDTH	;GET NEGATIVE OF CHARACTERS IN LINE
	TRZN	CNO,7		;MAKE IT EVEN ON 8 CHARACTERS
	SUBI	CNO,^D8		;TAB MOVES OVER 8
	ADD	CNO,WIDTH	;GET POSITIVE CHARACTERS LEFT
	SKIPLE	CNO,CNO		;HAVE WE MORE THAN ONE LINE FULL
	JRST	LISTPG		;NO GO GET NEXT CHARACTER
	JUMPE	CNO,LSTPG5	;SEE IF NEW LINE
	CALL	LSTFD2		;FOLD LINE
	SOS	OCNT		;SUBTRACT TAB OFF OF OUT COUNT
	JRST	LISTPG		;YES.  GET NEXT CHARACTER

;  PRETTY PRINT GARBAGE .........     !!!!!!!!!!!!!!!!!


LSTPP:	CAMG	LNO,L35		;HAVE TO WORRY YET
	JRST	LSTPP1		;YES
	MOVEM	OUTPTR,BESPTR	;SAVE AS A BREAK POINT IN CASE NO 
	MOVEM	LNO,BESLNO	;...LINES BETWEEN "35" AND "60" DUE TO
	MOVEM	OCNT,BESCNT	;...SMALL LENGTH AND LARGE SPACING
	RET

;HAVE AN EOL BEYOND LINE "35". IF BEYOND "LENGTH", PRINT.

; SCORE BREAK AT THIS POINT
LSTPP1:	PUSH	P,OUTPTR	;SAVE CURENT POSITION
	PUSH	P,OCNT
	PUSH	P,LNO
	SETZ	E,		;INITIALIZE SCORE
				;SCAN PAST EOLS & BLANKS, SCORING +10 PER EOL,
			;-1 PER COLUMN INDENTATION
LSTPPA:	CALL	GETC		;CHECK FOR COMENT
	SKIPA			;PRINTABLE CHARACTERS CHECK NOW
	JRST	LSTPP7		;GO CHECK ON CONTROL CHARACTERS
	CAIN	CHR," "		;IF A BLANK CHECK NEXT CHARACTER
	JRST	LSTPP5
	CAIN	CHR,"!"		;CKECK FOR COMMENT CHARACTERS
	JRST	LSTPP2
	CAIE	CHR,"$"		;FOR FORTRAN
	CAIN	CHR,"/"		; "    "
	JRST	LSTPP2
	CAIE	CHR,";"
	CAIN	CHR,"*"
LSTPP2:	JRST	[TLNN	F,B9	;WAS PREVIOS LINE COMMENT
		ADDI	E,^D70	;+50 IF PREVIOUS LINE NO COMMENT
				;-20 IF LAST LINE WAS COMMENT, TO AVOID
		SUBI	E,^D20	;BREAKING UP BLOCKS OF COMMENTS
		TLO	F,B9	;THIS LINE IS A COMMENT
		JRST LSTPP3]
		;-100 FOR ), ] AT LEFT MARGIN, FOR LISP PRETTYPRINT LISTINGS
	CAIE	CHR,")"
	CAIN	CHR,"]"
	SUBI	E,^D100
;LIST/TYPE... SCORING BREAK AT EOL...
		;IF HERE, THIS LINE WAS NOT COMMENT AT LEFT MARGIN
LSTPPS:	TLZ	F,B9		;ENTRY TO INDICATE NOT A COMMENT
		;NOW REDUCE ALL SCORES BY # LINES AWAY FROM "60"
LSTPP3:	SUB	E,(P)		;LNO SAVED BEFORE SCANNING PAST EOLS
		;UPDATE BEST BREAK SEEN IF THIS ONE IS BETTER
	CAMGE	E,BESCOR
	JRST	LSTPPM		;THIS IS NOT BEST BREAK DISCARD POINTERS
	MOVEM	E,BESCOR	;SAVE BEST SCORE
	TLZN	F,B8		;RESET FOUND BEST PLACE TO PRINT
	JRST	LSTPPL		;DID NOT FIND BEST PLACE TO PRINT ALREADY
	CAILE	LNO,0		;OVER PAGE
	JRST	LSTPPM		;NO BEST BREAK ALREAY SET DISCARD POINTERS
	SETZB	LNO,BESLNO	;FAKE BOTTOM OF PAGE
	CALL	LSTPGE		;PRINT PAGE
	POP	P,BESLNO	;SET POINTER TO SKIP EVERYTHING TO BEGINING 
	POP	P,BESCNT	;OF THIS LINE
	POP	P,BESPTR
	JRST	LSTPPN		;RETURN


LSTPPL:	POP	P,BESLNO	;THIS ONE IS BETTER
	POP	P,BESCNT
	POP	P,BESPTR
	SKIPA
LSTPPM:	SUB	P,[XWD	3,3]	;TAKE THING OFF STACK
	TLZ	F,B8		;RESET FOUND BEST PLACE TO PRINT
	SOS	CNO		;UPDATE COUNT OF CHARACTERS LFT IN LINE
	CAILE	LNO,0		;IS PAGE FULL
	RET			;RETURN FORM LSTLFS ROUTINE
	CALL	LSTPGE		;YES PRINT TO BEST BREAK
LSTPPN:	AOS	PAGEN1		;BUMP SUBPAGE NUMBER
	POP	P,B		;POP OFF LSTLFS RETURN
	RET			;RETURN FROM LISTPG




LSTPP4:	SOJE	CNO,LSTPP6	;TIME TO FOLD LINE
LSTPPC:	CALL	GETC		;THIS LOOP CHECK FOR CONTROL CHARACTERS
				;EOL, CR, LF, FORMFEED,TAB AND BLANK
	SKIPA			;CHECK FOR BLANK ONLY GOOD PRINTABLE
	JRST	LSTPP7		;GO CHECK CONTROL CHARACTERS
LSTPPB:	CAIE	CHR," "		;IS IT A BLANK
	JRST	LSTPPS		;NO GO SCORE IT AS NON COMMENT
LSTPP5:	SUBI	E,1		;SUBTRACT 1 FOR EACH BLANK
	JRST	LSTPP4		;TRY NEXT CHARACTER


;THIS CODE FOLDS LINE FOR PRETTY PRINT

LSTPP6:	CALL	LSTFLD		;CALL ROUTINE TO FOLD LINE
	JRST	[IDPB	CHR,OUTPTR  ;PUT CHARACTER IN BUFFER
		JRST	LSTPPB	;GO SEE IF IT WAS A BLANK
				]
	IDPB	CHR,OUTPTR	;PUT CONTROL CHARACTER IN BUFFER
				;AND CHECK IT OUT


;CODE TO CHECK OUT CONTROL CHARACTERS

LSTPP7:	CAIN	CHR,LF		;IS IT A LINE FEED
	JRST	LSTPLF		;YES GO ADJUST SCORE AND ADJUST COUNTERS
	CAIN	CHR,CR		;IS IT A CARRIAGE RETURN
	JRST	LSTPCR		;YES
	CAIN	CHR,EOL		;IS IT AN END OF LINE
	JRST	LSTPEL		;YES
	CAIN	CHR,11		;TAB
	JRST	LSTPTB		;YES
	CAIN	CHR,FORMF	;FORMFEED
	JRST	LSTPFF		;YES
	TLNN	F,B12		;^@ PRINTED FOR NULLS
	JUMPE	CHR,LSTPPC	;NO.  IGNORE NULLS
				;NOT DOING RIGHT THING FOR BACKSPACE HERE
				;BUT THEN IF HE HAS A BAKSPACE HERE HE IS WIRD
	CAIGE	CNO,2		;ROOM ENOUGH FOR TWO CHARACTERS
	JRST	[CALL	LSTFD2	;NO FOLD LINE
		IBP	OUTPTR	;BUMP POINTER
		JRST	.+1]
	MOVEI	B,"^"		;PUT OUT UP-ARROW
	DPB	B,OUTPTR
	ORI	CHR,100		;CONVERT CONTROL CHAR TO PRINTABLE CHAR
	IDPB	CHR,OUTPTR
	AOS	OCNT		;COUNT BUFFER
	SOS	CNO		;DECREMENT CHARACTER COUNT
	JRST	LSTPPS		;GO SCORE AS NONCOMMENT LINE



LSTPCR:	MOVE	CNO,WIDTH	;TOTAL WIDTH OF LINE LEFT
	JRST	LSTPPA		;GO GET NEXT CHARACTER



LSTPTB:	SUBI	E,10		;SUBTRACT 8 FOR TABS
	SUB	CNO,WIDTH	;GET NEGATIVE OF CHARACTERS IN LINE
	TRZN	CNO,7		;MAKE IT EVEN ON 8 CHARACTERS
	SUBI	CNO,^D8		;TAB MOVES OVER 8
	ADD	CNO,WIDTH	;GET POSITIVE CHARACTERS LEFT
	SKIPLE	CNO,CNO		;HAVE WE MORE THAN ONE LINE FULL
	JRST	LSTPPC		;NO GO GET NEXT CHARACTER
	JUMPE	CNO,LSTPP6	;SEE IF NEW LINE
	CALL	LSTFD2		;FOLD LINE
	SOS	OCNT		;SUBTRACT TAB OFF OF OUT COUNT
	JRST	LSTPPC		;YES.  GET NEXT CHARACTER



LSTPEL:	MOVEI	B,CR		;PUT OUT CR/LF INSTEAD OF EOLS
	MOVE	CNO,WIDTH	;RESET NUMBER OF CHARACTERS LEFT IN LINE
	DPB	B,OUTPTR	;PUT CR IN BUFFER
	MOVEI	CHR,LF		;GET READY TO DO LINE FEED
	IDPB	CHR,OUTPTR	;PUT FIRST LF IN BUFFER
	AOS	OCNT		;UPDATE CHARACTER COUNT



LSTPLF:	MOVE	C,SPCG		;GET NUMBER OF LINES/LF
	ADDI	E,12		;ADD 10 FOR EACH LINE FEED OR EOL
	SUBI	LNO,1(C)	;SUBTRACT NUMBER OF LF'S
	ADD	OCNT,C		;ADD THEM TO THE BUFFFER
	SKIPE	C,C		;SPECIAL TEST FOR ONLY ONE LF
LSTPL1:	IDPB	CHR,OUTPTR
	SOJG	C,LSTPL1	;FINISHED YET
	CAMGE	LNO,L50		;PAGE FULL
	CAMG	E,BESCOR	;IS THIS BEST SEEN
	JRST	LSTPPA		;NO GO GET NEXT CHARACTER
	TLOE	F,B8		;SET BIT INDICATING POSSIBLE FIXUP
	JRST	[SUB	P,[XWD	3,3]
		JRST	LSTPL2]	;WE HAVE BEEN HERE BEFORE SO DO NOT UPDATE BEST
	POP	P,BESLNO	;UPDATE BEST POINTERS
	POP	P,BESCNT
	POP	P,BESPTR
LSTPL2:	PUSH	P,OUTPTR	;SET UP POINT TO THROW AWAY TO
	PUSH	P,OCNT
	PUSH	P,LNO
	JRST	LSTPPA		;NOW GO GET NEXT CHARACTER



LSTPFF:	TLZ	F,B9		;RESET COMMENT FLAG
	TLZE	F,B8		;HAVE WE ALREADY FOUND BET PLACE TO BREAK
	JRST	LSTPPP
	JUMPGE	LNO,LSTPF1	;ARE WE OVER PAGE
	CALL	LSTPGE		;YES LIST PAGE TO BEST BREAK
	CALL	CHKHED		;PUT OUT HEADING AND EVERYTHING TO THIS POINT
	SUB	P,[XWD	4,4]	;REMOVE POINTERS AND LSTLFS RETURN
	RET			;TAKE LISTPG RETURN

LSTPF1:	POP	P,BESLNO	;SET UP BEST POINTERS
	POP	P,BESCNT
	POP	P,BESPTR
	POP	P,B		;POP OF LSTLFS RETURN
	SKIPA			;GO PRINT PAGES

LSTPPP:	SUB	P,[XWD	4,4]	;SUB BEST MARKERS AND LSTLFS RETURN
	SETZB	LNO,BESLNO	;FAKE BOTTOM OF PAGE
	CALL	LSTPGE		;LIST PAGE TO BEST POINT
	SETZM	PAGEN1		;SET SUBPAGE TO ZERO
	AOS	PAGENO		;BUMP PAGE NUMBER
	SETZB	OCNT,BESCNT	;SET COUNT TO ZERO
	RET			;RETURN FROM LISTPG




;LIST/TYPE SUBROUTINES
;LSTHDG SETS UP THE PAGE HEADING
;GHEAD =0 =>USE DEFAULT HEADING
;RETURNS HEADING STRING POINTER IN HEAD,NULL BYTE TERMINATES

LSTHDG:	SKIPE	INPTR,GHEAD	;SET INPTR,IS THERE A SUBCMD HEADING?
	JRST	LSTH2		;YES,USE IT
	MOVE	A,CSBUFP	;FIRST FREE BYTE IN CSBUF
	ADDI	A,20		;PAD FOR SAFTY (REWRITEN BELOW)
	MOVE	INPTR,A		;POINT TO THE BEGINNING FOR LATER
	MOVE	B,[POINT 7,[ASCIZ /;  /]] ;A STRING CONST
LSTH1A:	ILDB	C,B		;COPY IT
	JUMPE	C,LSTH1B	;JUMP IF NULL
	IDPB	C,A		;ELSE MOVE IT
	JRST	LSTH1A		;AND LOOP
LSTH1B:	HRRZ	B,@INIFH1	;GET THIS JFN
	MOVE	C,[2B2+1B5+1B8+1B11+1B14+1] ;SET UP FORMAT
	JFNS			;GET FILE NAME AND COPY
	MOVEI	B,40		;A SPACE
	MOVEI	C,3		;SET LOOP FOR 3 COUNT
LSTH1C:	IDPB	B,A		;ADD 3 SPACES
	SOJG	C,LSTH1C
	SETO	B,
	JUMPN	E,LSTH1		;JUMP IF OUTDEV NOT DSK (B IS SET UP)
	PUSH	P,A		;ITS DSK USE WRITE DATE IF ABLE
	HRRZ	A,@INIFH1	;GET THE JFN
	MOVE	B,[XWD 1,FDBWRT] ;ONLY WANT WRITEDATE WORD
	MOVEI	C,B		;AND PUT IT IN B
	CALL	$GTFDB
	SETO	B,		;CAN'T GET LST ACCESS USE CURRENT DATE
	POP	P,A		;RESTORE POINTER
LSTH1:	HRLZI	C,B1+B10+B11+B17 ;TIME FORMAT
	ODTIM			;GET IT AND COPY
	SETZ	C,
	IDPB	C,A		;NULL BYTE TERMINATES
LSTH2:	MOVE	OUTPTR,CSBUFP	;SET DEST BACK,WILL OVERWRITE DEFAULT
	MOVEM	OUTPTR,HEAD	;PRESERVE IT FOR RETURN
	MOVEI	CNT,377777	;KLUDGE FOR GETC ROUTINE
	MOVE	CNO,WIDTH	;GET PAGE WIDTH
	MOVEI	LNO,3		;COUNT EOL OF HEADING
LSTH2A:	SOJL	CNO,LSTH2B	;COUNT CHARS, DON'T OVERFLOW
	CALL	GETC		;MOVE A CHAR
	JRST	[CAIE	CHR,CONTCH	;IS IT CONTINUATION CHAR
		JRST	LSTH2A		;PRINTABLE,GET MORE
		JRST	LSTH2D]
LSTH2C:	JUMPE	CHR,LSTH2E	;QUIT IF NULL
	CAIN	CHR,EOL		;IS IT EOL?
	JRST	LSTH2D		;YES,DO ACCNTNG ETC
	ADDI	CNO,1		;UNCOUNT CONTROL CHAR
	CAIE	CNO,2		;ROOM FOR "^X"?
	CALL	LSTFD2		;NO,FOLD LINE
	ADDI	LNO,2		;MAKE UP FOR SOS
	MOVEI	C,136		;THERES ROOM (NOW)
	IDPB	C,OUTPTR	;PUT OUT "^"
	ADDI	CHR,100		;MAKE IT PRINTABLE
	IDPB	CHR,OUTPTR	;PRINT IT
	SUBI	CNO,2		;ACCOUNT FOR BOTH
	JRST	LSTH2A		;GO BACK TO WORK

LSTH2B:	IBP	OUTPTR		;SET UP FOR FOLDING LINE
	CALL	LSTFD2		;FOLD LINE
	ADDI	LNO,2		;ADD TWO TO MAKE UP FOR SOS
	JRST	LSTH2A		;FIXED UP,GO BACK FOR MORE

LSTH2D:	MOVEI	CHR,CR
	DPB	CHR,OUTPTR	;PUT OUT CR/LF
	MOVEI	CHR,LF
	IDPB	CHR,OUTPTR
	MOVE	CNO,WIDTH	;MOVE TO BEGINNING OF
	ADDI	LNO,1		;NEXT LINE
	JRST	LSTH2A		;GO BACK FOR MORE

LSTH2E:	MOVE	A,OUTPTR	;BACKUP ONE
	BKJFN
	SKIP
	MOVEM	A,OUTPTR
	TLNE	F,B13		;DO WE PRINT PAGE NO'S
	JRST	LSTH2J		;NO,SKIP PAGE TEXT
	SUBI	CNO,16		;YES,UNCOUNT NULL,COUNT SPACE &TEXT
	CAILE	CNO,0		;ENOUGH ROOM?
	JRST	LSTH2F		;YES,SKIP NEW LINE STUFF
	MOVEI	C,CR		;TERMINATE LINE
	IDPB	C,OUTPTR	;IN BUFFER
	MOVEI	C,LF
	IDPB	C,OUTPTR
	ADDI	LNO,1		;COUNT A NEW LINE
	MOVE	CNO,WIDTH	;RESET COLUMN
	SUBI	CNO,17		;MAKE ROOM FOR "PAGE   :   "
LSTH2F:	MOVEI	C,40		;NOW A SPACE
	CAIL	CNO,^D128		;INFINITE WIDTH
	MOVEI	CNO,^D10	;YES RESET TO 10 MORE SPACES
LSTH2G:	IDPB	C,OUTPTR	;SPACE OUT TO PAGE
	SOJGE	CNO,LSTH2G	;STOP WHEN THERE
	MOVE	A,[POINT 7,[ASCII /PAGE /]] ;THIS STRING
	MOVEI	C,5		;PUT AT END OF
LSTH2H:	ILDB	CHR,A		;HEADING BUFFER
	IDPB	CHR,OUTPTR	;PAGE NO'S PUT IN LATER
	SOJG	C,LSTH2H	;LOOP 5 CHARS
LSTH2I:	SETZ	CHR,		;NOW NULL
	IDPB	CHR,OUTPTR	;TO TERMINATE EVERYTHING
	ADD	LNO,SPCG	;COUNT THE EOL OF THIS STUFF NOW
	MOVEM	LNO,HEDLNO	;STORE LINE COUNT,REAL EOLS PUT IN LATER
	RET
LSTH2J:	CAME	OUTPTR,HEAD	;HAVE WE INSERTED ANY HEADING
	JRST	LSTH2I		;YES
	SETZM	HEAD		;NO INDICATE SO
	RET

;LSTFLD FOLDS A LINE WHEN WIDTH OVERFLOWS
;DOES RIGHT THINGS FOR A,B,CNO,LNO. CLOBBERS C

LSTFLD:	CALL	GETC		;CHECK FOR END OF LINE
	JRST	LSTFD2		;NEXT CHARACTER PRINTABLE FOLD LINE
	CAIE	CHR,CR		;WE WILL ACCEPT CR OR EOL
	CAIN	CHR,EOL
	RET			;IF CR OR EOL GO PROCESS THEM
	CAIE	CHR,LF		;RETURN ON LF OR FORMFEED
	CAIN	CHR,FORMF
	RET
	CAIN	CHR,0		;GO PROCESS NULL
	RET
	AOS	(P)		;SKIP RETURN IF PRINTABLE
LSTFD2:				;ENTRY TO JUST FOLD LINE
	MOVEI	C,CR		;TERMINATE THIS LINE
	DPB	C,OUTPTR	;PUT IN BUFFER
	MOVEI	C,LF
	IDPB	C,OUTPTR	;PUT IN BUFFER
	MOVEI	C,52		;NOW THE "*"
	IDPB	C,OUTPTR	;DO IT TWICE
	IDPB	C,OUTPTR	;AT BEGINNING OF LINE
	MOVE	CNO,WIDTH	;RESET COL COUNT
	ADDI	OCNT,4		;JUST PUT IN 4 CHARACTERS
	SUBI	CNO,2		;DON'T FORGET TO COUNT THEM
	SOS	LNO		;UPDATE LINE COUNT
	RET

PAUSE:	PRINT BELL		;RING BELL TO LET HIM KNOW WE ARE HERE
	MOVE	A,CIJFN
	BIN			;WAIT FOR EOL
	RET



;GETC MOVES ONE CHAR FROM HERE TO THERE AND FINDS OUT WHAT IT IS
;ON THE FLY
;
;RETURNS THE CHAR IN CHR--ALWAYS
;CALLING SEQ
;	CALL	GETC
;	+1	;PRINTABLE CHARACTER MOVED FROM INBUF TO OUTBUF
;	+2	;CHAR IS A CNTRL CHAR. FILE NOT UPDATED

GETC:	SOJL	CNT,GETBUF	;SEE IF ANY CHARACTERS LEFT
	ILDB	CHR,INPTR	;GET CHAR FROM FILE
	CAIGE	CHR,40		;IS IT CONTROL CHAR?
	AOS	(P)		;YES TAKE SKIP RETURN
	IDPB	CHR,OUTPTR	;NO,MOVE IT TO DEST
	AOS	OCNT		;CALCULATE CHARACTERS IN OUTPUT BUFFER
	RET

;PSI SERVICE FOR GETC
GCHEOF:	SETZM	EOFDSP		;GIVE PSI HANDLING BACK TO EXEC
	TLO	F,B0		;END OF FILE
	MOVMS	C		;CALCULATE NUMBER OF CHARACTERS TRANSFERED
	SUB	CNT,C
	JRST	GETC		;FINISH LAST BUFFER



;ROUTINE TO GET ANOTHER BUFFER
GETBUF:	TLNE	F,B0		;HAVE WE HAD AN END OF FILE
	JRST	LSTEND		;DO END OF FILE
	HRRZ	A,@INIFH1	;GET INPUT JFN
	MOVE	B,[POINT 7,INBUF]
	MOVEM	B,INPTR		;RESET BUFFER POINTERS
	MOVEI	CNT,INBUFL	;GET A PAGE FULL
	MOVE	C,CNT		;SET UP CNT
	TLNN	F,B15		;TTY ?
	MOVNI	C,INBUFL	;SET UP TO END WITH CNTRL Z
	MOVEI	D,CTRLZ
	SIN			;GET STRING
	TLNN	F,B15		;TTY
	JRST	GETC		;GO PROCESS IT
	JUMPE	C,GETC		;FULL BUFFER
	TLO	F,B0		;IDICATE END OF FILE
	JRST	GETC




;ROUTINE TO DO END OF FILE PROCESSING
LSTEND:	JUMPLE	LNO,LSTEN2	;MORE THAN A PAGE
	ADDI	OCNT,2		;PRINT LAST CHARACTER THIS TIME MAY NOT BE CARRIAGE CONTROL
	MOVEI	B,CR		;PUT CARRIAGE RETURN IN BUFFER
	IDPB	B,OUTPTR
	MOVEM	OCNT,BESCNT	;UPDATE CHAR CNT
	CALL	LSTPGE		;PUT OUT LAST PAGE
LSTEN1:	MOVEI	B,CR		;PUT OUT CARRIAGE RETURN
	TRNN	F,-1		;ONLY FOR TTY
	BOUT
	TLNE	F,B14		;IS PAUSE FLAG SET
	CALL	PAUSE		;PAUSE FOR LAST PAGE
	MOVE	P,LISTP		;REST STACK POINTER
	RET			;RETURN 


LSTEN2:	CALL	LSTPGE		;LIST PAGE TO BEST BREAK
	CALL	CHKHED		;DO TOP OF LAST PAGE
	MOVEI	B,LF		;PUT OUT LF IN CASE THER ISNT ONE
	TRNN	F,-1		;ONLY FOR TTY
	BOUT
	JRST	LSTEN1

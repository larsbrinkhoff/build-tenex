;<MON>TTYSRV.MAC;10    20-MAY-77 09:13:58    EDIT BY SWEER
;<MON>TTYSRV.MAC;9     3-MAY-77 14:20:00    EDIT BY SWEER
; ADDED CALL TO NVTDET IN TTHNGU
;<MON>TTYSRV.MAC;7    12-APR-77 12:07:16    EDIT BY SWEER
; MADE TTLINK A GS FOR GETAB
;<SCHULZ>TTYSRV.MAC;6     2-DEC-76 15:20:46    EDIT BY SWEER
; MADE LINKF AND IMECHF KS VARIABLES
;<SCHULZ>TTYSRV.MAC;5     2-DEC-76 15:05:52    EDIT BY SWEER
; PUT NOSKD1,OKSKD1 AROUND SETTING OF IMECHF
;<SCHULZ>TTYSRV.MAC;4    29-NOV-76 11:50:16    EDIT BY SWEER
; MADE NORMTF 80 CHARS/LINE, FIXED BUG IN IGNORING NULLS
;<SCHULZ>TTYSRV.MAC;3    24-NOV-76 13:29:12    EDIT BY SWEER
; THROW AWAY NULLS ON ASCII LINES BEFORE MOVING TO TTY BUFFER
;<SCHULZ>TTYSRV.MAC;2    24-NOV-76 10:33:11    EDIT BY SWEER
; REMOVE 1B31 FROM NORMTF SO LOWER CASE DOES NOT GET RAISED
;<MON>TTYSRV.SMX;19     1-MAR-76 15:58:15    EDIT BY SWEER
; DISALLOW LINKS TO PTY'S
;<MON>TTYSRV.SMX		7/75		EDIT BY HEATHMAN
;ADDED HOOKS TO NEW TYMNET HANDLER FOR BUILDING AUX CIRCUITS
;<MON>TTYSRV.SMX	6/15/75		EDIT BY HEATHMAN
;ADDED HOLD FEATURE TO NVT'S AT CLTTS1
;<MON>TTYSRV.SMX	6/10/75		EDIT BY HEATHMAN
;CHANGED SO PTYS DONT GET PARITY
;<MON>TTYSRV.SMX;13    29-JAN-75 23:53:30    EDIT BY LIEB
;INSERTED CALLS TO IMPDV FOR NVT THINGS--LIEB
;<NEWMON>TTYSRV.TYM;4    13-AUG-74 15:25:24	EDIT BY MANN
;IFN SUMEX, THEN STPAR,STTYP,AND GTTYP WILL "NOP" FOR NON-TERMINAL
;JFNS  . THIS WAS DONE TO AID THE REDIRECT COMMAND IN THE EXEC..
;<NEWMON>TTYSRV.TYM;2    13-AUG-74 15:00:43	EDIT BY MANN
;I4-TENEX:<TENEX-131>TT.MAC;131 27-JUN-73 22:00:56	EDIT BY PJ
; ADDED I4-TENEX DEFINITIONS AND CODE.
;<TENEX-131>TTYSRV.MAC;130    10-JAN-73 17:35:18	EDIT BY CLEMENTS
;ADD NVT TYPE, FIX TTCOHA, FIX TAB PADDING, DONT ECHO RUBOUT
;<TENEX-130>TTYSRV.MAC;129    27-DEC-72 14:38:51	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;128     4-DEC-72 23:16:30	EDIT BY CLEMENTS
;<TENEX-130>TTYSRV.MAC;127    30-NOV-72 11:50:21	EDIT BY TOMLINSON
; INCREASED TI PADDING TO 7
;<TENEX-130>TTYSRV.MAC;126    29-NOV-72 17:33:27	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;125    29-NOV-72 14:41:43	EDIT BY TOMLINSON
; MADE STI WAIT FOR ROOM IN OUTPUT BUFFER
;<TENEX-130>TTYSRV.MAC;124    27-NOV-72 16:43:14	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;123    21-NOV-72 17:45:54	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;122    21-NOV-72 15:55:06	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;121    21-NOV-72  7:08:09	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;120    21-NOV-72  6:48:58	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;119    20-NOV-72 16:50:25	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;118    20-NOV-72 14:59:18	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;117    18-NOV-72 18:35:35	EDIT BY WALLACE
;<TENEX-130>TTYSRV.MAC;116    10-NOV-72 13:07:33	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;115    10-NOV-72 12:45:25	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;114    10-NOV-72 12:40:38	EDIT BY TOMLINSON
; ADDED INTERNS
;<TENEX-130>TTYSRV.MAC;113     9-NOV-72 21:07:30	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;112     9-NOV-72 18:06:09	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;111     9-NOV-72 17:29:36	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;110     9-NOV-72 16:41:44	EDIT BY TOMLINSON
;<TENEX-130>TTYSRV.MAC;109     9-NOV-72 16:36:11	EDIT BY TOMLINSON
; ISOLATING TTYSRV AS SEPARATE ASSEMBLY -- ADDED EXTERNS
;<TENEX-130>TTYSRV.MAC;108     9-NOV-72 10:22:09	EDIT BY TOMLINSON
; TTYFLGS = TTFLGS
;<TENEX-130>TTYSRV.MAC;107     8-NOV-72 22:57:50	EDIT BY CLEMENTS
;<TENEX-130>TTYSRV.MAC;106     6-NOV-72 11:40:55	EDIT BY TOMLINSON
; IMMEDIATE CHANGE IN TTY MODE, FIX TTCOHA
;<TENEXDLM>TTYSRV.MAC;105    31-OCT-72  9:07:16	EDIT BY TOMLINSON
; FIX TTGTBF
;<TENEXDLM>TTYSRV.MAC;104    25-OCT-72 14:06:26	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;103    25-OCT-72 13:47:22	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;102    25-OCT-72 10:31:15	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;101    19-OCT-72 16:04:36	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;100    17-OCT-72 19:22:27	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;99    15-OCT-72 15:26:52	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;98    14-OCT-72 17:29:25	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;98    14-OCT-72 16:55:34	EDIT BY TOMLINSON
;<TENEXDLM>TTYSRV.MAC;97     3-OCT-72 12:26:03	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;96    29-SEP-72 12:34:35	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;95    26-SEP-72 11:44:22	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;94    25-SEP-72 13:59:18	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;93    22-SEP-72 17:38:42	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;92    20-SEP-72 13:44:03	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;91    18-SEP-72 14:28:32	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;90    23-AUG-72 20:49:56	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;89    21-AUG-72 17:46:29	EDIT BY MURPHY
;<TENEXDLM>TTYSRV.MAC;88     7-AUG-72 22:44:26	EDIT BY MURPHY
;28 JUN 72, 1432:
	SEARCH	PROLOG
	TITLE	TTYSRV

;TELETYPE SERVICE ROUTINES - D. MURPHY
; LINKAGE TO PISRV

EXTERN	MENTR,UJSYS,MRETN,MRETNE,ITRAP,ITRAP1,BUGCHK,BUGHLT,TADSEC

; LINKAGE TO SCHEDULER

EXTERN PILCK,HLOCKR,DLOCKR,DLSPI,TTYLCK,STOPLK,CPUID,SLOCKR
EXTERN NOPILK,CPUSW0,HLOCKP
	
EXTERN	INSKED,ISKED,FKINT,BLOCK1

; LINKAGE TO IMPDV

IFDEF IMPCHN,<	INTERN TTOMAX,TCOBQ
EXTERN	NVTDOB,NTTCSO,NETCAP,NVTCOB,NVTCHO,NVTXCR,NVTPAR
EXTERN NVTMOD,NVTDET,NVTRCC>

; MISCELLANEOUS EXTERNS

EXTERN AUTONX
EXTERN FACTSW,LOGDES
EXTERN	R,RSKP,CAPMSK,CAPENB,JOBDIR,NTTYOT,NTTYIN,TTFRKT
EXTERN	SKMRTN

INTERN	TTCHI,PSICHU,PSICHL,PSICHO,TTIMAX,TTRLOB,TTYLMD,WRPMSK,NVTCOF
	INTERN NLINES,NTTYS,CTYLIN,OTYLIN,TCI,TCO,TTHNGU,TTEMES
	INTERN .TLINK,NORMTF,TAB81,TAB82,TCOB,TCIB,HILIN,.ADVIZ
	INTERN BUGTYO,BUGMSG
	INTERN .TTMSG,.STTYP,.GTTYP,.STPAR
	INTERN TTINIT,TTRSET
	INTERN TTCOBF,TTCIBF,TTILIN,TTCOBI
	INTERN TTSIBE,TTSOBE,TTSOBF,TTDOBE,TTGTBS,TTSTBS,TTSPOS
	INTERN TTRMOD,TTSMOD,TTRPOS,TTRCOC,TTSCOC,TTSTI,TTBKPT
	INTERN TTDIBE,CLTTST
	INTERN PSICH
	INTERN CH6TAB,BHC
	INTERN BITS
	INTERN TTICB1,TTICB2
	INTERN TCITST,TCOTST
	INTERN TTCH7,TTCH7X,NCHBF
	INTERN DLSSV,TTSTI1,TTYCKK
IFDEF	I4SW,
<	INTERN TTCH70,TTI4RT,TTBSIZ,TTMBIT,TCEO2
	INTERN TTSND
>

IFN SUMEX,<INTERN TTCLZ>

;NLINES PARAMETER IN PROLOG

NCHBF==<TTSIZ-1>*4		;NUMBER OF CHARS IN 1 BUFFER
TTBSIZ==200		;BIG BUFFER SIZE
NTABBF==^D20		;NUMBER OF TABS BUFFERS
IFNDEF	I4SW,
<CTYLIN==NTTYS-1		;CTY IS ONE AFTER HIGHEST SCANNER
>
OTYLIN:	OTYLNE		;OTY FOR FIXING DISK
TTLCBT==1B3		;LOWER CASE FLAG BIT
DLSRCF==400		;DLS RECEIVER FLAG, DATAI WORD
DLSXMF==1000		;DLS XMITTER FLAG, DATAI WORD
DLSCXF==1B25		;CARRIER XITION FLAG
DLSACT==1B26		;ACTIVATE LEVEL IN DATAO
DLSDLB==1B29		;DIRECTED LINE BIT, LH OF DATAO
TTSCF==1B20		;FLAG - CHARACTER CAME FROM STI

TTLIND=="%"		;LOWER CASE INDICATION CHARACTER
TTCIND=="^"		;CONTROL INDICATION CHARACTER

T7TIM==^D15		;MAX MILLISECS BETWEEN BIG BUF SERVICE

	EXTERN JOBPT,FORKX,EDISMS,TODCLK,CHKTTM,ENTFLG
IFN SUMEX,<EXTERN CHKTTY,UNL,UNLCKF> ;NOP FOR STPAR
	EXTERN SCDRQ7,JOBSRT,RSKP,SYSIFG,TTYBKS,TTINTS
	EXTERN TTBTIM
	EXTERN TTPSRQ
IFDEF	I4SW,
<	EXTERN I4TTIN,TTSRA,TTRUBA
	EXTERN TLT3,TL24
>

;RANGE OF LINES TO ACCEPT FROM SCANNER

HILIN:	CTYLIN-1
LOLIN:	0
	SWAPCD
;
;	linkage to TYMSRV.MAC
;

	DEFINE IFTYM (AC,CODE) =
<
IFDEF TYMSW, <
	CAIL AC,TYMTTL		;;is right line?
	CAIL AC,TYMTTL+NTYMTT
	 CAIA			;;no, skip
	CODE			;;yes, do it
>>

IFDEF TYMSW,<NYCHBF==<TTSIZ-1>*3> ;12 BIT BYTES IN TYMNET BUFFERLETS

;STORAGE

LS TTOIN,NLINES		;OUTPUT BUFFER POINTERS (IN)
LS TTOOUT,NLINES	;	(OUT)
LS TTOCT,NLINES		;	(COUNT)

LS TTEIN,NLINES		;ECHO OUTPUT BUFFER POINTERS (IN)
LS TTEOUT,NLINES	;	(OUT)
LS TTECT,NLINES		;	(COUNT)

LS TTIIN,NLINES		;INPUT BUFFER POINTERS (IN)
LS TTIOUT,NLINES	;	(OUT)
LS TTICT,NLINES		;	(COUNT)

;TTY BUFFERS--INPUT, OUTPUT, AND ECHO
;BUFFERS ARE OF SIZE TTSIZ, AND START AT LOCATIONS N*TTSIZ+1

IFNDEF TTBUFF,<		;IF DEFINED, MEANS TTBUFS ALREADY DEFINED
LS TTBUFS,NTTBF*TTSIZ+TTSIZ >
LS TTFREC,1		;COUNT OF FREE BUFFERS
LS TTFREB,1		;LIST OF FREE BUFFERS

LS TTFLGS,NLINES	;FLAGS
GS TTLINK,NLINES	;OUTPUT-LINKED LINES (9-BIT BYTES)

LS FCMOD1,NLINES
LS FCMOD2,NLINES	;CONTROL CHARACTER MODES

LS TTLPOS,NLINES	;PAGE,,LINE POSITION
LS TTPSI,NLINES		;PSEUDO-INTERRUPT MASK
GS TTDPSI,NLINES	;DEFERRED INT CODES
GS TTFORK,NLINES	;OWNERSHIP STATUS,,INPUT WAIT STATUS
GS TTCS,NLINES		;CONTROL STATE
GS TTBFRC,NLINES	;BUFFER CONTROL FIELDS
GS TTMOD1,NLINES	;LAST CHAR INPUT, LAST MODE, TAB TABLE ADR
GS TTYPE,NLINES		;TYPE OF TERMINAL ON THIS LINE
LS TTADVS,NLINES	;ADVISE LINKS. -1 MEANS NONE, 0,,N MEANS
			; ADVISING LINE N, B0+N MEANS WILL ACCEPT
			; AN ADVIZ FROM LINE N
			; -1,,N MEANS AM RECEIVING ADVICE FROM N

IFN SUMEX,<
LS TTIOCT,NLINES	;character xfer count
>
LS TABLST,1		;LIST OF FREE TAB BUFFERS
LS TABBFR,NTABBF*3	;TAB BUFFERS

;BIG BUFFER

LS TTBIGI,1		;INPUT INDEX
LS TTBIGO,1		;OUTPUT INDEX
LS TTBIGC,1		;COUNT
LS TTBBUF,TTBSIZ	;BUFFER

;MISC TTY STORAGE

KS TTNIT1,1		;ISB COMMUNICATION REG
LS XDLSSV,1		;PI RETURN
LS TTCQLN,1		;CONTROL OP CURRENT LINE NUMBER
LS DLSLPI,1		;DLS LOST PI ASMT COUNT
LS TTHNGL,1		;LINE BEING EXAMINED FOR HUNG
LS TTHNGT,1		;TIME AT WHICH LINE WILL BE DEFINED AS HUNG
LS TTHNGN,1		;LAST HUNG LINE ,, NUMBER UNHANGS DONE
KS LINKF,1		;LINKED OUTPUT CHAR IN NOT 0
KS IMECHF,1		; SET IF IMMEDIATE ECHO BEING OUTPUT
IFN SUMEX,<
LS TTLSO0		;LINE 0 LAST SENT CHARACTER TIME, FOR SUMEX ONLY
>


	RESCD

TTYLCH:	POINT 9,TTMOD1(2),8
TTYLMD:	POINT 2,TTMOD1(2),10	;TERM DATA MODE FOR LAST TCI

;USUAL DEVICE FLAGS AND STATUS
; 66 LINES/PAGE, 80 CHARS/LINE
; WAKEUP ON ALL, ECHO MODE 2 (DEFERRED OR IMMED)
; DATA MODE ASCII, 'DO NOT RAISE' LC INPUT (ALSO CONVERTS OLD-STYLE ALT-MODES)

NORMTF:	^D66B10+^D80B17+17B23+2B25+1B29

TAB81:	EXP 1B0+1B8+1B16+1B24+1B32
TAB82:	EXP 1B4+1B12+1B20+1B28
TAB83:	EXP 1B0+1B8+1B16+1B24+1B32

;NORMAL CONTROL CHARACTER SETTINGS

TTICB1:	BYTE (2) 0,1,1,1,1,1,1,2,1,2,2,1,1,2,1,1,1,1
TTICB2:	BYTE (2) 1,1,1,1,1,1,1,1,1,3,1,1,1,2

;POINTERS TO FIELDS IN TTBFRC WORD

TTOMAX:	POINT 9,TTBFRC(2),35	;MAX BYTES IN OUTPUT BUFFER(S)
TTIMAX:	POINT 9,TTBFRC(2),26	; " INPUT BUFFER(S)
TTNOU:	POINT 5,TTBFRC(2),17	;NUMBER OF OUTPUT BUFFERS TO ASSIGN
TTNIN:	POINT 5,TTBFRC(2),12	;NUMBER OF INPUT BUFFERS TO ASSIGN
TTOWRN:	POINT 8,TTBFRC(2),7	;OUTPUT WAKEUP LEVEL

;TERMINAL TYPE TABLES
; B0, B1, B2, B3, B4-7, B8-11, B12-15, B16-19
; FF,TAB, LC,FCR, CRPD, LFPAD, TABPAD, FF PAD

;NORMAL MODE IS LOWERCASE BIT ON, MOST DEVICES WILL PRINT LC CHAR
;AS UC.  FF AND TAB PADDING IS SPECIFIED FOR TTYS IN CASE
;FF OR TAB BIT TURNED ON MANUALLY

TTYPE0:	PHASE 0			;!! MAH @ SUMEX 4/75 !! TO PROBERLY GENERATE
				;"TYPxx" SYMBOLS
TYP33::! 1B15+12B19		;(0) MOD 33
	1B0+1B1+1B15+12B19	;(1) MOD 35 (FF+TAB)
	1B2+1B15+12B19		;(2) MOD 37 (LC)
TYPEX::! 1B2+7B7		;(3) TI (LC+CRPAD)
	0			;(4) RESERVED FOR SRI-ARC
	0			;(5)   "  "  "
	0			;(6)   "  "  "
TYPNVT::! 1B0+1B1+1B2		;(7) NVT (TAB+LC+FF, NO PAD)
	1B2+1B3+5B7		;(8) TI-700(LC+FIXED CR)
	1B2			;(9) TEC
	1B2			;(10) IMLAC
	1B2			;(11) DATAMEDIA
TYPCRT::! 1B2			;(12) CRT
	1B0+1B1+1B2+4B7		;(13) DCT500
	1B1+1B2+6B11		;(14) TERMINET360
	1B2+4B7			;(15) UNIVAC
	DEPHASE
NTTYPS==.-TTYPE0

;POINTERS TO TERMINAL TYPE FIELDS
;ASSUME TYPE NUMBER IN 3

TTMBIT:	POINT 3,TTYPE0(3),2	;MECHANICAL BITS
TTCRPD:	POINT 4,TTYPE0(3),7	;CR PADDING FOR FULL LINE
TTLFPD:	POINT 4,TTYPE0(3),11	;LF PADDING FOR ONE LINE
TTTBPD:	POINT 4,TTYPE0(3),15	;TAB PAD FOR 4 SPACES
TTFFPD:	POINT 4,TTYPE0(3),19	;FF PAD FOR FULL PAGE

;NON PI ROUTINES

BUGTYO:	0
	CONSZ TTY,1B31
	JRST .-1
	DATAO TTY,1
	CONSZ TTY,1B31
	JRST .-1
	JRST @BUGTYO

BUGMSG:	0
	MOVE 7,1
	HRLI 7,440600
BUGM2:	ILDB 1,7
	ADDI 1,40
	CAIN 1,"/"
	JRST @BUGMSG
	CAIN 1,"$"
	JRST BUGM1
BUGM3:	JSR BUGTYO
	JRST BUGM2

BUGM1:	MOVEI 1,15
	JSR BUGTYO
	MOVEI 1,12
	JRST BUGM3

	SWAPCD

;SENDS MESSAGES TO ALL TTYS VIA ECHO BUFFER

.TTMSG:	JSYS MENTR
	MOVE 7,0(P)
	TLNE 7,UMODF		;FROM MONITOR?
	JRST [			;NO, CHECK CAPABILITIES
		MOVE 7,CAPENB	;  AND ALLOW FOR WHEELS AND OPER.
		TRNN 7,WHEEL+OPER
		JRST UJSYS
		JRST .+1 ]
	TLNE 2,007000
	HRLI 2,440700		;MAKE BYTE POINTER
IFN KAFLG,<TLZ 2,20>
IFN KIFLG,<TLZ 2,37>
	PUSH P,2
	JUMPGE 1,TPA5		;NOT ALL TTYS
	MOVSI 16,-NLINES	;TO ALL LINES
TPA6:	MOVE 14,0(P)		;BYTE POINTER
	MOVEI 2,0(16)		;LINE NUMBER

IFDEF I4SW,<
	CAIL 2,PTYLO		;SKIP PTYS
	CAIL 2,PTYLO+NPTY
	JRST .+2
	JRST TPA1
>
	MOVE 3,TTFLGS(2)	
	TRNN 3,3B29		;BINARY MODE AND REFUSE?
	TRNE 3,1B26
	 JRST TPA3		;NO, ITS OK
	JRST TPA1		;YES, IGNORE MESSAGE

TPA3:	XCTBU [ILDB 1,14]
	JUMPE 1,TPA1		;TERMINATE ON NULL
	CALL TCEO2
	JRST TPA3

TPA1:	AOBJN 16,TPA6
	POP P,2
	JRST MRETN

TPA5:	HRROI 16,0(1)		;DO ONE LINE OF GIVEN NUMBER
	JRST TPA6

;SEND SYSTEM CRASH MESSAGE TO ALL TTYS

	RESCD

LS CRSMSG,2			;CALLED BY JSR CRSMSG

CRSMS0:	MOVEM 17,CRSAC+17	;SAVE AC'S
	MOVEI 17,CRSAC
	BLT 17,CRSAC+16
	MOVE P,[IOWD NCRSPD,CRSPDL]
	MOVSI 16,-NLINES	;DO ALL EXISTING LINES
CRSM3:	MOVEI 14,[ASCIZ /
**TENEX IS DOWN**
/]
	HRLI 14,440700
	MOVEI 2,0(16)		;LINE NUMBER
CRSM2:	ILDB 1,14		;CHARACTER
	JUMPE 1,CRSM1		;NULL MARKS END
	CALL TCEO2		;OUTPUT VIA ECHO BUFFER
	JRST CRSM2

CRSM1:	AOBJN 16,CRSM3
	MOVSI 17,CRSAC		;RESTORE ACS
	BLT 17,17
	JRST @CRSMSG

LS CRSAC,20
NCRSPD==10
LS CRSPDL,NCRSPD

;INITIALIZATION

TTINIT:	MOVEI 1,TTBUFS		;COMPUTE BEGINNING OF BUFFERS
	TRNE 1,TTSIZ-2		; TO BE N*TTSIZ+1
	ADDI 1,TTSIZ		;FIRST WORD IN BUFFER AREA
	ANDCMI 1,TTSIZ-1	;WHICH IS 0 MOD TTSIZ
	ADDI 1,1		;SUCH THAT EACH BUFFER ENDS 0 MOD ADR
	MOVEI 2,NTTBF
	MOVEM 2,TTFREC		;FREE BUFFER COUNT
	SUBI 2,1
	MOVEM 1,TTSIZ(1)	;CONSTRUCT LIST OF FREE BUFFERS
	ADDI 1,TTSIZ
	SOJG 2,.-2
	MOVEM 1,TTFREB		;FREE BUFFER LIST
	ADD 1,[XWD 441100,1]	; +1 AND MAKE INTO BYTE POINTER
	MOVSI 7,-NLINES
TTIB1:	SETZM TTOIN(7)
	SETZM TTOOUT(7)
	SETZM TTOCT(7)		;INITIALIZE OUTPUT BUFFER WORDS
	SETZM TTEIN(7)
	SETZM TTEOUT(7)
	SETZM TTECT(7)		; ... ECHO BUFFER WORDS
	SETZM TTIIN(7)
	SETZM TTIOUT(7)
	SETZM TTICT(7)		; ... INPUT BUFFER WORDS
	SETOM TTFORK(7)
	SETZM TTFLGS(7)
	SETZM TTYPE(7)
	SETOM TTLINK(7)
	SETOM TTADVS(7)		;NO LINKS OR ADVICE IN PROGRESS
	MOVEI 2,(7)		;GET LINE NUMBER ALONE

	MOVE 1,[<^D20>B7+2B12+2B17+<2*NCHBF-1>B26+<2*NCHBF-2>B35]
IFN SUMEX,<			; !! MAH @ SUMEX !! 11/74
	CAIN 2,67		;IMSSS/SUMEX link uses 4 input buffers
	MOVE 1,[<^D20>B7+4B12+2B17+<4*NCHBF-1>B26+<2*NCHBF-2>B35]
>
IFTYM 2,<
	MOVE 1,[<^D20>B7+3B12+3B17+<3*NYCHBF-1>B26+<3*NYCHBF-2>B35]
>
	MOVEM 1,TTBFRC(7)	;NORMAL IS 2 BUFFERS FOR IN AND OUT
	AOBJN 7,TTIB1
	MOVSI 2,-NLINES
	CALL TTILIN
	AOBJN 2,.-1
	MOVEI 2,NTABBF-1	;INIT FREE LIST OF TAB BUFFERS
	MOVEI 1,TABBFR
	MOVEM 1,3(1)
	ADDI 1,3
	SOJG 2,.-2
	MOVEM 1,TABLST
	SETZM TTBIGI
	SETZM TTBIGO
	SETZM TTBIGC
	CONO TTY,DLSCHN
	CONO DLS,DLSCHN
TTACTL:	SETZM TTHNGT
	SETZM TTHNGN
	MOVE 1,[JRST CRSMS0]	;SETUP JSR DISPATCH
	MOVEM 1,CRSMSG+1
	MOVSI 2,-CTYLIN+1	;ACTIVATE DLS LINES (BUT NOT CTY)
	MOVE 1,[XWD DLSDLB,DLSACT+1B27]	;DIRECTED LINE, ACTIVATE, NO XMIT
	DPB 2,[POINT 6,1,17]	;PUT LINE NUMBER IN DATAO WORD
	DATAO DLS,1
	AOBJN 2,.-2

; I4-TENEX TTYSRV INITIALIZATION.

	CALL I4TTIN

; TYMNET initialization

IFDEF TYMSW, <CALL TYMINI>
	RET

;CALLED ONLY FROM TTINIT

TTILIN:	CALL TTCIBF		;INITIALIZE TTY LINE
	MOVE 1,NORMTF		;USUAL DEVICE FLAGS AND STATUS
	CAIGE 2,NTTYS
	TRO 1,1			;TURN ON "CARRIER ON" BIT FOR NON NET TTYS
	DPB 1,[POINT 35,TTFLGS(2),35]
	SETZM TTPSI(2)
	SETZM TTLPOS(2)
	MOVE 1,TTICB1		;SETUP USUAL CONTROL CHARACTER MODES
	MOVEM 1,FCMOD1(2)
	MOVE 1,TTICB2
	MOVEM 1,FCMOD2(2)
	MOVEI 1,TAB81		;NORMAL TABS
	MOVEM 1,TTMOD1(2)
	RET

;RESUME RUNNING TTY'S AFTER RESTART

TTRSET:	MOVSI 2,-CTYLIN
	CONO TTY,DLSCHN
	CONO DLS,DLSCHN		;ASSUMES I-O RESET WAS DONE
TTRST1:
	SKIPL TTFLGS(2)		;WAS XMITTER IN OPERATION
	JRST .+3		;NO
	HRRZM 2,TTNIT1		;YES, SIMULATE INTERRUPT TO RESUME ACTION
	ISB DLSCHN
	AOBJN 2,TTRST1
	JRST TTACTL

;TTY BUFFER CONTROL ROUTINES

;ASSIGN AND SETUP TTY BUFFERS
; 3/ NUMBER OF BUFFERS TO GET
;  RETURNS +1 TRANSPARENT, EXCEPT
; 3/ BYTE POINTER FOR INPUT AND OUTPUT POINTER WORDS
;THIS ROUTINE ASSUMES THAT IT IS PROTECTED FROM RESCHEDULING

TTGTBF:	PUSH P,1		;TRANSPARENT TO ALL AC'S EXCEPT 3
	PUSH P,3		;SAVE COUNT
	SETZ 1,
TTGTB1:	
	HLOCKI PILCK		;LOCK OUT OTHER PEOPLE
	SOSGE TTFREC		;REDUCE FREE BUFFER COUNT
	JRST TTGTB3
	HRRZ 3,@TTFREB		;GET BUFFER FROM LIST
	EXCH 3,TTFREB
	HULOCK PILCK
	OKPI
	JUMPE 1,[MOVSI 1,0(3)	;FIRST BUFFER, REMEMBER ITS ADDRESS
		JRST .+2]
	HRRZM 3,0(1)		;CONC NEW BUFFER ONTO LIST
	HRRI 1,0(3)
	SOSLE 0(P)		;GOT REQUESTED NUMBER OF BUFFERS?
	JRST TTGTB1		;NO
	HLRZ 3,1		;ADDRESS OF FIRST BUFFER IN LIST
	HRRZM 3,0(1)		;COMPLETE CIRCULAR LIST
	ADD 3,[XWD 441100,1]	;CONSTRUCT 9-BIT BYTE POINTER
IFTYM 2,<ADD 3,[300,,0]>	;TYMNET LINES GET 12-BIT BYTE POINTER
	AOS -2(P)		; SKIP RETURN
TTGTB2:	POP P,1			;JUNK
	POP P,1
	RET
TTGTB3:
	BUG(CHK,<RAN OUT OF TTY BUFFERS>)
	HULOCK PILCK
	OKPI
	JUMPE 1,TTGTB2	; NONE ASSIGNED, RETURN
	HLRZ 3,1	; COMPLETE WHAT WE HAVE
	HRRZM 2,0(1)
	ADD 3,[XWD 441100,1]
	CALL TTRLBF	; RELEASE THEM
	JRST TTGTB2

;RELEASE LIST OF TTY BUFFERS
; 3/ BYTE POINTER ANYWHERE IN ANY BUFFER OF LIST
;  RETURNS +1, CLOBBERS 3
;ASSUMES INTERRUPT PROTECTION AS ABOVE

TTRLBF:	MOVEI 3,0(3)
	JUMPE 3,R		;IN CASE NO BUFFERS
	PUSH P,1
	TDNN 3,WRPMSK		;NOW AT END OF BUFFER?
	SUBI 3,TTSIZ		;YES
	ANDCM 3,WRPMSK		;NORMALIZE POINTER TO FIRST WD OF BFR
	ADDI 3,1		;WHICH IS 1 AFTER THE 0 MOD TTSIZ
	PUSH P,3		;SAVE ADDRESS OF FIRST BUFFER
TTRLB1:	MOVEI 1,0(3)
	HRRZ 3,0(3)		;NEXT BUFFER IN LIST
	HLOCKI PILCK		;LOCK OUT
	EXCH 1,TTFREB		;PUT BUFFER ON FREE LIST
	MOVEM 1,@TTFREB
	AOS TTFREC
	HULOCK PILCK
	OKPI
	CAME 3,0(P)		;CIRCLED AROUND TO FIRST BUFFER?
	JRST TTRLB1		;NO
	POP P,3
	POP P,1
	RET

;RELEASE OUTPUT BUFFERS
; 2/ LINE NUMBER
;  RETURNS +1, CLOBBERS 3
;ASSUMES INTERRUPT PROTECTION AS ABOVE

TTRLOB:	SKIPN 3,TTEOUT(2)	;ECHO BUFFER TO RELEASE?
	JRST .+4		;NO
	SETZM TTEOUT(2)
	SETZM TTEIN(2)
	CALL TTRLBF		;RELEASE IT
	SKIPN 3,TTOOUT(2)	;OUTPUT BUFFERS TO RELEASE?
	JRST .+4		;NO
	SETZM TTOOUT(2)
	SETZM TTOIN(2)
	CALL TTRLBF		;RELEASE THEM
	RET

;TTY CONTROL ROUTINES

TTCOBF:
IFDEF IMPCHN,<
IFDEF I4SW,< CAIL 2,NVTLO >	;I4 NETWORK LINE
IFNDEF I4SW,< CAIL 2,NTTYS >
	JRST NVTCOB >
TTCOBI:	NOSKD1
	DLOCK TTYLCK
	HLOCKI DLSPI		;LOCK OUT INTERRUPT
	SETZM TTOCT(2)		;ZERO OUTPUT COUNT
	SETZB 3,TTOOUT(2)
	EXCH 3,TTOIN(2)
	HULOCK DLSPI
	OKPI
	CALL TTRLBF		;RELEASE BUFFERS
	HLOCKI DLSPI
	SETZM TTECT(2)		;CLEAR ECHO BUFFER TOO
	SETZB 3,TTEOUT(2)
	EXCH 3,TTEIN(2)
	HULOCK DLSPI
	OKPI
	CALL TTRLBF
	ULOCK TTYLCK
	OKSKD1

IFTYM	2,<JRST TYMCOB>		;TYMNET hook

	RET

TTCIBF:	CALL TCIBF

IFTYM	2,<JRST TYMCIB>		;TYMNET hook

	RET

TCIBF:	NOSKD1
	DLOCK TTYLCK		;LOCK TTYS
	MOVEI 1,1B34
	ANDCAM 1,TTFLGS(2)	;CLEAR BKJFN FLAG
	SETZM TTICT(2)
	SETZB 3,TTIOUT(2)
	EXCH 3,TTIIN(2)
	CALL TTRLBF		;RELEASE BUFFERS
	ULOCK TTYLCK		;UNLOCK TTY LOCKS
	OKSKD1
	IFTYM 2,<JRST TYMTCI>	;FOR TYMNET LINES, CHECK TO SEE IF WE
				;CAN TURN OFF POSSIBLE INPUT BACK
				;PRESSURE NOW.
	RET

TTOBET:	SKIPE TTOCT(1)		;SCHEDULER TEST - NOW EMPTY?
	JRST 0(4)
	JRST 1(4)		;YES, RESCHED

TTIBET:	SKIPE TTICT(1)		;SCHEDULER TEST FOR INPUT BUF EMPTY
	JRST 0(4)		;NOT EMPTY
	JRST 1(4)		;EMPTY

	SWAPCD

;MORE CONTROL ROUTINES
;ALL TAKE LINE NUMBER IN AC2, ARG/VALUE IN 1, 2ND ARG/VALUE IN 3, ...

TTSIBE:	MOVEI 3,1B34		;BACKUP BIT
	SKIPG 1,TTICT(2)	;SOMETHING IN BUFFER?
	TDNE 3,TTFLGS(2)	;OR CAN RE-READ PREVIOUS CHAR?
	RET			;YES, BUFFER NOT EMPTY
	JRST RSKP

TTSOBE:	SKIPG 1,TTOCT(2)	;SKIP IF OUTPUT BUFFER EMPTY
	AOS 0(P)
	RET

TTSOBF:	LDB 3,TTOMAX		;CAPACITY OF OUTPUT BUFFER
	MOVE 1,TTOCT(2)		;SKIP IF OUTPUT BUFFER FULL
	CAIL 1,0(3)
	AOS 0(P)
	RET

TTDOBE:	SKIPLE 1,TTOCT(2)	;DISMISS UNTIL OUTPUT BUFFER EMPTY
	JRST TTDOB1
IFTYM	2,<JRST TYMDOB>
IFDEF IMPCHN,< IFDEF I4SW,
			<CAIL 2,NVTLO	;I4 NETWORK?
			>
			IFNDEF	I4SW,
			<CAIL 2,NTTYS
			>
		 JRST NVTDOB>	; NVT WAIT FOR ALL NET BUFFERS TO CLEAR
	RET			; NOT NVT, DONE
TTDOB1:	MOVEI 1,TTOBET
	HRLI 1,0(2)		;LINE NUMBER
	JSYS EDISMS
	JRST TTDOBE

TTDIBE:	SKIPN TTICT(2)
	RET
	MOVEI 1,TTIBET		;INPUT BUFFER EMPTY TEST
	HRLI 1,0(2)
	JSYS EDISMS
	JRST TTDIBE

;TAB GET/SET

TTGTBS:	HRRZ 1,TTMOD1(2)	;TAB TABLE ADR
	MOVE 3,1(1)
	MOVE 4,2(1)
	MOVE 1,0(1)
	RET

TTSTBS:	PUSH P,1
	HRRZ 1,TTMOD1(2)	;ADDRESS OF CURRENT TABS
	CAIN 1,TAB81		;STANDARD?
	JRST TTSTB1		;YES, NOTHING TO RELEASE
	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	EXCH 1,TABLST		;PUT BUFFER ON FREE LIST
	MOVEM 1,@TABLST
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
TTSTB1:	POP P,1
	CAME 1,TAB81		;SEE IF REQUEST TABS ARE STANDARD
	JRST TTSTB2		;NO
	CAMN 3,TAB82
	CAME 4,TAB83
	JRST TTSTB2		;NO, NO
TTSTB4:	MOVEI 1,TAB81		;ADDRESS OF STANDARD TABS
TTSTB3:	HRRM 1,TTMOD1(2)
	RET

TTSTB2:	PUSH P,1
	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	SKIPN TABLST		;FREE TAB BUFFERS?
	JRST [	ULOCK TTYLCK
		OKSKED		;NO
		POP P,1
		JRST TTSTB4]	;USE STANDARD
	MOVE 1,@TABLST		;GET BUFFER
	EXCH 1,TABLST
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
	MOVEM 4,2(1)		;STORE BIT WORDS IN BUFFER
	MOVEM 3,1(1)
	POP P,0(1)
	JRST TTSTB3

TTRMOD:	MOVE 1,TTFLGS(2)	;READ MODES
	RET

TTSMOD:
IFDEF IMPCHN,< CALL NVTMOD>	;DO NECESSARY MODE NEGOTIATION IF NVT
	PUSH P,1
	XOR 1,TTFLGS(2)		;SET RH BITS
	ANDI 1,776300		;CHANGE ONLY THESE BITS
	XORM 1,TTFLGS(2)
	LDB 1,[POINT 2,TTFLGS(2),29]; GET POSSIBLE NEW MODE
	DPB 1,TTYLMD		; MAKE IT BE CURRENT MODE
	POP P,1
	HLLOS TTFORK(2)		;RESET LINE TO NO-WAIT STATE

IFTYM	2,<JRST TYMECO>

	RET

TTRPOS:	MOVE 1,TTLPOS(2)	;READ POSITION
	RET

TTRCOC:	MOVE 1,FCMOD1(2)	;READ CONTROL CHARACTER MODES
	MOVE 3,FCMOD2(2)
	RET

TTSCOC:	MOVEM 1,FCMOD1(2)	;SET CONTROL CHARACTER MODES
	MOVEM 3,FCMOD2(2)

IFTYM	2,<JRST TYMECO>		;TYMNET hook

	RET

;HANG UP DATASET

TTHNGU:

IFTYM	2,<JRST TYHNGU>		;TYMNET hook

	CAIE 2,CTYLIN		;CAN'T HANGUP CTY
	CALL	TTLINC		;CAN'T HANG UP PTY'S EITHER
	RET
	CALL TTDOBE		;WAIT TILL NO OUTPUT
IFDEF IMPCHN,<
	CAIL 2,NVTLO		;IS IT AN NVT?
	CAILE 2,NVTHI		; ..
	SKIPA			;NO
	JRST NVTDET		;YES.
>
	MOVEI 1,TTHU0		;HANGUP FIRST STATE ROUTINE
	CALL TTQAD		;ADD TO QUEUE
	RET

;"BACKUP" INPUT POINTER - CAN ONLY BACKUP ONE

TTBKPT:	MOVEI 3,1B34
	TDNE 3,TTFLGS(2)	;ALREADY BACKUPED?
	RET			;YES
	IORM 3,TTFLGS(2)	;SET FLAG TO BE NOTICED AT NEXT TCI
	JRST RSKP

TTSPOS:	MOVEM 1,TTLPOS(2)	;SET LINE CHARACTER POSITION
	RET

;SIMULATE TTY INPUT

	RESCD

TTSTI:	PUSH P,1
	CALL TTSOBF		; ROOM FOR DEFERRED ECHOS?
	 JRST TTSTI0		; YES, GO AHEAD
	MOVEI 1,TCOTST		; NO, WAIT
	HRL 1,2
	JSYS EDISMS
TTSTI0:	POP P,1
	CAIN 1,37
	MOVEI 1,15		;SUBSTITUTE CR FOR NOW
TTSTI1:	ANDI 1,377		;ISOLATE CHARACTER
	MOVEI 6,TTSCF		; FLAG CH FROM STI
	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	CALL TTCHI		; STUFF IT INTO TTY BUFFER
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
	RET

	SWAPCD

;SET/GET TERMINAL TYPE

.STTYP:	JSYS MENTR
IFE SUMEX,<CALL CHKTTM>		;PSI ERROR FOR NON TTY JFN
IFN SUMEX,<
	CALL CHKTTY		;NOP FOR NON TYY JFN
	 JRST UNL		;NOT A TTY UNLOCK AND EXIT
	CALL UNLCKF
>
	UMOVE 3,2
	CAIL 3,0		;REASONABLE NUMBER?
	CAIL 3,NTTYPS
	ITERR			;NO
	HRRM 3,TTYPE(2)
	LDB 1,TTMBIT		;GET MECH BITS
	DPB 1,[POINT 3,TTFLGS(2),3] ;PUT WHERE NOTICED

IFTYM	2,<CALL TYMTYP>		;TYMNET hook

	JRST MRETN

.GTTYP:	JSYS MENTR
IFE SUMEX,<CALL CHKTTM>		;PSI ERROR FOR NON TTY JFN
IFN SUMEX,<
	CALL CHKTTY		;NOP FOR NON TYY JFN
	 JRST [CALL UNLCKF	;NOT A TTY UNLOCK AND EXIT
		HRRZI 1,3	;default terminal type
		UMOVEM 1,2
		MOVEI 3,0	;default buffer allocation
		UMOVEM 3,3
		JRST MRETN]
	CALL UNLCKF
>
	HRRZ 1,TTYPE(2)
	UMOVEM 1,2
	LDB 1,TTNIN		;RETURN BUFFER ALLOC ALSO
	LDB 3,TTNOU
	HRLI 3,0(1)
	UMOVEM 3,3
	JRST MRETN

;SET TERMINAL PARAMETERS

.STPAR:	JSYS MENTR
IFE SUMEX,<CALL CHKTTM>		;PSI ERROR FOR NON TTY JFN
IFN SUMEX,<CALL CHKTTY		;NOP FOR NON TYY JFN
	JRST UNL		;NOT A TTY UNLOCK AND EXIT
	CALL UNLCKF
>
	UMOVE 1,2
IFDEF IMPCHN,<
	CALL NVTPAR >		;GO DO ANY NVT NEGOTIATIONS NEEDED
	PUSH P,1
	XOR 1,TTFLGS(2)
	ANDI 1,74		;CHANGE THESE BITS
	XORM 1,TTFLGS(2)
	TRNE 1,14		;CHANGING DUPLICITY?
	JRST [	IFDEF	I4SW,
		<CAIGE 2,NVTLO
		>
		IFNDEF	I4SW,
		<CAIGE 2,NTTYS	;YES, NET LINE?
		>
		JRST .+1	;NO
		MOVE 1,TTFLGS(2) ;GET NEW DUPLICITY
		ANDI 1,14
		CAIE 1,0	;FULL?
		SKIPA 1,[204]	;NO, SEND 'YOU ECHO'
		MOVEI 1,203	;SEND 'I ECHO'
		CALL TCOB
		JRST .+1]
	LDB 1,[POINT 7,0(P),10]
	CAIL 1,10		;LEGAL PAGE SIZE?
	CAIL 1,200
	MOVEI 1,^D66		;USE DEFAULT
	DPB 1,[POINT 7,TTFLGS(2),10]
	LDB 1,[POINT 7,0(P),17]
	CAIL 1,10		;LEGAL WIDTH
	CAIL 1,200
	SETZ 1,			;DEFAULT IS NO FOLDING
	DPB 1,[POINT 7,TTFLGS(2),17]
	LDB 1,[POINT 3,0(P),3]
	DPB 1,[POINT 3,TTFLGS(2),3]	;LH BITS
	POP P,1

IFTYM	2,<CALL TYMECO>		;TYMNET hook

	JRST MRETN
;DISPLAY DELETE - CHECK IF NON-BINARY MODE DISPLAY
;TO BACK UP LINE POSITION ONE CHARACTER FOR LINE NUMBER IN 2
;THEN OUTPUT TO DELETE CHAR ON DISPLAY - FOR DELETE CHAR JSYS(DELCH)
;RETURNS +1 IF BINARY MODE OR NOT DISPLAY
;	 +2 IF LINE EMPTY ALREADY
;	 +3 IF DELETE DONE OK
INTERN TTDELO

TTDELO:	MOVE 3,TTFLGS(2)	;CHECK BINARY MODE
	TRNN 3,3B29
	RET
	HRRZ 3,TTYPE(2)	;GET TYPE
	ANDI 3,37		;CLEANLY
	CAIL 3,^D9		;TEC=9,IMLAC=10
	CAILE 3,^D11		;DATA-MEDIA=11
	RET		;RETURN IF NOT TYPE 9-11
	AOS (P)			;TYPE OK, RET + 2
	HRRZ 4,TTLPOS(2)	;GET LINE POSITION
	SKIPN 4			;CHECK FOR 0
	RET			;RETURN +2
	SOS TTLPOS(2)		;ELSE BACK UP ONE
	AOS (P)			;RETURN +3
	CAIN 3,^D10		;IS IT IMLAC
	JRST TTDELI		;YES,DO IMLAC RUBOUT
	CAIN 3,^D11		;CHECK DATA-MEDIA
	JRST TTDELD		;DATA MEDIA DELETE
			;TEC - ELSE FALL INTO TEC DELETE
	MOVEI 1,167		;LOWER CASE W -LEFT ONE CHAR
	CALL TCOUT		;TO OUTPUT
	MOVEI 1,143		;LOWER CASE C - ERASE TO END OF LINE
	JRST TCOUT		;AND RETURN
			;IMLAC
TTDELI:	MOVEI 1,177		;RUBOUT DELETES ON IMLAC
	JRST TCOUT		;AND RETURN
			;DATA-MEDIA
TTDELD:	MOVEI 1, 10		;BACK CURSOR CHAR - ^H
	CALL TCOUT
	MOVEI 1, 27		;ERASE TO END OF LINE - ^W
	JRST TCOUT		;AND RETURN


;TLINK JSYS

.TLINK:	JSYS MENTR
	MOVEI 1,0(1)
	CALL CHKTTM		;CHECK DESIGNATOR, GET LINE NO IN 2
	PUSH P,2		;SAVE OBJECT LINE NUMBER
	UMOVE 1,1
	TLNN 1,(74B5)		;SECOND DESIGNATOR REQUIRED?
	JRST TL1		;NO
	XCTUU [HRRZ 2,2]
	CAIN 2,-1		;'ALL' ?
	JRST TL1		;YES, LEAVE AS IS
	TRZE 2,1B18		;4XXXXX?
	JRST TL2		;YES
	MOVE 1,2		;ASSUME REGULAR JFN
	CALL CHKTTM
TL2:	CALL	TTLINC		;CHECK FOR PTY'S
	RETERR	DESX1
	CAIGE 2,NLINES		;LEGAL LINE?
	CAIGE 2,0
	RETERR DESX1		;NO
TL1:	POP P,7			;OBJECT DESIGNATOR
	UMOVE 6,1		;GET FUNCTION FLAGS
	TLNE 6,(1B0)
	CALL TLINK0		;CLEAR REMOTE TO OBJECT
	TLNE 6,(1B1)
	CALL TLINK1		;CLEAR OBJECT TO REMOTE
	TLNE 6,(1B2)
	CALL TLINK2		;SET OBJECT TO REMOTE
	TLNE 6,(1B3)
	CALL TLINK3		;SET REMOTE TO OBJECT
	TLNE 6,(1B4)
	CALL TLINK4		;SET ACCEPT BIT TO C(B5)
MRSKP:	AOS 0(P)
	JRST MRETN

TTLINC:	CAIL	2,PTYLO
	CAIL	2,PTYLO+NPTY
	AOS	0(P)		;SKIP RETURN MEANS NON-PTY
	RET			;NON-SKIP MEANS PTY

;CLEAR REMOTE TO OBJECT

TLINK0:	CAIE 2,-1		;ALL REMOTES?
	JRST [	CALL TL0C	;NO, DO THE ONE SPECIFIED
		RET]
	PUSH P,2
	MOVEI 2,0		;SCAN ALL LINES
	CALL TL0C		;CLEARING ANY LINKS TO OBJECT
	CAIGE 2,NLINES-1
	AOJA 2,.-2
	POP P,2
	RET

TL0C:	CALL TLTST1		;LOOK AT REMOTE LINE
	JUMPL 1,R		;DONE IF NO LINKS TO OBJ
IFDEF	I4SW,
<	CALL	TLT3		;CK IF OBJECT IS CTY
>
	MOVEI 1,777
	DPB 1,5			;CLEAR THE LINK JUST FOUND
	JRST TL0C

;CLEAR OBJECT TO REMOTE

TLINK1:	CAIE 2,-1		;ALL?
	JRST [	CALL TL1C	;NO, CLEAR SPECIFIC
		RET]
	MOVE 5,[POINT 9,TTLINK(7),-1]
	PUSH P,2
TL12:	ILDB 2,5		;SCAN ALL FIELDS OF OBJECT LINE
	CAIN 2,777
	JRST .+4
	PUSH P,5
	CALL TL1C
	POP P,5
	TLNE 5,(7B2)
	JRST TL12
	POP P,2
	RET

TL1C:	CALL TLTST2		;FIND LINK TO REMOTE
	JUMPL 1,R		;NONE, DONE
IFDEF	I4SW,
<	LDB	1,5		;CK IF REMOTE IS CTY
	CALL	TLT3
>
	MOVE 1,CAPMSK
	TRNE 1,WHEEL+OPER	;PRIVILEGED?
	JRST TL13		;YES, SKIP CHECK
	PUSH P,5
	CALL TLTST1		;EXISTS REMOTE TO OBJECT?
	POP P,5
	JUMPG 1,TLNKE1		;ERROR IF YES
TL13:	MOVEI 1,777
	DPB 1,5			;CLEAR LINK JUST FOUND
	JRST TL1C

TLNKE1:	ITERR TLNKX1		;ILLEG REM TO OBJ

;SET OBJECT TO REMOTE

TLINK2:	CAIN 2,-1
	RETERR DESX1		;NON-SPECIFIC DESIGNATOR ILLEG HERE
	CAMN 2,7		;LINK TO SELF?
	RET			;YES, IGNORE
	CALL TLTST2		;LINK ALREADY EXISTS?
	JUMPG 1,R		;IGNORE IF YES
	MOVEI 5,5		;DO 5 RINGS
TL21:	MOVE 3,TTFLGS(2)	;GET ACCEPT BIT
	MOVE 4,CAPENB
	TRNN 4,WHEEL+OPER	;PRIVILEGED? OR
	TRNE 3,1B26		;REMOTE ACCEPTING?
	JRST TL22		;YES
IFDEF	I4SW,
<	CAIN	2,CTYLIN	; IF CTY, CHK
	JRST	TL24
>
	TRNN 3,3B29		;REFUSING LINE BINARY?
	 SETO 5,		;YES, GIVE ERROR NOW

	JUMPL 5,[		;NO, GIVEE ERROR AFTER FIVE RINGS
		RETERR(TLNKX2)]
	MOVEI 4,^D10		;A RING IS 10 BELLS
	MOVEI 1,"G"-100		;BELL
TL23:	CALL TCEO2		;RING REMOTE
	EXCH 2,7
	CALL TCEO2		;RING LOCAL
	EXCH 2,7
	SOJG 4,TL23
	MOVEI 1,^D3000		;WAIT FOR 3 SECONDS, THE BELL WILL BE
	DISMS			;RINGING FOR THE FIRST SECOND OF WAIT
	SOJA 5,TL21		;GO SEE IF REMOTE NOW ACCEPTING

TL22:	PUSH P,2
	MOVEI 2,777
	CALL TLTST2		;FIND FREE FIELD IN OBJECT
	POP P,2
	JUMPL 1,[		;GIVE LINKS FULL ERROR
		RETERR(TLNKX3)]
	DPB 2,5			;DEPOSIT REMOTE NUMBER IN FIELD
	PUSH P,2
IFDEF	I4SW,
<	CAIN	2,CTYLIN
	JRST	[HRROI	3,776777; SET CTY BUSY BY
		 ANDM	3,TTFLGS(2);  CLEARING ACCEPT LINKS
		 JRST	.+1]
>
	XCTUU [HRRZ 1,1]	;OBJECT DESIGNATOR
	HRROI 2,[ASCIZ /
LINK FROM /]
TL22AD:	SETZ 3,
	SOUT			;MSG ON OBJECT ALSO SEEN ON REMOTE
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)	;USER ON THIS JOB
	DIRST			;TYPE HIS NAME
	JFCL
	HRROI 2,[ASCIZ /, TTY /]
	SOUT
	MOVE 2,7		;OBJECT LINE NUMBER
	MOVEI 3,10
	NOUT
	JFCL
	MOVEI 2,37
	BOUT
	POP P,2
	RET

;SET REMOTE TO OBJECT

TLINK3:	CAIN 2,-1
	RETERR DESX1		;MULTIPLE DESIGNATOR ILLEGAL
	CAMN 2,7		;LINK TO SELF?
	RET			;YES, IGNORE
	CALL TLTST1		;LINK ALREADY EXISTS?
	JUMPG 1,R		;RETURN IF SO
	MOVE 1,CAPENB
	TRNE 1,WHEEL+OPER	;PRIVILEGED?
	JRST TL31		;YES, SKIP SHECK
	CALL TLTST2		;CHECK OBJ TO REMOTE
	JUMPL 1,TLNKE1		;ERROR, OBJ TO REMOTE NOT DONE FIRST
TL31:	PUSH P,7
	MOVEI 7,777
	CALL TLTST1		;FIND FREE FIELD IN REMOTE
	POP P,7
	JUMPL 1,MRETN		;LINK WORD FULL
	DPB 7,5			;DEPOSIT OBJ NUMBER IN FIELD
	RET

;SET ACCEPT BIT

TLINK4:	MOVEI 1,1B26		;IT IS BIT 26 IN TTFLGS
	TLNE 6,(1B5)		;SET IT?
	IORM 1,TTFLGS(7)	;YES
	TLNN 6,(1B5)		;CLEAR IT?
	ANDCAM 1,TTFLGS(7)	;YES
	RET

;CHECK FOR EXISTENCE OF REMOTE TO OBJECT
; VALUE .GE. 0 MEANS YES

TLTST1:	MOVE 5,[POINT 9,TTLINK(2),-1]
TLT1:	ILDB 1,5		;SCAN REMOTE
	CAMN 1,7		;FOUND OBJECT?
	RET			;YES
	TLNE 5,(7B2)		;NO, SCANNED ALL FIELDS?
	JRST TLT1		;NO
	SETO 1,			;YES, RETURN NEGATIVE VALUE
	RET

;CHECK FOR EXISTENCE OF OBJECT TO REMOTE
; VALUE .GE. 0 MEANS YES

TLTST2:	MOVE 5,[POINT 9,TTLINK(7),-1]
TLT2:	ILDB 1,5		;SCAN OBJECT
	CAMN 1,2		;FOUND REMOTE?
	RET			;YES
	TLNE 5,(7B2)		;NO, SCANNED ALL FIELDS?
	JRST TLT2		;NO
	SETO 1,			;YES, RETURN NEG VALUE
	RET

COMMENT \

;ADVIZ JSYS -- ADVISE ANOTHER TERMINAL
	ACCEPTS IN 1: CONTROL WORD AS FOLLOWS:
	B0=1 BREAK ANY ADVISE LINK TO/FROM ME
	B1=1 ESTABLISH ADVISE LINK FROM ME TO LINE IN 18-35
	B2=1 SET UP TO RECEIVE ADVICE FROM LINE IN 18-35

	RETURNS +1:	UNSUCCESSFUL, ERROR CODE IN 1
		+2:	SUCCESSFUL, ADVISE LINK ESTABLISHED
NOTE THAT THE CHARACTERS ^Y AND ^C HAVE SPECIAL MEANING FROM AN
ADVISOR: ^Y IS TRANSLATED TO ^C AND SENT AS ADVICE. ^C BREAKS
THE ADVISE LINK, BUT NOT THE OUTPUT LINK

TTADVS(LINE) HAS -1 IF NOT ADVISING OR BEING ADVISED,  0,,N  IF
	ADVISING LINE N,  OR  -1,,M  IF RECEIVING ADVISE FROM
	LINE M, OR  400000,,P IF WILLING TO RECEIVE ADVISE
	FROM LINE P
\

.ADVIZ:	JSYS MENTR		;ENTER MONITOR ENVIRONMENT
	MOVE 6,1		;SAVE CALLING ARGUMENT IN 6
	TLNE 1,(1B1)		;MAKE SURE NOT REQUESTING BOTH
	TLNN 1,(1B2)		;DIRECTIONS AT ONCE
	CAIA			;OK
	  RETERR ADVX3		;NO GOOD
	TLNN 1,(1B1!1B2)	;BOTH OFF?
	JRST ADVIZ0		;YES. BREAK THE LINKS, IF ANY.
	HRRZ 2,6		;GET TTY NUMBER INVOLVED
	TRZE 2,400000		;DESIGNATOR BIT ON?
	JRST ADVIZ1		;YES
	MOVE 1,2		;NO. MAY BE A TTY JFN
	CALL CHKTTM		;GO SEE, ERROR IF NOT.
ADVIZ1:	CAIGE 2,NLINES		;LEGAL LINE?
	CAIGE 2,0		; ..
	RETERR DESX1		;NO.
	MOVE 10,2		;OK. SAVE THE LINE NUMBER IN 10
ADVIZ0:	TLNE 6,(1B0)		;REQUEST TO BREAK LINK?
	CALL TADVS0		;YES
	TLNE 6,(1B1)		;REQUEST TO ADVISE SOMEONE?
	CALL TADVS1		;YES
	TLNE 6,(1B2)		;REQUEST TO RECEIVE ADVICE?
	CALL TADVS2		;YES
	JRST SKMRTN		;GIVE SKIP RETURN
RESCD
;RESIDENT BECAUSE DONE BY ^C
;BREAK ADVISE LINK.
TADVS0:	HRRZ 2,CTRLTT		;GET MY LINE NUMBER
	CAIN 2,-1
	RETERR DESX1		;BUT I AM DETACHED!
TADV00:	PUSH P,1		;CALLED HERE BY ^C
	SETO 1,
	EXCH 1,TTADVS(2)	;BREAK THE LINK. WHAT WAS IT?
	HRRZS 1			;LINE NUMBER
	CAIGE 1,NLINES		;IF STILL THERE.
	SETOM TTADVS(1)		;BREAK HIS SIDE OF IT TOO.
	POP P,1			;RESTORE AC 1
	RET			;POPJ
SWAPCD

;SET ME UP TO ADVISE SOMEONE ELSE (LINE IN 10)

TADVS1:	HRRZ 7,CTRLTT		;GET THE CONTROLLING TTY NUMBER
	CAIE 7,-1		;DETACHED?
	CAIN 7,0(10)		;OR TRYING TO ADVISE SELF?
	RET			;JUST RETURN.
	CAMN 10,TTADVS(7)	;ALREADY SET UP?
	RET			;YES. IGNORE.
	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	MOVE 2,TTADVS(7)	;SEE IF ALREADY ANOTHER ONE
	AOJN 2,CADVX4		;JUMP IF WASN'T -1
TADV11:	MOVE 4,CAPENB		;SEE IF A WHEEL/OPER
	TRNE 4,WHEEL+OPER
	JRST TADV12		;YES. DONT NEED PERMISSION
	HRRZ 4,TTADVS(10)	;NO, SEE IF ACCEPT HAS BEEN DONE
	HLRZ 3,TTADVS(10)
	CAIN 3,(1B0)		;B0 ON?
	CAME 4,7		;AND THIS LINE NUMBER = SELF?
	CAIA			;NO. NOT ACCEPTED
	JRST TADV12		;OK
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED			;ALLOW SCHEDULING AGAIN
	RETERR(ADVX1)		;NOT ACCEPTED

;HERE TO ACTUALLY SET THE ADVISE LINK

TADV12:	NOINT			;STABILIZE TABLES
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED			;ALLOW OTHER JOBS TO RUN
	HRRZ 2,10		;GET ADVISEE LINE
	CALL TLTST2		;ADVISOR ALREADY LINKED TO ADVISEE?
	JUMPGE 1,TADV13		;YES
	MOVEI 2,777
	CALL TLTST2		;LOOK FOR FREE LINK
	JUMPL 1,TADV19		;NONE, GIVE ERROR
	DPB 10,5		;SET LINK
TADV13:	HRRZ 2,10		;ADVISEE LINE
	CALL TLTST1		;ADVISEE ALREADY LINKED TO ADVISOR?
	JUMPGE 1,TADV14		;YES
	PUSH P,7
	MOVEI 7,777
	CALL TLTST1		;LOOK FOR FREE ENTRY
	POP P,7
	DPB 7,5			;SET THE LINK
	JUMPL 1,TADV19		;NONE, GIVE ERROR

TADV14:	HRRZM 10,TTADVS(7)	;SET UP ADVISEE TO BE RECEIVING
	HRROM 7,TTADVS(10)	;AND ADVISOR TO BE SENDING
	OKINT
	PUSH P,2		;NEEDED TO MATCH LEVEL IN LINK
	MOVEI 1,400000(7)	;SEND MSG TO THIS LINE
	HRROI 2,[ASCIZ /
ADVICE FROM /]
	JRST TL22AD		;JOIN CODE FOR LINK MESSAGE


TADV19:	SETOM TTADVS(10)	;FLUSH ADVISE LINK (MAKE IDLE)
	MOVEI 1,TLNKX3
	OKINT
	JRST MRETNE		;RETURN ERROR CODE

;HERE FROM ADVIZ JSYS TO ACCEPT ADVICE.

TADVS2:	HRRZ 7,CTRLTT		;MY LINE NUMBER
	CAIL 7,-1		;DETACHED?
	RETERR DESX1
	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	MOVE 3,TTADVS(7)	;GET MY CURRENT ADVISE STATE
	AOJE 3,TADV20		;JUMP IF WAS IDLE
CADVX4:	ULOCK TTYLCK
	OKSKED
	RETERR ADVX4		;ERROR. ANOTHER ADVISE IN PROGRESS.

TADV20:	MOVSI 3,(1B0)		;SET RECEIVING FROM LINE N
	HRR 3,10		;HERE'S N
	MOVEM 3,TTADVS(7)	;SET TO ACCEPT ADVISE
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
	RET

;CODE TO ACTUALLY DO THE ADVISE
;
; 1)	CHAR TYPED BY ADVISOR
; 2)	LINE NUMBER OF ADVISOR
; 3)	LINE NUMBER OF ADVISEE

RESCD

TTAVS:	MOVEI 4,0(1)		;GET JUST 7 BITS
	ANDI 4,177		; ..
	CAIN 4,"C"&37		;CONTROL C?
	JRST [	CALL TADV00	;YES. BREAK LINK.
		RET]		;AND RETURN
	MOVE 2,3		;SWITCH LINE NUMBERS
	CAIN 4,"Y"&37		;CONTROL Y?
	MOVEI A,"C"&37		;YES, MAKE IT A CONTROL C
	RET

	RESCD

;PSEUDO-INTERRUPT CHARACTER TABLE
	RADIX 10
NU==36		;NOT USED VALUE

PSICH:	0	;CONTROL GROUP - @ (BREAK)
	1	;A
	2	;B
	3	;C
	4	;D
	5	;E
	6	;F
	7	;G

	8	;H
	9	;I
	10	;J
	11	;K
	12	;L
	13	;M (CR)
	14	;N
	15	;O

	16	;P
	17	;Q
	18	;R
	19	;S
	20	;T
	21	;U
	22	;V
	23	;W

	24	;X
	25	;Y
	26	;Z
	27	;ALTMODE
	NU	;34
	NU	;35
	NU	;36
	NU	;37

	29	;SPACE
PSICHH:	NU	;173
	NU	;174
	27	;175 (OLD ALTMODE)
	27	;176 (OLD ALTMODE)
	28	;177 (RUBOUT)
	RADIX 8

PSICHU==173		;FIRST CHARACTER OF UPPER GROUP
PSICHL==PSICHH-PSICH	;SIZE OF LOWER GROUP
PSICHO==PSICH+PSICHU-PSICHH	;UPPER GROUP OFFSET

;CHARACTER CLASS TABLE (FOR WAKEUP CONTROL)

FC==10		;FORMAT CONTROL
C==4		;CONTROL, NON-FORMAT
PC==2		;PUNCTUATION
A==1		;ALPHANUMERIC

TTWKTB:	BYTE (6) C,C,C,C,C,C		;NULL - E(C)
	BYTE (6) C,C,FC,FC,FC,C		;F(C) - K(C)
	BYTE (6) FC,FC,C,C,C,C		;L(C) - Q(C)
	BYTE (6) C,C,C,C,C,C		;R(C) - W(C)
	BYTE (6) C,C,C,FC+C,C,C		;X(C) - Z(C), ESC - 035
	BYTE (6) C,FC,PC,PC,PC,PC	;036, EOL, SPACE - #
	REPEAT 2,<BYTE (6) PC,PC,PC,PC,PC,PC>
					;$ - /
	BYTE (6) A,A,A,A,A,A		;0 - 5
	BYTE (6) A,A,A,A,PC,PC		;6 - 9, COLON, SEMI
	BYTE (6) PC,PC,PC,PC,PC,A	;LEFT ANG BK - AT, A
	REPEAT 4,<BYTE (6) A,A,A,A,A,A>
					;B - Y
	BYTE (6) A,PC,PC,PC,PC,PC	;Z, LEFT BK - LARR
	BYTE (6) PC,A,A,A,A,A		;140, A(LC) - E
	REPEAT 3,<BYTE (6) A,A,A,A,A,A>
					;;F(LC) - W(LC)
	BYTE (6) A,A,A,PC,PC,PC		;X - Z(LC), 173 - 175
	BYTE (6) PC,FC			;176, RUBOUT

;6-BIT POINTER TABLE

	POINT 6,0,-1
CH6TAB:	POINT 6,0,5
	POINT 6,0,11
	POINT 6,0,17
	POINT 6,0,23
	POINT 6,0,29
	POINT 6,0,35

XX=0
BHC:	REPEAT 20,<EXP XX*1000001
		XX=XX+1>

XX==0
BITS:	REPEAT ^D36,<EXP 1B<XX>
		XX=XX+1>

;OUTPUT CHARACTER TO TERMINAL
; TCO - FIRST LEVEL, TRANSLATE ACCORDING TO PROGRAM DESIRES
; TOCY- SECOND LEVEL, DO LINKS AND FORMAT FOR PARTICULAR DEVICE
; TCOUT-THIRD LEVEL, DO BUFFERING ETC.

TCO:	MOVE 3,TTFLGS(2)
	TRCN 3,3B29		;BINARY?
	JRST TCOUTX		;YES, DIRECT OUTPUT, NO TRANSLATION
	PUSH P,1
	ANDI 1,177
	TRCN 3,3B29		;MODE 3? (BOTH 1'S)
	JRST TC1B		;YES, NO OUTPUT TRANSLATION
TCOE1:	CAIGE 1,40		;CONTROL GROUP?
	JRST TC1A		;YES
TC1B:	CALL TCOY
TC1C:	POP P,1
	RET

;ECHO OUTPUT

TCOE:	PUSH P,1
	ANDI 1,177
	CAIN 1,177		;RUBOUT?
	JRST TC1C		;DON'T ECHO (FIXES NVT LINK PROBLEM)
	MOVE 3,TTFLGS(2)
	TRNE 3,1B29		;MODE 1 OR 3?
	JRST TCOE1		;YES, TRANSLATE INPUT
	JRST TC1B

;TRANSLATE CONTROL CHARS ACCORDING TO CC MODES
; 00 - SEND NOTHING
; 01 - INDICATE, E.G. ^A
; 1X - DO FUNCTION (SECOND LEVEL HANDLES SIMULATION IF NECESSARY)

TC1A:	MOVE 4,FCMOD2(2)
	MOVE 3,FCMOD1(2)	;GET MODE BITS
	ROTC 3,0(1)
	ROTC 3,0(1)
	CAIN 1,33		;ESC SPECIAL CASE?
	JRST [	TLNN 3,(3B1)	;YES, FLUSH CASE?
		JRST TC1C	;YES
		TLNN 3,(1B1)
		JRST TC1B	;10 CASE, OUTPUT REAL CHAR
		TLNN 3,(1B0)
		JRST TC1D	;01 CASE, INDICATE WITH ^[
		MOVEI 1,"$"	;11 CASE, 'SIMULATE' WITH $
		JRST TC1B]
	TLNE 3,(1B0)		;DO?
	JRST TC1B		;YES
	TLNN 3,(1B1)		;FLUSH?
	JRST TC1C		;YES
TC1D:	ADDI 1,100		;CONVERT TO PRINTING EQUIV.
	PUSH P,1
	MOVEI 1,TTCIND
	CALL TCOY		;PRINT INDICATOR
	POP P,1
	JRST TC1B

;SECOND LEVEL - HANDLE DEVICE IDEOSYNCRACIES AND CHAR ACCOUNTING

TCOY:	SKIPE 3,TTLINK(2)	;LINKS?
	CALL TTLNK3		;YES, DO THEM
TCOY1:	CAIL 1,177
	JRST TCOUT		;RUBOUT
	SKIPE IMECHF		;IMMED ECHO CHAR?
	JRST [	IFDEF TYMSW,<
		CAIL 2,TYMTTL
		CAIL 2,TYMTTL+NTYMTT
		 CAIA
		SKIPA 3,TYMLNS(2)
>
		MOVE 3,TTFLGS(2) ;YES, CHECK DUPLEX BITS
		SKIPN LINKF	;LINKED CHAR? OR
		TRCN 3,3B33	;FULL?
		JRST .+1	;YES
		CALL TTCOHA	; ACCOUNT FOR SPACING OF HDX TERM
		CAIGE 1,40	;IS CONTROL CHAR AND MODE 2?
		TRNN 3,3B33
		RET		;NO, NO ECHO
		JRST TTCO1]	;YES, ECHO CONTROL FN
; SUMEX ONLY CODE TO TURN ON LOG TTY BEFORE PRINTING !! MAH @ SUMEX 12/74 !!
IFN SUMEX,<
	CAIN 2,0		;DO ONLY FOR LINE 0
	CALL TTSM7		;WAKE UP TTY FIRST
>
	CAIGE 1,40
	JRST TTCO1		;CONTROL GROUP
	CAIL 1,140
	JRST TTCO2		;LOWER CASE GROUP
TTCO6:	AOS 3,TTLPOS(2)		;SPACING CHARACTER
TTCO8:	LDB 4,[POINT 7,TTFLGS(2),17] ;GET RIGHT MARGIN
	JUMPE 4,TCOUT		;0 MEANS NEVER FOLD
	CAIL 4,0(3)		;CHECK FOR OVERFLOW
	JRST TCOUT
	PUSH P,1		;LINE OVERFLOW, DO CR AND CONTINUATION
	MOVEI 1,15
	CALL TTSM5		;DO CR
	MOVEI 1,12
	CALL TTSM2		;DO LF
	MOVEI 1,2		;COUNT 2 *'S
	HRRM 1,TTLPOS(2)
	MOVEI 1,52
	CALL TCOUT
	CALL TCOUT
	POP P,1
	JRST TTCO6

;LOWER CASE GROUP

TTCO2:	MOVE 3,TTFLGS(2)	;DEVICE CHARACTERISTICS
	TLNE 3,(TTLCBT)		;HAS LOWER CASE?
	JRST TTCO6		;YES
	SUBI 1,40		;INDICATE LOWER CASE AND CONVERT
	TRNN 3,40		;INDICATE LC?
	JRST TTCO6		;NO.
	PUSH P,1
	MOVEI 1,TTLIND		;INDICATION CHARACTER
	CALL TCOUT
	AOS TTLPOS(2)
	POP P,1
	JRST TTCO6

; ACCOUNT SPACING PERFORMED BY HDX TERMINAL

TTCOHA:	PUSH P,3
	CAIL 1,40		; SPACING CHARACTER
	 AOS TTLPOS(2)		; YES
	CAIN 1,15		; CR
	 HLLZS TTLPOS(2)
	MOVSI 3,1
	CAIN 1,12
	 ADDM 3,TTLPOS(2)
	CAIN 1,14
	 HRRZS TTLPOS(2)
	CAIN 1,10		;BACKSPACE?
	JRST [	MOVE 3,TTLPOS(2)	;YES. WHERE ARE WE ON LINE?
		TRNE 3,-1		;AT LEFT MARGIN ALREADY?
		SOS TTLPOS(2)		;NO, COUNT BACK ONE TO THE LEFT
		JRST TCOHA1]
	CAIE 1,EOL
	 JRST TCOHA1
	HLLOS TTLPOS(2)
	AOS TTLPOS(2)
TCOHA1:	POP P,3
	RET

;CONTROL GROUP
;FOR EACH CHARACTER, ACTION IS CONTROLLED BY TWO BITS:
; 00 => IGNORE, DO NOT SEND
; 01 => SEND PRINTING INDICATION (I.E. &C)
; 10 => SEND ACTUAL CODE AND ACCOUNT LINE AND PAGE POSITION
; 11 => SIMULATE FORMAT ACTION AND ACCOUNT

TTCO1:	MOVE 4,FCMOD2(2)	;SECOND CONTROL MODES WORD
	MOVE 3,FCMOD1(2)	;FIRST CONTROL MODES WORD
	ROTC 3,0(1)		;GET TWO BIT MODE FOR THIS CHAR
	ROTC 3,0(1)
	JRST @TTCTAB(1)		;DISPATCH TO FORMAT ROUTINE

;DISPATCH TABLE FOR FORMAT EFFECTING CONTROL CHARACTERS

NC=TCOUT	;DISPATCH FOR NON-FORMAT CONTROLS

TTCTAB:	NC	;@
	NC	;A
	NC	;B
	NC	;C
	NC	;D
	NC	;E
	NC	;F
	NC	;G

	TTSM4	;H - BACKSPACE
	TTSM1	;I - TAB
	TTSM2	;J - LINE FEED
	NC	;K
	TTSM3	;L - FORM
	TTSM5	;M - CARRIAGE RETURN
	NC	;N
	NC 	;O

	NC	;P
	NC	;Q
	NC	;R
	NC	;S
	NC	;T
	NC	;U
	NC	;V
	NC	;W

	NC	;X
	NC	;Y
	NC	;Z
	NC	;[ AND ALTMODE
	NC	;\
	NC	;]
	NC	;^
	TTSM6	;_, EOL

;TAB
;TAB STOPS ARE INDICATED BY BITS CORRESPONDING TO LINE POSITIONS
;THERE ARE 108 STOPS (3 WORDS)

TTSM1:	PUSH P,3
	MOVEI 7,1		;7 WILL CONTAIN SKIP DISTANCE ( >0 )
	HRRZ 3,TTLPOS(2)	;OLD POSITION
	ADDI 3,1		;MOVE AT LEAST ONE
	IDIVI 3,^D36		;36 TAB STOPS / WORD
TTSM11:	CAILE 3,2		;BEYOND END OF LINE?
	JRST TTSM15		;YES
	HRRZ 5,TTMOD1(2)	;TAB TABLE FOR THIS LINE
	ADDI 5,0(3)
	MOVE 5,0(5)		;GET BITS
	LSH 5,0(4)		;GET TO PRESENT POSITION
	JFFO 5,TTSM12		;FIND NEXT STOP
	ADDI 7,^D36		;NOT IN THIS WORD - UPDATE COUNT AND
	SUBI 7,0(4)
	MOVEI 4,0		;START AT BEGINNING OF NEXT WORD
	AOJA 3,TTSM11

TTSM12:	ADDI 7,0(6)		;ADD IN NUMBER SKIPPED, THIS WORD
TTSM15:	POP P,3			;MODE WORD
	MOVSI 4,(1B2)		;HAS-TAB BIT
	TLNN 3,(1B1)		;SIMULATE REQUESTED?
	TDNN 4,TTFLGS(2)	;OR NO MECH TAB ON DEVICE?
	JRST TTSM13		;YES, GO SIMULATE
	MOVEI 1,11		;SEND REAL TAB
	CALL TCOUT
	MOVE 4,7		;PLUS RUBOUTS TO KILL TIME
	IDIVI 4,4		;ASSUME FOUR SPACES PER RUBOUT
	HRRZ 3,TTYPE(2)		;GET TERMINAL TYPE INDEX
	LDB 1,TTTBPD		;PADDING FOR TAB ON THAT TYPE
	IMULI 4,(1)		;FOR EACH FOUR POSITIONS
	JUMPLE 4,TTSM14
	MOVEI 1,177
TTSM16:	CALL TCOUT
	SOJG 4,.-1
TTSM14:	ADDB 7,TTLPOS(2)	;UPDATE POSITION
	RET

TTSM13:	MOVEI 1,40		;SIMULATE WITH SPACES
	MOVEI 4,0(7)
	JRST TTSM16

;LINE FEED

TTSM2:	MOVSI 3,1		;INCREMENT PAGE POSITION
	ADDM 3,TTLPOS(2)
	CALL TCOUT
	HRRZ 3,TTYPE(2)
	LDB 5,TTLFPD		;LF PADDING
	MOVEI 1,177		;PAD WITH RUBOUTS
	JRST TTSM31

;FORM FEED

TTSM3:	HLRZ 4,TTLPOS(2)	;PRESENT PAGE POSITION
	HRRZS TTLPOS(2)		;RESET
	PUSH P,3
	LDB 3,[POINT 7,TTFLGS(2),10] ;PAGE SIZE
	IDIVI 4,0(3)
	SUBM 3,5		;DIFFERENCE TO END OF PAGE
	POP P,3
	MOVSI 4,(1B1)
	TDNE 4,TTFLGS(2)	;DEVICE HAS MECH FF?
	TLNE 3,(1B1)		;AND SEND DIRECT REQUESTED?
	JRST TTSM32		;NO, SIMULATE FF
	CALL TCOUT		;SEND REAL CHARACTER
	HRRZ 3,TTYPE(2)
	LDB 5,TTFFPD		;FF PADDING
	MOVEI 1,177		;PAD WITH RUBOUTS
	JRST TTSM31

TTSM32:	MOVEI 1,12		;SIMULATE WITH LINE FEEDS
TTSM31:	JUMPE 5,R
	CALL TCOUT
	SOJA 5,TTSM31

;BACKSPACE

TTSM4:	HRRZ 4,TTLPOS(2)	;REDUCE LINE POSITION
	JUMPE 4,.+2		;IF NOT AT BEGINNING OF LINE
	SOS TTLPOS(2)
	TLNN 3,200000		;REAL OR SIMULATED
	JRST TCOUT
	MOVEI 1,15		;SIMULATE WITH CR AND SPACES (UGH)
	CALL TCOUT
	HRRZ 4,TTLPOS(2)
	MOVEI 1,40
	JUMPE 4,R
	CALL TCOUT
	SOJA 4,.-2

;CARRIAGE RETURN

TTSM5:	HRRZ 4,TTLPOS(2)	;SAVE OLD POSITION
	HLLZS TTLPOS(2)		;RESET LINE POSITION
	CALL TCOUT

IFDEF IMPCHN,<
	CAIL 2,NVTLO
	CAILE 2,NVTHI
	SKIPA		;NOT AN NVT
	CALL NVTXCR	;AN NVT, REMEMBER CR OUTPUT
>
IFTYM	2,<RET>			;TYMNET hook

	HRRZ 3,TTYPE(2)
	LDB 5,TTCRPD		;CR PADDING
IFDEF I4SW,<
	MOVE 3,TTYPE0(3)
	TLNE 3,(1B3)		;FIXED CR PADDING
	JRST TTSM51
>
	IMULI 4,0(5)		;COMPUTE POSN/72*PAD, I.E. PAD IS
	ADDI 4,^D71		;AMOUNT FOR 72 CHAR LINE, SO PRO-RATE
	IDIVI 4,^D72		;BASED ON FULLNESS OF LINE, ROUNDING
	MOVEI 5,0(4)		;PAD COUNT UP TO NEXT INTEGER
IFDEF	I4SW,<
TTSM51:	SETZ	1,		;PAD WITH NULL'S.
>
	JRST TTSM31		;PAD WITH MORE CR'S

;EOL

TTSM6:	MOVEI 1,15		;BECOMES CR, LF
	CALL TTSM5
	MOVEI 1,12
	JRST TTSM2
;CODE TO WAKE UP TTY'S WITH TIMER CONTROL ON THEM
;!! MAH @ SUMEX 12/74 !!
IFN SUMEX,<
TTSM7:	MOVE 5,TODCLK		;CHECK TO SEE IF LAST CHARACTER OUTPUT
	SUBI 5,^D25*^D1000	;LONGER THAN 25 SECONDS AGO
	CAMG 5,TTLSO0		;(FOR SUMEX LINE 0 ONLY)
	 RET			;NO, WE'RE OK

	PUSH P,1		;YES, MUST WAKE UP TTY FIRST
	MOVEI 5,^D15		;WITH 15.
	MOVEI 1,0		;NULLS

	CALL TCOUT
	SOJG 5,.-1
	
	POP P,1			;RESTORE ORIGINAL CHARACTER
	RET
>

;OUTPUT ONE CHARACTER TO SPECIFIED TTY LINE
;CHARACTER IN 1, LINE NUMBER IN 2

TCOUT:	MOVEI 3,3B29		;MODE BITS
IFDEF	I4SW,
<	CAIL 2,NVTLO
	JRST TCOUTX		;NO PARITY FOR NVT
	CAIL 2,PTYLO		;NO PARITY FOR PTYS
	CAIL 2,PTYLO+NPTY
	JRST .+2
	JRST TCOUTX
>
IFNDEF	I4SW,
<	CAIL 2,NTTYS
	JRST TCOUTX		;NO PARITY FOR NVT
>
;;;	CAIGE 1,40		;CONTROL CHARACTER, AND !!MAH @ SUMEX 6/75 !!
	TDNN 3,TTFLGS(2)	;NOT BINARY? !! EVEN PARITY ON AL ASCII CHARS
	JRST TCOUTX
	MOVEI 3,0(1)
	IMULI 3,200401		;COMPUTE PARITY FOR CONTROL CHAR
	AND 3,[11111111]
	IMUL 3,[11111111]
	TLNE 3,(1B14)		;(EVEN PARITY) BIT ON?
	TRO 1,200		;YES, PUT (EVEN PARITY) BIT ON
TCOB:				;BINARY OUTPUT ENTRY POINT
TCOUTX:
IFDEF IMPCHN,<
	CAIL 2,NVTLO		;NVT?
	CALL NVTCHO		;YES PERFORM SPECIAL PROCESSING
>
TCOBQ:	SKIPE IMECHF		;IMMED ECHO CHAR?
	JRST TCEOUT		;YES
	NOSKD1
	DLOCK TTYLCK
	LDB 3,TTOMAX		;CAPACITY OF OUTPUT BUFFERS
	CAMG 3,TTOCT(2)		;FULL?
	JRST [ ULOCK TTYLCK
		OKSKD1
		JRST TCOUT1 ]   ;YES
TCEO3A:
	HLOCKI DLSPI		;LOCK INTER.
	SKIPN 3,TTOIN(2)	;BUFFERS EXIST?
	JRST [	HULOCK DLSPI
		OKPI
		LDB 3,TTNOU	;NO, GET NUMBER TO ASSIGN
		CALL TTGTBF	;ASSIGN THEM
		 JRST [	ULOCK TTYLCK
			OKSKD1
			LDB 1,TTNOU
			MOVSS 1
			HRRI 1,TTBUFW
			JSYS EDISMS ; WAIT FOR BUFFERS
			JRST TCEO3]
		HLOCKI DLSPI
		MOVEM 3,TTOOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK		;END OF BUFFER?
	HRR 3,1-TTSIZ(3)	;YES, GET ADDRESS OF NEXT BUFFER
	IDPB 1,3
	MOVEM 3,TTOIN(2)
	AOS TTOCT(2)
	HULOCK DLSPI		;UNLOCK INTERRUPT
	OKPI			;SAFE TO TURN CHN ON AFTER AOS
	ULOCK TTYLCK
	OKSKD1
	AOS NTTYOT		;COUNT ALL OUTPUT
IFN SUMEX,<
	 AOS TTIOCT(2)		;count individual output
>
TCEO1:
IFDEF IMPCHN,<
IFDEF	I4SW,
<	CAIL 2,NVTLO
>
IFNDEF	I4SW,
<	CAIL 2,NTTYS		;PSEUDO TTY?
>
	JRST [	CALL NTTCSO	;YES, DO OUTPUT IF POSSIBLE
		JRST TCEO4]
>
	SKIPGE TTFLGS(2)	;TEST OUTPUT ACTIVE
	JRST TCEO4
IFDEF I4SW,<
	MOVSI 3,400000
	IORM 3,TTFLGS(2)
IFDEF TYMSW,<
	CAIL 2,TYMTTL
	CAIL 2,TYMTTL+NTYMTT
>
	CAILE 2,CTYLIN
	JRST TCEO4
>
IFNDEF I4SW,<
IFDEF TYMSW,<
	CAIL 2,TYMTTL
	CAIL 2,TYMTTL+NTYMTT
	JRST .+4
	MOVSI 3,400000
	IORM 3,TTFLGS(2)
	JRST TCEO4
>>	
	NOSKD1
	SKIPL TTNIT1
	JRST .-1		;WAIT FOR INTERRUPT TO TAKE CHARACHTER
	MOVEM 2,TTNIT1		;SIMULATE INTERRUPT THIS LINE
	SKIPN CPUID
	ISB DLSCHN
	OKSKD1
TCEO4:	POP P,3
	JRSTF 0(3)		;RESTORE FLAGS

TCEO3:	NOSKD1
	DLOCK TTYLCK
	JRST TCEO3A		;SET LOCKS HERE


;SCAN LINK WORD, SENDING CHAR TO LINES SPECIFIED BY NON-777 BYTES

TTLNK3:	PUSH P,2		;SAVE CURRENT LINE NUMBER
	SKIPE IMECHF
	SETOM LINKF		;BE SURE CHARS GO OUT
TTLNK2:	SETZ 2,
	LSHC 2,^D9		;GET NEXT FIELD
	CAIN 2,777
	JRST TTLNK1		;MEANS NOT IN USE
	PUSH P,3
	PUSH P,1		;SAVE CHARACTER
	CALL TCOY1		;YES, SEND ON LINK
	POP P,1
	POP P,3
TTLNK1:	JUMPN 3,TTLNK2		;DO MORE IF ANY
	SETZM LINKF
	POP P,2			;RESTORE ORIG LINE NUMBER
	RET

;ACTION WHEN BUFFER FULL

TCOUT1:	PUSH P,1		;SAVE CHARACTER
	MOVEI 1,TCOTST		;SETUP SCHEDULER TEST WORD
	HRLI 1,0(2)		;  LINE NO,,TEST ROUTINE ADR
	JSYS EDISMS
	POP P,1
	JRST TCOUTX

;CALLED FROM SCHEDULER TO TEST FOR RUNNABLE

TCOTST:	MOVEI 2,0(1)		;LINE NUMBER TO REGULAR AC
	LDB 1,TTOWRN		;REGULAR WAKEUP COUNT
	SKIPE FKINT(7)		;BUT IF INTERRUPT WAITING,
	LDB 1,TTOMAX		;WAKEUP IF BUFFER IS NOT FULL
	CAMG 1,TTOCT(2)		;AT OR BELOW WAKEUP LEVEL?
	JRST 0(4)		;NO
	JRST 1(4)		;YES

; WAIT FOR N BUFFERS

TTBUFW:	CAMLE 1,TTFREC
	 JRST 0(4)
	JRST 1(4)

;ROUTINE TO GET CHARACTER FROM TELETYPE
;CONVERT FROM ASCII TO INTERNAL AND GENERATE ECHOS
;AS REQUESTED

TCI:	MOVEI 3,1B34
	TDNE 3,TTFLGS(2)	;REPEAT LAST CHAR?
	JRST TCIRC		;YES
	LDB 3,[POINT 2,TTFLGS(2),29] ;DATA MODE BITS
	CALL TCI0		;GET A CHAR
IFDEF TYMSW,<
	TRNE 1,1000		;IF TYMNET CONTROL MESSAGE CODE,
	 JRST RCVCMP		;HANDLE IN TYMNET CODE
>
	MOVE 3,TTFLGS(2)
	TRNN 3,3B29		;BINARY?
	JRST [	ANDI 1,377	;YES
		JRST TCIR]
	PUSH P,1		;CHECK FOR DEFERRED TERM INT CHAR
	ANDI 1,177
	CAIGE 1,PSICHL		;WITHIN RANGE?
	JRST TCI3		;YES
	CAIGE 1,PSICHU
	JRST TCI2		;NO
	SUBI 1,PSICHO
TCI3:	MOVE 3,PSICH(1)		;GET CODE
	CAIN 3,NU
	JRST TCI2		;NOT DEFINED
	MOVE 1,BITS(3)
	TDNN 1,TTPSI(2)		;THIS CODE ENABLED?
	JRST TCI2		;NO
	MOVEM 2,0(P)		;YES, SAVE LINE NUMBER
	NOSKED
	CALL TTPSRQ		;INITIATE INTERRUPT
	OKSKED
	SKIPE FKINT(2)		;HAS BEEN PROCESSED YET?
	JSYS BLOCK1		;NO, WAIT A WHILE
	POP P,2
	JRST TCI		;GET ANOTHER CHAR, DON'T RETURN INT CHR

TCI2:	POP P,1
	TRNN A,177		;ignore nulls on ascii input
	 JRST TCI		; !! MAH@SUMEX 10/25/74 !!
	MOVEI 3,15
	XORI 1,(3)
	TRNN 1,177		;IF NOT BINARY, CATCH ANY CRLF'S
	MOVEI 3,EOL
	XORI 1,(3)
	MOVE 3,TTFLGS(2)
	TLNE 3,(TTLCBT)		;NO LOWER CASE ON THIS TERMINAL?
	TRNE 3,1B31		;OR 'RAISE' REQUESTED?
	CALL TTRAIS		;YES, DO IT
	ANDI 3,3B25		;ISOLATE ECHO MODE BITS
	JUMPE 3,TCIN		;NO ECHO
	TRNE 1,400		;HAS CHAR BEEN ECHOED?
	CAIN 3,3B25		;BOTH IMMED AND DEFERRED?
TCIY:	CALL TCOE		;YES, DO ECHO
TCIN:	ANDI 1,177
TCIR:	DPB 1,TTYLCH		;SAVE LAST CHAR
	RET

;ENTRY FOR BINARY INPUT

TCIB:	MOVEI 3,1B34
	TDNE 3,TTFLGS(2)	;REPEAT LAST CHAR?
	JRST TCIRC		;YES
	SETZ 3,			;USE DATA MODE 0
	CALL TCI0		;GET A CHAR
	JRST TCIR		;RETURN IT UNMODIFIED AND UNECHOED

TCIRC:	ANDCAM 3,TTFLGS(2)	;CLEAR BIT
	LDB 1,TTYLCH		;GET LAST CHARACTER
	RET

;GET ONE CHARACTER FROM INPUT BUFFER, ACCORDING TO DATA MODE IN 3

TCI0:	NOSKED
	DLOCK TTYLCK		;LOCK TTYS
	SKIPG 1,TTICT(2)		;ANY CHARS IN BUFFER?
	JRST TCI1		;NO
	SKIPN 3,TTIOUT(2)	;GET POINTER
	BUG(HLT,<TCI - NO BUFFER POINTER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)	;NEW BUFFER
	ILDB 1,3
	MOVEM 3,TTIOUT(2)
	SOSG TTICT(2)		;REDUCE COUNT, NOW EMPTY?
	JRST [	SETZB 3,TTIOUT(2) ;YES, RELEASE BUFFERS
		EXCH 3,TTIIN(2)
		CALL TTRLBF
		JRST .+1]
	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
	IFTYM 2,<JRST TYMTCI>	;FOR TYMNET LINES, CHECK TO SEE IF
				;WE CAN TURN OFF POSSIBLE INPUT BACK
				;PRESSURE NOW
	RET

;ACTION IF BUFFER IS EMPTY

TCI1:	ULOCK TTYLCK		;UNLOCK TTYLOCK
	OKSKED
	HRL 3,TTFORK(2)		;CHECK FOR OTHER FORK WAITING THIS LINE
	JUMPGE 3,TCIF1		;YES
TCIF2:	DPB 3,TTYLMD		;SAVE DATA MODE THIS INPUT
	PUSH P,3
	MOVE 3,FORKX		;GET INDEX OF THIS FORK
	HRRM 3,TTFORK(2)	;RECORD THIS FORK WAITING FOR TTY
IFDEF IMPCHN,<
IFDEF	I4SW,
<	CAIL 2,NVTLO
>
IFNDEF	I4SW,
<	CAIL 2,NTTYS		;NETWORK TTY?
>
	CALL NETCAP		;YES, CHECK ALLOCATE
>

IFTYM 	2,<CALL GREENT>		;input hung, ok to send green ball?

	MOVEI 1,TCITST		;SETUP SCHEDULER TEST WORD
	HRLI 1,0(2)		;  LINE NO,,TEST ROUTINE ADR
	SKIPN TTICT(2)		;STILL EMPTY?
	JSYS EDISMS
	POP P,3			;RESTORE CURRENT MODE
	JRST TCI0		;TRY AGAIN

TCIF1:	PUSH P,2
	PUSH P,3
	HRRZ 1,TTFORK(2)	;INDEX OF WAITING FORK
	ANDI 1,7777
	CAME 1,FORKX		;SELF?
	CALL TTFRKT		;NO, GO RESOLVE CONFLICT BY HALTING FORK
	POP P,3
	POP P,2
	JRST TCIF2

;SCHEDULER TEST ROUTINE FOR FORKS WAITING FOR TTY INPUT
;CALLED WITH JSP 4,
;AC 1 CONTAINS LINE NUMBER
;AC 7 CONTAINS FORK NUMBER OF FORK BEING TESTED

TCITST:	HRRZ 2,TTFORK(1)
	TRNE 2,1B18+1B19	;WAKEUP OR BUFFER FULL?
	JRST 1(4)		;YES
	JRST 0(4)		;NO, DON'T WAKE

;'RAISE' INPUT

TTRAIS:	CAIGE 1,177
	CAIGE 1,140		;LC CHAR?
	RET			;NO
	CAIGE 1,173		;REGULAR LC CHAR?
	TRZA 1,40		;YES, MAKE UC
	MOVEI 1,33		;NO, MUST BE OLD ALT-MODE. MAKE ESC
	RET

;TELETYPE INPUT CHANNEL 7 ROUTINE
;RUN EVERY SO OFTEN TO MOVE CHARACTERS FROM BIG BUFFER TO LINE BUFFERS,
;GENERATE ECHOS AND HANDLE CARRIER TRANSITIONS
;ENTERED BY  CALL  FROM SCHED

TTCH7X:
	CONI DLS,1		;CHECK FOR LOST PI
	ANDI 1,7
	CAIN 1,DLSCHN		;CORRECTLY SET?
	JRST .+3		;YES
	AOS DLSLPI		;NO, COUNT LOSSAGES
	CONO DLS,DLSCHN		;AND RESET IT
	SKIPN 1,TTHNGT		;ACTIVE LINE TO BE CHECKED?
	JRST TTHNG1		;NO
	MOVE 2,TTHNGL		;YES, GET LINE NUMBER
	CAML 1,TODCLK		;INTERRUPT OVERDUE?
	JRST TTHNG4		;NO, KEEP WAITING
	AOS TTHNGN		;YES, COUNT UNHANGS
	HRLM 2,TTHNGN		;REMEMBER LAST HUNG LINE
	MOVEM 2,TTNIT1		;SIMULATE OUTPUT INTERRUPT
	ISB DLSCHN
TTHNG1:	AOS 2,TTHNGL		;GET NEXT LINE
	CAIL 2,NTTYS
	SETZB 2,TTHNGL		;WRAPAROUND LINE NUMBERS
	MOVE 1,TODCLK
	ADDI 1,^D500		;HALF-SECOND FROM NOW
	MOVEM 1,TTHNGT		;IS TIME AT WHICH LINE IS CALLED HUNG
	SKIPL TTFLGS(2)		;LINE NOW ACTIVE?
	SETZM TTHNGT		;NO, DON'T CHECK
TTHNG4:	MOVE 2,TTCQLN		;BEFORE LEAVING, CHECK CONTROL ON
	MOVEI 4,10		;A FEW LINES
TTCQ3:	SKIPN 1,TTCS(2)		;ANYTHING ON THIS LINE?
	JRST TTCQ2		;NO
	HRRZ 3,TODCLK		;SEE IF NOW TIME TO DO IT
	ANDI 3,377777
	HLRZ 1,1
	SUB 1,3			;DESIRED TIME MINUS NOW
TTCQ1:	JUMPLE 1,TTCQ4		;0 OR NEGATIVE TIME LEFT TO WAIT
	CAIGE 1,200000		;GREATER THAN MAX POSSIBLE?
	JRST TTCQ2		;NO, KEEP WAITING
	SUBI 1,400000		;ACCOUNT FOR WRAPAROUND
	JRST TTCQ1		;CHECK AGAIN

TTCQ4:	HRRZ 1,TTCS(2)		;GET ADDRESS OF FUNCTION TO DO
	SETZM TTCS(2)		;CLEAR CONTROL STATE
	CALL 0(1)		;DO THE FUNCTION
TTCQ2:	ADDI 2,1		;GO TO NEXT LINE
	CAIL 2,NLINES		;WRAPAROUND
	SETZ 2,
	SOJG 4,TTCQ3		;DONE ENOUGH FOR THIS TIME?
	MOVEM 2,TTCQLN		;YES, START AT THIS LINE NEXT TIME
IFDEF TYMSW,<
	CALL TTYCKK		;LOCK TTYS
	RET
	CALL TYMCHK
	ULOCK TTYLCK		;UNLOCK TTYLOCK
>
	MOVEI 1,T7TIM		;SETUP TIME TO NEXT SERVICE
	MOVEM 1,TTBTIM
	RET

TTYCKK:	MOVSI 3,-20		;TRY 100 TIMES
	SLOCK TTYLCK
	JRST	[AOBJN 3,TTYCKK+1
		RET  ]
	AOS 0(P)
	RET


;ADD ITEM TO CONTROL QUEUE

TTQAD1:	HRLI 1,^D3000		;ITEM TO BE DONE IN 3 SEC.
TTQAD:	HRLZ 3,TODCLK		;WAIT TIME IN LH OF 1
	TLZ 3,400000		;ROUTINE ADDRESS IN RH OF 1
	ADD 1,3			;COMPUTE TIME TO DO FUNCTION
	MOVEM 1,TTCS(2)
	RET

TTCH7:	SKIPG TTBIGC		;BIG BUFFER EMPTY?
	 JRST TTCH7X		;YES, RETURN
	CALL TTYCKK		;LOCK TTYS
	RET
	AOS 3,TTBIGO		;NO, GET WORD
	CAIN 3,TTBSIZ		;WRAPAROUND IF NECESSARY
	 SETZB 3,TTBIGO
	MOVE 1,TTBBUF(3)
	SOS TTBIGC
	HLRZ 2,1		;GET LINE NUMBER
	MOVEI 6,0(1)		;SAVE ALL ORIGINAL FLAGS
	TRNE 1,DLSCXF		;CARRIER TRANSITION?
	 JRST TT7CX		;YES
	TRNN 1,DLSRCF		;RECEIVER?
	 JRST TTCH7A		;NO (SHOULD NOT HAPPEN) - RESUME  SCAN
IFDEF	I4SW,
<
TTI4RT::
>
	ANDI 1,377
IFN SUMEX,<			;CATCH NULLS ON ASCII LINES EARLY
	MOVE 3,TTFLGS(2)
	TRNE 3,3B29		;SKIP IF BINARY
	JUMPE 1,TTCH7A	;ELSE THROW AWAY NULLS
>; END IFN SUMEX
	CALL TTCHI		; PUT THE CHARACTER WHERE IT BELONGS
TTCH7A:	ULOCK TTYLCK		;UNLOCK TTYLOCK
	JRST TTCH7		; AND SEE IF ANY MORE TO DO

;CARRIER ON/OFF

TT7CX:	MOVEI 3,1		;CARRIER STATE FLAG
	TRNN 1,1B24		;CARRIER NOW ON?
	 JRST TTCX1		;NO, OFF
	SKIPGE TTFORK(2)	;TTY ASSIGNED OR
	TDNE 3,TTFLGS(2)	;CARRIER NOT OFF BEFORE?
	 JRST TTCH7		;YES, INTERRUPT IS SPURIOUS
	IORM 3,TTFLGS(2)	;UPDATE SOFTWARE FLAG
	MOVEI 1,TTCON		;QUEUE A CHECK TO GO IN 1 SEC.
	CALL TTQAD1
	JRST TTCH7

TTCON:	MOVEI 3,1
	TDNN 3,TTFLGS(2)	;CARRIER STILL ON?
	 RET			;NO, IGNORE IT
	SKIPL 3,TTFORK(2)	;JOB ACTIVE HERE?
	 JRST TTCH7F		;YES, SEND BELL, OTHERWISE IGNORE
	JRST TTC7SJ		;NO, START JOB

TTCX1:	TDNN 3,TTFLGS(2)	;WAS ON BEFORE?
	 JRST TTCH7		;NO, SPURIOUS INTERRUPT
	ANDCAM 3,TTFLGS(2)	;UPDATE SOFTWARE FLAG
	MOVEI 1,TTCOF		;QUEUE A CHECK FOR 1 SEC.
	CALL TTQAD1
	JRST TTCH7

TTCOF:	MOVEI 3,1
	TDNE 3,TTFLGS(2)	;CARRIER STILL OFF?
	 RET			;NO, IGNORE
	MOVEI 1,TTHU0		;YES, QUEUE A HANGUP-REACTIVATE SEQUENCE
	CALL TTQAD		;TO START IMMEDIATELY
	SKIPGE TTFORK(2)	;JOB ATTACHED?
	 RET		;NO, IGNORE

NVTCOF:	MOVEI 3,1
	ANDCAM 3,TTFLGS(2)	;RESET CARRIER ON
	MOVEI 3,^D30		;YES, INITIATE A CODE 30 INTERRUPT
	MOVE 5,TTPSI(2)
	TDNE 5,BITS(3)		;IF ITS ASSIGNED
	JRST TTPSI2
	RET			;OTHERWISE IGNORE

;HANGUP-REACTIVATE SEQUENCE

TTHU0:	MOVEI 1,TTHU0		;MAYBE SAME ROUTINE AGAIN
	SKIPGE TTFLGS(2)	;OUTPUT NOT ACTIVE?
	JRST TTQAD1		;NO, RE-QUEUE THIS ROUTINE FOR 1 SEC.
	MOVSI 3,DLSDLB(2)	;CONSTRUCT DATAO WORD
	HRRI 3,1B27		;DIRECTED LINE+NO XMIT BITS
	DATAO DLS,3
	MOVE 1,[XWD ^D100,TTHU1] ;QUEUE NEXT OP TO GO IN 100 MS.
	JRST TTQAD

TTHU1:	MOVSI 3,DLSDLB(2)	;CONSTRUCT DATAO WORD TO REACTIVATE
	HRRI 3,DLSACT+1B27	;DIRECTED LINE+ACTIVATE+NO XMIT
	DATAO DLS,3
	RET

; STORE CHARACTER IN TTY INPUT BUFFER
; 1/	CHARACTER
; 2/	LINE NUMBER
; 6/	FLAGS

TTCHI:	AOS NTTYIN		;COUNT ALL INPUT
IFN SUMEX,<
	MOVSI 3,10
	ADDM 3,TTIOCT(2)	;count individual output
>
	SKIPL 3,TTADVS(2)	;ADVISE TO ANOTHER LINE?
	CALL TTAVS		;YES
	SKIPGE 3,TTFORK(2)	;ASSIGNED TO A JOB?
	JRST TTC7N		;NO
	MOVEI 4,0(1)		;CHECK FOR INTERRUPT CHAR
	ANDI 4,177		;JUST SEVEN BITS OF IT
IFDEF	I4SW,<
	LDB 3,TTYLMD
	JUMPE 3,TTCH70
	HRRZ 3,TTRUBA(2)
	JUMPE 3,.+3
	CALL TTSRA
	RET			;ILLEGAL RUBOUT RECEIVED
	LDB 3,[POINT 8,TTRUBA(2),17]
	JUMPE 3,TTCH70
	CAIE 4,(3)
	JRST TTCH70
	MOVSI 3,(1B0)
	XORM 3,TTRUBA(2)	;INVERT BIT
	TDNN 3,TTRUBA(2)	;SET NOW
	CALL CLTTS1		;SJTART OUTPUT
	RET
TTCH70::
	CALL CLTTST		;SET OUTPUT AGAIN
>	CAIGE 4,PSICHL		;TRANSLATE TO INTERRUPT CODE
	JRST TTCH71
	CAIGE 4,PSICHU
	JRST TTCH72		;NOT INTERRUPT CHAR
	SUBI 4,PSICHO
TTCH71:	MOVE 3,PSICH(4)
	CAIN 3,NU		;NOT USED?
	JRST TTCH72		;YES
	MOVE 5,BITS(3)		;BIT FOR THIS CODE
	TDNE 5,TTPSI(2)		;CODE ENABLED?
	JRST TTPSI1		;YES, GO INITIATE INTERRUPT

;DETERMINE ECHO STATUS

TTCH72:	LDB 3,TTYLMD		;CHECK MODE NOW IN FORCE
	JUMPE 3,[LDB 3,TTIMAX	;BINARY, SKIP ECHO TESTS
		CAMG 3,TTICT(2)	;ROOM FOR CHAR IN INPUT BUFFER?
		RET		;NO, QUIETLY FLUSH IT
		JRST TTRNE]	;YES, GO PUT IT IN
	ANDI 1,177		;ONLY 7-BIT ASCII FROM HERE ON
	LDB 3,TTIMAX		;CAPACITY OF INPUT BUFFERS
	CAMG 3,TTICT(2)		;FULL?
	JRST TTCH7F		;YES, ECHO BELL
	MOVE 3,TTFLGS(2)
	CAIN 1,15		;CR?
	MOVEI 1,EOL		;END OF LINE CHARACTER
	CAIGE 2,PTYLO+NPTY
	CAIGE 2,PTYLO
	JRST .+2
	JRST   [TRNE 3,3B33	;HALF DUPLEX ON PTY?
		TRO 1,400	;YES, BE SURE TO SAY ALREADY ECHOED, SO WILL
		JRST TTRNE]	;NEVER ECHO FOR PTY IN HALF DPLX, ECHO DEFF
				;IN FULL DPLX

IFTYM	2,<JRST TYMCHI>		;TYMNET hook

	TRNE 3,3B33		;REGULAR FDX LINE?
	JRST TTREC4		;HDX - 'ECHO' IMMED
IFDEF TYMSW,<TYMCHX:>		;TYMNET hook
	TRNN 3,3B25		;ANY ECHOS?
	JRST TTRNE		;NO
IFDEF IMPCHN,<
	CALL NVTRCC		;CHECK FOR ECHOS DONE BY RCTE
	JRST TTRNE>
	TRNE 3,1B25		;IMMEDIATE ECHOS?
	JRST TTREC4		;YES
	HRLZ 4,TTFORK(2)	;MAYBE, GET STATUS OF FORK WAITING
	JUMPL 4,TTRNE		;DEFER IF NO FORK WAITING
TTREC4:	TLNE 3,(TTLCBT)		;WILL ECHO NOW.  MUST RAISE INPUT?
	TRNE 3,1B31
	CALL TTRAIS		;YES, DO IT
	TRNN 1,177		;ignore null echos on ascii input
	 JRST TTRNE		; !! MAH@SUMEX 10/25/74 !!
	TRO 1,400		;BIT TO DISABLE DEFERRED ECHO THIS CHAR
	PUSH P,6
	NOSKD1
	SETOM IMECHF		; SAY THIS AN IMMEDIATE ECHO
	CALL TCOE		;ECHO VIA NORMAL OUTPUT STREAM
	SETZM IMECHF
	OKSKD1
	POP P,6

;PUT CHAR IN BUFFER AND CHECK FOR WAKEUP

TTRNE:	SKIPN 3,TTIIN(2)	;INPUT BUFFERS EXIST?
	JRST [	LDB 3,TTNIN	;NO, GET NUMBER TO ASSIGN
		CALL TTGTBF	;ASSIGN THEM
		 JRST TTCH7F	; NO BUFFERS, GO DING
		MOVEM 3,TTIOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	IDPB 1,3
	MOVEM 3,TTIIN(2)
	AOS TTICT(2)
	HRLZ 3,TTFORK(2)	;IF NO FORK WAITING FOR THIS LINE,
	JUMPL 3,R		;THEN SKIP WAKEUP CHECKS
	TRNE 6,TTSCF		;CHAR CAME FROM STI?
	JRST TTWKT2		;YES, ALWAYS WAKEUP
	LDB 3,TTYLMD		;CHECK MODE
	JUMPE 3,TTWKT2		;WAKE ALWAYS IF BINARY
	LDB 3,TTIMAX		;CAPACITY OF INPUT BUFFERING
	SUBI 3,40		;LESS AN ARBITRARY AMOUNT
	CAMG 3,TTICT(2)		;BUFFER NOW THAT FULL?
	JRST [	MOVEI 3,1B19	;YES, ALLOW PGM WAKEUP
		IORM 3,TTFORK(2)
		JRST .+1]
	MOVEI 3,0(1)		;NO - WAKEUP CHARACTER?
	ANDI 3,177
	IDIVI 3,6
	ADDI 3,TTWKTB
	HLL 3,CH6TAB(4)
	LDB 4,3			;GET FLAGS THIS CHAR
	LDB 3,[POINT 6,TTFLGS(2),23] ;GET FLAGS THIS FORK
	TDNN 3,4		;ANY THE SAME?
	 RET			; DONE
TTWKT2:	HLLOS TTFORK(2)		;INDICATE WAKEUP
	AOS ISKED
	RET			; DONE

TTCH7F:	MOVEI 1,207		;INPUT BUFFER FULL,
IFDEF	I4SW,<
	CAIL 2,NVTLO
>
IFNDEF	I4SW,
<	CAIL 2,NTTYS		;IF NETWORK TERMINAL,
>
	MOVEI 1,007		;ONLY 7 BITS OF CHARACTER
	CALL TCEO2		;ECHO BELL
	RET			; DONE
; TYPE MESSAGE VIA ECHO BUFFER
TTC7SM:
	MOVE 3,1		;MOVE STRING ADDRESS
	HRLI 3,440700		;MAKE IT A BYTE POINTER
TTC7SN:
	ILDB	1,3		;GET A BYTE
	JUMPE 1,R		;DONE IF NULL
	PUSH P,3
	PUSHJ P,TCEO2
	POP P,3
	JRST TTC7SN		;DO THEM ALL

CLTTST:	SKIPL TTRUBA(2)		;OUTPUT STOPPED
	RET			;NO
	MOVSI 3,(1B0)
	ANDCAM 3,TTRUBA(2)
CLTTS1:	
IFDEF IMPCHN,<			;RESTART NVT'S !! MAH @ SUMEX 6/75 !!
IFNDEF I4SW,<CAIL 2,NTTYS>
IFDEF I4SW,<CAIL 2,NVTLO>
	 JRST NTTCSO
>
	CAILE 2,CTYLIN
	 RET
	NOSKD1
	SKIPL TTNIT1
	JRST .-1		;WAIT FOR INTERRUPT TO TAKE CHAR.
	HRRZM 2,TTNIT1
	SKIPN CPUID		;DONT DO ON CPU1
	ISB DLSCHN
	OKSKD1
	RET

;RECEIVED CHARACTER ON UNASSIGNED LINE

TTC7N:
IFN SUMEX,<
IFDEF TYMSW,<
	CAIL 2,TYMTTL
	CAIL 2,TYMTTL+NTYMTT
>
	SETZM TTIOCT(2)
>
	ANDI 1,177
	CAIE 1,003		;CONTROL-C?
	JRST	[TLNN 3,1	;ARE WE IN PROCESS OF STARTING
		JRST TTCH72	;YES SAVE CHARS FOR LATER
		JRST TTCH7F]	;NO ECHO BACK BELL
TTC7SJ:	CAIE 2,CTYLIN		;CTY AND OTY IF CHECKDSK FINISHED
	CAMN 2,OTYLIN
	JRST [	SKIPE SYSIFG	;CHKDSK AND SYS INI FINISHED?
		JRST TTC7SK	;CHECKDSK IS FINISHED
		MOVEI	1,[ASCIZ /
DISK VERIFY IN PROGRESS/]
		JRST TTC7SM]	;GO TELL HIM THE NEWS
	MOVE 1,[CHKDSE]		;ANY CHECKDSK ERRORS ?
	TDNE 1,FACTSW
	JRST	[MOVEI 1,[ASCIZ /
FILESYSTEM WORK IN PROGRESS/]
		JRST TTC7SM]	;GO BREAK IT TO HIM
	SKIPL TADSEC		;TIME SET YET?
	SKIPL AUTONX		;AUTO JOBS ALL STARTED ?
	JRST [MOVEI 1,[ASCIZ /
TENEX RESTARTING, WAIT.../]
		JRST TTC7SM]
	CAME 2,ENTFLG		;ALLOW LOG IN FOR SELECTED LINE
	SKIPGE ENTFLG		;OTHERWISE LOGIN FOR ALL LINES IF <0
	CAIA			;OR NO LOGINS IF =>0
	JRST	[MOVEI 1,[ASCIZ /
TENEX NOT AVAILABLE/]
		JRST	TTC7SM]	;TELL HIM(HER?)
TTC7SK:
IFN SUMEX,<
	MOVE 1,LOGDES		;DON'T LET LOGGING TTY LOG IN
	ANDI 1,377777
	CAIGE 1,NLINES		;IF NOT A TTY ,
	CAME 1,2		;OR IF A TTY BUT NOT THE LOG DES
	 JRST .+3		;THEN ALLOW LOGIN

	MOVEI 1,[ASCIZ /LOGGING TTY-NOT AVAILABLE
/]
	JRST TTC7SM		;OTHERWISE TELL HIM NO
>
	TLNN 3,1		;REALLY UNASSIGNED?
	JRST TTCH7F		;NO, IGNORE
	MOVSI 1,-2		;YES, SET TO JOB STARTING STATE
	HLLM 1,TTFORK(2)
	CALL TCIBF
	MOVEI 1,JOBSRT		;REQUEST SCHEDULER- START JOB
	HRLI 1,0(2)		;ON SPECIFIED TTY LINE
	CALL SCDRQ7
	RET

TTPSI1:	ANDI 1,177		;JUST 7 BITS
	LDB 4,TTIIN(2)		;GET LAST INPUT CHAR
	CAIE 4,0(1)		;SAME AS THIS ONE?
	TDNN 5,TTDPSI(2)	;OR NOT DEFERRED CHAR?
	JRST TTPSI2		;YES, INTERRUPT IMMED
	HLLOS TTFORK(2)		;WAKE UP PGM SO IT CAN SEE INT
	AOS ISKED
	LDB 3,TTIMAX		;MUST PUT DEFERRED CHAR IN BUFFER
	ADDI 3,1		;1 RESERVED FOR INT CHAR
	CAMG 3,TTICT(2)		;IS ROOM?
	JRST [	DPB 1,TTIIN(2)	;NO, SMASH CHAR ON TOP OF LAST ONE
		RET]
	JRST TTRNE		;PUT IN BUFFER W NO ECHOS

TTPSI2:	CALL TTPSRQ		;REQUEST INTERRUPT FROM PSI SYSTEM
	AOS TTINTS		;COUNT INTERRUPTS
	RET

IFN SUMEX,<
TTCLZ:	SETOM TTFORK(2)		;CLOSE OUT TTY LINE
	SETZM TTPSI(2)
	CALL TCIBF
	RET
>

;ROUTINE TO PUT CHAR IN ECHO BUFFER - CALLED FROM TCO

TCEO2:	NOSKD1
	DLOCK TTYLCK
	JRST TCEO2A

TCEOUT:	LDB 3,TTOMAX		;OUTPUT BUFFER CAPACITY
	ADDI 3,2		;PLUS RESERVE FOR ECHO
	NOSKD1
	DLOCK TTYLCK
	CAMLE 3,TTOCT(2)	;OUTPUT BUFFER FULL?
	JRST TCEO3A		;NO, GO PUT IN OUTPUT BUFFER

TCEO2A:	MOVEI 3,<TTSIZ-1>*4
IFTYM 2,<MOVEI 3,<TTSIZ-1>*3>	;ONLY 3 CHAR. PER BUFFER
	CAMG 3,TTECT(2)		;FULL
	JRST [ ULOCK TTYLCK
		OKSKD1
		RET ]
	HLOCKI DLSPI
	SKIPN 3,TTEIN(2)	;BUFFERS EXIST?
	JRST [	HULOCK DLSPI
		OKPI
		MOVEI 3,1	;NO, ASSIGN 1
		CALL TTGTBF
		 JRST [	ULOCK TTYLCK
			OKSKD1
			RET]
		HLOCKI DLSPI
		MOVEM 3,TTEOUT(2)
		JRST .+1]
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	IDPB 1,3
	MOVEM 3,TTEIN(2)
	AOS TTECT(2)
	HULOCK DLSPI
	OKPI
	ULOCK TTYLCK
	OKSKD1
	JRST TCEO1

;TYPE (SHORT) MESSAGE VIA ECHO BUFFER

TTEMES:	PUSH P,1		;GIVEN BYTE POINTER TO STRING IN 1
TTEM1:	ILDB 1,0(P)		;LINE NUMBER IN 2
	JUMPE 1,[POP P,1	;NULL TERMINATES
		RET]
	CALL TCEO2		;OUTPUT VIA ECHO BUFFER
	JRST TTEM1

;DLS CHANNEL INTERRUPT SERVICE
;CALLED WITH JSYS FROM CHANNEL SEQUENCE

DLSSV:	XWD XDLSSV,.+1
	IFN KIFLG,<CLSB DLSCHN>	;CLEAR SOFTWARE PI REQUEST
	SKIPL 2,TTNIT1
	JRST TTNITS
	SKIPL 2,TTNIT1-KIEPT+KIEPT1 ;FOR CPU1
	JRST TTNITA
	CONSZ DLS,330		;PI REQ, CAR XITION, XMIT, RECV
	JRST DLSSV2
	CONI TTY,1		;CONSOLE TTY
	TRNE 1,7		;PI ASSIGNED?
	TRNN 1,50		;AND SERVICE NEEDED?
	JRST @XDLSSV		;NO
	JRST TTYSV

;SERVICE DLS

DLSSV2:	DATAI DLS,1
	IFDEF DECDLS,<
	 TRNN 1,DLSRCF>		;IF NOT RECEIVER FLAG,
	IFDEF BBNDLS,<
	 TRNE 1,DLSXMF>		;IF TRANSMITTER FLAG,
	DATAO DLS,[400+DLSACT]	;RELEASE SCANNER
	IFDEF BBNDLS,<
	 CONO DLS,110+DLSCHN>	;RESET SCANNER TO 0 AND RELEASE
	HLRZ 2,1		;LINE NUMBER
	CAML 2,LOLIN		;WITHIN PROPER RANGE OF LINES?
	CAIL 2,CTYLIN
	JRST DLSSV3		;UNDEFINED LINE
TTYSV1:	TRNN 1,DLSRCF+DLSCXF	;RECEIVER OR XITION
	JRST DLSSV1
	MOVEI 3,TTBSIZ
	CAMG 3,TTBIGC		;BUG BUF OVERFLOW?
	JRST DLSSV1		;YES, IGNORE CHAR
	AOS 3,TTBIGI		;PUT WORD IN BIG BUFFER
	CAIN 3,TTBSIZ
	SETZB 3,TTBIGI		;WRAPAROUND
	MOVEM 1,TTBBUF(3)
	AOS TTBIGC		;COUNT CONTENTS
DLSSV1:	IFDEF DECDLS,<
	 TRNN 1,DLSRCF>		;IF NOT RECEIVER FLAG,
	IFDEF BBNDLS,<
	 TRNE 1,DLSXMF>		;TRANSMITTER
	JSP 4,TTSND
;	TRNE 1,DLSRCF		;RECEIVER
	JFCL 0			;NO SPECIAL ACTION
DLSSV3:	UNBRK DLS

;INITIATED INTERRUPT TO START OUTPUT ON LINE

TTNITA:	SETOM TTNIT1-KIEPT+KIEPT1
	SKIPA
TTNITS:	SETOM TTNIT1
	MOVEI 1,0
IFDEF	I4SW,
<	CAILE 2,CTYLIN
	BUG(CHK,<LINE # NOT CTYLIN IN TTNIT1>)
>
	JSP 4,TTSND		;DO OUTPUT
	JRST DLSSV3

;CONSTANTS

WRPMSK:	XWD 770000,TTSIZ-1	;MASK FOR WRAPAROUND OF CHAR POINTER

;SERVICE INTERRUPT FROM CONSOLE TTY
;CONSTRUCT WORD LIKE SCANNER DATAI

TTYSV:	MOVEI 1,0
	CONSO TTY,40		;INPUT DONE
	JRST .+3
	DATAI TTY,1
	TRO 1,DLSRCF		;SCANNER RECEIVER BIT
	CONSO TTY,10		;OUTPUT DONE
	JRST .+3
	TRO 1,DLSXMF		;SCANNER TRANSMITTER
	CONO TTY,200+DLSCHN	;TURN OFF OUTPUT DONE
	HRLI 1,CTYLIN		;PSEUDO-LINE NUMBER
	MOVEI 2,CTYLIN
	JRST TTYSV1


;SEND CHARACTER TO TTY LINE,
;FROM ECHO BUFFER IF NOT EMPTY, OTHERWISE
;FROM OUTPUT BUFFER IF NOT EMPTY; OTHERWISE
;CLEAR OUTPUT-ACTIVE FLAG

TTSND:
	CAMN 2,TTHNGL		;LINE BEING CHECK FOR OUTPUT INTERRUPTS?
	SETZM TTHNGT		;YES, MAKE CHECK OK
	CAIG 2,CTYLIN
	SKIPL TTRUBA(2)		;OUTPUT STOPPED
	JRST .+2
	JRST 0(4)
	SKIPE TTECT(2)		;CHECK ECHO BUFFER
	JRST TTSNDE
	SKIPE TTOCT(2)		;CHECK OUTPUT BUFFER
	JRST TTSNDO
	MOVSI 3,400000
	ANDCAM 3,TTFLGS(2)	;CLEAR OUTPUT-ACTIVE
	CALL TTRLOB		;RELEASE OUTPUT BUFFERS, SINCE EMPTY
	JRST TTSND1

TTSNDE:	SKIPN 3,TTEOUT(2)	;GET POINTER
	BUG(HLT,<TTY ECHO OUTPUT - NO BUFFER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	MOVEM 3,TTEOUT(2)	;WRAP POINTER
	ILDB 3,TTEOUT(2)
	SOS TTECT(2)
	JRST TTSND2

TTSNDO:	SKIPN 3,TTOOUT(2)	;GET BUFFER POINTER
	BUG(HLT,<TTY OUTPUT - NO BUFFER BUT COUNT NON-0>)
	TDNN 3,WRPMSK
	HRR 3,1-TTSIZ(3)
	MOVEM 3,TTOOUT(2)	;WRAP POINTER
	ILDB 3,TTOOUT(2)
	SOS TTOCT(2)
TTSND2:	ANDI 3,377
	CAILE 2,CTYLIN		;SKIP REST FOR NOT CTY
	JRST 1(4)
;PART OF CODE TO WAKE UP TTYS WITH TIMER TURN OFF'S ON THEM
;!! MAH @ SUMEX 12/74 !!
IFN SUMEX,<
	CAIN 2,0		;FOR SUMEX LINE 0 ONLY
	 JRST	[MOVEM 3,TTLSO0	;SAVE CHAR IN 3
		 MOVE 3,TODCLK	;GET TIME CHAR GOING OUT
		 EXCH 3,TTLSO0	;SET IT AND GET CHAR
		 JRST .+1]
>
	CAIE 2,CTYLIN		;IS CONSOLE TTY?
	JRST TTSND5		;NO
	DATAO TTY,3		;YES
	JRST TTSND4

TTSND5:	HRLI 3,DLSDLB(2)	;DIRECTED LINE BIT
	IORI 3,DLSACT		;ACTIVATE BIT
	DATAO DLS,3
TTSND4:	MOVSI 3,400000
	IORM 3,TTFLGS(2)	;SET OUTPUT-ACTIVE
TTSND1:	JRST 0(4)

IFNDEF TYMSW,<END>


;<MON>DISC.MAC;3    22-APR-77 11:20:31    EDIT BY SWEER
;ADD CODE IN OPENF1 TO UPDATE LAST READER
;<MON>DISC.NEW;2    10-SEP-75 14:33:26    EDIT BY LIEB
;SUBSTITUTE JSYS BLOCK0 FOR DISMS AT OFNJFX+4, BLOCK0 BECAUSE
;WE WANT TO STAY IN BALANCE SET
;<NEWMON>DISC.SMX;4     5-SEP-74 11:17:01	EDIT BY MANN
;<NEWMON>DISC.MAC;2    26-AUG-74 11:12:39	EDIT BY MANN
;<TENEX-130>DISC.MAC;89    28-DEC-72 09:44:14	EDIT BY TOMLINSON
;<TENEX-130>DISC.MAC;88    20-DEC-72 13:50:28	EDIT BY TOMLINSON
;<TENEX-130>DISC.MAC;87    20-DEC-72 10:29:32	EDIT BY TOMLINSON
;<TENEX-130>DISC.MAC;86     7-DEC-72 14:05:02	EDIT BY TOMLINSON
;<TENEX-130>DISC.MAC;85     4-DEC-72 23:28:22	EDIT BY TOMLINSON
; CHANGED REFERENCE DATES TO BE READ DATES
;<TENEX-130>DISC.MAC;84     4-DEC-72 23:13:29	EDIT BY TOMLINSON
; BUG FIXES TO DSK RENAME PAGE COUNTING
;<TENEX-130>DISC.MAC;83    29-NOV-72 13:36:40	EDIT BY CLEMENTS
;CHECK FOR ZERO BYTE SIZE AT DISK CLOSE
;<TENEX-130>DISC.MAC;82    21-NOV-72 16:07:44	EDIT BY WALLACE
;<TENEX-130>DISC.MAC;81    19-NOV-72 23:37:31	EDIT BY WALLACE
;<DLM/TEMP>DISC.MAC;80    30-OCT-72 11:40:53	EDIT BY TOMLINSON
; FIXED CALL TO DELFIL IN DSKREN

	SEARCH	FILEDEF,STENEX,PROLOG
	TITLE	DISC
	SUBTTL	R.S.Tomlinson	28 JUN 72	1000:

EXTERN DLOCKR,LONFLK

EXTERN I4DEL
EXTERN DSKFRC
EXTERN	DEDSK,BHC,DELOFN
EXTERN	PFILPC,PFILBS
EXTERN	PBYTSZ,PBYTPO
EXTERN	CHKJFN,UNLCKF,DELFIL,FPTA
EXTERN	CPOPJ,SKPRET
EXTERN	MDDDIR,MDDNAM,MDDEXT,MDDVER,INSPRT,INSACT
EXTERN	JOBDIR,ACCCHK,GETFDB,USTDIR,NFBSZ,ASGPAG,RELPAG
EXTERN	NSKED
EXTERN	RSKED
EXTERN	NXTDMP		; Zero to cause dump of open files
EXTERN	DIDSCA		; Disc address for di
EXTERN	DIDSCI		; Initial disc address for di
EXTERN	BLOCK0

INTERN	USRSPC,SYSSPC

DEFINE	NOSKED<AOS NSKED>
DEFINE	OKSKED<SOSG NSKED
		XCT RSKED>

LS(CLASS)		; Class field counter

USRSPC:	USRSCF	; DONT ALLOW WRITE OPEN IF USER EXCEEDED DISK ALLOCATION
SYSSPC:	SYSSCF	; DONT ALLOW WRITE OPEN IF SYSTEM FREE PAGE COUNT IS .L.
		; SYSSPC (ASSUMING SYSSPC .NE. 0 )

	USE	SWAPPC

DSKDTB::MDDDIR
	MDDNAM
	MDDEXT
	MDDVER
	INSPRT
	INSACT
	DSKINS		; Insert status
	DSKOPN
	DSKSQI
	DSKSQO
	DSKCLZ
	DSKREN
	DSKDEL
	DSKDMI
	DSKDMO
	CPOPJ
	CPOPJ
	CPOPJ
	CPOPJ
	CPOPJ		; Device status read
	CPOPJ		; Device status set

DSKDEL:	PUSHJ P,GETFDB
	JRST SKPRET
	PUSH P,A
	HRLI A,WRTF		;TO DELETE MUST HAVE WRITE ACCESS
	PUSHJ P,ACCCHK
	JRST [	SUB P,[XWD 1,1]
		PUSHJ P,USTDIR
		MOVEI A,DELFX1
		POPJ P,]
	POP P,A
	MOVSI B,FDBDEL
	IORB B,FDBCTL(A)
;   I4 CHANGE
;;;	TLNE B,FDBPRM
;;;	SETZM FDBSIZ(A)		; Zero size when deleting permanent files
	PUSHJ P,USTDIR
	JRST SKPRET

DSKINS:	PUSHJ P,GETFDB
	BUG(HLT,<DSKINS: GETFDB FAILURE.>)
	MOVSI B,FDBTMP
	IORM B,FDBCTL(A)
	PUSHJ P,USTDIR
	POPJ P,

; Disk open routine
; Call:	LH(STS)	; Access desired
;	JFN	; Job file number
;	PUSHJ P,DSKOPN
; Return
;	+1	; Cannot open, reason in a
;	+2	; Success

DSKOPN:	PUSHJ P,GETFDB		; Get pointer to fdb
	JRST [	MOVEI A,OPNX2
		POPJ P,]	; File has been deleted
	PUSH P,A
	HLL A,STS
	PUSHJ P,ACCCHK		; Check access
	JRST [	PUSHJ P,USTDIR	; Access not allowed
		SUB P,[XWD 1,1]
		POPJ P,]
	POP P,A
	TEST(CE,RNDF)		; Change flag from "append" to "random"
	TEST(O,WRTF)		; And if append, allow writing
	TRNE STS,17
	JRST [MOVEI A,OPNX14
		PUSHJ P,USTDIR
		POPJ P,]	; Illegal mode
	TEST(NN,WRTF)
	JRST OPENF1		; Not write
	PUSH P,B		; SAVE B WHILE DOING SPACE CHECKING
	MOVE B,CAPENB		; DONT CHECK IF ENABLED WHEEL
	TRNE B,WHEEL
	JRST DSKOP2
	SKIPN USRSPC		; INDIVIDUAL CHECK ON ?
	JRST DSKOP1		; NO
	PUSH P,A

ifn SUMEX,	<
;IF BIT 100 OF DIRDBK IS ON THEN WRITE LOCK THIS USER
;WHEN HE IS OVER HIS ALLOCATION
		MOVE 	A,DIRDBK	;GET DIR DEFAULT SPEC
		TRNN	a,100
		Jrst	[POP 	p,a
			 jrst	DSKOP1]
	>

	HLRZ B,DIRDSK		; GET MAX ALLOCATION THIS DIRECTORY
	HRRE A,DIRDSK		; GET CURRENT ALLOCATION THIS DIRECTORY
	SUB B,A			; COMPUTE DIFFERENCE
	POP P,A
	JUMPLE B,[		; IF OVER-ALLOCATED, GIVE ERROR
		POP P,B
		MOVEI A,OPNX10
		PUSHJ P,USTDIR
		POPJ P, ]
DSKOP1:	MOVE 2,DSKFRC		; FREE SPACE LEFT
	CAMG 2,SYSSPC		; AND GIVE ERROR IF LESS THAN SYSSPC
	JRST [
		POP P,B
		MOVEI A,OPNX10
		PUSHJ P,USTDIR
		POPJ P, ]
DSKOP2:	POP P,B
	TRNE STS,1B27
	JRST OPENF0
	MOVE B,JOBNO
	HRRZ B,JOBDIR(B)
	HRLM B,FDBUSE(A)	; Save in fdb
	PUSH P,A
	GTAD			; Get today
	MOVE B,A
	POP P,A
	SKIPL B
	MOVEM B,FDBWRT(A)	; Save as date of last write
	MOVSI B,1
	ADDM B,FDBCNT(A)	; Count number of writes

OPENF0:	SKIPE B,FDBADR(A)	; Get disc address
	JRST OPENF4
	PUSH P,A		; No disc address, must get one
	MOVEI A,0
	PUSHJ P,DSKASN		; Assign a disc address
	JRST [	POP P,A
	MOVEI A,OPNX10
		PUSHJ P,USTDIR
		POPJ P,]
	AOS B,CLASS
	ANDI B,777
	MOVEM B,CLASS
	CAIG B,2
	JRST .-4
	ROT B,4
	TLO A,<(1B3)>(B)
	MOVE B,A
	POP P,A
	MOVEM B,FDBADR(A)
	JRST OPENF4		; CONTINUE WITH WRITE

OPENF1:	MOVE B,FDBCTL(A)
	TLNE B,FDBNXF		; Does this file exist
	JRST OPENF8		; NO, CANNOT OPEN
	TRNE STS,1B27		; SUPPRESS REFERENCE UPDATE?
	 JRST OPENF4		; YES, BYPASS
IFN SUMEX,<
	MOVE	B,JOBNO		;UPDATE LAST READER
	HRRZ	B,JOBDIR(B)
	HRRM	B,FDBUSE(A)
>
	PUSH P,A
	GTAD			; GET NOW
	MOVE B,A
	POP P,A
	SKIPL B
	MOVEM B,FDBREF(A)	; UPDATE LAST READ DATE
	AOS FDBCNT(A)
	JRST OPENF4

OPENF8:	MOVEI A,OPNX2		; No, cannot be opend
	PUSHJ P,USTDIR
	POPJ P,

OPENF4:	SKIPN FDBADR(A)
	 JRST OPENF8
	MOVEI B,0
	TEST(NE,RNDF)
	TLNE STS,READF!XCTF!ASPF
	MOVE B,FDBSIZ(A)	; Get size of file
	MOVEM B,FILLEN(JFN)	; To open file length
	MOVEM B,FILBYN(JFN)
	TEST(NE,RNDF)
	SETZM FILBYN(JFN)
	PUSH P,A
	LDB A,PFILBS		; Get byte size
	SKIPN A
	MOVEI A,^D36
	LDB B,[POINT 4,STS,35]
	CAIN B,17
	SKIPA B,[^D36]		; Dump mode always 36 bit bytes
	LDB B,PBYTSZ
	CAILE B,^D36
	JRST [	POP P,A
		MOVEI A,SFBSX2
		JRST OPENF6]
	PUSHJ P,NFBSZ
	POP P,B
OPENF9:	MOVE A,FDBADR(B)
	MOVE C,FDBCTL(B)
	TRNE STS,1B25		; Thawed access?
	TLO A,(1B2)		; Yes
	TEST(NE,WRTF)
	TLO A,(1B1)
	TLNE C,FDBLNG
	JRST OPNLNG		; Long files are opened peculiarly
	TLNN A,(1B3)
	JRST OPENF2		; Yes

OPENF7:	PUSH P,B
	PUSHJ P,ASOFN		; Get an ofn for the file
	JRST OPENF5
	HRLM A,FILOFN(JFN)
	PUSH P,A
	PUSHJ P,ASGPAG		; Get a free page of memory
	JRST [	HLRZ A,FILOFN(JFN)
		PUSHJ P,RELOFN
		SUB P,[XWD 2,2]
		MOVEI A,OPNX18
		JRST OPENF6]
	MOVE B,A
	EXCH A,(P)
	HRLI B,140000
	PUSHJ P,SETMPG		; Map the index block
	POP P,A
	HRLZI B,(A)
	HRRI B,1(A)
	SETZM (A)
	BLT B,777(A)		; Zero the index block
	POP P,B
	MOVSI C,(1B3)
	ANDCAM C,FDBADR(B)	; Clear new ib bit
	MOVSI C,FDBNXF
	TRNE STS,1B25
	ANDCAM C,FDBCTL(B)	; Clear non-existent bit for thawed
	HRRZ B,A
	MOVEI A,0
	PUSH P,B
	PUSHJ P,SETMPG		; Unmap the page
	POP P,A
	PUSHJ P,RELPAG		; Return to free pool
	SETZM NXTDMP
	JRST OPENF3

OPENF2:	PUSHJ P,ASOFN		; Get an of for this file
	JRST OPENF6
	HRLM A,FILOFN(JFN)
OPENF3:	TEST(O,WNDF)		; No windows yet, and allow size change
	PUSHJ P,USTDIR
	JRST SKPRET

OPENF5:	POP P,B
OPENF6:	PUSHJ P,USTDIR
	POPJ P,

OPNLNG:	PUSHJ P,ASOFN		; Assign ofn for pt table
	JRST OPENF6		; Busy
	HRRM A,FILOFN(JFN)	; Save ofn
	PUSHJ P,ASGPAG		; Assign a page to map the pt table
	JRST OPNLN1		; None available
	HRRM A,FILLFW(JFN)	; Save long file pt location
	MOVE B,A
	HRLI B,140000
	HRRZ A,FILOFN(JFN)
	PUSHJ P,SETMPG		; Map the pt table
	MOVE C,A
	SKIPN A,(B)
	BUG(HLT,<OPNLNG: NO PAGE TABLE 0 IN LONG FILE.>)
	HLLZ C,SPTH(C)
	TLZ C,760017
	TLZ A,40
	IOR A,C
	PUSHJ P,ASOFN		; Assign an ofn for it
	JRST OPNLN2		; This should happen rarely (if at all)
	HRLM A,FILOFN(JFN)	; Save as ofn of current pt
	TEST(O,LONGF)
	JRST OPENF3		; Set bits and exit

OPNLN2:	PUSH P,A		; Save error code
	HRRZ B,FILLFW(JFN)
	MOVEI A,0
	PUSHJ P,SETMPG
	HRRZ A,B
	PUSHJ P,RELPAG
	JRST OPNLN3

OPNLN1:	PUSH P,[OPNX17]
OPNLN3:	HRRZ A,FILOFN(JFN)
	PUSHJ P,RELOFN
	POP P,A
	JRST OPENF6

; Disc sequential input
; Call:	JFN	; Job file number
;	STS	; File status
;	FILBYT ETC. SETUP PROPERLY FOR NEXT BYTE
;	PUSHJ P,DSKSQI
; Returns +1 with a byte in a

DSKSQI:	MOVE B,FILBYN(JFN)
	CAML B,FILLEN(JFN)
	JRST [	TEST(O,EOFF)
		POPJ P,]
	TEST(NE,WNDF)		; Has window been set up yet?
	PUSHJ P,SETWND		; No, set it up
	SOSGE FILCNT(JFN)
	PUSHJ P,NEWWNI
	ILDB A,FILBYT(JFN)	; Get next byte
	AOS FILBYN(JFN)		; Count bytes
	POPJ P,

NEWWNI:	PUSHJ P,NEWWND
	SOS FILCNT(JFN)
	POPJ P,

; Disc sequential output
; Call:	JFN	; Job file number
;	STS	; File status
;	FIL BYT ETC SET UP
;	A	; A byte
;	PUSHJ P,DSKSQO

DSKSQO:	TEST(NE,WNDF)		; Has a window been set up?
	PUSHJ P,SETWND		; No, set it up
	PUSH P,A
	SOSGE FILCNT(JFN)
	PUSHJ P,NEWWNI
	POP P,A
	IDPB A,FILBYT(JFN)	; Deposit the byte
	AOS B,FILBYN(JFN)	; Count bytes
	CAMGE B,FILLEN(JFN)	; Beyond the end?
	POPJ P,			; No, done.
	TEST(O,EOFF)		; Yes, set eoff
	MOVEM B,FILLEN(JFN)	; Update new length
	POPJ P,

; Disk dump io

DSKDMI:	TDZA B,B
DSKDMO:	MOVEI B,1
	PUSH P,B
	PUSH P,A
	TEST(NE,WNDF)
	 PUSHJ P,SETWND
DMPLP:	SKIPL 0(P)
	 JRST [	SUB P,[XWD 2,2]
		POPJ P,]
	MOVE B,FILBYN(JFN)
	SKIPN -1(P)		; Writing
	CAMGE B,FILLEN(JFN)	; Or not past eof
	SKIPA			; Is ok
	 JRST [	TEST(O,EOFF)
		SUB P,[XWD 2,2]
		POPJ P,]
	SOSGE FILCNT(JFN)
	 PUSHJ P,NEWWNI
	AOS FILCNT(JFN)
	HLRE A,0(P)		; Iowd count
	MOVMS A			; Magnitude
	CAML A,FILCNT(JFN)
	 MOVE A,FILCNT(JFN)	; Keep lesser of the two
	MOVE C,A		; Keep copy of count
	ADDB A,FILBYN(JFN)	; Update filbyn
	CAML A,FILLEN(JFN)
	 MOVEM A,FILLEN(JFN)	; Update length
	MOVN A,C		; Neg of count
	ADDM A,FILCNT(JFN)	; Decrease filcnt
	MOVE A,FILBYT(JFN)	; Get copy of byte pointer
	ADDM C,FILBYT(JFN)	; Update byte pointer
	IBP A			; Gets loc of first word of file
	MOVE B,0(P)		; Get core loc
	HRLZI B,1(B)		; Into left half
	HRR B,A			; Make up blt pointer
	HRL C,C			; Put count in both halves
	ADDM C,0(P)		; Update iowd
	SKIPN -1(P)		; Write?
	 MOVSS B		; No reverse from and to
	ADDI C,-1(B)		; Last address in c
	BLT B,0(C)
	JRST DMPLP

; Set up a window for a file
; Call:	PUSHJ P,SETWND

SETWND:	PUSH P,A
	PUSHJ P,ASGPAG		; Assign a job page
	JRST [	TEST(O,ERRF)
		POP P,A
		POP P,0(P)	; Pop return off stack
		POPJ P,]	; And return one level back
	HRRZM A,FILWND(JFN)
	TEST(Z,WNDF)
	PUSHJ P,NEWWND		; Set up window pointers
	POP P,A
	POPJ P,

; Set up pointers to a file
; Call:	FILBYN(JFN)	; File byte number
;	FILBYT(JFN)	; Byte size bits
;	LH(FILWND(JFN))	; Current page number
;	RH(FILWND(JFN))	; File window location
;	ETC.
;	PUSHJ P,NEWWND

NEWWND::TEST(NE,WNDF)
	POPJ P,			; Do nothing if no window yet
	PUSH P,A
	LDB A,PBYTSZ		; Get current byte size
	MOVEI C,^D36
	IDIV C,A		; Get bytes per word
	MOVE B,FILBYN(JFN)	; Get current byte number
	CAMLE B,FILLEN(JFN)
	MOVEM B,FILLEN(JFN)
	IDIV B,C		; Current word in b, offset in b+1
	IMUL B+1,A		; Offset times byte size
	MOVN C,B+1
	ADDI C,^D36
	DPB C,PBYTPO		; Yields byte pointer position
	MOVE C,B
	PUSH P,C		; Save for later
	LSH C,-9		; Get page number
	HLRZ B,FILWND(JFN)	; Get current page number
	TRNE B,777
	CAME B,C
	JRST NEWWNA		; Need to set up a new window

NEWWNZ:	POP P,C			; Restore word number
	ANDI C,777		; Get relative to page origin
	HRRZ B,FILWND(JFN)
	IOR B,C			; Get absolute address
	HRRM B,FILBYT(JFN)	; Put into byte pointer
	LDB A,PBYTSZ		; Get current byte size
	MOVEI C,^D36
	IDIV C,A		; Get bytes per word
	IMULI C,1000		; Get bytes per page
	MOVEM C,FILCNT(JFN)	; Save as count
	MOVN B,FILBYN(JFN)	; Get byte number
	IDIV B,C		; Remainder is negative
	ADDM B+1,FILCNT(JFN)	; Adjust if not at beginning of page
	MOVE B,FILLEN(JFN)
	SUB B,FILBYN(JFN)	; Distance to end of file
	TEST(NE,READF)		; If reading
	CAMLE B,FILCNT(JFN)	; And smaller than filcnt
	SKIPA
	MOVEM B,FILCNT(JFN)	; Then this should be filcnt
	POP P,A			; Restore a
	POPJ P,

NEWWNA:	HRRZ A,C
	PUSHJ P,JFNOF1		; Get ofn.pn for this page
	JRST [	TEST(O,ENDF)
		POP P,C
		POP P,A
		POPJ P,]
	TEST(NN,ASPF)		; If access is ass specified?
	JRST NEWWN1
	PUSH P,A
	PUSHJ P,MRPACS		; Read access of the page
	LSH A,1			; Shift bits into position for sts
	TLZ STS,READF!WRTF!XCTF	; Change access to that of this page
	AND A,[XWD READF!WRTF!XCTF,0]
	OR STS,A		; Change file access to that of the page
	POP P,A
NEWWN1:	HRRZ B,FILWND(JFN)
	HRLI B,160000
	PUSHJ P,SETMPG		; Map the the page
	MOVE C,(P)
	LSH C,-9
	HRLM C,FILWND(JFN)
	JRST NEWWNZ		; And finish up

; New page table for long file

NEWLFP:	PUSH P,C		; Save pt number
	TEST(NE,LONGF)		; Is this file already long?
	JRST NEWLFT		; Yes, no sweat
	PUSHJ P,GETFDB		; No, let's get the fdb
	BUG(HLT,<NEWLFP: GETFDB FAILURE FOR OPEN FILE.>)
	MOVE C,FDBCTL(A)	; And see if it's become long
	TLNE C,FDBLNG		; Since we opened it
	JRST NEWFLL		; Yes, it has
	PUSH P,A		; No. save fdb location
	MOVE A,FDBADR(A)	; Get disc address of pt 0
	PUSHJ P,DSKASN		; Assign a page for the pt table
	 JRST [	PUSHJ P,USTDIR	; NO SPACE
		SUB P,[XWD 2,2]	; PULL UP STAKES
		POPJ P,]	; AND FAIL
	HLRZ B,FILOFN(JFN)	; Get ofn of current pt
	HLLZ C,SPTH(B)		; Get class field and write and thawed
	TLZ C,460017		; RETAIN WRITE, THAWED, AND CLASS
		IOR A,C		; COPY INTO NEW DISC ADDRESS
	PUSH P,A		; Save it for later
	TLO A,(1B3)		; Mark as new
	PUSHJ P,NEWLFS		; Assign ofn etc
	 JRST [	POP P,A		; GET BACK DISK ADDRESS
		PUSHJ P,DEDSK	; RELEASE IT
		PUSHJ P,USTDIR
		SUB P,BHC+2	; FLUSH THINGS ON STACK
		POPJ P,]	; AND GIVE FAIL RETURN
	HLRZ A,FILOFN(JFN)	; GET OFN OF PT
	MOVSI C,300000		; WRITE AND THAW
	ANDCAM C,SPTH(A)	; REMOVE FROM SPTH
	HRLZ A,B
	HRRI A,1(B)		; Prepare to clear the page
	SETZM (B)
	BLT A,777(B)
	POP P,C			; Get new disc address
	POP P,A			; And fdb location
	TLZ C,300000
	EXCH C,FDBADR(A)	; Store new disc address, get old
	TLZ C,017760		; No class fields in pt table
	TLO C,40
	MOVEM C,0(B)		; Store old disc address as pt 0
	MOVSI D,FDBLNG
	IORM D,FDBCTL(A)	; Mark fdb as long file
	JRST NEWLF1		; Continue with rest

NEWLFS:	PUSHJ P,ASOFN		; Assign ofn for new disc address
	 POPJ P,		; FAIL
	HRRM A,FILOFN(JFN)	; Save
	PUSHJ P,ASGPAG		; Get a page to map the pt table
	 JRST [	HRRZ A,FILOFN(JFN)
		HLLZS FILOFN(JFN)
		PUSHJ P,RELOFN
		POPJ P,]
	HRRM A,FILLFW(JFN)	; Store location of pt table
	MOVE B,A
	HRLI B,140000
	HRRZ A,FILOFN(JFN)
	PUSHJ P,SETMPG
	JRST SKPRET

NEWFLL:	MOVE A,FDBADR(A)	; File became long since we opened
	PUSHJ P,NEWLFS		; Map the pt table
	 JRST [	PUSHJ P,USTDIR
		SUB P,BHC+1
		POPJ P,]
NEWLF1:	PUSHJ P,USTDIR		; Finished with directory
	TEST(O,LONGF)

NEWLFT:	HRRZ B,FILLFW(JFN)	; Get location of pt table
	ADD B,(P)		; Offset by pt # to get disc addr
	NOSKED			; To prevent others from tampering
	DLOCK LONFLK		; LOCK THE LONG-FILE CODE
	SKIPE A,(B)		; Is a disc address assigned for this pt
	JRST NEWLFA		; Yes, use it
	PUSH P,B		; Save location in pt table
	HLRZ A,FILOFN(JFN)	; Get ofn of pt table
	MOVE A,SPTH(A)		; Get disc address of pt table
	PUSHJ P,DSKASN		; Get a new disc address
	JRST [	ULOCK LONFLK	; RELEASE LOCK
		OKSKED
		SUB P,BHC+2
		POPJ P,]
	PUSH P,A
	HLRZ A,FILOFN(JFN)
	HLLZ A,SPTH(A)		; Get class bits
	TLZ A,760017
	IOR A,(P)
	TLO A,(1B3)
	PUSHJ P,ASOFN		; Assign ofn for new ib
	 JRST [	POP P,A		; UNLIKELY FAILURE OF ASOFN
		PUSHJ P,DEDSK	; BUT DO THE RIGHT THING ANYWAY
		ULOCK LONFLK	; RELEASE LOCK
		OKSKED
		SUB P,BHC+2
		POPJ P,]
	PUSH P,A
	PUSHJ P,ASGPAG
	 JRST [	POP P,A		; OH NO!, THE WORST THING JUST HAPPENED
		PUSHJ P,DELOFN
		SUB P,BHC+3
		ULOCK LONFLK	; RELEASE LOCK
		OKSKED
		POPJ P,]

	MOVE B,A
	HRLI B,140000
	MOVE A,(P)
	PUSHJ P,SETMPG		; Map the pt
	HRLZ A,B
	HRRI A,1(B)
	SETZM (B)
	BLT A,777(B)		; Clear pt
	MOVEI A,0
	PUSHJ P,SETMPG
	HRRZ A,B
	PUSHJ P,RELPAG
	POP P,A
	PUSHJ P,RELOFN
	POP P,A
	POP P,B
	TLO A,40
	MOVEM A,(B)
NEWLFA:
	ULOCK LONFLK		; RELEASE LOCK
	OKSKED
	HRRZ B,FILOFN(JFN)	; Get pt table ofn
	HLLZ B,SPTH(B)		; Get class field
	TLZ B,760017
	TLZ A,40
	IOR A,B			; Insert into disc address
	PUSHJ P,ASOFN
	 JRST [	SUB P,BHC+1
		POPJ P,]
	HLRZ B,FILOFN(JFN)
	HRLM A,FILOFN(JFN)
	MOVE A,B
	PUSHJ P,RELOFN
	POP P,C
	JRST SKPRET

; Convert jfn.pn to ofn.pn
; Call:	LH(A)	; Jfn
;	RH(A)	; Page number
;	PUSHJ P,JFNOFN
; Return
;	+1	; Error, illegal jfn or page number too big
;	+2	; Ok
;	LH(A)	; Ofn
;	RH(A)	; Page number

JFNOFN::HLRZ JFN,A
	PUSH P,A
	PUSHJ P,CHKJFN
	JRST [	POP P,ERRSAV
		POPJ P,]	; Garbage designator
	JFCL
	JRST [	POP P,ERRSAV
		MOVEI A,DESX4
		POPJ P,]
	POP P,A
	TEST(NE,ASTF)
	 JRST [	MOVEI A,DESX7
		JRST UNLCKF]
	TEST(NN,OPNF)
	JRST [	MOVEI A,DESX5
		JRST UNLCKF]
	HRRZ B,DEV
	CAIN B,DSKDTB
	TEST(NN,RNDF)
	JRST [	MOVEI A,PMAPX1
		JRST UNLCKF]
	HRRZS A
	PUSHJ P,JFNOF1
	JRST .+2
	AOS (P)
	JRST UNLCKF

JFNOF1::TLNE A,777777
	POPJ P,
	PUSH P,A
	HLRZ B,FILWND(JFN)	; Get current page number
	XOR B,A
	TRNN B,777000		; If different page tables
	JRST JFNOF2
	LSH A,-9		; Need special action
	MOVE C,A
	PUSHJ P,NEWLFP		; Change current page
	 JRST [	SETO A,		; FAILED
		SUB P,BHC+1
		POPJ P,]
	SETZM FILCNT(JFN)	; Force any sequential io to remap
JFNOF2:	MOVE A,(P)
	TRZ A,777
	HRLM A,FILWND(JFN)
	POP P,A
	HLL A,FILOFN(JFN)
	ANDCMI A,777000		; Mask out pt number
	JRST SKPRET

; Convert ofn.pn to jfn.pn
; Call:	LH(A)	; Ofn
;	RH(A)	; Pn
;	PUSHJ P,OFNJFN
; Return
;	+1	; No jfn found
;	+2	; Ok
;	A	; Jfn.pn

OFNJFX::TLO A,400000
OFNJFN::PUSH P,A
	HLRZS A
	ANDI A,377777
	PUSH P,A
	NOINT
	LOCK(JFNLCK,<JRST [
		OKINT
		SKIPA		;JSYS BLOCK0 RETURNS PC - 1
		JRST .-2	;THEREFORE...
		JSYS BLOCK0]>)	;INSTEAD OF DISMS BECAUSE CALLED AT TRAP LEVEL
	MOVE JFN,MAXJFN
	SOS JFN
	LSH JFN,SJFN		; Convert to index
OFNJF1:	MOVE STS,FILSTS(JFN)
	HRRZ A,FILDEV(JFN)
	CAIE A,DSKDTB
	JRST OFNJF2
	MOVE A,FILLFW(JFN)
	TLNN A,777776
	SKIPL -1(P)
	TEST(NN,OPNF)
	JRST OFNJF2
	TEST(NE,LONGF)
	JRST OFNJF3
	HLRZ A,FILOFN(JFN)
	CAME A,(P)
	JRST OFNJF2
OFNJF6:	POP P,A
	POP P,A
	LSH JFN,-SJFN		; Convert back to jfn
	HRL A,JFN
	UNLOCK JFNLCK
	OKINT
	JRST SKPRET

OFNJF3:	MOVE A,(P)		; Get ofn
	MOVE A,SPTH(A)		; Get disc address
	TLZ A,777760
	TLO A,40
	PUSH P,B
	MOVSI B,-1000
	HRR B,FILLFW(JFN)
OFNJF4:	CAMN A,(B)
	JRST OFNJF5
	AOBJN B,OFNJF4
	POP P,B
	JRST OFNJF2

OFNJF5:	SUB B,FILLFW(JFN)	; Get pt number
	HRRZS B
	LSH B,9			; Convert to page offset
	ADDM B,-2(P)		; Augment page number
	POP P,B
	JRST OFNJF6

OFNJF2:	SUBI JFN,1_SJFN	; To next jfn index
	JUMPGE JFN,OFNJF1
	POP P,A
	POP P,A
	UNLOCK JFNLCK
	OKINT
	POPJ P,

; Disk close
; Call:	JFN	; Job file number
;	PUSHJ P,DSKCLZ

DSKCLZ:	MOVE A,FILLEN(JFN)
	TEST(NN,WNDF)		; If no window
	CAME A,FILBYN(JFN)	; Or if not at end of file
	JRST DSKCL9		; Don't fix end
	HRRZ A,FILWND(JFN)	; Get window address
	PUSHJ P,FPTA		; Get ptn.pn
	PUSHJ P,MRPACS		; Read page access
	TLNN A,(1B3)		; Writable?
	 JRST DSKCL9		; No.
	MOVEI A,0
	MOVE B,FILBYT(JFN)
	TLNN B,007700		;ANY BYTE SIZE? 
	JRST DSKCL9		;NO. SHOULD BE, BUT DON'T HANG IN LOOP.
DSKCL7:	IBP B
	TRNN B,777
	JRST DSKCL9
	DPB A,B
	JRST DSKCL7

DSKCL9:	HRRZ B,FILWND(JFN)	; If window page exists
	JUMPE B,DSKCL2
	MOVEI A,0
	PUSHJ P,SETMPG		; Unmap window
	HRRZ A,FILWND(JFN)
	PUSHJ P,RELPAG		; Return page to free list
	HLLZS FILWND(JFN)
DSKCL2:	TEST(NE,LONGF)
	JRST CNTLNG
	HLRZ A,FILOFN(JFN)	; Get ofn
	PUSHJ P,RELOFN
DSKCL0:	PUSH P,A		; Save page count
	PUSHJ P,GETFDB
	 JRST [	SUB P,[XWD 1,1]
		JRST DSKCL1]	; Fdb is gone, update unnecessary
	POP P,B
	SKIPL B
	JRST [
		PUSH P,B
		PUSH P,C
		LDB C,PFILPC	;GET OLD DISK PAGES THIS FILE
		SUB B,C		;COMPUTE NET CHANGE
		HRRE C,DIRDSK	;GET CURRENT USED COUNT
		ADD B,C		;COMPUTE NEW USED COUNT
		HRRM B,DIRDSK	;AND SAVE IT
		POP P,C
		POP P,B
		DPB B,PFILPC
		JRST .+1 ]
	MOVSI B,FDBNXF
	ANDCAM B,FDBCTL(A)	; Clear non-existent flag
	TEST(NE,WRTF)
	TEST(NE,WNDF)
	JRST DSKCL3
	LDB B,PBYTSZ
	DPB B,PFILBS		; Update byte size
	MOVE B,FILLEN(JFN)
	MOVEM B,FDBSIZ(A)
;
;   I4 CHANGE
DSKCL3:
	JRST I4DEL	;DELETE EXTRA VERSIONS
DSKCL4::
	PUSHJ P,USTDIR
DSKCL1::	SETZM NXTDMP
	JRST SKPRET

CNTLNG:	HLRZ A,FILOFN(JFN)	; Get current page table ofn
	PUSHJ P,RELOFN		; Release
	HRRZS FILOFN(JFN)
	JUMPL A,CNTLN4		; If still in use, skip counting
	MOVSI C,-1000		; Count thru 1000 page tables
	HRR C,FILLFW(JFN)	; At fillfw
	SETZ E,			; Total count
CNTLNL:	SKIPN A,(C)
	 JRST CNTLN1
	PUSH P,C
	HRRZ B,FILOFN(JFN)
	HLLZ B,SPTH(B)
	TLZ B,760017
	TLZ A,40
	IOR A,B
	PUSHJ P,ASOFN		; Have to assign ofn for it to map
	 JRST CNTLN2		; If failure, skip rest of counting
	PUSHJ P,RELOFN		; Now release which will count pages
	JUMPL A,CNTLN2		; If any page table busy, stop
	ADD E,A			; Add into sum
	POP P,C
CNTLN1:	AOBJN C,CNTLNL
	JRST CNTLN3

CNTLN2:	POP P,C
CNTLN4:	SETO E,			; Remember we have no valid page count
CNTLN3:	PUSH P,E		; Save
	HRRZ B,FILLFW(JFN)
	SETZ A,
	PUSHJ P,SETMPG		; Remove ptt from map
	HRRZ A,FILLFW(JFN)
	PUSHJ P,RELPAG		; And release storage
	HLLZS FILLFW(JFN)
	HRRZ A,FILOFN(JFN)
	PUSHJ P,RELOFN		; Release ofn of ptt
	HLLZS FILOFN(JFN)
	POP P,A
	JRST DSKCL0

; Mutlitple directory rename
; Call:	JFN	; Jfn of new name
;	A	; Jfn of existing file
;	PUSHJ P,DSKREN

DSKREN:	PUSH P,A		; SAVE SOURCE JFN
	PUSHJ P,GETFDB		; GET FDB
	JRST [	POP P,A		; NAME GONE
		MOVEI A,RNAMX2
		POPJ P,]
	PUSH P,A
	HRLI A,WRTF
	PUSHJ P,ACCCHK		; CAN WE WRITE ON SINK
	JRST [	PUSHJ P,USTDIR
		SUB P,[XWD 2,2]
		MOVEI A,RNAMX3
		POPJ P,]
	MOVE A,0(P)		; GET BACK FDB LOCATION
	SKIPN A,FDBADR(A)	; IS THERE A DISK ADDRESS FOR DESTINATION?
	JRST [	MOVEI A,0	; NO, WE'LL HAVE TO ASSIGN ONE
		PUSHJ P,DSKASN	; TO SERVE AS A PLACE HOLDER
		 JRST [	MOVEI A,RNAMX4	; BUT IF THAT FAILS,
			PUSHJ P,USTDIR	; WE CAN'T DO THE RENAME
			SUB P,BHC+2
			POPJ P,]
		MOVE B,(P)
		TLO A,(1B3+777B13)
		MOVEM A,FDBADR(B)
		JRST .+1]
	TLO A,(1B1)
	PUSHJ P,ASOFN		; ASSIGN OFN FOR UNTHAWED WRITING
	JRST [	SUB P,[XWD 2,2]	; CAN'T. BUSY OR BAD PT
		PUSHJ P,USTDIR
		CAIE A,OPNX9	; IF NO BUSY,
		SKIPA A,[RNAMX6]
		MOVEI A,RNAMX5
		POPJ P,]
	MOVEM A,(P)		; SAVE OFN (SMASHES FDB LOC)
	PUSHJ P,USTDIR		; THRU WITH DEST FOR NOW
	EXCH JFN,-1(P)		; SAVE DEST JFN, GET SOURCE JFN
	PUSHJ P,GETFDB		; GET SOURCE FDB
	JRST [	POP P,A		; WHOOPS, SOURCE WENT AWAY
		PUSHJ P,RELOFN	; HAVE TO UNDO WHAT WE DID
		POP P,JFN
		MOVEI A,RNAMX7
		POPJ P,]

DSKREO:	PUSH P,A		; SOURCE Fdb loc
	HRLI A,WRTF
	PUSHJ P,ACCCHK		; HAVE TO BE ABLE TO DELETE (WRITE)
	 JRST [	MOVEI A,RNAMX8	; AWW, SHUCKS. CAN'T DO THE RENAME
		JRST DSKRE8]
	MOVE A,0(P)		; GET BACK FDB LOC
	SKIPN A,FDBADR(A)
	 JRST [	MOVEI A,RNAMX9	; FROM HAS NO DISK ADDRESS
		JRST DSKRE8]
	TLO A,(1B1)
	PUSHJ P,ASOFN		; ASSIGN OFN FOR UNTHAWED WRITING
	 JRST [	CAIE A,OPNX9	; BUSY OR BAD PT
		SKIPA A,RNMX11
		MOVEI A,RNMX10
		JRST DSKRE8]
	CAMN A,-1(P)		; RENAME TO SELF?
	JRST [	PUSHJ P,RELOFN	; Rename to self
		MOVEI A,RNMX12
		JRST DSKRE8]

; STACK NOW CONTAINS
; 0	; FDB LOC OF SOURCE
; -1	; OFN OF DESTINATION
; -2	; JFN OF DESTINATION
; -3	; RETURN

	MOVE JFN,-2(P)		; GET DESTINATION JFN BACK
	MOVEM A,-2(P)		; STORE SOURCE OFN ON STACK
	MOVEI B,0(P)		; WHERE TO PUT FDB
	MOVE A,0(P)		; RESCUE FDB LOC FIRST
	ADD P,[XWD FDBLEN-1,FDBLEN-1]
	JUMPGE P,MSTKOV
	HRL B,A			; MAKE BLT POINTER
	BLT B,0(P)
	MOVSI B,FDBPRM
	AND B,FDBCTL(A)		; RETAIN PERM BIT
	TLO B,FDBNXF!FDBDEL	; AND DELETE AND NON-EX IT
	HLLM B,FDBCTL(A)	; NEW CONTROL BITS
	LDB B,PFILPC		; GET PAGE COUNT (OLD GUY)
	MOVNS B
	ADD B,DIRDSK
	HRRM B,DIRDSK
	SETZB B,FDBADR(A)	; NO DISC ADDRESS
	DPB B,PFILPC
	PUSHJ P,USTDIR		; FINISHED WITH SOURCE

; STACK NOW HAS
; 0 THRU -FDBLEN+1	; FDB
; -FDBLEN		; DESTINATION OFN
; -1-FDBLEN		; SOURCE OFN
; -2-FDBLEN		; RETURN

	PUSHJ P,GETFDB		; To other fdb (REMEMBER JFN SET ABOVE)
	BUG(HLT,<DSKREN: GETFDB FAILURE FOR OPEN FILE.>)
	EXCH A,-1-FDBLEN(P)	; SAVE FDB LOC, GET SOURCE OFN
	PUSHJ P,RELOFN		; FLUSH IT
	HRRZ A,-FDBLEN(P)	; Get ofn of new name
	PUSHJ P,RELOFN
	MOVE A,-FDBLEN-1(P)	; GET BACK TO FDB LOC
	MOVEI D,-DIRORG(A)
	PUSH P,E
	PUSH P,F
	PUSHJ P,DELFIL		; DELETE OLD CONTENT OF DESTINATION
	 JFCL			; MIGHT FAIL IF PERM NAME
	SKIPLE A,FDBACT+DIRORG(D)
	AOS DIRORG+1(A)		; CONTINUE TO USE OLD PROTECTION
	POP P,F			; RESTORE F AND E
	POP P,E

; NOW READY TO PLANT THE OLD FDB INTO THE NEW
; FIRST TO RECAP THE STACK
; -FDBLEN+1 TO 0	; SOURCE FDB
; -FDBLEN		; PREVIOUS OFN OF DESTINATION (NO LONGER VALID)
; -FDBLEN-1		; DEST FDB LOC
; -FDBLEN-2		; RETURN

DSKRE9:	MOVSI D,-FDBLEN		; PREPARE TO DO ALL FDB ENTRIES
	MOVE A,-1-FDBLEN(P)
	LDB B,PFILPC		; GET PAGES JUST FLUSH BY DELFIL
	MOVNS B
	ADD B,DIRDSK
	HRRM B,DIRDSK
	HRLI A,D
	MOVEI B,-FDBLEN+1(P)
	HRLI B,D
DSKR9L:	MOVE C,@B		; GET SOURCE
	XOR C,@A		; BIT DIFFERENCE
	ANDCM C,RENMSK(D)		; BITS TO RETAIN FROM DESTINATION
	XORM C,@A
	AOBJN D,DSKR9L
	LDB B,PFILPC		;GET FILE PAGES COUNT
	ADDM B,DIRDSK	;UPDATE NEW GUYS ALLOCATION
	SUB P,[XWD FDBLEN+2,FDBLEN+2]
	PUSHJ P,USTDIR
	SETZM NXTDMP
	JRST SKPRET

; COMMON ERROR ROUTINE

DSKRE8:	MOVEM A,-2(P)
	PUSHJ P,USTDIR
	POP P,A
	POP P,A
	PUSHJ P,RELOFN
	POP P,A
	POPJ P,

; MASKS OF BITS TO RETAIN IN DESTINATION

RENMSK:	-1
	XWD FDBTMP!FDBPRM,-1	; FDBCTL
	-1			; FDBEXT
	0			; FDBADR
	-1			; FDBPRT
	0			; FDBCRE
	-1			; FDBUSE
	-1			; FDBVER
	-1			; FDBACT
	0			; FDBBYV
	0			; FDBSIZ
	0			; FDBCRV
	0			; FDBWRT
	0			; FDBREF
	0			; FDBCNT
	REPEAT 5,<0>		; FDBBCK
	0			; FDBUSW

	END


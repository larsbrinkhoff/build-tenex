;<MON>DSKPAK.MAC;5    19-APR-77 15:54:31    EDIT BY SWEER
;UN HALF KILLED NDVMAX FOR ANAL PROGRAM
; REMOVED DISKOP OVERDUE BUGCHK IF DRIVE GE NPACKS
; ADDED DSKTAB GETTAB AND INTERNED DRIVTB FOR GETTAB SWEER
;<MON>DSKPAK.MAC;3    14-JAN-77 14:34:42    EDIT BY SWEER
;CHANGED NDVMAX TO 8
;<MON>DSKPAK.MAC;2    14-JAN-77 14:32:51    EDIT BY SWEER
;MOVED INFBUF TO ISYS.MAC
;<MON>DSKPAK.SMX	3-JUL-75		EDIT BY HEATHMAN
;ADDED RECOVERABLE ERROR LOGGING CODE
;<MON>DSKPAK.SMX;	14-FEB-75		EDIT BY HEATHMAN
;RE ORGANIZED DISK SPACE ALLOCATING PARAMETERS
;<XTENEX>DSKPAK.ISI;7    25-NOV-73 22:44:32	EDIT BY MELVIN
;CHANGED DSKSWA TO HITRK+1 AND THUS DSKRMA TO <HITRK+1+DSKNST>*NSECTK
;<XTENEX>DSKPAK.ISI;6    14-NOV-73 22:35:15	EDIT BY MELVIN
;CHANGED HITRK TO BE EQUAL TO NTRACK-1
;<XTENEX>DSKPAK.ISI;5    13-JUL-73 22:52:59	EDIT BY MELVIN
;<XTENEX>DSKPAK.ISI;4    13-JUL-73 22:36:20	EDIT BY MELVIN
;PUT IN ALLOCATION FOR NEW DISK -- USING ONLY LOWER HALF OF THE
;FORTH DRIVE (DRIVE 3)
;<XTENEX>DSKPAK.ISI;3    16-MAY-73 03:31:39	EDIT BY MELVIN
;CHANGED HITRK TO NTRACK
;<XTENEX>DSKPAK.ISI;2    16-MAY-73 01:18:14	EDIT BY MELVIN
;CHANGED DISK ALLOCATION SO THAT ALL OF SYSTEM DRIVES IS USED
;FOR FILE SPACE.  IF THE DRUM GOES DOWN, THE STANDBY DRIVE MUST BE
;BROUGHT UP FOR SWAPPING.
;WRMON AND WRSWM ARE DISABLED
;<XTENEX>DSKPAK.ISI;1     8-FEB-73 21:47:42	EDIT BY MELVIN
;HITRK AND DSKRMA CHANGED AND FILE CHANGED TO DSKPAK.ISI
;<TENEX-130>DSKPAK.MAC;48    28-DEC-72 19:26:25	EDIT BY CLEMENTS
;FIXED TYPO IN DSKRCK
;<TENEX-130>DSKPAK.MAC;47    26-DEC-72 16:20:45	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;46    26-DEC-72 14:59:37	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;49    20-DEC-72 10:21:53	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;48    20-DEC-72 10:06:43	EDIT BY TOMLINSON
; ADDED TEMPORARY TABLE OF HOME ADDRESSES TO RESERVE SPACE
;<TENEX-130>DSKPAK.MAC;47    20-DEC-72 09:01:27	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;46    18-DEC-72 15:24:40	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;45    18-DEC-72 15:20:37	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;44    21-NOV-72 16:58:16	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;43    21-NOV-72 15:44:50	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;42    20-NOV-72 23:55:32	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;41    20-NOV-72 17:23:00	EDIT BY WALLQcE
;<TENEX-130>DSKPAK.MAC;40    20-NOV-72 15:05:03	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;39    18-NOV-72 18:49:01	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;38     9-NOV-72 19:35:17	EDIT BY TOMLINSON
; ISOLATING FOR SEPARATE ASSEMBLY -- ADDED BGHERE AND END
;<TENEY-530>DSKPAK.MAC;37     6-NOV-72 12:27:56	EDIT BY TOMLINSON
; DSKRDA FIXES
;<TENEXDLM>DSKPAK.MAC;36    22-SEP-72 15:21:03	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;35    21-SEP-72 11:31:21	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;34     8-AUG-72 22:02:56	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;33     8-AUG-72 19:01:30	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;32     7-AUG-72 23:15:17	EDIT BY MURPHY

;19 JUN 72, 1852:
;TENEX DRIVER FOR DISK PACKS.  D. MURPHY

;GENERAL CODE FOR DISK PACK DEVICES; DEVICE DEPENDENT CODE FOR
;DEC RP10/RP02 AND TELEFILE DC10 INCLUDED UNDER ASSEMBLY SWITCH

	INTERN RLMX0,DSKRMA,VERSIZ,NSECPG,DSKNOV
	INTERN DSKIO,DSKCHK,UDSKIO,UDSKSW,CVDSK,CDSKVA,DIDSCI,DSKCP
	EXTERN NOFN,BLOCK1,DSKTIM,DISKP,FPTA,JFNOFN,NXTDMP
	EXTERN SETMPG,SETPT,DBUGSW,PSKED,DIDSCA,DEVMPE
	EXTERN DISGET,SCHEDP,EDISMS
	EXTERN DDERWD,DDERST,DDERLL,DSKEDA,DSKEUT,JB0FLG,DDERTP,INSKED
	EXTERN DDERBP
	EXTERN DSKPI,FORKX,HLOCKR,STOPLK,SWPPI,NOPILK,HLOCKP

;THE FOLLOWING ARE ALL OF THE DEVICE AND INSTALLATION DEPENDENT
;PARAMETERS

IFDEF RP02F,<		;RP02 DEVICE PARAMETERS

DSK=250			;DEVICE ADDRESS
DSKCP=62		;INITIAL CHANNEL ADDRESS

NTKUN=^D406		;NUMBER OF TRACKS PER DRIVE (UNIT)
NCYLBT==8
NSECBT==5

	NTRACK=NTKUN*NPACKS ;EACH DRIVE CONSIDERED A GROUP OF TRACKS

NWSEC==200		;RPO2'S HAVE 128 WORDS/SECTOR,
NSECS==^D10		; 10 SECTORS PER ROTATION,
NSURFS==^D20		; AND 20 SURFACES PER UNIT

	HOMCY1==1			; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5			; SURFACES
	HOMSF2==^D15
	HOMSC1==0			; AND SECTORS
	HOMSC2==0
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
	NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
	DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING

;THE FOLLOWING PARAMETERS RESERVE THE VARIOUS AREAS OF THE DISK(S)

DSKPFS==<NPACKS*NTKUN-250>*NSECTK ;SIZE OF DISK PUBLIC FILE AREA, LEAVES 250
				;TRACKS FOR THE FOLLOWING
DSKRMS==200*NSECPG		;SIZE OF DISK RESIDENT MON AREA,
				;NEEDS 200 PAGES
DSKSMS==200*NSECPG		;SIZE OF SWAPPABLE MONITOR, NEEDS 200 PAGES
DSKNOV==NDST-^D4500		;AREA ON DRUM FOR WHICH THERE IS NO DISK
				;BACKUP
DSKSWS==<NDST-DSKNOV>*NSECPG	;SIZE OF DISK SWAPPING AREA, ASSUMING ABOUT
				;^D4500 PAGES
DSKCSS==<3*1000+1>*NSECPG	;SIZE OF MON IMAGE CRASH SAVE AREAS, ASSUME
				;THREE AREAS
				;(DETERMINES NUMBER OF CRASH AREAS (SEE 
				;NCSHSV BELOW) WHICH IS ALSO HARD WIRED IN
				;CRSHSV.MAC - ANY CHANGES TO THE NUMBER OF 
				;CRASH AREAS MUST BE MADE TO BOTH FILES -
				;CURSE MACRO/LOADER FOR NOT ALLOWING EXTERNALS
				;IN PRODUCTS)
DSKVSS==<5*240+1>*NSECPG	;SIZE OF MON BOOT AREAS, ASSUME 5 AREAS
DSKEND==NPACKS*NTKUN*NSECTK	;SIZE OF ALLOCATED DISKS, IN SECTORS

DSKPFA==0			;START OF DISK PUBLIC FILE AREA
DSKRMA==DSKPFA+DSKPFS		;START OF DISK RESIDENT MONITOR AREA
DSKSMA==DSKRMA+DSKRMS		;START OF DISK SWAPABLE MONITOR
DSKSWA==DSKSMA+DSKSMS		;START OF DISK SWAPPING AREA

DSKVSA==DSKEND-DSKVSS		;START ADDRESS OF MON BOOT AREA
DSKCSA==DSKVSA-DSKCSS		;START OF MON IMAGE CRASH SAVE AREA

IFG DSKSWA+DSKSWS-DSKCSA,<PRINTX DISK OVER ALLOCATED IN DSKPAK>

LOTRK==DSKPFA/NSECTK
HITRK==<DSKPFA+DSKPFS>/NSECTK

	INTERN NCSHSV,CSHSIZ,DSKCSS ;LINK TO CRSHSV
CSHSIZ==1000*NSECPG
NCSHSV==DSKCSS/CSHSIZ		;NUMBER OF CRASH AREAS - ANY CHANGE HERE
				;MUST ALSO BE REFELCTED IN CRSHSV.MAC BECAUSE
				;MACRO/LOADER WON'T ALLOW EXTERNALS IN
				;PRODUCTS
	INTERN NSYSSV,RESAR	;LINK TO SYSSAV
VERSIZ==240			;SIZE OF BOOT IMAGE
RESAR==170			;SIZE OF RESIDENT PORTION
NSYSSV==DSKVSS/<NSECPG*VERSIZ>

	INTERN DSKRML,DSKSML,DSKCML,DSKVML

DSKRML:	DSKRMA			;"LITERALS", BECAUSE LOADER WON'T LINK FULL
DSKSML:	DSKSMA			;WORD SYMBOLS
DSKCML:	DSKCSA
DSKVML:	DSKVSA+1B0		;SYSSAV EXPECTS DSKOP TYPE LINEAR ADDRESS

REPEAT 0,<
HITRK=NTRACK-^D100		;UPPER LIMIT, PUBLIC FILE SYSTEM
LOTRK==0			;LOWER LIMIT
DSKSWA==<HITRK+1>*NSECTK	;SWAPPING AREA BEGINS ON STANDBY DRIVE
DSKRMA==<HITRK+1+DSKNST>*NSECTK	;RESIDENT MON IS JUST ABOVE SWAPPING AREA
DSKSMA==DSKRMA+200*NSECPG	;SWAPPABLE MONITOR JUST ABOVE RESIDENT MON
CSHPAG:: DSKSMA+200*NSECPG	;LINEAR DISK ADDR OF CRSH CNTRL PAGE
				;CRASH IMAGES START AT PAGE CSHPAG+1
;*******************************
;defined in CRSHSV:
;NCSHSV==1			;number of crash dump areas
;LCSHSV==600*NSECPG		;size of each dump area (in sectors)
;*******************************
VERSIZ==276			;SIZE OF MON SAVES PER AREA
VERSNL==<NTRACK-^D16>*NSECTK	;SYSTEM SAVE AREA
> ;END REPEAT 0

>			;END OF RP02 PARAMETERS

IFDEF DC10F,<		;TELEFILE DC10 PARAMETERS

DSK=700
DSKCP=62

IFNDEF CD215F,<
NTKUN==^D203
NWSEC==100
NSECS==^D18
NCYLBT==8
NSECBT==5
>

IFDEF	CD215F,<
NTKUN==^D406
NWSEC==200
NSECS==^D9
NCYLBT==9
NSECBT==4
>

NSURFS==^D20

	HOMCY1==1		; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5		; AND SURFACES
	HOMSF2==15
	HOMSC1==0		; AND SECTORS
	HOMSC2==0
	ADRPOS==^D14+NSECBT
	NTRACK=NTKUN*NPACKS
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
	NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
	DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING

HITRK=NTRACK-5
LOTRK=0

DSKSWA==<NTRACK>*NSECTK		;SWAPPING AREA AFTER 'LAST' PACK

DSKRMA==<HITRK>*NSECTK		;RESIDENT MON IMAGE
DSKSMA==DSKRMA+PPRMPG*NSECPG	;SWAP MON IMAGE
>			;END OF DC10 PARAMETERS

;COMMON PARAMETERS AND STORAGE

NGS DSKFCT,NTRACK	;COUNT OF FREE PAGES EACH TRACK
NGS DSKBTB,NTRACK*NBWTK	;BIT TABLE
XX==NTRACK+NTRACK*NBWTK		;SIZE OF ACTUAL STORAGE FOR CNT AND BITS
NGS DSKDMY,<<<XX+777>/1000>*1000>-XX ;FILL TO NEXT PAGE BOUNDARY

LS DSKBLK,1		;BIT TABLE LOCK
LS DBTJFN,1		;JFN OF BIT TABLE FILE

;DISC ADDRESS OF INDEX FILE

;; !! MAH @ SUMEX 2/75 !! LEAVE OLD DIDSC0 TO SIMPLIFY DISK ADDITIONS
;;;DIDSC0==<HITRK+LOTRK>/2*NSECTK	;PUT IN MIDDLE OF FILE AREA
DIDSC0==451520

DIDSCI:	DIDSC0+DSKABT
GS DIDSCA,1

NDVMAX=^D8		;MAX NUMBER OF DRIVES for Sumex !! MAH @ SUMEX 2/75 !!
			;HARD WIRED LIMITATION OF ^D8 DRIVES (IN DRIVTB AND 
			;IN UDSKIO)

DSKSIP=1B19		;SEEK IN PROGRESS, LH OF DSKSTS
DSKCMR=1B20		;COMMAND READY, LH OF DSKSTS
DSKUIO=1B21		;UDSKIO TYPE OPERATION, LH OF DSKSTS
DSKRCB=1B22		;RECALIBRATE IN PROGRESS

NDSKCM==10		;SIZE OF UDSKIO COMMAND BUFFER

;STATUS OF DRIVE IS RECORDED IN DSKSTS
; BITS 18 - 23 ARE ERROR COUNTER
; BITS 24 - 32 ARE CYLINDER AT WHICH DRIVE IS POSITIONED OR SEEKING
;LH BITS 13-17 ARE AN INDEX INTO THE UDSKIO COMMAND BUFFER
;DSKUIO BIT ON INDICATES UDSKIO TYPE OPERATION
; DSKRCB BIT ON INDICATES RECALIBRATE OPERATION IN PROGRESS
;STATE OF DRIVE IS INDICATED BY DSKSIP AND DSKCMR BITS IN LH
; 00 - NOTHING HAPPENING
; 10 - DRIVE SEEKING TRACK
; 01 - DRIVE POSITIONED, TRANSFER READY TO BE STARTED
; 11 - TRANSFER IN PROGRESS (ALSO USED WHEN REQUEST BEING UNQUEUED)

;STORAGE

LS DSKFCL,1		;FREE LIST FOR UDSKIO REQUEST PAIRS
LS DSKCCT,1		;COUNT OF UDSKIO REQUESTS
LS DSKCL,2*NDSKCM	;COMMAND BUFFER FOR UDSKIO REQUESTS
LS DSKLUN,1		;LAST UNIT XFERRING, -1 IF NO UNIT XFERRING
LS DSKCCM,2		;BUFFER FOR DF10 CHANNEL COMMAND

LS DSKQ,NDVMAX		;QUEUE FOR ALL SWAP IO REQUESTS

LS DSKUI,NDVMAX		;UTILITY QUEUE IN
LS DSKUO,NDVMAX		;UTILITY QUEUE OUT

LS DSKDAW,NDVMAX	;DISK ADDRESS FOR CURRENT OPERATION
LS DSKCAW,NDVMAX	;CORE ADDRESS AND COUNT FOR CURRENT OPERATION
LS DSKSTS,NDVMAX	;STATUS OF DRIVE,,CURRENT TRACK
LS DSKLSV,NDVMAX	;TIME WHEN CURRENT OPERATION IS OVERDUE

LS DSKSRQ,1		;SOFTWARE INTERRUPT REQUEST

LS DSKSVR,1		;INTERRUPT SERVICE RETURN
IFDEF RP02F,<		;!! MAH @ SUMEX 12/74 !!
LS DSKRSF,1		;LOST COMMAND RESTART FLAG
>

;DO NOT REORDER ERROR WORDS, USED BY GETAB

NDSKEW==^D10		;NUMBER OF ERROR WORDS FOR GETAB

LS DSKRCE,1		;COUNT OF RECOVERABLE ERRORS
LS DSKRER,4		;COMMAND WORDS AND ERROR BITS OF LAST ERROR
LS DSKNRE,1		;COUNT OF NON-RECOVERABLE ERRORS
LS DSKLER,4		;COMMAND WORDS AND ERROR BITS LAST NON-REC ERR

DSKNTR==^D5		;NUMBER OF TRIES ON RECOVERABLE ERRORS

UCMIPT:	POINT 5,DSKSTS(1),17	; POINTER TO UDSKIO COMMAND INDEX
ERRCPT:	POINT 6,DSKSTS(1),23	;POINTER TO ERROR RETRY COUNT
CTRKPT:	POINT 9,DSKSTS(1),32	; CURRENT TRACK

IFN SUMEX,<			;GETTAB TABLE FOR DSK PARMS
	INTERN	DSKTAB,DSKTSZ,NDVMAX
DSKTAB: LOTRK		;FIRST TRACK IN FILE SYSTEM
	HITRK		;LAST TRACK IN FILE SYSTEM
	DSKEND		;LAST SECTOR IN USE BY ANYTHING
	NWSEC		;NUM WORDS PER SECTOR
	NSECS		;NUM SECTORS PER ROTATION
	NSURFS		;NUM SURFACES PER DRIVE
	NTKUN		;NUM TRACKS PER UNIT
	NPACKS		;NUM PACKS IN FILE SYSTEM
	NDVMAX		;NUM DRIVES ON CONTROLLER
DSKTSZ==.-DSKTAB
> ;END IFN SUMEX

;DEVICE DEPENDENT CONSTANTS AND ROUTINES
;SOME ARE CALLED WITH PUSHJ, OTHERS ARE SINGLE INSTRUCTIONS EXECUTED
;WITH XCT

IFDEF RP02F,<		;DEC RP02 DRIVES

DSOIRQ:	CONSO DSK,1B32		;CONSO DSK INTERRUPT REQUEST

DSKPWF:	CONO DSK,175700+1B32	;CONO IN CASE OF POWER FAIL
	JRST DSKSV1

DSZERR:	CONSZ DSK,177760	;CONSZ ERROR CONDITIONS

DCLERR:	CONO DSK,175720+1B32+DSKCHN ;CONO CLEAR ALL ERROR CONDITIONS

DCLDNF:	CONO DSK,1B32+DSKCHN	;CONO CLEAR DONE FLOP

DRATT:	DATAI DSK,0		;READ ATTENTIONS TO AC0, B28-35

DSKPOS:	MOVE 2,DSKDAW(1)	;ISSUE POSITION (SEEK) REQUEST
	TLO 2,(4B2)		;UNIT NUMBER IN AC1, DSK ADR IN DSKDAW(1)
	DATAO DSK,2
	RET

DSKRCL:	MOVSI 2,(7B2)		;ISSUE RECALIBRATE (RESTORE) COMMAND
	DPB 1,[POINT 3,2,5]
	DATAO DSK,2
	RET

DCLATT:	CALL DCLAT1		;INST. TO CLEAR ATTENTIONS FOR DRIVE IN 1

DCLAT1:	MOVSI 2,(5B2)
	DPB 1,[POINT 3,2,5]
	IOR 2,BITS+^D27(1)
	DATAO DSK,2
	RET

DCKSEK:	DATAI DSK,2		;CALLED TO CHECK SEEK COMPLETE
	TLNN 2,(1B11)		;SKIP IF NO SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B14+1B16)	;SKIP NO PCI (GIVEN CONI BITS IN 0)

DSZSCF:	TRNE 0,1B21		;SKIP NO SEARCH FAILURE

DSZATN:	TDNE 0,BITS+^D27(1)	;SKIP IF ZERO ATTENTION

DUEATT:	RET			;UNEXPECTED ATTENTION (NOP FOR RP02)

;TEST EXISTENCE OF UNIT AND INIT

DIUNIT:	MOVEI 3,0(1)		;UNIT NUMBER
	ROT 3,-6		;CONSTRUCT NOP COMMAND
	TLO 3,(6B2)
	DATAO DSK,3		;ISSUE IT, SELECTING UNIT
	JFCL
	DATAI DSK,3		;GET BITS FOR THAT UNIT
	LDB 2,[POINT 3,3,2]	;GET UNIT NUMBER AS REPORTED
	CAIE 2,0(1)		;AGREES?
	BUG(HLT,<DSK - FAILED TO SELECT UNIT>)
	TLNN 3,(1B15)		;NO SUCH UNIT? OR
	TLNN 3,(1B13)		;NOT ON LINE?
	JRST [	SETOM DSKSTS(1)	;YES, PREVENT USE OF DRIVE
		RET]
	MOVEI 3,0(1)
	ROT 3,-6		;CONSTRUCT RECALIBRATE COMMAND
	TLO 3,(7B2)
	DATAO DSK,3		;ISSUE IT
	JFCL
DSKII2:	DATAI DSK,3		;CHECK STATUS OF DRIVE
	LDB 2,[POINT 8,3,10]	;TRACK
	TRNE 3,1B24		;TEST EXTRA BIT FOR RP03
	TRO 2,1B27
	JUMPN 2,DSKII2		;WAIT FOR TRACK 0
	TLNN 3,(1B12)		;AND 'ON CYLINDER'
	JRST DSKII2
	MOVEI 3,0(1)
	ROT 3,-6
	TLO 3,(5B2)		;CONSTRUCT CLEAR ATTENTIONS COMMAND
	IOR 3,BITS+^D27(1)
	DATAO DSK,3		;ISSUE IT
	SETZM DSKSTS(1)		;CLEAR STATUS AND SET TRACK TO 0
	RET

DMKHWA:	LSH 2,^D12		;CONVERT LOGICAL H'WARE ADR TO ACTUAL
	RET			;H'WARE FORMAT

DSKCYL:	POINT 8,DSKDAW(1),13	;POINTER TO CYLINDER ADDRESS

DSKWDA:	1B2+DSKCP			;WRITE DATA COMMAND BITS
DSKRDA:	0B2+DSKCP			;READ DATA COMMAND BITS
>	;END OF RP02 SECTION

IFDEF DC10F,<			;TELEFILE DC10 CONSTANTS AND ROUTINES

DSOIRQ:	JSP 1,.+1		;CONSO DSK REQUESTING
	CONSZ DSK,640777	;ERRORS, DONE, OR ATTENTIONS?
	CONSZ DSK,1B20		;AND NOT BUSY?
	JRST 0(1)		;NO
	JRST 1(1)		;YES

DSKPWF:	CONO DSK,0		;POWER FAIL - CLEAR PI
	JRST DSKSV1

DSZERR:	TDNE 0,[XWD 73700,440000] ;TEST ERRORS, IGNORE EOC

DCLERR:	CALL DCLER1		;DO NOP, CLEARS ALL ERROR FLOPS

DCLER1:	JSP 2,DWTCTL		;WAIT FOR CONTROL NOT BUSY
	MOVEI 2,1(1)		;DEVICE ADDRESS IS 1+LOGICAL UNIT
	LSH 2,^D9		;SHIFT TO POSITION FOR DATAO
;	IORI 2,0B22		;NOP COMMAND
	DATAO DSK,2
	RET

DCLDNF:	CALL [	JSP 2,DWTCTL	;CLEAR DONE FLAG
		DATAO DSK,[0]	;ANY DATAO DOES IT
		RET]

DRATT:	CONI DSK,0		;READ ATTENTIONS INTO 0

DSKPOS:	JSP 2,DWTCTL		;WAIT FOR CONTROLLER
	MOVE 2,DSKDAW(1)	;DSK AND CYLINDER
	IORI 2,3B22		;SEEK COMMAND
	DATAO DSK,2
	RET

DSKRCL:	JSP 2,DWTCTL		;WAIT FOR CONTROL
	MOVEI 2,1(1)		;DEVICE ADDRESS
	LSH 2,^D9		;SHIFT FOR DATAO
	IORI 2,2B22		;RECALIBRATE (RESET) COMMAND
	DATAO DSK,2
	RET

DCLATT:	CALL DCLER1		;CLEAR ATTENTIONS AND SELECT DRIVE

DCKSEK:	CONI DSK,0		;GET SELECTED DRIVE STATUS
	TLNN 0,(1B13)		;CHECK SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B0+1B1)	;CHECK PCI

DSZSCF:	TLNE 0,(1B7+1B8+1B9)	;CHECK SEARCH FAILURE

DSZATN:	CALL [	MOVEI 2,1	;SKIP IF ZERO ATTENTION
		LSH 2,0(1)	;COMPUTE BIT FOR DRIVE
		TDNN 0,2
		AOS 0(P)
		RET]

DUEATT:	JFCL			;UNEXPECTED ATTN (E.G. POWER ON)

DMKHWA:	MOVEI 2,0(2)		;CYL, SURF, AND SEC
	LSH 2,^D35-ADRPOS	;SHIFT FOR DATAO
	DPB 1,[POINT 4,2,26]	;DRIVE NUMBER
	ADDI 2,1B26		;PLUS 1 FOR DRIVE ADDRESS
	RET

;WAIT FOR CONTROL NOT BUSY

DWTCTL:	CONSO DSK,1B20		;CTL BUSY
	JRST 0(2)
	AOS NCTBSY		;COUNT CURRANCES
	JRST DWTCTL

LS NCTBSY,1

DSKCYL:	POINT NCYLBT,DSKDAW(1),9	;POINTER TO CYL IN H'WARE ADDRESS

DSKWDA:	6B22+DSKCP		;WRITE DATA COMMAND
DSKRDA:	4B22+DSKCP		;READ DATA COMMAND

;TEST UNIT FOR READY AND INIT

DIUNIT:	MOVEI 3,1(1)		;UNIT ADDRESS
	LSH 3,^D9
	CONO DSK,DSKCHN(3)	;SELECT IT
	CONI DSK,3		;GET DEVICE STATUS
	TLNE 3,(1B12+1B15)	;OFF LINE OR WRITE INHIBIT?
	JRST [	SETOM DSKSTS(1)	;YES, SET STATE TO OFFLINE
		RET]
	CALL DSKRCL		;ISSUE RECAL
	MOVEI 2,1		;COMPUTE BIT FOR DRIVE
	LSH 2,0(1)
	CONSO DSK,0(2)		;WAIT FOR ATTN
	JRST .-1
	CONI DSK,3
	TLNE 3,(1B13)		;SEEK INCOMPLETE?
	BUG(HLT,<DSKINI - SEEK INCOMPLETE ON RECAL>)
	MOVEI 3,1(1)
	LSH 3,^D9
	IOR 3,DSKRDA		;CONSTRUCT READ
	DATAO DSK,3		;DO 1-WORD READ TO CLEAR ATTN
	CONSZ DSK,1B20		;WAIT FOR DONE
	JRST .-1
	CONSZ DSK,0(2)		;ATTN NOW GONE?
	BUG(HLT,<DSKINI - XFER FAILED TO CLEAR ATTN>)
	SETZM DSKSTS(1)		;SET STATUS TO READY
	RET
>			;END DC10 SECTION

;DISK I/O DRIVER - CALLED FROM SWAPPER

DSKIO:	SKIPG DISKP
	JRST DRMIO		;NO DISK, USE DRUM
	PUSH P,1
	MOVE 4,CST1(1)		;GET DISK ADDRESS
	TLNN 4,10		;REGULAR DISK ADDRESS?
	JRST [	PUSH P,1	;NO, MUST BE SWAPPING ADDRESS
		MOVE 1,4
		CALL DSKIS	;CONVERT TO REGULAR DISK ADDRESS
		MOVE 4,1
		POP P,1
		JRST DSKI7]
DSKI7:	PUSH P,1
	MOVE 1,4		;DISK ADDRESS
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,4
	LDB 3,[POINT NCYLBT,1,17+NCYLBT]	;GET TRACK NUMBER
	TRNE 1,1B31		;TEST RP03 EXTRA BIT
	TRO 3,1B27	
	TLO 4,0(3)		;PUT IN LH OF LIST WORD
	HLRZ 1,1		;GET DRIVE NUMBER FOR INDEX
	HLOCKI DSKPI		;LOCK QUEUES
	MOVEI 3,CST3(4)		;ADD TO SWAP QUEUE
	EXCH 3,DSKQ(1)
	HRRI 4,0(3)
	MOVEM 4,@DSKQ(1)
	HULOCK DSKPI		;UNLOCK QUEUES
	OKPI
	SETO 3,
	CAMN 3,DSKSTS(1)	;DRIVE INITIALIZED?
	BUG(CHK,<DSKIO REQUESTED ON UNAVAILABLE DRIVE>)
	SETOM DSKSRQ		;NO, GO START THIS OPERATION
DSKIR:	POP P,1
	RET

;IF SWAPPING TO DISK, DISK ADDRESS DISGUISED AS DRUM ADDRESS

DSKIS:	SKIPE DRUMP		;REALLY SWAPPING ON DISK?
;;;	BUG(HLT,<DSKIO - BAD SWAP ADDRESS>)
	JFCL 0
	HRRZS 2,1		;LINEARIZE 'DRUM' ADDRESS
	ANDI 2,77		;SECTOR
	LSH 1,-6		;BAND
	IMULI 1,DRMSEC
	ADD 1,2
	CAIGE 1,DSKNOV		;IS IT VALID DSK ADDRESS
	BUG(HLT,<DSKIO - BAD SWAP ADDRESS>)
	SUBI 1,DSKNOV		;SUBTRACT OFF NUMBER OF PAGES NOT ON DISK
	IMULI 1,NSECPG		;TIMES SECTORS PER PAGE
	ADD 1,[DSKSWA]		;BEGINNING OF SWAP AREA
	RET

;PERIODIC CHECK OF DISK

DSKCHK:	MOVEI 1,^D1000		;DO IT ONCE PER SEC.
	MOVEM 1,DSKTIM
	MOVSI 1,-NDVMAX
DSKCH3:	SKIPE 2,DSKLSV(1)	;TIME SETUP ON THIS DRIVE?
	CAMLE 2,TODCLK		;AND PAST DUE?
	JRST DSKCH1		;NO
	SETO 2,
	CAME 2,DSKSTS(1)	;DRIVE UNINITIALIZED?
	JRST DSKCH4		;NO
;	CALL DIUNIT		;YES, TRY TO INIT IT
	MOVE 2,TODCLK
	ADDI 2,^D10000
	SKIPL DSKSTS(1)		;WAS INIT SUCCESSFUL?
	SETZ 2,			;YES, NO FURTHER CHECK
	MOVEM 2,DSKLSV(1)	;OTHERWISE CHECK AGAIN IN 10SEC.
	JRST DSKCH1

;!! MAH @ SUMEX 12/74 !! FOLLOWING CODE MODIFIED TO HANDLE LOST COMMAND
;RESTARTS BETTER
DSKCH4:	
IFNDEF RP02F,<
	BUG(HLT,<DISK OPERATION OVERDUE>)
> ;END IFNDEF
IFDEF RP02F,<
	BUG(NTE,<DISK OPERATION OVERDUE>)
	HRRM 1,DSKRSF	;FLAG RESTART ON THIS DRIVE
	ISB DSKCHN	;AND TELL DSKSV ABOUT IT
>
REPEAT 0,<		;THE FOLLOWING WAS INTENDED TO RESTART A DRIVE
			;FROM WHICH AN INTERRUPT HAD BEEN LOST, BUT
			;PECULIARITIES IN THE DC10 MAKE IT INADEQUATE
	MOVSI 2,DSKUIO		;GIVE ERROR COMPLETION FOR REQUEST
	TDNE 2,DSKSTS(1)	;IN PROGRESS
	JRST [	LDB 3,UCMIPT	; UTILITY OP
		MOVEI 2,-1	;RETURN -1 FOR NONSPECIFIC FAILURE
		MOVEM 2,DSKCL+1(3)
		JRST DSKCH2]
	CHNOFF DSKCHN
	CALL DSKEP1		;PROCESS 'UNREC' ERROR
	CHNON DSKCHN
DSKCH2:	CALL DIUNIT
>
DSKCH1:	AOBJN 1,DSKCH3
	RET

;UTILITY DISK I/O
; AC1/ HARDWARE DISK ADDRESS
; AC2/ BIT 13 - WRITE HEADER, BIT 14 - WRITE, BIT 15 - COMPARE CLASS
;      BITS 16-24 - CLASS, BITS 25-35 WORD COUNT
; AC3/ REAL CORE ADDRESS
;RETURNS +1 WITH ERROR BITS IN AC1 24-35 (0 IF NO ERRORS); IF NOT IN SCHED
; ELSE RETURNS +2 WITH POINTER TO COMMAND WORDS IN AC1 IF COMMAND WAS
; ACCEPTED, OR RETURNS +1 IF NOT ENOUGH COMMAND WORD PAIRS

UDSKIO:
UDSK3:	SOSGE DSKCCT		;COMMAND BUFFER FULL?
	JRST UDSK1		;YES, GO WAIT FOR ROOM
	NOSKD1
	HLOCKI DSKPI		;LOCK QUEUES
	MOVE 4,@DSKFCL		;GET A COMMAND PAIR
	EXCH 4,DSKFCL
	HULOCK DSKPI		;UNLOCK QUEUES
	OKPI
	HRLZM 1,0(4)		;STORE DISK ADDRESS LH OF FIRST WORD
	HRRZM 3,1(4)		;CORE ADDRESS RH OF SECOND WORD
	HRLM 2,1(4)		;WORD COUNT IN BITS 7-17
	MOVEI 3,0(4)
	SUBI 3,DSKCL		;INDEX FOR THIS PAIR
	TLNE 2,(1B14)		;READ OR WRITE?
	TROA 3,600000B46	;WRITE
	TRO 3,400000B46		;READ, B0 ALWAYS SET
	DPB 3,[POINT 7,1(4),6]	;TO BITS 0-6
	HLRZ 1,1		;DRIVE NUMBER
	ANDI 1,7
	SETO 3,
	HLOCKI DSKPI		;LOCK QUEUES
	HRRM 4,@DSKUI(1)	;APPEND TO UTILITY QUEUE
	HRRZM 4,DSKUI(1)
	HULOCK DSKPI		;UNLOCK QUEUES
	OKPI
	SETOM DSKSRQ		;SET REQUEST FLAG
	OKSKD1
	SKIPE INSKED		;IN SCHED?
	 JRST	[MOVE 1,4	;YES, RETURN POINTER TO COMMAND WORDS
		AOS (P)		;SKIP RETURN WHEN OK
		RET]
	MOVEI 1,DISGET		;SCHEDULER .GE. TEST
	HRLI 1,1(4)		;WILL TEST SECOND WORD OF PAIR
	JSYS SCHEDP
	NOSKED
	MOVE 1,1(4)		;ERROR BITS RETURNED HEREIN
UDSK4:	
	HLOCKI DSKPI		;LOCK QUEUES
	EXCH 4,DSKFCL		;RETURN PAIR TO FREE LIST
	MOVEM 4,@DSKFCL
	AOS DSKCCT
	HULOCK DSKPI		;UNLOCK QUEUES
	OKPI
	OKSKED
	RET

UDSK1:	AOS DSKCCT		;CORRECT COUNT
	SKIPE INSKED		;IN SCHED?
	 RET			;YES, SIMPLY TAKE ERROR RETURN
	PUSH P,1
	MOVEI 1,UDSK2
	JSYS EDISMS		;DISMISS TILL ROOM IN COMMAND LIST
	POP P,1
	JRST UDSK3

UDSK2:	SKIPG DSKCCT		;ROOM NOW?
	JRST 0(4)		;KEEP WAITING
	JRST 1(4)		;RUN

; UTILITY DISK OP WAIT FROM SCHED SIDE, RETURNS +1 IF COMMAND NOT DONE,
; RETURNS +2 WITH ERROR BITS IN 1 IF COMMAND FINISHED.  RELEASES
; COMMAND WORD PAIR WHEN FINISHED.

UDSKSW:	SKIPGE 2,1(1)		;COMMAND THROUGH YET?
	 JRST 0(4)		;NO
	HLOCKI DSKPI		;LOCK QUEUES
	EXCH 1,DSKFCL		;YES
	MOVEM 1,@DSKFCL
	AOS DSKCCT
	HULOCK DSKPI		;UNLOCK QUEUES
	OKPI
	MOVE 1,2		;PUT ERROR BITS IN 1
	JRST 1(4)		;OK RETURN

; UTILITY OP ROUTINE FOR TAKING THINGS OFF QUEUE

DSKRC3:	HRRZ 2,0(2)		;UNQUEUE
	JUMPN 2,.+3
	MOVEI 3,DSKUO(1)	;FIXUP ON END
	MOVEM 3,DSKUI(1)
	EXCH 2,DSKUO(1)
	MOVSI 3,DWRBIT+DSKUIO
	ANDCAM 3,DSKSTS(1)	;BITS
	HULOCK DSKPI		;UNLOCK QUEUES
	LDB 3,[POINT 5,1(2),6]	;DSKCL INDEX
	DPB 3,UCMIPT	 ;WHERE INTERRUPT ROUTINE CAN GET
	HLLZ 3,1(2)		;WORD COUNT
	TLZ 3,774000
	MOVNM 3,DSKCAW(1)	;TO LH OF CHANNEL WORD
	MOVE 4,1(2)		;CORE ADDRESS AND BITS
	HRRM 4,DSKCAW(1)	;STORE CORE ADDRESS
	MOVSI 3,DSKUIO		;SET UTILITY BIT IN ANY CASE
	TLNE 4,200000		;AND IF WRITE,
	MOVSI 3,DSKUIO+DWRBIT	;SET WRITE BIT TOO
	IORM 3,DSKSTS(1)	;YES
	HLRZ 2,0(2)		;DISK ADDRESS
	HRLI 2,0(1)		;INCLUDE UNIT
	JRST DSKRC4

;ROUTINE TO REMOVE REQUESTS FOR READ AND WRITE QUEUES AND
;INITIATE SEEK OPERATIONS
;CALLED AT MAIN AND INTERRUPT LEVEL WITH DRIVE NUMBER IN 1

DSKRCK:	
	HLOCK DSKPI		;LOCK QUEUES
	IORM 3,DSKSTS(1)	;SET BITS TO INDICATE UNQUEUEING IN PROG
	SKIPE 2,DSKUO(1)	;UTILITY QUEUE WAITING?
	JRST DSKRC3		;YES, IS FIRST PRIORITY
	SKIPN DSKQ(1)		;SWAP REQUESTS WAITING?
	JRST DSKRCC		;NO
	MOVEI 2,DSKQ(1)		;PTR TO QUEUE
	LDB 3,CTRKPT		 ;CURRENT TRACK
	CALL TRKSCH		;FIND NEAREST .GE. TRACK
	JRST [	SETZ 3,		;NONE .GE., SO RESET TO 0
		MOVEI 2,DSKQ(1)	;AND TRY AGAIN
		CALL TRKSCH
		JRST DSKRCC	;NONE, ALL MUST HAVE BEEN FLUSHED
		JRST .+1]
	HULOCK DSKPI		;UNLOCK QUEUES
	SUBI 2,CST3		;CONVERT BACK TO CORE PAGE NUMBER
	HLL 2,CST3(2)		;GET WRITE AND CLASS INFO
	MOVSI 3,DWRBIT+DSKUIO
	ANDCAM 3,DSKSTS(1)	;CLEAR BITS
	MOVSI 3,DWRBIT
	TLNE 2,DWRBIT		;WRITE BIT ON?
	IORM 3,DSKSTS(1)	;YES, PUT IT ON IN STATUS WORD
	MOVEI 3,0(2)
	LSH 3,^D9		;MAKE PAGE NUMBER INTO CORE ADDRESS
	HRLI 3,-1000		;WITH ONE PAGE WORD COUNT
	MOVEM 3,DSKCAW(1)	;LEAVE IT FOR TRANSFER STARTUP
	PUSH P,1
	MOVE 1,CST1(2)		;DISK ADDRESS
	TLNN 1,10		;REGULAR?
	CALL DSKIS		;NO, SWAPPING. CONVERT
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	MOVE 2,1
	POP P,1
DSKRC4:	CALL DMKHWA		;MAKE INTO HARDWARE FORMAT
	MOVEM 2,DSKDAW(1)	;LEAVE FOR OTHER ROUTINES
	SETZ 2,
	DPB 2,ERRCPT		;CLEAR ERROR COUNT BEFORE SEEK
	LDB 3,DSKCYL		;GET DESIRED CYLINDER
	MOVE 2,DSKDAW(1)	;GET EXTRA BIT FOR RP03
	TRNE 2,1B19
	TRO 3,1B27
	LDB 2,CTRKPT		 ;CYL DISK IS NOW AT
	DPB 3,CTRKPT		;SET NEW CURRENT TRACK
	CAMN 2,3		;NOW AT DESIRED TRACK?
	JRST [	CONSO PI,1B<DSKCHN+^D20> ;YES, ON PI LEVEL?
		JRST DSKSVX	;NO, GO START TRANSFER
		MOVSI 2,DSKSIP	;YES, SET STATE TO READY
		ANDCAM 2,DSKSTS(1) ;TRANSFER WILL BE STARTED BEFORE DBRK
		RET]
	MOVSI 2,DSKCMR		;CLEAR READY BIT
	ANDCAM 2,DSKSTS(1)
	MOVE 2,TODCLK
	ADDI 2,^D5000		;SET OVERDUE TIME FOR SEEK AS 5 SEC
	MOVEM 2,DSKLSV(1)	;FROM NOW
	JRST DSKPOS		;ISSUE SEEK AND RETURN

;SCAN FOR BEST OP TO DO NEXT
; 2/ QUEUE TO SEARCH
; 3/ CURRENT TRACK
; FIND ANY PAGE ON CURRENT TRACK, OR CLOSEST PAGE .G. CURRENT TRACK

TRKSCH:	PUSH P,1
	PUSH P,[400000]		;USED TO REMEMBER BEST DIFFERENCE FOUND
	PUSH P,[0]		;REMEMBERS PTR TO BEST PAGE FOUND
	PUSH P,3		;CURRENT TRACK
TRKS1:	HRRZ 3,0(2)		;2 ALWAYS HAS PTR TO PTR TO ITEM
	JUMPE 3,TRKSD		;END OF LIST
	MOVEI 1,0(3)
	SUBI 1,CST3		;GET PAGE NUMBER
	HLOCKI SWPPI
	MOVE 4,CST0(1)
	TLNE 4,(700B8)		;PAGE NOW IN USE?
	JRST [	HRRZ 4,0(3)	;YES, CANCEL IO. UNQUEUE PAGE
		HRRM 4,0(2)
		MOVSI 4,(CORMB)
		IORM 4,CST0(1)	;SET MODIFIED BIT
		PUSH P,2
		HULOCK SWPPI
		OKPI
		JSP 4,SWPDON
		POP P,2
		JRST TRKS1]
	HULOCK SWPPI
	OKPI
	HLRZ 3,0(3)		;GET TRACK
	ANDI 3,7777
	SUB 3,0(P)		;DIFFERENCE OF THIS AND CURRENT TRACK
	JUMPE 3,TRKSS		;SAME TRACK, CAN'T BE ANY BETTER
	JUMPL 3,TRKSN		;LOWER TRACK, NOT INTERESTED
	CAML 3,-2(P)		;BEST DIFFERENCE?
	JRST TRKSN		;NO
	MOVEM 3,-2(P)		;YES, SAVE DIFFERENCE
	MOVEM 2,-1(P)		;SAVE PTR
TRKSN:	HRRZ 2,0(2)		;CDR
	JRST TRKS1

TRKSD:	MOVE 4,-2(P)
	CAIL 4,400000		;FOUND ANY PAGE?
	JRST TRKSX		;NO
	MOVE 2,-1(P)		;YES, GET PTR
TRKSS:	HLOCKI SWPPI
	HRRZ 3,0(2)		;UNQUEUE PAGE
	HRRZ 4,0(3)
	HRRM 4,0(2)
	MOVEI 2,0(3)
	HULOCK SWPPI
	OKPI
	AOS -4(P)		;RETURN SKIP
TRKSX:	SUB P,BHC+3		;FLUSH TEMPS
	POP P,1
	RET

DSKRCC:	HULOCK DSKPI		;UNLOCK QUEUES
	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)	;SET DRIVE TO IDLE STATE
	RET

;DISK INTERRUPT SERVICE

	INTERN DSKSV

DSKSV:	XWD DSKSVR,.+1
; CODE ADDED FOR RP03'S TO HANDLE LOST (OVERDUE) COMMANDS
IFDEF RP02F,<			;!! MAH @ SUMEX 12/74 !!
	SKIPE 1,DSKRSF		;AN OVER DUE INTERRUPT?
	 JRST	[		;YES
	IFN KIFLG,<CLSB DSKCHN>	;(FOR KI'S EXPLICITLY TURN OFF INT BIT)
		MOVE 0,[1B21+1B13] ;FAKE SEARCH ERROR (TO FORCE RECAL)
		JRST DSKERR]	;TREAT AS ERROR
> ;END RP02F
	CLSB DSKCHN
	SKIPGE DSKLUN
	JRST [	SKIPL DSKSRQ 	;SOFTWARE REQUEST
		JRST .+1	;NO SOFTWARE REQUEST
		JRST DSKSV7 ]
	XCT DSOIRQ		;DISK REQUESTING?
	JRST @DSKSVR		;NO
DSKSV7:	
	SETZM DSKSRQ
	CONI DSK,0		;GET ALL BITS
	SKIPE PWRDWN		;PWR FAIL?
	JRST DSKPWF		;YES, CLEAR DSK
	SKIPGE 1,DSKLUN		;WAS A DRIVE TRANSFERRING?
	JRST DSKSV2		;NO
	XCT DSZERR		;ERROR?
	JRST DSKERR		;YES
	MOVSI 2,DSKSIP+DSKCMR	;XFER FINISHED
	ANDCAB 2,DSKSTS(1)	;SO CLEAR ALL BITS FOR THAT DRIVE
	SETZM DSKLSV(1)		;RESET OVERDUE ALARM
	TLNE 2,DSKUIO		;UTILITY OP?
	JRST DSKSVU		;YES
	HRRZ 1,DSKCAW(1)	;GET CORE ADDRESS JUST FINISHED
	LSH 1,-^D9		;PAGE NUMBER
	JSP 4,SWPDON		;NOTE XFER COMPLETED
DSKSV2:	
;  CODE TO HANDLE LOST COMMANDS
IFDEF RP02F,<			;!! MAH @ SUMEX !! 12/74
	TLNE 0,(1B13)		;LOST COMMAND (SOFTWARE INTERRUPT)?
	JRST   [SETZM DSKRSF	;YES, CLEAR LOST COMMAND FLAG
		SKIPL DSKLUN	;AND CONTROLLER BUSY?
	 	JRST DSKSV1	;YES, DONT BOTHER LOOKING FOR MORE WORK
		JRST .+1]
>
	XCT DRATT	;READ ATTENTION BITS INTO AC0, B28-35
	MOVSI 1,-NDVMAX
DSKSV6:	MOVSI 3,DSKSIP+DSKCMR
	XCT DSZATN		;SEEK COMPLETE ON THIS DRIVE?
	JRST DSKSV4		;YES
	TDNN 3,DSKSTS(1)	;THIS DRIVE FREE?
	CALL DSKRCK		;YES, SEE IF ANY WAITING REQUESTS
DSKSV5:	AOBJN 1,DSKSV6		;CHECK ALL DRIVES
	AOS 1,DSKLUN		;START WITH NEXT UNIT, OR 0 IF NONE
	HRLI 1,-NDVMAX
DSKSV3:	MOVEI 2,0(1)
	CAIL 2,NDVMAX
	HRRI 1,0		;WRAPAROUND DRIVE NUMBER
	MOVE 3,DSKSTS(1)
	TLNE 3,DSKCMR		;COMMAND READY AND NO SEEK IN PROGRESS?
	TLNE 3,DSKSIP
	JRST [	AOBJN 1,DSKSV3	;NO, CHECK NEXT DRIVE
		SETOM DSKLUN	;ALL DRIVES CHECKED, NONE XFERRING
		XCT DCLDNF	;CLEAR DONE FLAG
		 IFDEF DC10F,<
		 XCT DSOIRQ	;NEW ATTENTIONS APPEARED?
		 JRST DSKSV1	;NO
		 JRST DSKSV2>	;YES, MUST SERVICE NOW CAUSE PI CLRD
		JRST DSKSV1]	;GO DEBREAK
;;; THESE LINES ERRONEOUSLY PREVENT ERROR COUNTER FROM BEING INCREMENTED
;;; ON ERRORS (SEARCH ERRORS) THAT FORCE A RECAL.  ERRCPT ZEROED IN DSKRCK
;;; ANY HOW  !! MAH @ SUMEX 12/74 !!
;;;	SETZ 2,
;;;	DPB 2,ERRCPT		;CLEAR ERROR COUNT
	CALL DSKSVX		;START TRANSFER
DSKSV1:	
	UNBRK DSK		;DEBREAK

;ROUTINE TO START XFER ON READY DRIVE

DSKSVX:	MOVSI 3,DSKSIP+DSKCMR
	IORB 3,DSKSTS(1)	;SET STATE TO XFER IN PROGRESS
	MOVE 2,TODCLK
	ADDI 2,^D1000		;SET OVERDUE ALARM FOR 1 SEC.
	MOVEM 2,DSKLSV(1)
	MOVE 2,DSKCAW(1)	;CORE ADDRESS AND COUNT
	HRRI 2,-1(2)		;LIKE IOWD, ADDRESS IN 1 LESS
	MOVEM 2,DSKCCM		;FIXED LOCATION FOR CHANNEL COMMAND
	MOVE 2,DSKDAW(1)	;DISK ADDRESS
	TLNE 3,DWRBIT		;READ OR WRITE?
	TDOA 2,DSKWDA		;WRITE, CONSTRUCT COMMAND
	TDO 2,DSKRDA		;CONSTRUCT READ COMMAND
	PIOFF
	DATAO DSK,2		;START XFER
	HRRZM 1,DSKLUN		;REMEMBER NUMBER OF DRIVE XFERRING
	PION
	RET

;FOUND ATTN BIT FOR DRIVE

DSKSV4:	XCT DCLATT		;CLEAR ATTENTIONS
	MOVSI 3,DSKSIP
	XOR 3,DSKSTS(1)
	TLCE 3,DSKSIP+DSKCMR	;WAS SEEK IN PROGRESS?
	JRST DSKSC1		;NO
	TLNE 3,DSKRCB		;WAS RECALIBRATE COMMAND?
	JRST [	MOVSI 3,DSKRCB	;YES, CLEAR BIT
		ANDCAM 3,DSKSTS(1)
		CALL DSKPOS	;ISSUE NEW SEEK COMMAND
		JRST DSKSV5]
	CALL DCKSEK		;SKIP NO SEEK INCOMPLETE
	JRST DSKSKE
DSKSK1:	MOVSI 3,DSKSIP+DSKCMR
	XORM 3,DSKSTS(1)	;CHANGE STATE TO COMMAND READY
	JRST DSKSV5

DSKSC1:	TLNE 3,DSKSIP+DSKCMR	;WAS IN COMMAND READY STATE?
	CALL DUEATT		;NO, UNEXPECTED
	JRST DSKSV5		;IGNORE IT

DSKSKE:	LDB 3,ERRCPT		;GET RETRY COUNT
	ADDI 3,1
	CAILE 3,DSKNTR		;UNRECOVERABLE?
	JRST DSKSK1		;YES, TRY XFER ANYHOW
	DPB 3,ERRCPT
	MOVSI 3,DSKRCB		;SEEK INCOMPLETE, TRY RECAL
	IORM 3,DSKSTS(1)
	CALL DSKRCL
	JRST DSKSV5

DSKUER:	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)
	TLZA 0,400000		;RETURN ERROR BITS (B0 SHOULD BE OFF)
DSKSVU:	SETZ 0,			;0 MEANS NO ERRORS
	LDB 3,UCMIPT		; GET COMMAND INDEX
	MOVEM 0,DSKCL+1(3)	;WORD GOING POSITIVE INDICATES DONE
	AOS PSKED		;SIG SCHED
	JRST DSKSV2

;DISK ERROR

	INTERN DSKERR

DSKERR:	XCT DCLERR		;CLEAR ALL ERROR CONDITIONS
	MOVE 3,DSKDAW(1)	;SAVE ERROR WORDS
	MOVEM 3,DSKRER
	MOVE 3,DSKCAW(1)
	MOVEM 3,DSKRER+1
	MOVE 3,DSKSTS(1)
	MOVEM 3,DSKRER+2
	MOVEM 0,DSKRER+3	;AND ERROR BITS
	AOS DSKRCE		;COUNT REC ERRORS
	LDB 3,ERRCPT		;RETRY COUNT
	ADDI 3,1
	DPB 3,ERRCPT
	CAIN 3,1		;FIRST ERROR?
	 CALL DSKEL1		;YES, SEE IF WE SHOULD RECORD ERROR
	CAILE 3,DSKNTR		;UNRECOVERABLE?
	JRST DSKERP		;YES
DSKER2:	XCT DSZSCF		;SKIP NO SEARCH FAILURE
	JRST DSKER3		;SEARCH FAILED, TRY RECALIBRATE
	CALL DSKSVX		;START XFER OVER AGAIN
	JRST DSKSV1		;DEBREAK

DSKER3:	MOVSI 3,DSKCMR+DSKRCB	;SET STATE TO RECAL IN PROGRESS
	XORM 3,DSKSTS(1)
	CALL DSKRCL		;INITIATE RECAL
	JRST DSKSV2		;CONTINUE PROCESSING INTERRUPTS

;UNRECOVERABLE ERROR

DSKERP:	XCT DSZPCI		;SKIP NO PCI ERROR
	JRST [	MOVE 3,[SIXBIT /DSKPAK/]
		MOVEM 3,DEVMPE	;YES, REQUEST CORE SCAN
		ISB APRCHN
		JRST DSKER2]	;TRY AGAIN
IFDEF RP02F,<			;!! MAH @ SUMEX 5/75 !!
	CAIGE	1,NPACKS	;DON'T WORRY IF NOT IN FILE SYS
	TDNN 0,[1B13+1B25]	;DISK OP OVER DUE OR DISK NOT READY?
	 JRST DSKEP2
	BUG(CHK,<DSKPAK: PERMANENT DISK OP OVER DUE ERROR>)
	SETZ 3,
	DPB 3,ERRCPT		;ZERO ERRCT TO TRY 5 MORE TIMES
	JRST DSKER3		;RECAL RESTART
DSKEP2:
> ;END IFDEF RP02F
	MOVE 3,DSKDAW(1)	;GET HARDWARE ADDRSS
	SETZM DSKLSV(1)		;RESET OVERDUE ALARM
	MOVNI 3,DSKNTR
	ADDM 3,DSKRCE		;REMOVE FROM RECOVERABLE COUNT
	AOS DSKNRE		;COUNT IRRECOVERABLE
	MOVE 3,[XWD DSKRER,DSKLER]
	BLT 3,DSKLER+3		;SAVE COMMAND WORDS
	MOVSI 3,DSKUIO
	TDNE 3,DSKSTS(1)	;UTILITY OP?
	JRST DSKUER		;YES
	HRRZ 2,DSKCAW(1)	;GET PAGE NUMBER
	LSH 2,-^D9
	CALL DSKEP1		;CLEAN UP
	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)
	JRST DSKSV2

DSKEP1:	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;NOTIFY SWAPPER OF ERROR
	MOVE 3,CST2(2)		;FIND OUT WHAT PAGE IS
	TLNN 3,-1		;FROM SPT?
	JRST [	CAIL 3,NOFN	;YES, OFN?
		HLRZ 3,SPTH(3)	;NO, GET OFN
		JRST DSKXX3]
	HLRZ 3,3
DSKXX3:	CAIL 3,1		;SENSITIVE FILE? I.E. DI OR DIRECTORY?
	CAILE 3,NFDIB+3
	JRST .+2
	BUG(CHK,<DISK ERROR IN SENSITIVE PAGE>)
	PUSH P,1
	MOVE 1,2		;CORE PAGE NUMBER
	JSP 4,SWPDON		;NOTIFY SWAPPER OF COMPLETION
	POP P,1
	RET

DSKAGN:	SUB P,BHC+1		;REMOVE US FROM DSKEP1 ROUTINE
	MOVSI 3,SWPERR		;REMOVE PERMANENT ERROR BIT
	ANDCAM 3,CST3(2)
	DPB 3,ERRCPT		;ZERO ERROR COUNT FOR 5 RETRYS
	JRST DSKER3		;RECAL RESTART
	SUBTTL	DSKERL - DISK ERROR RECORDING HANDLER

; FIRST ERROR, RECORD ERROR STATUS BITS, TELL SCHED TO WRITE OUT "BAD" PAGE

DSKEL1:	AOSE DDERLL		;GET DDER CODE
	 POPJ P,		;COULDN'T GET IT

	PUSH P,3
	MOVSI 3,DSKUIO		;UTILITY OP?
	TDNE 3,DSKSTS(1)
	SKIPA 3,[3B8+@DSKUTD]	;YES
	MOVE 3,[2B8+@DSKSWD]	;NO
	MOVEM 3,DDERTP		;IDENTIFY OURSELVES - ON THE LOGGING FILE

 	MOVE 3,[DSKRCE,,DDERWD] ;SAVE ERROR WORDS
	BLT 3,DDERWD+4
	POP P,3

	TDNN 0,[1B14+1B15+1B16+1B17+1B22+1B24] ;RECORD ON THESE ERRORS
				;CHAN CTRL WD P.E., DISK SECT P.E.,
				;CHAN DATA WD P.E., DISK WD P.E.,
				;CHAN SLOW, ANY P.E.
	 JRST  [SETOM DDERST	;NO, TELL JOB 0 TO LOG ERROR WORDS
		SETOM DDERBP	;SAY NO DATA PAGES WITH THIS ERROR
		AOS JB0FLG	;AND GET JOB 0 IN TO LOOK AT IT
		RET]

	HRRZ 3,DSKCAW(1)	;GET CORE PAGE ADDRESS
	MOVEM 3,DDERST		;AND USE IT TO TURN SCHED LEVEL ON

	MOVSI 3,DSKSIP+DSKCMR	;UNQUE COMMAND AND RETURN TO DSK SERVER
	ANDCAM 3,DSKSTS(1)
	SETZM DSKLSV(1)		;ZERO LOST COMMAND TIMER
	SUB P,BHC+1
	JRST DSKSV2

; THE FOLLOWING ROUTINES ARE DEVICE DEPENDENT ROUTINES CALLED FROM SCHED
; LEVEL THROUGH THE OPERATION TYPE (SWAPPER, UTILITY OP) DEPENDENT
; DISPATCH TABLES

; SWAPPER ROUTINES DISPATCH TABLE

DSKSWD:	JRST DSKEL2		;REQUE COMMAND
	JRST UDSKSW		;TEST FOR SCHED LEVEL UDSKIO COMPLETION
	JRST DSKEL3		;HANDLE PERMANENT ERROR
	JRST DSKEL4		;HANDLE SUCCESSFULL COMPLETION

; UTILITY OP ROUTINES DISPATCH TABLE

DSKUTD:	JRST DSKEL2		;REQUE COMMAND
	JRST UDSKSW		;TEST FOR SCHED LEVEL UDSKIO COMPLETION
	JRST DSKEL6		;HANDLE PERMANENT ERROR
	JRST DSKEL5		;HANDLE SUCCESSFUL COMPLETION

; REQUE DISK READ AFTER BAD DATA HAS BEEN COPIED

DSKEL2:	MOVE 1,DSKEDA		;GET DISK HARDWARE ADDRESS FROM ERROR WORDS
	LSH 1,-^D12		;CONVERT TO INTERNAL HARDWARE FORMAT 
	MOVEI 2,1000		;GET READY TO REQUE A READ
	MOVE 3,DDERST		;CORE ADDRESS
	JRST UDSKIO		;QUEUE UP OP

; ON PERMANENT ERROR FINISH OF SWAPPER INITIATED READ, NOTIFY SWAPPER

DSKEL3:	MOVE 2,DDERST
	LSH 2,-^D9
	PUSH P,4		;CHANGE JSP INTO PUSHJ
	JRST DSKEP1		;RECORD PERMANENT ERROR

; ON GOOD FINISH OF SWAPPER INITIATED READ, NOTIFY SWAPPER

DSKEL4:	MOVE 1,DDERST
	LSH 1,-^D9
	JRST SWPDON

; ON GOOD FINISH OF UTILITY READ, NOTIFY COMMAND WORDS
	
DSKEL5:	SETZ 1,				;SAY, NO ERRORS

; ON PERMANENT ERROR FINISH OF UTILITY READ, NOTIFY COMMAND WORDS

DSKEL6:	LDB 3,[POINT 5,DSKEUT,17]	;GET UTILITY COMMAND WORD INDEX
	MOVEM 1,DSKCL+1(3)		;SET IN ERROR BITS
	JRST (4)

;DISK DRIVER INITIALIZATION

	INTERN DSKINI,DSKRST

DSKINI:	IFNDEF DRMCHN,<CALL DRMINI> ;INIT SWAP BIT TABLE
DSKRST:	SETOM DSKLUN
	SKIPN DISKP
	RET
	SETOM DSKBLK
	MOVEI 1,DSKCL+2*NDSKCM-2
	SETZM 0(1)		;END OF LIST
	MOVEM 1,-2(1)		;INIT UTILITY FREE LIST
	SUBI 1,2
	CAILE 1,DSKCL
	JRST .-3
	MOVEM 1,DSKFCL
	MOVEI 1,NDSKCM
	MOVEM 1,DSKCCT		;INIT UTILITY COMMAND FREE COUNT
	MOVEI 1,DSKCCM
	MOVEM 1,DSKCP		;INITIAL COMMAND WORD FOR CHANNEL
	MOVSI 1,-NDVMAX		;FOR EACH UNIT, DO:
DSKII1:	SETZM DSKQ(1)
	MOVEI 2,DSKUO(1)	;INIT UTILITY QUEUE
	MOVEM 2,DSKUI(1)
	CALL DIUNIT		;INIT UNIT
DSKII3:	AOBJN 1,DSKII1
	CONO DSK,DSKCHN		;GIVE IT IT'S PI ASSMT
	RET

;RELOAD RES MON, CALLED FROM SYSGO

PPRMPX==170		;IN PLACE OF PPRMPG FOR KI
RLRMA==3000		;RUN LOCATION OF RELOAD ROUTINE
RLRCA==36		;FIRST CORE LOCATION RESTORED

RLRMON:	MOVE 1,[XWD RLMX0,RLRMA]
	BLT 1,RLRMA+777		;MOVE RELOAD ROUTINE TO RUN LOCATION
	JRST RLMGO		;IT RELOADS AND STARTS MON

IFDEF RP02F,<		;BOOT ROUTINE FOR RP02

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPX,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20		;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI 1,20
	HRRI 1,21
	BLT 1,777
	MOVEI 7,100		;SETUP RETURN TO DDT WHEN LOADED
RLMGO:	MOVSI 10,-PPRMPX+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE 1,RLMC5(10)	;DISK ADDRESS
	LSH 1,^D12
	TLO 1,(4B2)
	DATAO DSK,1		;POSITION HEADS
	ROTC 2,^D72		;DELAY SEEMS NECESSARY HERE
RLMG1:	DATAI DSK,2
	TLNN 2,(1B11)		;ERROR?
	TLNN 2,(1B13)		;OR NOT ON LINE?
	JRST 4,RLMGO		;YES
	TLNN 2,(1B12)		;ON CYL?
	JRST RLMG1		;NO, WAIT
	CONO DSK,1B32		;CLEAR DONE
	MOVEI 2,-1(11)		;CONSTRUCT CHANNEL COMMAND
	HRLI 2,-1000		;TRANSFER ONE PAGE
	MOVEM 2,RLMNB
	SETZM RLMNB+1		;ONE WORD CHAN PGM
	MOVEI 2,RLMNB
	MOVEM 2,DSKCP		;INITIAL CHANNEL LOC
	TLZ 1,(7B2)		;READ COMMAND = 0
	IORI 1,DSKCP		;CONSTRUCT READ COMMAND
	DATAO DSK,1		;ISSUE READ
	CONSO DSK,1B31		;WAIT TILL BUSY OFF AND DONE ON
	CONSO DSK,1B32
	JRST .-2
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)		;RETURN

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END RP02F

IFDEF DC10F,<		;BOOT ROUTINE FOR DC10

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

DCBSY==1B20		;DC10 BUSY FLAG

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPX,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20	;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI 1,20
	HRRI 1,21
	BLT 1,777
	MOVEI 7,100	;SET UP RETURN TO DDT

RLMGO:	MOVEI 11,RLMNB	;SET UP DF10 CMD POINTER
	MOVEM 11,DSKCP
	MOVSI 10,-PPRMPX+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE 1,RLMC5(10)	;DISK ADDRESS
	HLRZ 2,1	;FORM REAL HARWARE DISK ADR
	ADDI 2,1	;UNIT IN 2 +1 (CONTROLLER IS 0)
	HRRZS 1
	LSH 1,^D35-ADRPOS
	LSH 2,^D9
	IOR 1,DSKRDA	; MAKE READ COMMAND
	IORI 1,(2)	;COMPLETE HARDWARE ADR
	JSR RWDSK	;CORE ADR IN 11, DISK DATAO IN 1
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)	;RETURN

;STAND ALONE DISK DRIVER FOR RELOADING MONITOR OFF DISK, AND FOR 
;WRITING CRASH COPY OF MONITOR TO CRASH AREA OF DISK.  AC2,3 SCRATCH
;	1=DATAO WORD FOR DISK
;	11=CORE ADDRESS
;	JSR RWDSK

RWDSK:	0
	MOVEI 2,0(11)
	ANDI 2,777
	SUBI 2,1000	;-WDCNT FOR PARTIAL OR COMPLETE PAGE
	HRLI 2,-1(11)	;XWD ADR-1, -WDCNT	(BACKWARDS IOWD)
	MOVSM 2,RLMNB	;IOWD TO CHANNEL CMD LOCATION
RWDSK3:	MOVEI 3,DSKNTR	;NO. OF RETRIES IF ERROR
RWDSK1:	MOVE 2,1	;DISK CMD WORD
	ANDI 2,17000	;JUST GET UNIT
	CONO DSK,DSKCHN(2)	;SELECT THE UNIT
	CONI DSK,2	;AND READ ITS STATUS
	TLNE 2,(1B12+1B14+1B15)	;OFF LINE, UNSAFE, OR WRITE PROTECTED?
	HALT RWDSK1	;YES, HALT. CLEAR HALT TO TRY AGAIN
	DATAO DSK,1	;START XFER
	CONSZ DSK,DCBSY	;WAIT FOR CONTROLLER BUSY STATE TO RESET
	JRST .-1
	CONSO DSK,640000	;ERRORS?
	JRST @RWDSK	;NO, JUST RETURN
	SOJG 3,RWDSK1	;YES, TRY AGAIN
	HALT RWDSK3	;HARD ERROR, CLEAR HALT TO RETRY

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END DC10F

RLRMSZ==400	;MINIMUM SIZE BECAUSE TENDMP CAN'T LOAD 1 BLOCK FILES
	IFG <RLRMX1-RLMX0-RLRMSZ>,<RLRMSZ==RLRMX1-RLMX0>
	IFG <RLRMSZ-1000>,<PRINTX <RELOAD MONITOR ROUTINE EXCEEDS 1 PAGE - CODE WON'T WORK>>

;CONVERT LINEAR ADDRESS TO HARDWARE DISK ADDRESS

CVDSK:	TLZ 1,DSKMSK		;FLUSH EXTRA BITS
	IDIVI 1,NSECTK		;GET TRACK, SECTORS
	PUSH P,2
	IDIVI 1,NTKUN		;GIVES DRIVE NO IN 1, TRACK IN 2
	LSH 2,^D18-NCYLBT	;TRACK TO BITS 18-XX
	TLZE 2,1		;TEST EXTRA BIT FOR RP03
	TRO 2,1B31
	HRL 2,DRIVTB(1)		;PHYS. DRIV NO FOR TRK GROUP TO B15-17
	POP P,1
	PUSH P,2
	IDIVI 1,NSECS		;GET SURFACE, SECTOR
	LSH 1,NSECBT		;SURFACE TO B26-30
	IORI 1,0(2)		;WITH SECTOR IN B31-35
	POP P,2			;RECOVER DRIVE AND TRACK
	IOR 1,2			;MERGE ALL FIELDS
	RET

;CONVERT HARDWARE FORMAT TO LINEAR ADDRESS

CDSKVA:	HLRZ 2,1		;15-17 IS DRIVE
	ANDI 2,7
	HLRZ 3,DRIVTB(2)	;GET CORRESPONDING TRACK GROUP NO
	IMULI 3,NTKUN		;FIRST OF THIS GROUP OF TRACKS
	LDB 2,[POINT NCYLBT,1,17+NCYLBT]	;18-25 IS TRACK ON SPECIFIED DRIVE
	TRZE 1,1B31		;TEST EXTRA RP03 BIT
	TRO 2,1B27
	ADDI 3,0(2)		;NOW HAVE ACTUAL TRACK NUMBER
	IMULI 3,NSECTK		;COMPUTE SECTOR NUMBER
	LDB 2,[POINT 5,1,35-NSECBT]	;26-30 IS SURFACE
	IMULI 2,NSECS		;FIRST SECTOR THIS SURFACE
	ANDI 1,<1_NSECBT>-1	;31-35 IS SECTOR
	ADDI 1,0(2)		;TOTAL SECTORS
	ADD 1,3
	RET

; TABLE OF HOME BLOCKS (TEMPORARY UNTIL MOUNTABLE PACKS ARE DONE)

QQ==0
HOME:	REPEAT NPACKS,<
	<QQ>B17+<HOMCY1>B<^D17+NCYLBT>+<HOMSF1>B<^D17+NCYLBT+5>+HOMSC1
	<QQ>B17+<HOMCY2>B<^D17+NCYLBT>+<HOMSF2>B<^D17+NCYLBT+5>+HOMSC2
QQ==QQ+1
>
NHOME==.-HOME

;TABLE FOR CONVERSION BETWEEN PHYSICAL DRIVE NUMBERS AND INTERNAL
;TRACK GROUPS NUMBERS.  INDEXED BY INTERNAL, RH GIVES PHYSICAL.
;INDEXED BY PHYSICAL, LH GIVES INTERNAL

DRIVTB::XWD 0,0
	XWD 1,1
	XWD 2,2
	XWD 3,3
	XWD 4,4
	XWD 5,5
	XWD 6,6
	XWD 7,7

	END






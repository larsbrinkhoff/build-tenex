;<MON>I4.MAC;11    21-JUN-77 14:26:35    EDIT BY SWEER
; removed heavy logic plus parrd/parst
;<MON>I4.MAC;10    21-JUN-77 12:19:19    EDIT BY SWEER
; REMOVED .LKPG JSYS AND FKWKWT TABLE
;<MON>I4.MAC;9     2-MAY-77 10:36:38    EDIT BY SWEER
; added nicksv for handling Nick's special clock
;<MON>I4.MAC;8    25-APR-77 16:20:25    EDIT BY SWEER
;CHECK USE OF LKPG JSYS
;<MON>I4.MAC;5    25-APR-77 16:11:33    EDIT BY SWEER
; INSERTED 1ST GO AT PC SAMPLING CODE
;REMOVED GDTYPE SUB - NOT USED AT SUMEX
;	6/28/73--ILLIAC-4 ROUTINES AND JSYS


	SEARCH PROLOG,FILEDEF
	TITLE I4

	INTERN RESERV
	INTERN ISKPOT,ISKIN1,ISKIN2
	INTERN ISKOVF,ISKTCK,ISKDMS,JOBLIM
	INTERN .ASPTY,.REPTY,.PSTI,.PSTO,.SIBF,.STCHA


	EXTERN STOPLK

	EXTERN TTSTI1,BHC,CLTTST,REMOLO
	EXTERN SETJFK,RFSTSA,SKIIF,FKPTAB
	EXTERN DSKCL4,DSKCL1,DELDEL,ACCCHK,USTDIR
	EXTERN SAVRT,BALSET,NBW,ISKCLK
	EXTERN DBUGSW,DDTPRS,DCHKSW
	EXTERN SWHLT,MEMCHK
	EXTERN INSKED,TADSEC,TODCLK,TADDAY,CRSTD1
	EXTERN SYSGO,BUGTYO,BUGMSG,EXBUGH,SWPCOR,TOTRC
	EXTERN JB0FLG
	EXTERN CHKTTY,INSKED,MMSPTN,SWPERR
	EXTERN TTBIGI,TTCH7X,SKMRTN
	EXTERN JOBNO,JOBPT,JOBDIR
	EXTERN WHEELX,FPTA,MLKPG,MONCOR,MULKPG,NOFN
	EXTERN RELMPG,RELCPT,SETCPT,SETPT,JFNOFN
	EXTERN FORKX,FKWSP,FKJOB,FKSTAT,FKPGST,FKPT
	EXTERN MENTR,MRETN,ITRAP,ITRAP1,EDISMS
	EXTERN DISLT,DISLET,DISGET,DISGT,DISMT,QNTDM1
;I4 ROUTINE TO DO MONTE CARLO SAMPLING OF THE PC

;WHEN SPYING, THIS ROUTINE IS CALLED ONCE A MS TO COLLECT
;DATA ON WHERE THE CPU IS SPENDING IT'S TIME. IT IS STARTED BY
;SETTING LOCATION SPYING: TO -1 VIA MDDT. THE DEFAULT PARAMETERS
;ARE TO SAMPLE THE PC EVERY 20MS TO GET 10000 SAMPLES. BARRING
;ANY STRANGENESSES, THAT SHOULD TAKE APPROXIMATELY 3 MINUTES
;AND 20 SECONDS. WHEN THROUGH THE SAMPLING STOPS ITSELF AUTOMATICALLY
;LEAVING THE DATA THERE ACCESSIBLE THROUGH A GETTAB. RESTARTING
;THE RUN CAUSES THE DATA BASE TO BE RE-INITIALIZED AND ALL GOOD
;THINGS. THE DEFAULTS MAY BE CHANGED BY DIDDLING THE APPROPRIATE
;VARIABLE DEFINED BELOW.

IFN SUMEX,<

	INTERN	SPY,SPYTAB,SPYSIZ,SPYING,NICKSV
	EXTERN	RJAV,PIAPRX

	RESCD

CLK2==74			;IO BUS ADDR OF NICK'S CLOCK

NICKSV:	0			;JSR HERE FROM KIEPT+42(FOR PI 1)
	CONSO	CLK2,10		;SKIP IF PI REQ ON FOR THIS DEVICE
	JEN	@NICKSV		;WASN'T, IGNORE WHATEVER IT WAS
	JSR	SPY		;ACCUMULATE STATS
	CONO	CLK2,0		;TURN OFF CLOCK PRIOR TO EXIT
	SKIPE	SPYTOT		;SKIP IF NO MORE SAMPLING TO DO
	CONO	CLK2,11		;REENABLE ON PI LEVEL 1
	JEN	@NICKSV
;TO CALL SPY FROM PI LEVEL 3 IN PISRV SET LOCATION SPYING TO
;NON ZERO. TO CALL IT FROM PI LEVEL 1 VIA NICK'S CLOCK DO THE
;FOLLOWING:
;	0) ENSURE THAT LOCATION SPYING IS 0
;	1) ENSURE NO OTHER PI LEVEL 1 ACTIVITY IS GOING ON
;	   (AT SUMEX ASSIGN THE MAG TAPES AND DON'T USE THEM)
;	2) INSERT A JSR NICKSV AT KIEPT+42 (50042 CURRENTLY)
;	3) DO A CONO 74,11$X FROM MDDT TO FIRE IT UP

SPY:	0			;JSR HERE FROM PISRV OR NICKSV
	MOVEM	A,SPYSAV	;RESPECT ALL AC'S
	SKIPE	SPYINI		;IS DATA BASE INITIALIZED?
	  JRST	SPY.2		;YES, SKIP IT
	SETZM	SPYZRF		;EMPTY THE BUCKETS
	MOVE	A,[SPYZRF,,SPYZRF+1]
	BLT	A,SPYZRL
	SKIPG	A,SPYINT	;GET USER CHANGED INTERVAL, IF ANY
	  MOVEI	A,^D20		;WASN'T ANY, USE DEFAULT
	SKIPN	SPYING		;SKIP IF SPYING FROM PISRV
	MOVEI	A,1		;INTERVAL IS 1 FROM NICKSV
	MOVEM	A,SPYINT
	MOVEM	A,SPYSOS

	SKIPG	A,SPYTOT	;SAME FOR # SAMPLES
	  MOVEI	A,^D10000
	MOVEM	A,SPYTOT
	MOVE	A,TODCLK	;save status at beginning
	MOVEM	A,SPYTD1
	MOVE	A,[TADDAY,,SPYDA1]
	BLT	A,SPYSE1
	MOVE	A,DNJOBS
	MOVEM	A,SPYNJ1
	MOVE	A,[RJAV,,SPYRJ1]
	BLT	A,SPYRJ1+2
	SETOM	SPYINI		;MARK DATABASE INITIALIZED
SPY.2:	SOSLE	SPYSOS		;INTERVAL UP?
	  JRST	SPY.3		;NO, EXIT
	SOSLE	SPYTOT		;ONE MORE TIME
	  JRST	SPY.21
	SETZM	SPYINI
	SETZM	SPYING		;ALL DONE
	MOVE	A,TODCLK	;save status at end of sample
	MOVEM	A,SPYTD2
	MOVE	A,[TADDAY,,SPYDA2]
	BLT	A,SPYSE2
	MOVE	A,DNJOBS
	MOVEM	A,SPYNJ2
	MOVE	A,[RJAV,,SPYRJ2]
	BLT	A,SPYRJ2+2
SPY.21:	MOVE	A,SPYINT	;RESET INTERVAL TIMER
	MOVEM	A,SPYSOS
	MOVE	A,PIAPRX	;PICK UP THE PC WHEN CLOCK TICKED
	SKIPN	SPYING		;SKIP IF CALL FROM PISRV
	MOVE	A,NICKSV	;ELSE CALLED FROM NICKSV
	TLNN	A,UMODF		;SKIP IF IN USER MODE
	  JRST	SPY.4		;WASN'T, MUST BE EXEC MODE
	AOS	SPYUSR		;FOR USER MODE JUST ADD 'EM UP
	HRRZS	A		;rid the flags
	DMOVEM	B,SPYSAV+1
	SKIPL	B,SPYJOB	;skip if any job will do
	  JRST	[SKIPGE	C,FORKX
		JRST	SPY.26
		HLRZ	C,FKJOB(C)
		CAIE	B,(C)
		JRST	SPY.26
		JRST	.+1]
	SETZ	B,
SPY.25:	HLRZ	C,SPYUWD(B)
	JUMPE	C,SPY.26
	CAIGE	A,(C)
	  JRST	SPY.26
	HRRZ	C,SPYUWD(B)
	CAILE	A,(C)
	  AOJA	B,SPY.25
	AOS	SPYUBK(B)
SPY.26:	DMOVE	B,SPYSAV+1
SPY.3:	MOVE	A,SPYSAV	;RESTORE WORK AC
	JRST	@SPY		;AND RETURN
SPY.4:	DMOVEM	B,SPYSAV+1	;HERE IF EXEX MODE
	AOS	SPYEXC		;#SAMPLES IN EXEC MODE
	HRRZS	A		;RID THE FLAGS
	SETZ	B,		;I=0
SPY.5:	HLRZ	C,SPYXWD(B)	;LOWER BOUND OF REGION
	JUMPE	C,SPY.6		;ZERO MEANS END OF REGIONS
	CAIGE	A,(C)		;SKIP IF IN RANGE
	  JRST	SPY.6		;SMALLER THAN SMALLEST RANGE
	HRRZ	C,SPYXWD(B)	;UPPER BOUND OF REGION
	CAILE	A,(C)		;SKIP IF LESS THAN UPPER BOUND
	  AOJA	B,SPY.5		;NEXT I
	AOS	SPYBKT(B)	;ONE MORE FOR THIS BUCKET
SPY.6:	CONI	PI,A		;SEE WHAT PI'S ARE IN PROGRESS
	ANDI	A,077400	;ISOLATE THE BITS WE WANT
SPY.7:	JFFO	A,.+2		;SIGH! MY FIRST JFFO INSTRUCTION
	  MOVEI	B,^D20		;COUNT NO PI'S AS PI LEVEL 0
	AOS	SPYPIS-^D20(B)
	MOVSI	C,400000	;BIT TO SHIFT
	MOVNS	B
	LSH	C,(B)		;JFFO TELLS HOW FAR
	ANDCAM	C,A		;TURN OFF SO WON'T FIND AGAIN
	JUMPN	A,SPY.7		;BACK IF MORE PI'S IN PROG
	DMOVE	B,SPYSAV+1
	JRST	SPY.3
SPYTAB:			;FOR GETTAB
SPYING:	0		;SET TO -1 TO BEGIN
SPYINI:	0		;INITIALIZED FLAG
SPYINT:	0		;SPY INTERVAL
SPYTOT:	0		;# SAMPLES
SPYSOS:	BLOCK	1	;INTERVAL TIMER
SPYSAV:	BLOCK	3	;AC SAVE AREA
SPYJOB:	-1		;.GE.0 means look for that job only
SPYTD1:	BLOCK	1	;todclk at beginning
SPYDA1:	BLOCK	1	;tadday at beginning
SPYSE1:	BLOCK	1	;tadsec at beginning
SPYNJ1:	BLOCK	1	;dnjobs at beginning
SPYRJ1:	BLOCK	3	;rjav's at beginning

SPYTD2:	BLOCK	1	;todclk at end
SPYDA2:	BLOCK	1
SPYSE2:	BLOCK	1
SPYNJ2:	BLOCK	1
SPYRJ2:	BLOCK	3

SPYUWD:			;xwd's for user mode
	1,,677777	;default values
	700000,,712777	;PA1050 area
	713000,,767777	;nothin' really here
	770000,,774777	;DDT
	775000,,777777
	0		;end of list (leaves 5 buckets)
SPYXWD:	BLOCK	^D20	;XWD Low Address,,High address (20 pairs).
	EXP	0	;Insure termination on a zero

SPYZRF==.		;FIRST LOC TO ZERO
SPYUSR:	BLOCK	1	;#SAMPLES IN USER MODE
SPYUBK:	BLOCK 5		;USER MODE BUCKETS
SPYEXC:	BLOCK	1	;# SAMPLES IN EXEC MODE
SPYPIS:	BLOCK	^D8	;# AT EACH PI LEVEL
SPYBKT:	BLOCK	^D20	;1 BUCKET PER REGION
SPYZRL==.-1		;LAST LOC TO ZERO
SPYSIZ==.-SPYTAB	;SIZE OF SPY DATA GETTAB
> ;END IFN SUMEX
	SWAPCD
;GET FORK STRUCTURE

;REGISTER USAGE:
;1-JOB FORK NUMBER OF ENTRY BEING CONSTRUCTED
;2,3,4-TEMPORARY
;6-USER FLAGS,,CURRENT END OF USER FORK TABLE
;7-PTR.TO USER ADDRESS TABLE IN THE STACK
;10-JOB FORK NO. FOR FIRST FORK IN STRUCTURE
;11-BYTE PTR. FOR ENTRY NOW BEING BUILT IN USER SPACE

.GFRKS::	JSYS MENTR
	RESKED		;WELL RFSTS DOES IT, BUT DO I NEED IT?
	JUMPL 1,FRKE1	;NO DEFAULT HANDLES ALLOWED EXCEPT 0 FOR SELF
	HRRZ 7,P
	AOS 7		;SAVE USER ADDRESS TABLE LOCATION
	HRROI 4,-NUFKS	;INIT TABLE
	PUSH P,[-1]
	AOJL 4,.-1
	MOVE 6,2	;6 HOLDS UPDATED USER ADDR PTR AND FLGS
	CALL SETJFK	;GET JOB FORK NO OF TOP FORK
	MOVE 10,1	;SAVE FIRST FORK IN STRUCTURE
	MOVE 2,1
	CALL GFRKS5	;FIRST ENTRY IN USER TABLE IS TOP NODE
	PUSH P,[0]	;MARK END OF TREE STACK
	PUSH P,1	;TOP NODE ONTO TREE STACK
GFRKS1:	TLNE 6,(1B1)	;USER WANTS STATUS?
	JRST [PUSH P,1	;SAVE A FEW THINGS
		PUSH P,6
		PUSH P,7
		CALL RFSTSA	;GET STATUS INTO 1
		POP P,7
		POP P,6
		POP P,3		;SAVE JOB FRK NO. FOR A BIT
		MOVE 2,3
		CALL GFRKS5
		UMOVEM 1,2(4)	;STORE RETURNED STATUS NOW
		MOVE 1,3
		JRST .+1]
	MOVE 2,7	;INIT BYTE PTR TO THIS FORK'S ENTRY
	ADD 2,1
	MOVE 2,(2)	;GET USER ADDR FOR THIS FORK'S ENTRY
;;;	HRRM 2,@.+1
	MOVE 11,[POINT 18,0]
	HRR 11,2
	HRROI 3,-3	;LOOP TO CONSTRUCT ENTRY
GFRKS2:	LDB 2,PARPTR+3(3)
	SETZM 4
	SKIPE 2
	CALL GFRKS5	;FILL IN THIS HALF WRD IF THERE'S A PTR
	XCTBU GFRKS4	;STORE HALF WRD INTO USER MEMORY
	AOSGE 3
	JRST GFRKS2
	TLNE 6,(1B0)	;GET FORK HANDLE?
	JRST [PUSH P,1		;YUP
		CALL GFRKS6
		SETZM 1		;NO HANDLE RETURNED
		MOVE 4,1	;SETUP FOR STORE
		XCTBU GFRKS4	;STORE INTO USER SPACE
		POP P,1
		JRST .+1]
	LDB 1,INFPTR	;MOVE ALONG TREE
	SKIPE 1		;ANY CHILDREN?
	JRST [PUSH P,1		;YES-SAVE NODE
		JRST GFRKS1]
GFRKS3:	POP P,1		;NO-GET LAST NODE
	SKIPN 1		;END MARKER?
	JRST [UMOVEM 6,2	;YES-UPDATE HIS TABLE PTR
		JRST MRETN]
	LDB 1,PARPTR	;NO
	SKIPE 1		;ANY SISTERS?
	JRST [PUSH P,1		;YES-PUT IT ON STACK
		JRST GFRKS1]
	JRST GFRKS3	;NO-DONE WITH THIS NODE-GET LAST

GFRKS4:	IDPB 4,11	;USED WITH EXECUTE TO STORE TO USER

;CONVERTS JOB FORK NO. PASSED IN 2 TO USER ADDR RETURNED IN 4
;RETURNS 0 IF THIS JOB FORK NO. IS SUPERIOR TO FRK CALLING JSYS
;(NOTE:  NOT FORK IN R1 OF SUBROUTINE CALL)
;2-CLOBBERED
;6-UPDATED WHEN NEW USER SLOT ASSIGNED

GFRKS5:	PUSH P,1
	MOVE 1,2
	CALL SKIIF	;INFERIOR OR SELF?
	SETZM 2		;NO-USE 0 END MARKER TO RETURN 0
	POP P,1
	ADD 2,7		;ADD JOB FRK NO. TO USER ADDR TABLE BASE
	SKIPL 4,(2)
	RET		;ALREADY AN ADDRESS ASSIGNED
	HRRZ 4,6	;ASSIGN NEXT AVAILABLE ADDRESS
	ADDI 6,2	;AND UPDATE 6
	TLNE 6,(1B1)
	AOS 6
	MOVEM 4,(2)	;SAVE SLOT ADDRESS FOR FUTURE REFERENCE
	RET

GFRKS6:	PUSH P,2	;GET A RELATIVE FORK HANDLE FOR
	PUSH P,3	;JOB FORK HANDLE IN 2 RELATIVE TO
	PUSH P,4	;JOB HANDLE STORED IN 10
	PUSH P,[0]
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
	HRRZ 2,10	;ALL HANDLES RELATIVE TO TOP NODE
	CAIN 2,(1)
	SOJA 4,GFKH4
	HRLI 1,400000
	JRST GFKH1

PARPTR:POINT 12,FKPTRS(1),23
INFPTR:POINT 12,FKPTRS(1),35
SUPPTR:	POINT 12,FKPTRS(1),11

	RESCD
I4INI::	;EARLY SYSTEM INITIALIZATION CODE FOR I4-TENEX

	SETZM ISKCLK	;INIT INTERVAL CLOCK
	SETZM DNJOBS	;CLEAR DYNAMIC NO. OF JOBS

	RET

INTERN ISKPT1
JOBLIM:	NJOBS-1	;LIMIT ON NUMBER OF JOBS
RESERV: 1	;RESERVE SCHEDULING FLAG--IF 0,INTERVAL SCHEDULER IS
;	TO ALLOW NORMAL SCHEDULING.IF =1, RESERVE SCHEDULING IS
;	IN EFFECT

ISKINV==^D100000
ISKPOT:	ISKINV 		;BASE-PERIOD**0 ;INITIAL 2 MIN.
ISKPT1:	ISKINV/^D100
ISKIN1:	XWD  144,144		;INITIAL INTERVAL EXPONENT ZERO,,
				;INITIAL PERCENT 100.
ISKIN2:	XWD	377777,777777	;INITIAL QUANTUM.

LS DNJOBS,1		;DYNAMIC NUMBER OF JOBS
KS MSCNT1,1		;SCHED FLAG
LS JOBISK,NJOBS		;PERCENT ALLOWED FOR JOB
LS JOBQNT,NJOBS		;REMAINING JOB QUANTUM FOR INTERVAL SCHED

;DISMISS FORK ON QUANTUM OVERFLOW

ISKDMS:	SKIPG (1)
	JRST (4)
	JRST 1(4)

;DISMISS TO WAITING LIST FOR INTERVAL QUANTUM OVERFLOW.

ISKOVF:
	RET		;NOOP THIS ROUTINE
	MOVE	7,FORKX
	JUMPL	7,R
	SKIPN	NSWAP	;IS PROCESS NO SWAP OR NO SCHEDULE?
	SKIPE	NSKED
	RET		;YES.
;
;	CHANGE--6/8/73--DON'T REMOVE USER FOR RESERVATION TIMOUT
;	IF IN MONITOR MODE
	MOVE 1,PPC
	TLNN 1,UMODF	;TEST USER-MODE BIT IN P-COUNTER
	RET		;WAS IN MONITOR
;
;
	CALL	SAVRT
	HLRZ	1,FKJOB(7)
	HRLI	1,JOBQNT(1)
	HRRI	1,ISKDMS	;GET ADDRESS OF .GT. TEST ROUTINE.
	MOVEM	1,FKSTAT(7)
	MOVEI	1,DISMT		;GET ADDRESS OF DISMISS TEST (BALSET)
	MOVEM	1,FKPGST(7)
	MOVSI	1,400000	;"WAITING".
	HRRZ	10,FKPT(7)	;GET BALSET INDEX.
	HLLM	1,BALSET(10)
	HRRZS	FKPT(7)
	SETOB	7,FORKX
	MOVE	1,TODCLK
	MOVEM	1,NBW(10)
	RET

EXTERN SKDLCK,SLOCKR

ISKTCK:	SLOCK	SKDLCK		;LOCK QUEUES
	POPJ 	P,0		;CANT DO NEXT TIME
	MOVE	1,ISKPOT	;GET INTERVAL PERIOD
	MOVEM	1,ISKCLK	;UPDATE CLOCK WORD.
	MOVSI	4,-NJOBS
ISKTK1:	HRRZ	1,JOBISK(4)	;GET PERCENTAGE
	IMUL	1,ISKPT1
	MOVEM	1,JOBQNT(4)	;STORE QUANTUM
	AOBJN	4,ISKTK1	;LOOP.
	PUSHJ	P,REMOLO	;PUT ON GOLST-ALL ENTRIES
	ULOCK	SKDLCK
	RET
;
;
SKPRET:
RSKP:	AOS 0(P)
R:	RET
	SWAPCD

;	JSYS ADDED FOR PSEUDO TTY STUFF
;
;

;
;	ASSIGN PSEUDO TTY RETURNS WITH TERMINAL DESIGNATOR
;	IF ONE AVAILABLE, OTHERWISE FRETURN.
;
.ASPTY:	JSYS	MENTR
	CALL	ASSPTY
	JRST	MRETN
	UMOVEM	2,1		;RETURN TO USER IN AC1
	JRST	SKMRTN


;
;	RELEASE PSEUDO TTY, AC#2 HAS TERMINAL DESIG AFTER CHKTTY
;	IF AC2  HAS -1 RELEASE ALL OWNED BY THIS JOB
;

.REPTY:	JSYS	MENTR
	CAIGE	1,0	;IF AC1 >=0 JUST ONE PTTY
	JRST	.REPY0
	CALL	CHKTTY
	JRST	MRETN
	SUBI	2,PTYLO		;MAKE INTO PTTY INDEX
	CAIGE	2,NPTY
	SKIPGE	2
	JRST	MRETN
	MOVE	1,PTYJOB(2)
;	CAILE	1,0
;	CAIL	1,NJOBS
	CAME	1,JOBNO		;MAKE SURE IT BELONGS TO JOB RELEASING IT.
	JRST	MRETN		;BAD PTY #
	CALL	PTYREL
	JRST	SKMRTN

.REPY0:	MOVEI	2,0
.REPY1:	MOVE	1,PTYJOB(2)	;SEE WHO OWNS
	CAME	1,JOBNO
	JRST	.REPY2
	CALL	PTYREL		;RELEASE THIS PTTY
.REPY2:	AOJ	2,
	CAIGE	2,NPTY
	JRST	.REPY1
	JRST	SKMRTN


;
;	DO PSEUDO TTY STI FUNCTION GET AN FRET IF INPUT BUFFER
;	FULL
;
.PSTI:	JSYS	MENTR
	CALL	CHKTTY
	JRST	MRETN	;INVALID TTY# OR UNOWNED PTTY
	UMOVE	3,2	;GET CHAR IN AC3
	CALL	TTPSTI
	JRST	MRETN	;INPUT BUFFER FULL
	JRST	SKMRTN	;SUCESS.

;
;	DO PSEUDO TTY STO FUNCTION.
;	AC2 HAS TERMINAL DESIGNATOR
;	AC3 WILL HAVE CHAR IF SUCESSFUL
;	GET AN FRET ON OUTPUT BUFFER EMPTY
;	IF AC2 HAS VALUE OF -1, THEN BLOCK UNTIL OUTPUT BUFFER
;	IS NOT EMPTY AND RETURN WITH CHAR, OR UNTIL
;	PSEUDO TTY PROCESS BLOCKS FOR INPUT, THEN FRET
;
.PSTO:	JSYS	MENTR
	CALL	CHKTTY
	JRST	MRETN	;INVALID TTY# OR UNOWNED PTTY
	UMOVE	5,2	;GET BLOCK OPTION IN AC5 FOR TTPSTO
	CALL	TTPSTO
	JRST	MRETN	;OUTPUT BUFFER EMPTY
	UMOVEM	3,2	;GIVE CHAR TO USER
	JRST	SKMRTN

;
;	SKIP IF INPUT BUFFER FULL
;	AC 2 HAS TERMINAL DESIGNATOR
;
.SIBF:	JSYS	MENTR
	CALL	CHKTTY
	JRST	MRETN	;INVALID TTY# OR UNOWNED PTTY
	CALL	TTSIBF
	JRST	[UMOVEM	1,2	;NOT FULL-RETURN # CHARS IN BUFFER
	 	 JRST	MRETN]
	JRST	SKMRTN			;FULL

;	CODE TO HANDLE RESERVATION SCHEDULING--IF USER LOGS IN AND
;	HAS RESERVED HEAVY USE,SET UP PROPER SCHEDULER VALUES.

I4LOGI::NOSKED
	MOVE D,CAPMSK	;GET RESERVATION BITS
	ANDI D,177	;SEVEN BITS MAX ^D100
	PUSHJ P,LCHK2	;SET UP JOB'S PERCENTAGE
	OKSKED		;ALLOW SCHEDULING
	JRST SKMRTN

	;THIS ROUTINE DETERMINES PERCENTAGE AND
	;PUTS IT IN JOB'S QUANT

LCHK2:	SKIPN D		;IF NOT SET GIVE 100 %
	MOVEI D,^D10	;10 %
	CAIG D,^D100	;LIMITED TO LESS THAN OR EQUAL 100%
	SKIPN RESERV	;RESERVE SCHEDULING ON
	MOVEI D,^D100	;NO--FORCE NORMAL SCHED
	HRLI D,0(D)	;SET BOTH HALVES
	MOVEM D,JOBISK(A)  ;SAVE PERCENTAGE
	POPJ P,

	EXTERN FRKE1,GFKH1,GFKH4,ISKED
	EXTERN	TTYPE,CHKTTM,TTFLGS,TTBFRC,TTIMAX,TTICT
	EXTERN TTCOBF,TTFORK,TTCH7
	EXTERN	TTCH70,TCEO2,TTI4RT,TTBIGC,TTBSIZ,TTBBUF
	EXTERN	WRPMSK,TTEOUT,TTECT,TTOOUT,TTOCT
	EXTERN	TTRLOB,TTCIBF,TTSND,TTNIT1

	RESCD
IFG NPTY, <
GS	PTYJOB,NPTY		;TABLE OF OWNING FORKS FOR PTYS
GS	PTYFRE,1		;POINTER TO FREE PTY LIST
	>

GS TTRUBA,NLINES		;RUBOUT SPECIAL HANDLING ACTION WORD

;	INITIALIZATION FOR PTTYS 
;	BUILDS LINKED LIST IN PTYJOB
;	POINTER TO HEAD OF LIST IN PTYFRE
;	LAST ENTRY HAS -1 FOR LINK
;
;
;


; I4-TENEX TTYSRV INITIALIZATION.

I4TTIN::
IFG NPTY, <
	SETZM	,PTYFRE		;INITIALIZE FREE LIST PTR
	MOVEI	1,NPTY-1
	MOVSI	2,777777	;SET END OF FREE LIST
	MOVEM	2,PTYJOB(1)	;INTO END OF PTYFRK LIST
	HRLZ	2,1		;PUT POINTERS IN LEFT HALF
	SOJGE	1,.-2
	>


	SETOM TTNIT1		; INIT TTSND TTY #
	RET
;



;	SIBF - SKIP IF INPUT BUFFER FULL
;	CLOBBERS AC1,AC4
;	RETURNS # OF CHARS IN BUFFER IN AC1
	SWAPCD
TTSIBF::LDB	4,TTIMAX	;MAX BYTES OF INPUT BUFFER.
	MOVE	1,TTICT(2)	;CURRENT # IN BUFFER
	CAML	1,4
	AOS	0(P)		;SKIP IS FULL
	RET

; I4-TENEX PSEUDO TELETYPE PRIMITIVES.

IFG NPTY, <
	RESCD

EXTERN PTYLCK,DLSPI,HLOCKR,HLOCKP

PTYASS::
	HLOCKI PTYLCK
	SKIPGE	2,PTYFRE	;GET POINTER
	JRST	[HULOCK PTYLCK
		OKPI
		POPJ	P,]
	HLRZ	2,2		;GET LINK FIELD TO AN INDEX VALUE
	MOVE	1,PTYJOB(2)	;GET NEXT LINK
	MOVEM	1,PTYFRE	;GET NEXT LIST ENTRY
	HULOCK PTYLCK
	OKPI
	AOS	(P)
	POPJ	P,
;
;	RELEASE A LINE. AC2 HAS LINE# FOR PTY
;
PTYREL::PUSH	P,2
	ADDI	2,PTYLO
	HLRZ	1,TTFORK(2)
	CAIE	1,0
	CAIL	1,NJOBS
	JRST	PTYRL1
	CALL	TTCOBF		;CLEAR OUTPUT FIRST
	PUSH	P,CAPENB
	MOVEI	3,WHEEL
	IORM	3,CAPENB
	LGOUT
	JFCL
	POP	P,CAPENB
PTYRL2:	MOVEI	1,^D1000
	DISMS
	CALL	TTCOBF
	SKIPL	TTFORK(2)
	JRST	PTYRL2
PTYRL1:	POP	P,2
	HLOCKI PTYLCK
	MOVE	1,PTYFRE
	MOVEM	1,PTYJOB(2)
	HRLZM	2,PTYFRE	;MAKE INDEX FIELD A LINK VALUE
	HULOCK PTYLCK
	OKPI
	RET
;
;
SWAPCD
;	ASSIGN A PSEUDO TTY TO A FORK..
;
;
ASSPTY::CALL	PTYASS		;GET A LINE IF AVAILABLE
	POPJ	P,		;NONE FREE
	MOVE	1,JOBNO		;GET INDEX OF CALLING JOB
	MOVEM	1,PTYJOB(2)	;MARK AS OWNED
	ADDI	2,PTYLO
	CALL	TTCOBF
	CALL	TTCIBF
	ADDI	2,400000	;MAKE A TTY DESIGNATOR
	AOS	(P)		;REPORT SUCCESS
	POPJ	P,
;
;
;	PTY STI ROUTINE USES ITS OWN ,LOGIC DIFFERENT FROM BBN STI
;	AC3 HAS THE CHARACTER IN IT, AC2 HAS PTTY NUMBER
;
;	PROVIDES FRET ON INPUT BUFFER FULL
;	OR IF NOT SUFFICIENT ROOM IN BIG BUFF, AS PARMD BY FNUM
TTPSTI:: 
	CALL	TTSIBF		;SEE IF ROOM IN BUFFER
	JRST	.+2
	POPJ	P,	;YES
	HRR	1,3		;PUT CHAR IN BIG BUFF WORD
	PUSH P,6
	PUSHJ P,TTSTI1
	POP P,6
	AOS	(P)
	POPJ	P,
;
;	PSEUDO TTY STO GETS A CHAR OUT OF OUTPUT BUFFER OF PTY
;	AC2 HAS PTY #
;	AC3 GETS CHARACTER IF THERE
;	AC5 HAS BLOCKING OPTION, IF <0, BLOCK UNTIL CHAR IN	>
;		OUTPUT BUFFER, OR PROCESS BLOCKS FOR INPUT
;	PROVIDES FRETURN IF OUTPUT BUFFER EMPTY
;
;
TTPSTO::CALL GETCH
	JRST	TPSTO1
	AOS	(P)	;HAVE A CHAR IN AC3, S RETURN TO CALLER IN JSYS
	POPJ	P,
TPSTO1:	CAIL	5,0	;LOOK FOR BLOCKING OPTION
	JRST	[POPJ	P,]	;NO OPTION, FRETURN
	MOVEI	1,STOTST	;TEST ADDR FOR SCHED
	HRLI	1,0(2)		;LINE # IN LEFT HALF
	JSYS	EDISMS
	CALL	GETCH		;SEE IF CHAR THERE
	JRST	[HRREI	6,-1	;FORK BLOCKED ON INPUT
		 UMOVEM	6,2	;-1 TO CALLER AC2
		 POPJ	P,	]
	AOS	(P)
	POPJ	P,
;	SCHEDULER TEST FOR STEAL OUTPUT
;	WILL WAKEUP IF OUTPUT BUFFER GETS A CHARACTER
;	OR IF PROCESS BLOCKS FOR INPUT
;
;
RESCD
STOTST::SKIPE	TTOCT(1)	;TEST OUTPUT BUFF CONTENTS
	JRST	1(4)		;NOT EMPTY, WAKEUP
	HRLZ	2,TTFORK(1)
	SKIPGE	2
	JRST	0(4)		;TRY LATER
	JRST	1(4)		;WAKE UP
;
;	GETCHARACTER SEE IF ANYTHING IN BUFFERS
;	PTY # IN AC2
;	RETURNS +1 IF BUFFERS EMPTY, +2 IF NOT EMPTY, WITH CHAR IN AC3

EXTERN NOPILK,TTYLCK,DLOCKR

GETCH:	
	NOSKED
	DLOCK TTYLCK
	JSP 4,TTSND
	CAIA 
	AOS (P)
	ULOCK TTYLCK
	OKSKED
	POPJ	P,
SWAPCD
	>
; I4-TENEX CTY LINK LOGIC.

;CHECK IF CLEARING LINK TO CTY
;SET CTY'S ACCEPT LINKS BIT IF SO
;1 HOLDS LINK NO. TO BE CHECKED

TLT3::	CAIE 1,CTYLIN		;IS THIS THE CTY?
	RET			;NO
	MOVEI 3,1000		;YES--SET HIS ACCEPT LINKS BIT
	ORM 3,TTFLGS(1)
	RET


; ATTEMPTING TO LINK TO CTY AND CTY ALREADY BUSY...
; SEND MSG TO USER, RING BELL ON CTY.

TL24::	MOVE 1,7		;SEND MESSAGE TO CALLER
	IORI 1,400000	;LEGAL DESIGNATOR
	HRROI 2,[ASCIZ/
CONSOLE TTY BUSY/]
	SETZM 3
	SOUT
	MOVEI 4,3	;RING BELL 3 TIMES
	MOVEI 2,CTYLIN	;ON CTY
	MOVEI 1,"G"-100	;IT'S A BELL
	CALL TCEO2
	SOJG 4,.-1
	MOVEI 1,^D3000	;DISMIS SO BELL CAN RING
	DISMS
	JRST MRETN	;AND NON-SKIP RETURN


; I4-TENEX SPECIAL RUBOUT SUBSTITUTION CODE.

;	HERE TO DO SPECIAL RUBOUT PROCESSING

RESCD
TTSRA::	CAIN	4,177		;RUBOUT?
	RET			;YES, IGNORE IT
	AOS 0(P)		;SKIP RETURN
	CAIE	4,(3)	;NO. IS IT RUBOUT SUBSTITUTE?
	RET
	MOVEI	1,377		;YES. CHANGE IT INTO A RUBOUT
	MOVEI	4,177
	RET

SWAPCD



;	JSYS TO SET RUBOUT SPECIAL HANDLING ACTION WORD
;
;	INPUT:	1:  1B0 ON MEANS IGNORE RUBOUTS
;		    1B18 ON MEANS THAT BITS 29-35 ARE TO BE
;		     USED AS A SUBSTITUTE FOR RUBOUT. (I.E.
;		     WHEN THE SUBSTITUTE CHARACTER IS TYPED,
;		     IT WILL APPEAR TO THE JOB AS A RUBOUT.)
;
;	RETURN:	+1:  ALWAYS

.SRUBA::
	JSYS	MENTR
	PUSH P,[0]
SRUBA1:	MOVE	2,JOBNO		;GET JOB #
	HLRE	3,JOBPT(2)	;GET CONTROLLING TTY #
	JUMPL	3,SRUBA2		;IF DETACHED, EXIT
	LDB	4,[POINT 7,1,35]
	CAIN	4,3		;DON'T ALLOW ^C
	JRST	SRUBA2
	SKIPE 0(P)
	JRST [ MOVEI 2,(3)
		PUSHJ P,CLTTST
		HRLM 4,TTRUBA(2)
		JRST .+2 ]
	HRRM 4,TTRUBA(3)
SRUBA2:	POP P,1
	JRST	MRETN		;EXIT

.STCHA:	JSYS MENTR		;SET STOP CHARACHTER
	PUSH P,[-1]
	JRST SRUBA1
	SWAPCD

I4DEL::
	push	p,d

	IFN IMSSS,< JRST WDMDCY>; DONT CHECK FOR NOW
	PUSH	P,A
	HRLI	A,WRTF		; ONLY IF WRITE ACCESS WAS ALLOWED
	PUSHJ	P,ACCCHK
	JRST	WDMDCX		; NO WRITE ACCESS

	POP	P,A
	HRRZ	B,DIRDBK
	SKIPN	B		; NUMBER OF VERSIONS TO KEEP
	HRRZI	B,2		; (DEFAULT IS 2)
ifn SUMEX,	<		;check versions to keep for the file
		ldb	b,[point 5,fdbbyv(a),5]
		jumpe	b,wdmdcy	;if 0 the leave it alone
		movsi	d,fdbdel	;set delete bit
		skipl	fdbbyv(a)	; set expunge to
		tlo	d,fdbsdl	;yes
		>

ife SUMEX, < movsi	d,FDBDEL!FDBSDL>	;if not on sumex alway expunge

	MOVN	B,B
	HRLZI	B,(B)

WDMDC1:	HRRZ	C,FDBVER(A)	; PASS OVER KEPT VERSIONS
	JUMPE	C,WDMDCY	; FINISHED WITHOUT MEETING QUOTA
	HRRZI	A,DIRORG(C)	; POINT TO NEXT FDB
	AOBJN	B,WDMDC1

wdmdc2:	IORM	d,FDBCTL(A)
;	TLNE	B,FDBPRM	; IF PERM FILE, SET SIZE TO ZERO
;	CHANGE--5/13//BCH
;	SETZM	FDBSIZ(A)
	HRRZ	C,FDBVER(A)	; ANOTHER SURPLUS VERSION?
	JUMPE	C,WDMDC3	; NO--EXPUNGE
	HRRZI	A,DIRORG(C)	; YES - ADDRESS NEXT FDB
	JRST	WDMDC2		; AND DELETE IT

WDMDC3:	PUSHJ	P,USTDIR	; UNLOCK DIR AND OKINT
	PUSH	P,JFN
	HRRZ	JFN,FILDDN(JFN)	; GET DIRECTORY NUMBER
	SETO	16,		; SET SELECTIVE EXP FLAG
	PUSHJ	P,DELDEL	; EXPUNGE
	POP	P,JFN
	POP	P,D
	JRST	DSKCL1

WDMDCX:	POP	P,A
wdmdcy:	pop	p,d
	JRST	DSKCL4

REPEAT 0,<
;JSYS RDPAR, STPAR ARE PRIVILEDGED JSYS'S FOR OPERATORS TO USE.  THEY
;CAN READ AND CHANGE PREDETERMINED PARAMETERS IN THE SYSTEM WITH
;THESE CALLS.
;RDPAR:  ACC (1) : SIXBIT NAME OR TABLE INDEX 
;	ACC (2) INDEX VALUE
;        ACC (3) : POINTER TO WHERE TO STORE INFORMATION
;RETURN: +1   INVALID NAME OR INDEX
;        +2   TABLE INFOR RETURNED AT PROVIDED ADDRESS IN FORMAT =
;			0 = SIXBIT NAME
;			1 = MAX VALUE
;			2 = MIN VALUE
;			3 = CURRENT VALUE
;                       4 = LH - LOW VALUE OF INDEX
;                       4 = RH - HIGH VALUE OF INDEX

;STPAR:  ACC (1) = SIXBIT NAME OR TABLE INDEX
;        ACC (2) = VALUE INDEX
;        ACC (3) = VALUE
;TABLE DESCRIPTION
;NAME, MAX VALUE, MIN VALUE, ALL MIN INDEX, ALL MAX  INDEX, NO. BITS, LAST BIT
DEFINE PARS (CC.)<
	CC.(JOBISK, 144, 2, 1, NJOBS-1, 36, 35)
	CC.(JOBLIM, NJOBS-1, 2, 0, 0, 36, 35)
	CC. (RESERV, 1, 0, 0, 0, 36, 35)
	CC.(ENTFLG, 0, -1, 0, 0, 36, 35)
	>

EXTERNAL ENTFLG

DEFINE A1 (N1, N2, N3, N4, N5, N6, N7)<
	SIXBIT/N1/>

DEFINE A2 (N1, N2, N3, N4, N5, N6, N7)<
	BYTE (36)N2>

DEFINE A3 (N1, N2, N3, N4, N5, N6, N7)<
	BYTE (36)N3>

DEFINE A4 (N1, N2, N3, N4, N5, N6, N7)<
	BYTE (18)N4, N5>

DEFINE A5 (N1, N2, N3, N4, N5, N6, N7)<
	POINT N6, N1(2), N7>

PARNAM:  PARS(A1)	;NAME
NPARS==.-PARNAM
PARMAX:  PARS(A2)	;MAX VALUE
PARMIN:  PARS(A3)	;MIN VALUE
PARAIN:  PARS(A4)	;ALLOW. INDEX
PAPTR:  PARS(A5)	;BYTE POINTER

INTERNAL .PARRD,.PARST

;READ PARAMETERS
.PARRD:  JSYS MENTR
         PUSHJ P,CKINDR		;CHECK VALID INDEX
         JRST MRETN		;INVALID INDEX
         AOS 0(P)
         MOVE 4, PARNAM(1)	;NAME
         UMOVEM 4, 0(3)
         MOVE 4, PARMAX (1)	;MAX VALUE
         UMOVEM 4, 1(3)
         MOVE 4, PARMIN(1)	;MIN VALUE
         UMOVEM 4, 2(3)
         LDB 4, PAPTR(1)	;ACTUAL VALUE
         UMOVEM 4, 3(3)
         MOVE 4, PARAIN(1)
         UMOVEM 4, 4(3)		;ALLOWABLE INDEX
         JRST MRETN

;SET PARAMETER
.PARST:  JSYS MENTR
         PUSHJ P, CKINDW	;CHECK VALID INDEX
         JRST MRETN
         DPB 3, PAPTR(1)	;STORE VALUE
         AOS 0(P)
         JRST MRETN

CKINDR:  PUSH P,[0]		;CHECK READING
         SKIPA
CKINDW:  PUSH P, [-1]		;CHECK SETTING
         MOVE 4, CAPENB
         TRNN 4, WHEEL + OPER
         JRST CHKIN1		;FAILURE RETURN
         TLNN 1, -1		;SIXBIT
         JRST CHKIN2		;NO
         MOVSI 4, -NPARS
         CAMN 1, PARNAM(4)	;SEARCH FOR NAME
         JRST CHKIN3
         AOBJN 4, .-2
         JRST CHKIN1		;FAILURE
CHKIN3:  MOVEI 1, (4)
CHKIN2:  CAIL 1, NPARS		;VALID INDEX
         JRST CHKIN1
         HLRZ 4, PARAIN(1)	;CHECK INDEX
         CAIGE 2, (4)
         JRST CHKIN1		;INVALID INDEX
         HRRZ 4, PARAIN(1)
         CAILE 2, (4)
         JRST CHKIN1		;INVALID INDEX
         SKIPL 0(P)		;WRITING
         JRST CHKIN4		;NO, OK
         CAMGE 3, PARMIN(1)	;VALUE CHECK
         JRST CHKIN1		;TOO SMALL
         CAMLE 3, PARMAX(1)
         JRST CHKIN1
CHKIN4:  AOS -1(P)		;SUCCESS
CHKIN1:  POP P, 4
         POPJ P, 0
> ;END REPEAT 0 AROUND PARRD, PARST
	END


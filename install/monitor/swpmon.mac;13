;<MON>SWPMON.MAC;13    21-JUN-77 16:56:16    EDIT BY SWEER
; REMOVED INTPER GETTAB
;<MON>SWPMON.MAC;12    21-JUN-77 11:24:10    EDIT BY SWEER
; INSERTED ISI GET/SAVE CODE FOR .EXE FILES
;<MON>SWPMON.MAC;11    25-APR-77 16:23:13    EDIT BY SWEER
; ADDED SPYTAB GETTAB
;<MON>SWPMON.MAC;10    25-APR-77 15:48:05    EDIT BY SWEER
; QUICKIE CHECK FOR EXEC IN SETNM JSYS
;FIXED GETPAT LISP FIX, FORGOT 1 KI40
;<MON>SWPMON.MAC;8    12-APR-77 14:36:08    EDIT BY SWEER
;ADDED TTLINK GETTAB, REMOVED GDTYPE CALL
;<MON>SWPMON.MAC;7    12-APR-77 10:03:03    EDIT BY SWEER
;REMOVED CLRDIR DEFINITION, ALWAYS UNLOCK DIRS ON STARTUP
;changed 40's to ki40's in prev edit Sweer 3/5/77
;added interlisp support in getpat edit by sweer 2/28/77
;<MON>SWPMON.MAC;6    15-FEB-77 16:03:46    EDIT BY SWEER
; ADDED TOPDIR GETTAB ENTRY FOR COPY OF LSTDNO
;<MON>SWPMON.MAC		7/75		EDIT BY HEATHMAN
;MINOR CHANGES TO EXTERNALS WHILE ADDING NEW TYMNET HANDLER
;<MON>SWPMON.MAC;25    21-MAY-75 16:45:55    EDIT BY HEDBERG
;Added reason for downage to HSYS, IMPDRQ to OPRFN JSYS
;Made .ATACH check for existence of job
;<MON>SWPMON.MAC;22     7-APR-75 17:32:02    EDIT BY LIEB
;ADDED BUGCHK FOR SKIP RET FROM HSTINI
;<MON>SWPMON.MAC;20     3-FEB-75 11:58:07    EDIT BY LIEB
;<MON>SWPMON.MAC;19    30-JAN-75 02:49:39    EDIT BY LIEB
;ADDED BUGNOTE REPORTING--LIEB
;<MON>SWPMON.MAC;18    29-JAN-75 16:34:38    EDIT BY LIEB
;INSERTED GTBNHN AND GTBHST INTERNS FOR HOSTS.MAC---LIEB
;<MON>SWPMON.MAC;17    27-JAN-75 13:35:50    EDIT BY LIEB
;INSERT CALL TO HSTINI TO CONFORM TO 133 NET STUFF--LIEB
;<KI-ASSEMBLY>SWPMON.MAC;197    18-JUL-73 22:36:02	EDIT BY DURHAM
;ADDED KI-10 CHANGES
;	6/28/73--INSERT ILLIAC 4 CHANGES INTO BBN DISTRIBUTED SWPMON
;
;<TENEX-131>SWPMON.MAC;187    12-JAN-73 15:26:20	EDIT BY CLEMENTS
;<TENEX-131>SWPMON.MAC;186     9-JAN-73 14:24:04	EDIT BY CLEMENTS
;<TENEX-130>SWPMON.MAC;184     5-JAN-73 11:02:59	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;183     2-JAN-73 15:37:28	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;182    29-DEC-72 17:55:27	EDIT BY CLEMENTS
;<TENEX-130>SWPMON.MAC;181    28-DEC-72 14:04:00	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;180    27-DEC-72 14:10:03	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;179    26-DEC-72 15:42:23	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;178    26-DEC-72 14:11:31	EDIT BY TOMLINSON
; REWROTE AUTO JOB STARTUP
;<TENEX-130>SWPMON.MAC;177    13-DEC-72 16:54:54	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;176     8-DEC-72 11:35:50	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;175     7-DEC-72 17:11:23	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;174     7-DEC-72 16:59:35	EDIT BY TOMLINSON
; FIXED UP DDTRCL AND DDTFSH
;<TENEX-130>SWPMON.MAC;173     5-DEC-72 00:04:40	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;172     4-DEC-72 23:41:48	EDIT BY CLEMENTS
;<TENEX-130>SWPMON.MAC;171     4-DEC-72 11:19:31	EDIT BY TOMLINSON
; FLUSHED CFIBF IN JOB STARTUP CODE
;<TENEX-130>SWPMON.MAC;170     4-DEC-72 10:17:31	EDIT BY TOMLINSON
; CHANGED NAME OF MONSYMS FILE
;<TENEX-130>SWPMON.MAC;169    29-NOV-72 13:16:29	EDIT BY CLEMENTS
;FIXED ITRAP BUGCHK ON SAVE/GET WITH BAD FILE DESIGNATOR
;<TENEX-130>SWPMON.MAC;168    27-NOV-72 17:31:10	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;167    27-NOV-72 16:40:15	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;166    27-NOV-72 15:13:00	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;165    27-NOV-72 14:02:14	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;164    27-NOV-72 13:28:52	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;163    21-NOV-72 15:49:53	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;162    21-NOV-72 15:32:48	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;161    21-NOV-72  6:57:05	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;160    21-NOV-72  6:51:56	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;159    20-NOV-72 17:14:13	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;158    20-NOV-72 15:35:22	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;157    20-NOV-72 14:15:02	EDIT BY WALLACE
;<TENEX-130>SWPMON.MAC;156    13-NOV-72 21:17:03	EDIT BY CLEMENTS
;<TENEX-130>SWPMON.MAC;155    13-NOV-72 11:41:59	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;154    10-NOV-72 12:53:03	EDIT BY TOMLINSON
; ADDED INTERNS
;<TENEX-130>SWPMON.MAC;153    10-NOV-72 12:44:25	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;152     9-NOV-72 20:11:57	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;151     9-NOV-72 17:27:34	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;150     9-NOV-72 16:39:07	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;149     9-NOV-72 16:08:20	EDIT BY TOMLINSON
;<TENEX-130>SWPMON.MAC;148     9-NOV-72 15:59:18	EDIT BY TOMLINSON
; ISOLATING SWPMON AS SEPARATE ASSEMBLY -- ADDED EXTERNS
;<TENEX-130>SWPMON.MAC;147     8-NOV-72 22:45:41	EDIT BY CLEMENTS
;<TENEX-130>SWPMON.MAC;146     8-NOV-72 14:15:36	EDIT BY TOMLINSON
; ADDED CODE FOR SPLFK JSYS, MODIFIED GFKH
;<TENEXDLM>SWPMON.MAC;145    31-OCT-72 22:50:27	EDIT BY CLEMENTS
;<TENEXDLM>SWPMON.MAC;144    30-OCT-72 18:56:16	EDIT BY CLEMENTS
;<TENEXDLM>SWPMON.MAC;143    20-OCT-72 20:17:19	EDIT BY TOMLINSON
;<TENEXDLM>SWPMON.MAC;142    20-OCT-72  8:57:50	EDIT BY TOMLINSON
;<TENEXDLM>SWPMON.MAC;141    19-OCT-72 16:13:39	EDIT BY TOMLINSON
;<TENEXDLM>SWPMON.MAC;139    29-SEP-72 12:30:22	EDIT BY MURPHY
;<TENEXDLM>SWPMON.MAC;138    20-SEP-72 13:39:29	EDIT BY MURPHY
;<TENEXDLM>SWPMON.MAC;137    18-SEP-72 13:38:14	EDIT BY MURPHY
;<TENEXDLM>SWPMON.MAC;136    14-SEP-72 17:50:52	EDIT BY MURPHY
;<TENEXDLM>SWPMON.MAC;135    23-AUG-72 20:48:01	EDIT BY MURPHY
;<TENEXDLM>SWPMON.MAC;134    22-AUG-72 20:35:20	EDIT BY MURPHY

;5 JUL 72, 1326:

	SEARCH PROLOG
	TITLE SWPMON

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY

	EXTERN DLOCKR,JLOCKR,JOBLCK,JULCKR,STOPLK,TTYLCK,KI40
	EXTERN PSILCK,HLOCKR,NOPILK,CPUSW0,FKCNO

	EXTERN HILIN,JOBISK

	EXTERN MENTR,MRETN,MRETNE,UJSYS,FKINTT,FKINTW
	EXTERN ISKED,NSKED,RSKED,BUGHLT,BUGCHK,BUGNTE
	EXTERN FORKX,FKPGS,INSKED,NPMAX,JB0FLG,DDTIME,IOIP
	EXTERN CHNSON,ITRAP,JOBPT,JOBRT,PSIRQB,TODCLK,FKJOB
	EXTERN GETCHA,RSKP,R,JFNOFN,SETMPG,BLOCKW,FRZB1,FRZB2,FRZBB
	EXTERN JBFINI,FILINI,SYSIFG,MMSPTN,CHKTIM,DRMIN0
	EXTERN JOBDNO,MRPACS,SWAKES,SBLKTM,FKWSP,PSILOB
	EXTERN ASSFK,EDISMS,FKPT,FKSTAT,FREFK,JSKP,JRET,WTLST,HLTJB
	EXTERN ILIST,DDMP,FPTA,SETPT,HALTF1,BLOCK1,HALTT
	EXTERN CLRM0,FKINT,FORCTM,HLTFK1,PSIR4,SUSFKR,SUSWT,WTFPGS
	EXTERN PRIMRY,CAPMSK,CAPENB,MLKPG,MULKPG,TENDMP
	EXTERN NXTDMP,TTPSRQ,UCLOCK,ITRAP1,SETOVF,SPTC,SPC1
	EXTERN JOBNAM,NNAMES,SNAMES,STIMES,SPFLTS,CRSTAD,CGFLG
	EXTERN SUPERP,PARALP,INFERP,PSIT1A,PWRDWN,PASSWC,ACCIFG
	EXTERN NTTYIN,NTTYOT,GETDDB,DDBMAX,USTDIR,SYSRST
	EXTERN SKMRTN,OPNX1,JOBQNT
	EXTERN MAKPGA,MAKPGU,DDERJ,DDERJI
IFN SUMEX,<
	EXTERN TTLINK,JBTINI,TTYPCK	;SUMEX TTY TYPE INITIALIZER
>
IFN IMSSS,< EXTERN INFBUF,LOGINI,DATINI,LD.INI,AUDINI,INIBUF,RUNDAT>

; LINKAGE TO SYSTEM VERSION INFO

EXTERN	SVNN,SVN,SVNUM

IFDEF IMPCHN,<

; LINKAGE TO NETWRK

	EXTERN NETKFK

; LINKAGE TO IMPDV

EXTERN	IMPBEG,IMPRDY,IMPLBT,IMPHRT,IMPNLK,IMPLT1,IMPLT2,IMPLT3,IMPLT4
EXTERN	NLHOST,CHKNET>
IFDEF DSPCHN,<
	EXTERN DSPKFK>

; LINKAGE TO TYMNET

IFDEF TYMSW,<
	INTERN LOGFCT
	EXTERN TYMJB0
>

; LINKAGE TO DSK

EXTERN	DIDSCA,MAPBTF,CVDSK,UDSKIO,NSECPG,DISKP,WRMON,WRSWM
EXTERN	CHKBT,DSKRBS,DSKRCE,DSKNRE,DSKLER,DSKRER,NDSKEW,DSKRML,DSKSML

; LINKAGE TO DRM

EXTERN	DRMCFE,DRMFRE,NDRMEW

; LINKAGE TO TTYSRV

EXTERN	NORMTF,TTICB1,TTICB2,TAB81,TAB82,OTYLIN,TTFORK,TTHNGU
EXTERN	TCITST,PSICHL,PSICHU,PSICHO,PSICH,TTPSI,TTDPSI

IFN SUMEX,<EXTERN TTCLZ>

; LINKAGE TO SCHEDULER

EXTERN	JOBSRT,SCDRQ7,ENTFLG,DBUGSW,DCHKSW

; MISCELLANEOUS OTHER EXTERNS

EXTERN MAKPGA,MAKPGU,DDTPRS,SYMPRS,DDTX,PLCKT
EXTERN	BHC,BITS,NOFN
EXTERN FACTSW
EXTERN .JBUSY,SWPCOR,MONCOR,OLDTCK,JOBRTT,MAPDIR,DIRDSK
IFN SUMEX,<
EXTERN	SPTIM1,JOBAL,JOBGO,JOBTAL,JOBTGO	;SPECIAL STAT TABLES
EXTERN	PAGMOV,TOPDIR,DSKTAB,DSKTSZ		;PAGE MIGRATION STATISTICS
EXTERN SPYTAB,SPYSIZ
EXTERN	DSKSTS,DRIVTB,NDVMAX
>


INTERN	CHKBG1,CHKH1,WHEELX
	INTERN .CFORK,.KFORK,.FFORK,.RFORK,.RFSTS,.SFORK,.SPLFK,.RIR
	INTERN .RFACS,.SFACS,.HFORK,.WFORK,.SFRKV,.SEVEC,.GEVEC
	INTERN .RPCAP,.EPCAP,.DTACH,.ATACH,.SJPRI,.SIRCM,.RIRCM
	INTERN EXEC0,EXECI,.EXEC,EXBUGH,TTFRKT,SETLFK,GETMST,WMST
	INTERN WHEEL,OPER,FRZWT,.RTIW,.STIW,SWCEND,VERCEL
	INTERN JB0TT,MDDT,.GCVEC,.SCVEC,.MSFRK
	INTERN GETSWM,ULKSM1,RUNDD,.PEEK
	INTERN CHKR,GETPAT,.GTRPW,.SPRIW,KSELF,MAPFKH
	INTERN .GJINF,.TIME,.JOBTM,.RUNTM,.GTRPI,.GTDAL,.HSYS,.USRIO
	INTERN .GETAB,.SYSGT
	INTERN .SETNM,.GETNM
	INTERN .SWTCH,.LITES,.BPT,.WAIT
	INTERN .LGOUT,FLOGO
	INTERN LOGTOT,LOGDES,LOGONM,LOGCJM
	INTERN .GPJFN,.SPJFN
	INTERN SKIIF,SKISF,SKIIFA
	INTERN .SIR,.EIR,.SKPIR,.DIR,.AIC,.IIC,.DIC
	INTERN .RCM,.RWM,.ATI,.DTI,.CIS
	INTERN FKHPTN,PTNFKH
	INTERN .GET,.SAVE,.SSAVE

SSTSIZ==30000		;MAX SIZE OF SWP SYM TAB
DDTSYM=MDDT+1		;PTR TO DDT SYMTAB PTR

NGSP BUGTAB,SBUGTF/1000			;BUG TABLE AND STRINGS
NGSP SWPST,SSTSIZ/1000		;SWP SYM TAB

	DEFINE TMSG
<	PUSHJ P,TMSGQ>

LOGDES:	LOGTTY			;DESIGNATOR FOR LOG MSGS - DEF IN PARAMS
JB0TT:	JB0TTY			;DESIG FOR JOB 0 AND ERR MSGS

; STUFF FOR NON-JOB0 AUTOJOB STARTUP FROM FILE

GS AUTONX,1		; STATE OF NON-JOB0 STARTUP
			; + CHARACTER POINTER TO STARTUP FILE
			; -1 DONE

IFN SUMEX,<
LS TOPDIR,1>		;RESIDENT COPY OF LSTDNO FOR GETTAB

EXEC0:	MOVSI 1,UMODF		;SIMULATE CALL FROM USER
	MOVEM 1,FPC
	JSYS MENTR
	SKIPE DIDSCA		;REFRESHING DISK?
	SETOM ACCIFG		;NO, ACCOUNTING SHOULD EXIST
	SKIPN SYSIFG		;NEW SYSTEM?
	CALL GETSWM		;YES, GET SWAPPABLE MONITOR
	MOVEI 1,FKPTRS
	MOVEI 2,NUFKS
	CALL ILIST
	MOVE 1,0(1)		;GRAB FIRST SLOT FOR TOP FORK
	MOVEM 1,FREJFK
	SETZM FKPTRS
	MOVE 1,FORKX
	MOVEM 1,SYSFK
	MOVE 1,[XWD SYSFK+1,SYSFK+2]
	SETOM -1(1)		;INIT REMAINDER OF TABLE
	BLT 1,SYSFK+NUFKS-1
	SETOM TTJTIW
	MOVSI 1,<JFCL>B53
	MOVEM 1,MONINT		;FOR DDT BREAKPOINT
	MOVE 1,[XWD ITFPC,EXECI]
	MOVEM 1,MONBK
	SETZ 1,
	MOVEI 2,3		;ENABLE CHANS 34 AND 35 FOR ^P
	MOVEM 2,MONCHN		;AND GRAB THEM IF THEY HAPPEN
	AIC
	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
IFN IMSSS,<
	MOVE 1,JOBNO		;INITIALIZE PUTINF-GETINF BUFFER
	IMULI 1,40
	ADDI 1,INFBUF
	SETZM (1)
	HRL 1,1
	ADDI 1,1
	HLRZ 2,1
	BLT 1,37(2)		;ZERO OUT AREA
>

	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES
	CALL FILINI		;INIT FILE SYSTEM
	SKIPE ACCIFG		;CAN'T GET BIT TABLE IF REFRESHING
	CALL MAPBTF		;INIT DSK BIT TABLE
IFN IMSSS,<
	CALL LOGINI
	CALL DATINI
	CALL LD.INI
	CALL AUDINI
	CALL INIBUF
>
IFDEF IMPCHN,<EXTERN HSTINI
		CALL HSTINI	;IF WE HAVE A NET, PROCESS HOST NAME TABLE
		BUG(CHK,<HSTINI FAILED TO INIT HOSTNAME TABLES>)
>
;
	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK

SYSINE:	NOINT
	HRROI 2,[ASCIZ /<PMFDIR0>JOBPMF/]
	MOVE 1,JOBNO
	CAIGE 1,10
	HRROI 2,[ASCIZ /<SYSTEM>JOBPMF/] ;SYSTEM DIR FOR FIRST JOBS
	MOVSI 1,(1B5+1B8+1B17)	;TEMP FILE,IGN DEL AND SHORT FORM GTJFN
	GTJFN
	JRST PMFBAD
	HRRZM 1,JOBPMF
	MOVEI 2,1B19+1B20+1B21+1B25	;IN, OUT, XCT, THAWED
	OPENF			;OPEN PMF
	JRST PMFBAD
PMFB1:	MOVE 1,CTRLTT
	HRLI 1,600012		;CONSTRUCT DEVICE DESIGNATOR FOR CTRLTTY
	JFCL ;	ASND			;ASSIGN IT
	JFCL
	TIME
	MOVEM 1,CONSTO		;SET CONSOLE TIME ON
	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIGE 1,NSPECJ		;IS THIS ONE OF THEM?
	JRST [	MOVE 2,BHC+1	;YES, FAKE A LOGIN AS SYSTEM
		MOVEM 2,JOBDIR(1)
		HRRZ 2,SPECJT(1)
		JRST 0(2)]	;GO DO THE SPECIAL FUNCTION
	MOVEI 1,100
IFN SUMEX,<			;!! MAH @ SUMEX 4/75 !!
	CALL JBTINI		;INITIALIZE TTY MODES AND TYPES
>
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	MOVE 2,TAB81		;GET STANDARD TAB STOPS
	MOVE 4,2
	MOVE 3,TAB82
	STABS			;SET CONTROLLING TTY
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL

	MOVE 1,[CHKDSE]		;CHKDSK ERRORS?
	TDNE 1,FACTSW
	JRST	[HRRZ 3,CTRLTT		;YES, ALLOW CTY & DIALUP TO FIX
		CAME 3,OTYLIN		;DIALUP LINE?
		CAIN 3,CTYLIN		;OR OPERATORS CONSOLE
		JRST STEX		;START THE EXEC
		MOVEI 1,SYSINT		;HAVE AUTOJOBS WAIT FOR DISK OK
		JSYS EDISMS
		JRST .+1]
	SETO 3,
	EXCH 3,AUTONX		; PREVENT FURTHER AUTO START UP
	JUMPGE 3,SPECJB		; IF ANY MORE AUTOSTARTUP, DO IT
	JRST STEX		;GO START EXEC

SYSINT:	MOVE 1,[CHKDSE]	;DISK ERRORS FIXED?
	TDNE 1,FACTSW
	JRST 0(4)		;NO
	JRST 1(4)		;YES
PMFBAD:	BUG(CHK,<PMF FAILURE>)
	MOVE 1,JOBPMF
	RLJFN
	JFCL
	SETOM JOBPMF
	SETZM PSIBW		;FLUSH ANY BREAKS, E.G. DATA ERROR
	OKINT
	JRST PMFB1		;ALLOW JOB WITH NO PMF


;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;DO LOGIN STUFF
	MOVE 4,CTRLTT
	DTACH
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		;USE JOB 0 TTY FOR ANY OUTPUT
	MOVE 1,JOBNO
	CAIGE 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST DONS1		;YES
	RET
DONS1:	MOVE 2,4
	CALL SPCSTJ		; START ANOTHER JOB ON THIS TTY
	RET


; ATERNATE STARTUP MECHANISM TO START JOBS FROM FILE "AUTOJOBS"

SPECJB:	PUSH P,3
	MOVE 1,JOBNO
	MOVE 2,BHC+1
	MOVEM 2,JOBDIR(1)	; FAKE LOGIN AS SYSTEM
	PUSHJ P,LOGONM		; AND PRINT LOGIN MESSAGE
	POP P,3
	DTACH			; DETACH THIS JOB
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		; PRIMARY OUTPUT TO JB0 TTY
	MOVE 1,DBUGSW
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.RUN/]
	CAIN 1,2
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.DEBUG/]
	MOVSI 1,(1B2+1B17)	; OLD FILE & STRING & SHORT FORM
	GTJFN			; GET JFN OF AUTOJOBS FILE
	 JRST SPECJ5		; FILE NON-EXISTENT
	PUSH P,1		; SAVE IT
	MOVE 2,[7B5+1B19]
	OPENF			; OPEN TO READ
	 JRST [	POP P,1
		RLJFN
		 JFCL
		JRST SPECJ9]	; COULDN'T OPEN
	MOVE 2,3		; START POINT
	SFPTR
	 JRST SPECJ8		; HADN'T OUGHT TO HAPPEN
	HRLZ 2,1		; MAKE IT BE INPUT FOR GTJFN
	HRRI 2,377777		; NO OUTPUT
	MOVSI 1,(1B2+1B16+1B17)	; OLD FILE, FILE INPUT, SHORT FORM
	GTJFN
	 JRST SPECJ6		; FILE APPARENTLY NOT THERE
	EXCH 1,0(P)		; SAVE JFN OF TASK, GET JFN OF AUTOJOBS
	CALL SPECJN		; GET NEXT ONE STARTED
	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
	GTJFN
	JRST [	POP P,1		; NO EXEC?  GET RID OF JFN
		RLJFN
		JFCL
		JRST SPECLO]	; AND LOGOUT
	HRLI 1,400000
	GET			;GET CURRENT EXECUTIVE
	XCTMU [POP P,2]		; PUT JFN OF SAVE FILE IN AC2 OF EXEC
	HRRO 1,JB0TT
	UMOVEM 1,1		;GIVE THE PRIMARY I/O TO THE EXEC
	HRRZ 1,ENTVEC
	ADDI	1,2		;GO TO AUTO JOB ENTRY POINT
	HRRM 1,0(P)
	JRST MRETN

SPECJ6:	POP P,1
	CALL SPECJN		; SKIP TO NEXT TASK
SPECLO:	SETO 1,
	LGOUT			; LOG OURSELVES OUT
	 JFCL
	BUG(HLT,<IMPOSSIBLE FAILURE OF LGOUT(-1)>)

SPECJ8:	POP P,1
	CLOSF
	 JFCL
SPECJ9:	BUG(CHK,<SPECJB:  AUTOJOB FILE SCREWED UP>)
SPECJ5:	HRROI 1,[ASCIZ /NO AUTOJOBS FILE
/]
	PSOUT
	CALL SPECJL		; PRETEND THIS WAS LAST TASK
	JRST SPECLO		; GO LOGOUT

SPECJN:	BIN			; SKIP TO NON-SEPARATOR
	JUMPE 2,SPECJ7		; NULL == EOF, FINISH UP
	CAIG 2,40		; SPACE OR LESS IS TO BE SKIPPED
	 JRST SPECJN
	RFPTR			; GET WHERE WE ARE AT
	 JFCL
	SOS 2			; MINUS ONE
	MOVEM 2,AUTONX		; IS NEXT PACE TO START
	CLOSF			; DONE WITH AUTOJOBS FILE
	 JFCL
	MOVEI 2,CTYLIN
	CALL SPCSTJ		; THEN START UP NEXT ON CTYLIN
	RET			; CONTINUE STARTING THIS TASK

SPECJ7:	CLOSF			; CLOSE AUTOJOBS FILE
	 JFCL
SPECJL:	MOVE 3,[CHKDSE]		;CHECK DEBUG AND ERROR CONDITIONS
	MOVE 1,DBUGSW
	TDZN 3,FACTSW		;IF DSK ERRORS, CLEAR 3 AND SKIP
	CAIN 1,2		;IF DEBUGSW AT 2, DONT ALLOW ON.
	SKIPA			;ONE OR THE OTHER FAILED.
	SETOB 3,ENTFLG		;PERMIT ENTRIES NOW
	HRROI 2,TNAMS2		;NOT AVAIL MSG, DEBUGGING
	CAIE	1,2
	HRROI 2,TIOMSG		;TENEX IN OPERATION MSG
	SKIPN 3			;DISK ERRORS?
	HRROI 2,TNAMS1		;YES. NOT AVAIL MSG DSK ERRORS.
	SETO 1,
	TTMSG
	GTAD			;IF WE NEED TIME AND DATE
	JUMPGE 1,R
	MOVEI 2,CTYLIN		; START JOB ON CTY
	CALL SPCSTJ
	RET

SPCSTJ:	NOSKED			;PREVENT RACE ON TTY STARTUP
	DLOCK TTYLCK
	SKIPGE 1,TTFORK(2)	;IS THERE A JOB EXTANT
	TLNN 1,1		; OR STARTING ON THIS LINE?
	JRST 	[ULOCK TTYLCK
		OKSKED		;YES
		RET]		; NOT ANOTHER.
	MOVSI 1,-2		;NO.. FLAG STARTING ONE.
	HLLM 1,TTFORK(2)	; ..
	MOVEI 1,JOBSRT
	HRL 1,2
	CALL SCDRQ7		;START JOB ON CTY TO GET T&D
	ULOCK TTYLCK		;RELEASE TTY LOCK
	OKSKED
	RET

TNAMS1:	ASCIZ /
TENEX NOT AVAILABLE: DISK NEEDS FIXING.
/
TNAMS2:	ASCIZ /
TENEX NOT AVAILABLE
/
TIOMSG:	ASCIZ /
TENEX IN OPERATION
/

;GET SWAPPABLE MONITOR

	EXTERN BGTEND,LWTEND,GETSMF

GETSWM:	PUSH P,NPMAX		;SAVE CURRENT MAX SIZE
	MOVE 1,TOTRC
	MOVEM 1,NPMAX		;ALLOW ALL OF CORE WHILE GETTING SWM
	MOVEI 7,SWPMP0		;FIRST PAGE OF SWM
;    I4 CHANGE
	MOVE 10,VERCEL	;DISK ADR OF SYS AREA WHERE SYSTEM WAS WRITTEN
	HRRZ 2,GETSMF
	CAIE 2,2	;SYSTEM WAS BOOTED FROM PAPER TAPE
;
	MOVE 10,DSKSML		;SWP MONS DISK ADDRESS
	NOSKED
LOKSM1:	MOVEI 2,0(7)
	LSH 2,^D9
	MOVES 0(2)		;REF THE PAGE THEREBY ASSIGNING IT
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	PUSH P,7
	CALL MLKPG		;LOCK THE PAGE
	POP P,7
	SKIPG GETSMF		;GETTING MONITOR FROM DISK?
	JRST LOKSM2		;NO
	MOVE 1,10		;YES, GET CURRENT ADDRESS
	CALL CVDSK		;CONVERT TO H'WARE FORMAT
	MOVEI 2,1000		;READ 1000 WORDS
	LDB 3,[POINT 11,MMAP(7),35] ;CORE PAGE NUMBER
	LSH 3,^D9		;CORE ADDRESS
	CALL UDSKIO		;OPERATE THE DISK
	MOVEI 1,(7)
	HRL 1,MMSPTN
	CALL MULKPG		;UNLOCK PAGE
	ADDI 10,NSECPG		;INCREMENT DISK ADDRESS 4 SECTORS
LOKSM2:	CAMGE 7,SWCEND		;HIGHEST PAGE OF SWM
	AOJA 7,LOKSM1
	SKIPLE GETSMF		;GETTING FROM DISK?
	JRST LOKSM3		;YES, SKIP TENDMP CALL
	MOVSI 1,1
	SOJG 1,.		;WAIT AWHILE FOR DRUM OPS TO COMPLETE
	MOVE 1,[XWD BGTEND,LWTEND]
	MOVEI 2,LWTEND		;TENDMP ENDS AT LAST
	IORI 2,17777		;LOCATION OF 8K BLOCK
	BLT 1,0(2)		;MOVE IT TO PLACE ABOVE MON AND SWPMON
	PIOFF			;TO PREVENT DATA LATE
	MOVEM P,TW1
	JSR TENDMP		;CALL TO INTERPRET PRE-STORED STRING
	MOVE P,TW1
	PION
	MOVEI 7,SWPMP0
LOKSM4:	MOVEI 1,(7)
	HRL 1,MMSPTN
	CALL MULKPG		;UNLOCK PAGES
	CAMGE 7,SWCEND
	AOJA 7,LOKSM4

;GETSWM ...

LOKSM3:	MOVSI 6,WRITEB		;SET TO CLEAR WRITE BIT FROM MMAP
	MOVE 1,DBUGSW
	CAIN 1,2		;BUT IF DBUGSW = 2,
	SETZ 6,			;LEAVE IT WRITABLE
	MOVEI 7,SWPMP0
	MOVE 10,DSKSML		;DISK ADDRESS FOR POSSIBLE WRITING
ULKSM1:	ANDCAM 6,MMAP(7)	;CLEAR ANY UNWANTED ACCESS
;;;	MOVEI 1,0(7)
;;;	HRL 1,MMSPTN
;;;	CALL MULKPG		;UNLOCK THE PAGES
	CAMGE 7,SWCEND
	AOJA 7,ULKSM1
	OKSKED
	POP P,NPMAX		;RESTORE NORMAL MAX SIZE
;;;	SKIPN GETSMF		;IF FRESH START FROM DTA
;   I4 CHANGE
	MOVE 1,GETSMF
	JUMPL 1,ULKSM2		;DONT WRITE OUT
	CAIE 1,1		;ALREADY WRITTEN OUT?
	SKIPN DISKP		;AND DISK AVAILABLE
	JRST ULKSM2
	PUSH P,CAPENB		;SAVE CURRENT CAPS
	SETZM GETSMF		;INIT FLAG FOR WRITE OUT
	MOVEI 1,WHEEL		;WE NEED WHEEL FOR THE FOLLOWING
	IORM 1,CAPENB
	CALL WRMON		;WRITE RES AND SWP MON ON DISK
	CALL WRSWM
	POP P,CAPENB
	AOS GETSMF		;FLAG MON NOW ON DISK
ULKSM2:
	MOVE 1,DBUGSW		;SHOULD WE FLUSH DDT ?
	IOR 1,DCHKSW
	SKIPN 1
IFN IMSSS,<JFCL 0>
IFE IMSSS,<CALL DDTFSH>		;YES
	RET

;SWCEND IS SET BY POSTLD TO CONTAIN THE NUMBER OF THE HIGHEST
;PAGE CONTAINING SWAPPABLE CODE

VERCEL:	0	;DISK ADDRESS FOR SWPMON GET STORED BY SYSSAV
SWCEND:	0

;FLUSH DDT AND SYMBOL TABLE AND MAKE PAGES AVAILABLE FOR SWAPPING
;RESIDENT DDT AND ITS SYMBOL TABLE CAN BE FLUSHED SEPARATELY
;THE CONTENTS OF CELL SYMDDT CONTROL WHAT GETS FLUSHED AS FOLLOWS
; C(SYMDDT)=0 MEANS FLUSH DDT AND SYMBOL TABLE
; C(SYMDDT)<>0 MEANS FLUSH SYMBOL TABLE ONLY
;THE FOLLOWING TWO CELLS DEFINE THE CURRENT STATUS
;  DDTPRS=0 MEANS DDT IS RESIDENT
;  SYMPRS=0 MEANS THE SYMBOL TABLE IS RESIDENT
;(NOTE THAT THE CODE WILL NOT ALLOW FOR A RESIDENT SYMBOL TABLE AND
;  A NON-RESIDENT DDT)

GS SAVE36,1		;SAVED LOCATION 36
GS SAVE32,1		;SAVED LOCATION 32
GS RCADDT,1		;SAVE ADDRESS OF SWPCOR
SYMDDT:	0
	SWAPCD

DDTFSH:	PUSH P,3		;SAVE REGISTERS
	PUSH P,2
	PUSH P,1
	NOINT			; PREVENT CONFUSION
	SKIPE DDTPRS		;DDT ALREADY FLUSHED ?
	JRST DDTFSR		;YES
	SETZM SWPSTP		; CAUSE ANY MDDT'S TO TO FORGET SYMTAB
	SKIPE SYMDDT		;FLUSH SYMBOLS ONLY ?
	JRST [	SKIPE SYMPRS	;SYMBOLS ALREADY FLUSHED ?
		JRST DDTFSR	;YES
		HRRZ 1,SAVE36	;COMPUTE STARTING FLUSH ADDRESS
		MOVEI 3,777(1)	; AS FIRST PAGE .GE. SYMTAB BEG
		ANDCMI 3,777
		SUBI 1,-1(3)	; LENGTH -1
		ANDCMI 1,1	; INCREASE LENGTH BY 1 IF ODD
		HRLM 1,36	; NEW LENGTH
		LSH 3,-^D9	; CONVERT ADDRESS TO PAGE NUMBER
		JRST DDTFS1]
	SETOM DDTPRS		; NO DDT
	MOVE 1,[JRST 4,100]	;CHANGE 100 DISPATCH
	MOVEM 1,100
	SETZM 36		;INDICATE NO SYMBOL TABLE
;;;	SETZM 32
	HRRZ 3,MONCOR		; START FLUSHING HERE
DDTFS1:	MOVE 2,RCADDT		; FIRST PAGE TO NOT FLUSH
	SUBM 3,2		; NEG NUMBER OF PAGES
	HRLZS 2
	HRR 2,3			; AOBJN POINTER
DDTFSL:	MOVE 1,MMAP(2)
	JUMPE 1,DDTFSE		; IGNORE IF NOTHING HERE
	SETZM MMAP(2)		; DDT IS MAPPED ONE-TO-ONE
	MOVSI 1,(01B5)
	MOVEM 1,CST0(2)		; MARK AS UNAVAILABLE
	HRRZ 1,2
	CALL MAKPGA		;FREE THE PAGE
DDTFSE:	AOBJN 2,DDTFSL		;LOOP TILL ALL FREE
DDTFSR:	OKINT
	POP P,1			;RESTORE REGISTERS
	POP P,2
	POP P,3
	RET			;RETURN


;RECLAIM DDT AND/OR SYMBOL TABLE (SEE ABOVE COMMENTS)

DDTRCL:	MOVE 1,MONCOR		; RESTORE FROM MONCOR
	MOVE 2,RCADDT		; THRU RCADDT
	SOS 2			; MINUS 1
	CALL MAKPGU		;GET THE PAGES
	 JRST DDTRCF		; FAILED TO GET ALL THE PAGES
	HRRZ 1,MONCOR		; START WITH MONCOR
	HRLZ 2,MMSPTN		;FIXUP THE MAP AND CST'S
	MOVSI 3,400000
	MOVSI 4,RWXB
DDTRC1:	HRR 4,1
	MOVEM 4,MMAP(1)
	MOVEM 3,CST0(1)		; PREVENT TRAPS
	MOVEM 1,CST1(1)
	HRR 2,1
	MOVEM 2,CST2(1)
	AOS 1
	CAMGE 1,RCADDT		; ALL DONE?
	 JRST DDTRC1		; NO, DO NEXT
	MOVE 4,MONCOR		;GET DDT AND SYMBOLS BACK FROM DISK
	SUB 4,RCADDT		; NEG NUMBER OF PAGES
	HRLZ 4,4
	HRR 4,MONCOR
DDTRC2:	MOVEI 1,-1(4)		;COMPUTE LINEAR DISK ADDRESS
	IMULI 1,NSECPG
	ADD 1,DSKRML
	CALL CVDSK		;CONVERT TO HARDWARE ADDRESS
	MOVEI 2,1000		;READ 1000 WORDS
	MOVEI 3,0(4)		;GET CORE ADDRESS
	LSH 3,^D9
	DSKOP
	AOBJN 4,DDTRC2		;ALL DONE, NO TO DDTRC2
DDTRC3:	MOVE 1,[JRST DDTX]	;UPDATE 100
	MOVEM 1,100
	MOVE 1,SAVE36		;SETUP SYMBOL TABLE POINTER
	MOVEM 1,36
	MOVE 1,SAVE32
;;;	MOVEM 1,32
	SETZM DDTPRS		;INDICATE DDT PRESENT
	SETZM SYMPRS		;INDICATE SYMBOLS PRESENT
	RET

DDTRCF:	PUSH P,1		; SAVE VALUE OF MAKPGU
	HRRZ 2,1		; NUMBER OF LOCKED PAGES
	MOVEI 1,101
	MOVEI 2,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ / PAGES LOCKED.  ONE OF THEM IS PAGE /]
	PSOUT
	POP P,2
	HLRZS 2
	MOVEI 1,101
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ /. WAITING FOR IT...
/]
	PSOUT
	MOVEI 1,PLCKT
	HRL 1,2
	JSYS EDISMS		; WAIT FOR PAGE TO BE UNLOCKED
	JRST DDTRCL		; THEN TRY AGAIN

RUNDD:	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS

IFN IMSSS,< CALL RUNDAT>

	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;NO
	STAD			;YES, SET IT
	JFCL
RUNDD3:	MOVEI 1,101
	DOBE
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX RESTARTING, WAIT.../]
	TTMSG
;
;	PUSHJ P,I4EXC0	;I4-TENEX INIT ROUTINE
;
	SKIPG DISKP
	JRST RUNDD2		;SKIP DISK STUFF IF NO DISK
	MOVEI 1,RUNDD1		;BREAK TO RUNDD1 IF ANYTHING GOES WRONG
	HRRM 1,MONBK
	CALL CHKBT		;CHECK CONSISTENCY OF DISK BIT TABLE
	MOVE 2,DBUGSW
	CAIN 2,2		;IF REAL DEBUGGING,
	JRST RUNDD2		;SKIP DISK CHECKING
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>CHECKDSK.SAV/]
	GTJFN
	JRST RUNDD1
	PUSH P,1
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR CHECKDSK
	BUG(HLT,<JOB 0 CFORK FAILED>)
	EXCH 1,0(P)
	HRL 1,0(P)
	GET
	MOVE 1,[CHKDSR]		;SAY CHECK DSK RUNNING
	IORM 1,FACTSW
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY
	WFORK
	KFORK
	MOVE 1,[CHKDSR]		;SAY CHKDSK COMPLETED
	ANDCAM 1,FACTSW
	JRST RUNDD2

RUNDD1:	HRROI 1,[ASCIZ / NO CHECKDSK
/]
	PSOUT
RUNDD2:	MOVEI 1,RUNDD6		;BREAK TO RUNDD6 IF ANY SCREWUP
	HRRM 1,MONBK
	MOVEI 1,101
	DOBE			;WAIT FOR ANY JOB0 OUTPUT
	MOVE 1,[CHKDSE]		;DISK OK?
	TDNE 1,FACTSW
	JRST 	[HRROI 2,TNAMS1
		SETO 1,
		TTMSG
		JRST .+1]
	MOVE 1,JB0TT		;JOB 0 TTY
	CAIE 1,377777		;REAL TTY?
	JRST RUNDD4		;YES
	MOVSI 1,(1B0+1B17)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.REPORT/]
	GTJFN
	BUG(CHK,<CAN'T GTJFN ERROR REPORT FILE>)
	MOVE 2,[44B5+1B20]
	OPENF
	BUG(CHK,<CAN'T OPENF ERROR REPORT FILE>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT 
	MOVEI 1,[SIXBIT '$RUNNING DDMP$$/']
	TMSG			;ON TTY 0
	MOVSI 1,(740B8)
	MOVEM 1,LOGBUF
	HRROI 1,LOGBUF
	EFACT			;RESTART ENTRY IN FACT FILE
	JSP 2,XEFACT		;CHECK EFACT FAILURE
	AOS SYSIFG		;MAKE SYSTEM AVAILABLE
	CALL DONSJ		;START NEXT SPECIAL JOB
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR SYSJOB
	BUG(HLT,<JOB 0 CFORK FAILED>)
	PUSH P,1
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>SYSJOB.SAV/]
	GTJFN
	JRST [	POP P,1
		KFORK
		MOVEI 1,[SIXBIT '$NO SYSJOB$/']
		TMSG
		JRST RUNDD5]
	HRL 1,0(P)
	GET
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY, LET RUN FOREVER

RUNDD5:
RUNDD6:	MOVEI 2,CTYLIN
	CALL SPCSTJ		; START UP FIRST AUTO JOB
	IFDEF IMPCHN,<CALL IMPBEG> ;START IMP ASYNCH FORK
	MOVEI 1,103
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	MOVEI 1,CHKRI
	HRRM 1,MONBK		;SET DISPATCH FOR INTERRUPTS
	CALL DDERJI		;ONE TIME INIT OF DISK/DRUM RECOVERABLE ERROR
				;LOGGING SYSTEM !!MAH @ SUMEX 7/75 !!
	JRST CHKR		;GO DO BACKGROUND

;MAP DDT FROM IMAGE FILE

GETDDT:	SKIPE GOTDDT		;GOT DDT NOW?
	RET			;YES
	MOVSI 1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>MDDT2.SAV/]
	GTJFN
	JRST NODDT
	MOVE 2,[44B5+1B19]	;36-BIT READ
	OPENF
	JRST NODDT
	BIN			;FIRST WORD IS XWD -LENGTH,LOC
	HLRE 3,2		;GET LENGTH
	CAMGE 3,[-LMDDT]	;OUR SPACE BIG ENOUGH?
	JRST [	CLOSF		;NO
		JFCL
		MOVEI 1,[SIXBIT '$MDDT TOO BIG$/']
		JRST NODD2]
	HLLZ 7,2		;SETUP OUR AOBJN PTR
	MOVEI 2,0(2)		;SEE IF LOC IS CORRECT
	CAIE 2,MDDT
	JRST [	CLOSF		;WRONG-MUST BE REASSEMBLED
		JFCL
		MOVEI 1,[SIXBIT '$MDDT AT WRONG LOCATION$/']
		JRST NODD2]
	BIN
	MOVEM 2,MDDT(7)		;STORE MDDT CODE IN PRIVATE PAGE, BUT
	AOBJN 7,.-2		;CODE WILL BE USED BY ALL PROCESSES
	CLOSF
	JFCL
	NOINT
	MOVE 1,[XWD -LMDDT,MDDT]
	ASH 1,-^D9
	MOVSI 2,WRITEB
	ANDCAM 2,MMAP(1)	;WRITE-PROTECT ALL MDDT PAGES
	AOBJN 1,.-1
	AOS GOTDDT
	OKINT
	RET

NODDT:	MOVEI 1,[SIXBIT '$NO MDDT FILE$/']
NODD2:	TMSG
	JRST NODD1

LS SWPSTP,1			;POINTER TO SWAPPABLE SYMTAB
LS GOTDDT,1			;REMEMBERS IF WE HAVE MAPPED DDT

;READ IN MONITOR SYMBOL TABLE FROM FILE

GETMST:	MOVE 1,SVNUM		; SYSTEM VERSION NUMBER
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>MONSYMS.>,<\>)]
	GTJFN
	JRST NOSYMS		;NO FILE
	MOVE 2,[44B5+1B19]	;36 BIT READ
	OPENF
	JRST [	RLJFN
		JFCL
		JRST NOSYMS]
	NOINT
	BIN			;GET XWD -LENGTH,ADDRESS
	HLRE 3,2
	MOVM 3,3		;POSITIVE OF LENGTH
	CAILE 3,SSTSIZ		;TOO BIG?
	HRLI 2,-SSTSIZ		;YES, READ ONLY TO MAX
	HRRI 2,SWPST		;ADDRESS WHERE TABLE TO BE PUT
	MOVEM 2,SWPSTP
	MOVE 7,2
	BIN
	MOVEM 2,0(7)
	AOBJN 7,.-2
	OKINT
	CLOSF
	JFCL
NOSYMS:	RET

EWMST:	MOVEI 1,[SIXBIT 'RITE MON SYM TAB/']
	TMSG
	CALL OKGO
	SKIPE 1,@DDTSYM		;DDT HAS CURRENT POINTER?
	MOVEM 1,SWPSTP		;YES, UPDATE IT
	JSP 4,WMST		;WRITE TABLE ONTO FILE
	JRST EXCRR

;WRITE MONITOR SYMBOL TABLE ONTO FILE
;CALLED WITH JSP 4,WMST

WMST:	HRROI 1,[ASCIZ /
SYMBOL TABLE LARGER THAN SWAPPABLE STORAGE ALLOCATED FOR IT.
/]
	HLRE 2,SWPSTP
	MOVM 2,2
	CAILE 2,SSTSIZ		;TOO LARGE?
	PSOUT			;YES, PRINT MESSAGE
	HRROI 1,[ASCIZ /
SYMBOL TABLE WRITTEN ON FILE /]
	PSOUT
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B0+1B17)	; FOR OUTPUT & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \MONSYMS.>,<\>)]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	JFNS			;TYPE THE FILE NAME
	MOVE 1,2
	MOVE 2,SWPSTP
	BOUT			;OUTPUT -LENGTH,,ADR
	MOVE 7,2
	MOVE 2,0(7)
	BOUT
	AOBJN 7,.-2
	CLOSF
	JFCL
	JRST 0(4)

EXEC2:	
IFN IMSSS,<
	MOVEI 1,100
	RFMOD
	TRNE 2,4
	JRST LOGO
>
	MOVEI 1,100	;ESTABLISH CORRECT TTY MODES
	MOVE 2,NORMTF
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL
	MOVE 1,[XWD 20,^D34]
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 2,JOBNO
	HRRZ 1,JOBDIR(2)
	SKIPE ACCIFG		;IF NOT REFRESHING,
	JUMPE 1,[SETZM CAPMSK	;AND NOT LOGGED, FLUSH ALL CAPS
		SETZM CAPENB
		MOVE 3,CTRLTT
		CAIE 3,CTYLIN	;ALLOW MINI-EXEC ONLY ON CTY
		JRST .+1
		HRLOI 3,777000	;GIVE ALL CAPS
		MOVEM 3,CAPMSK
		MOVEM 3,CAPENB
		MOVE 3,BHC+1	;FAKE LOGIN AS SYSTEM
		MOVEM 3,JOBDIR(2)
		JRST .+1]
	MOVE 1,CAPMSK		;LOOK AT CAPS, ALLOW MINI-EXEC
	TRNN 1,WHEEL+OPER	;ONLY IF WHEEL OR OPER
	JRST [	SKIPE FORKN	;OTHERWISE,
		HALTF		;HALTF IF BELOW EXEC
		JRST LOGO]	;LOGOUT IF TOP FORK
	MOVEI 1,"."
	PBOUT
EXECT1:	PBIN			;AWAIT USER INPUT
	CAIL 1,"a"		;IN UPPER CASE!
	CAILE 1,"z"
	JRST .+2
	TRZ 1,40
	CAIN 1,"E"
	JRST GEX
	CAIN 1,"B"
	JRST EBLT		;BLT SWP MON TO USER SPACE
	CAIN 1,"M"
	JRST EMNT		;MOUNT DTA-
	CAIN 1,"R"
	JRST EREST		;RESET USER MAP AND FILES
	CAIN 1,"G"		;G - GET FILE
	JRST EGET
	CAIN 1,"S"		;S - START
	JRST EST
	CAIN 1,"D"		;D - DUMP ON FILE
	JRST EDMP
	CAIN 1,"I"
	JRST EINI
	CAIN 1,"H"
	JRST EHLT		;HALT T.S.
	CAIN 1,"W"
	JRST EWMST
	CAIN 1,"^"
	JRST MRETN
	CAIN 1,"/"
	JRST TODDT
	JRST EXERR		;NOTA

TODDT:	MOVEI 1,EOL
	PBOUT
	CALL GETDDT		;GET PROTOTYPE DDT
	SKIPN SWPSTP		;NON RES SYMTAB HERE?
	CALL GETMST		;NO, TRY TO GET IT
	SKIPN 1,SWPSTP		;USE NON-RES SYMTAB IF PRESENT
	MOVE 1,36		;MOVE MONITOR SYMBOL POINTER
	SKIPN @DDTSYM		;HAVE SYMTAB PTR ALREADY?
	MOVEM 1,@DDTSYM		;NO, SET ONE UP
	JRST MDDT		;GO TO DDT

;BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

EBLT:	MOVEI 1,[SIXBIT 'LT SWP MON/']
	TMSG
	CALL OKGO
	SKIPLE DISKP		;IF DISK,
	SKIPGE	GETSMF
	JRST	.+2
	CALL WRSWM		;WRITE IT ON DISK
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVEI 1,SWPMP0		;FIRST PAGE
	LSH 1,^D9
	HRLI 1,0(1)
	XCTMU [BLT 1,777(2)]
	JRST EXCRR

EREST:	MOVEI 1,[SIXBIT 'ESET/']
	TMSG
	CALL OKGO
	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVSI 7,-1000
	MOVNI 1,1
	MOVSI 2,400000
	SETZ 3,
ERES1:	HRRI 2,0(7)
	SKIPE UPTA(7)
	PMAP
	AOBJN 7,ERES1
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	JRST EXCRR

OKGO:	PBIN
	CAIN 1,"."
	RET			;PERIOD MEANS GO
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

GEX:	MOVEI 1,[SIXBIT 'XEC$/']
	TMSG
STEX:
IFN IMSSS,<
	MOVEI 1,100
	RFMOD
	HRROI 1,[ASCIZ/SEXEC.SAV/]
	TRNN 2,4
>
	HRROI 1,[ASCIZ /<SYSTEM>EXEC.SAV/]
	MOVE 2,1
	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM

	GTJFN
	JRST [	HRROI 1,[ASCIZ /NO EXEC/]
		PSOUT
		JRST EXCRR]
	HRLI 1,400000
	GET
	JRST GEX1

;INIT DISK BIT TABLE, BAD SPOTS, ETC

EINI:	MOVEI 1,[SIXBIT 'NIT BIT TABLE/']
	TMSG
	CALL OKGO
	CALL DSKRBS		;READ BAD SPOTS
	JRST EXCRR

;HALT TENEX

EHLT:	MOVEI 1,[SIXBIT 'ALT TENEX/']
	TMSG
	CALL OKGO
	SETZM NXTDMP		;REQUEST DDMP ACTION
	SETZM DDTIME		;FORCE DDMP RUN
	AOS JB0FLG		;REQUEST JOB 0
	MOVEI 1,^D1000
	DISMS			;WAIT A SECOND
	SKIPN CGFLG		;SWAPPING AND
	SKIPL NXTDMP		;DDMP FINISHED?
	JRST .-4		;NO
	MOVSI 1,400000
	MOVEM 1,20		;HALT SCHED
	JRST EXCRR

;MOUNT DECTAPE

EMNT:	MOVEI 1,[SIXBIT 'OUNT DTA/']
	TMSG
	PBIN
	CAIL 1,"0"		;USER TYPES DIGIT
	CAILE 1,"7"		;FROM 0 TO 7
	JRST EXERR		;BAD CHAR
	MOVE 10,[ASCIZ /DTA0/]
	DPB 1,[POINT 7,10,27]	;CONSTRUCT STRING WITH UNIT NUMBER
	HRROI 1,10
	STDEV
	JRST EXERR		;NO SUCH DEVICE
	MOVE 1,2
	MOUNT
	JRST EXERR
	JRST EXCRR

EGET:	MOVEI 1,[SIXBIT 'ET FILE /']
	TMSG
	MOVSI 1,(1B2+1B4+1B16+1B17)	;OLD FILE,TERMINATION,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	JRST EXCRR

EST:	MOVEI 1,[SIXBIT 'TART/']
	TMSG
	CALL OKGO
	MOVEI 1,EOL
	PBOUT
GEX1:	HRRZ 1,ENTVEC
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	HRRM 1,0(P)
	JRST MRETN

EDMP:	MOVEI 1,[SIXBIT 'UMP ON FILE /']
	TMSG
	MOVSI 1,(1B0+1B3+1B4+3B17)	;NEW V,PNT O/N,TERM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD 777760,20]	;ALL EXCEPT AC'S
	SAVE
	JRST EXCRR

EXERR:	MOVEI 1,[SIXBIT '  ?/']
	TMSG
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
EXCRR:	MOVEI 1,EOL
	PBOUT
	JRST EXEC2

;PSI TRAPPED TO HERE

EXECI:	XCT MONINT		;FOR DDT BREAKPOINT
	EXCH 1,ITFPC		;SAVE 1, GET TRAP PC
	TLNN 1,UMODF		;USER?
	JRST EXECI1		;NO
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFPC		;RESTORE AC1
EXECI2:	JSYS MENTR
	SETOM PRIMRY
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	MOVEI 1,400000
	SETO 2,
	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	MOVEI 1,EM2
	TMSG
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 1,1(P)		;GET USER PC
	HRLI 1,UMODF
	MOVEM 1,FPC
	HRLZ P,ACBAS1		;RECOVER USER AC'S
	LSH P,4
	BLT P,17
	JRST EXECI2

EXECI3:	MOVEI 1,EM3
	TMSG
	MOVEI 1,101
	HRRZ 2,UPP
	HRRZ 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	JFCL
	JRST EXCRR		;TO MINI-EXEC IF WHEEL OR OPERATOR

EM2:	SIXBIT '$ABORT$/'
EM3:	SIXBIT '$INTERRUPT AT /'

;JSYS TO ENTER MINI-EXEC

.EXEC:	JSYS MENTR
	MOVEI 1,WHEEL+OPER
	TDNN 1,CAPENB
	JRST WHEELX		;ITRAP WITH WHEEL ERROR
	JRST EXEC2

EXBUGH:	MOVE 1,UPDL		;RESET STACK, ETC.
	HRLI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR
	SETOM TRAPC
	SETZM NSKED
	SETZM INTDF
	SKIPN JOBNO		;JOB 0?
	JRST CHKRI		;YES, INTERRUPT
	HRRZ 1,PRIMRY
	HRROI 2,[ASCIZ /
BUGHLT AT /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2,EOL
	BOUT
	JRST ITRAP

;EXEC UTILITY ROUTINES

;MESSAGE TYPER - ADR OF SIXBIT TEXT IN 1

TMSGQ:	HRLI 1,440600		;CONSTRUCT BYTE POINTER
	PUSH P,1
TMSG1:	ILDB 1,0(P)
	ADDI 1,40		;CONVERT TO ASCII
	CAIN 1,"/"		;SLASH IS TERMINATOR
	JRST TMSG2
	CAIN 1,"$"		;DOLLARS MEANS EOL
	MOVEI 1,EOL
	PBOUT
	JRST TMSG1

TMSG2:	POP P,1			;FLUSH TEMP
	RET

;HALT SYSTEM - REQUIRES MAINT (OR WHEEL ETC.) CAPABILITY
; ACCEPTS A GTAD-STYLE DATE AND TIME IN 1, AT WHICH TIME TENEX
;WILL BE SHUT DOWN. JOB 0 NOTIFIES USERS AND DOES THE SHUTDOWN.
; AND ACCEPTS A GTAD TIME IN 2 WHEN SYSTEM IS EXPECTED UP AGAIN
; ACCEPTS 4-BIT CODE FOR REASON FOR DOWNAGE IN 3.
; REQUIRES WHEEL, MAINT, OR OPER CAPABILITY.

.HSYS:	JSYS MENTR		;SET UP AC BLOCK
	MOVE 2,CAPENB		;SEE IF USER ALLOWED TO HALT TENEX.
	TRNN 2,WHEEL+OPER+MAINT	; ..
	JRST CAPXR		;NO. RETURN CAPX ERROR
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING THE SHUTDOWN
	SETZM HSYST1		;ABORTING. KILL FLAGS.
	SETZM HSYST2		; ..
	SETZM HSYST3		; ..
	JRST SKMRTN		;SKIP RETURN TO USER

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN.
	GTAD			;GET CURRENT TIME AND DATE
	SUB 1,0(P)		;DIFFERENCE IN TIMES
	MOVNS 1			;POSITIVE
	TRNE 1,400000		;SECONDS WENT NEGATIVE?
	ADD 1,[-1,,^D<3600*24>]	;YES. GET DAYS AND SECONDS
	TLNE 1,777770		;OVER A WEEK AHEAD, OR NEGATIVE?
	RETERR TIMEX1		;YES. GIVE BAD TIME FAILURE
	POP P,2			;SHUTDOWN TIME AGAIN
	MOVEM 2,HSYST1		;STORE FOR EXEC TO SEE
	HLRZ 2,1		;CONVERT DELAY TO TODCLK FORMAT
	IMULI 2,^D<3600*24>	;DAYS TO SECONDS
	ADDI 2,(1)		;PLUS PART OF DAY
	IMULI 2,^D1000		;TO MILLISECONDS
	ADD 2,TODCLK		;PLUS CURRENT TIME
	MOVEM 2,HSYST2		;IS SHUTDOWN TIME.
	SETZM HSYST3		;NO MSG BEEN TYPED YET.
	UMOVE 2,2		;GET BACK UP TIME FROM USER
	CAMG 2,HSYST1		;MINIMAL RANGE CHECK IT
	MOVEI 2,0		;JUNK. ASSUME UNKNOWN
	MOVEM 2,HSYST4		;SAVE FOR EXEC TO TELL USERS.
	UMOVE 2,3		; GET REASON FOR DOWN TIME
	ANDI 2,17		; RESTRICT TO 4 BITS
	MOVEM 2,HSYST5
	AOS JB0FLG		;WAKE JOB 0 TO SEE THIS
	JRST SKMRTN		;AND GIVE SUCCESS RETURN TO USER.

EXTERN HSYST1,HSYST4		;GTAD FORMAT, IN SYSTAT GETAB TABLE
EXTERN HSYST5			;REASON CODE FOR SHUTDOWN (A LA 1822)
LS HSYST2,1			;TODCLK AT SHUTDOWN
LS HSYST3,1			;TODCLK FOR NEXT MSG TYPEOUT

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS:	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;FORK STARTED BY CHKR AT ARMAGEDDON TIME.
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVSI 1,UMODF		;FAKE UP SLOW JSYS ENTRY
	MOVEM 1,FPC		; ..
	JSYS MENTR		; ..
	SETZM ENTFLG		;PREVENT NEW JOBS
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;WHAT TTY IS THE JOB ON?
	CAME 1,OTYLIN		;ONE OF THE PRIVILEGED ONES?
	CAIN 1,CTYLIN		; ..
	JRST HSYS41		;YES. LET IT STAY ON
	MOVEI 1,(6)		;NO, LOG OUT THIS JOB NUMBER
	LGOUT			; ..
	  JFCL
	JRST HSYS41

HSYS7:	MOVEI 5,^D120000	;MAX TIME FOR JOBS TO LOG OUT
	ADD 5,TODCLK		;LOGGING OUT
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;TTY NUMBER OF THIS JOB
	CAME 1,OTYLIN		;PRIVILEGED?
	CAIN 1,CTYLIN		; ..
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8

HSYS9:	SETZM NXTDMP		;INITIATE DDMP
	SETZM DDTIME
	AOS JB0FLG
	MOVEI 5,^D30		;MAX TIME FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN CGFLG		;EVERYTHING FINISHED?
	SKIPL NXTDMP
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS9		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVEI 1,CTYLIN		;ANNOUNCE SHUTDOWN.
	HRROI 2,[ASCIZ /SHUTDOWN COMPLETE.
/]
	TTMSG
	MOVEI 1,^D15000		;FINALLY FOR TTY OUTPUT TO QUIT,
	DISMS			; WAIT JUST A BIT MORE
	MOVE 1,OTYLIN		;NOW HALT OR HALTF DEPENDING ON
	MOVEI 2,CTYLIN
	SKIPGE TTFORK(1)	;WHETHER A JOB IS STILL ON CTY/OTY
	SKIPL TTFORK(2)		; ..
	HALTF			;SOMEONE STILL ON. KEEP RUNNING.
	JRST [	PIOFF 610000	;CLEAR EVERYTHING
		CONO APR,200000	;IOB RESET
		SETOM ENTFLG	; IN CASE CONTINUED
		JRST 4,SYSRST]

;ROUTINE TOSEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	PUSH P,1		;1 CONTAINS NUMBER OF MINUTES
	SETO 1,
	HRROI 2,[SYSNAM(<ASCIZ /
*** >,< GOING DOWN IN />)]
	TTMSG
	MOVE 2,0(P)		;GET NUMBER OF MINUTES AGAIN
	CAIN 2,1		;THE 'ONE' CASE?
	JRST [	HRROI 2,[ASCIZ /ONE MINUTE!! ***
/]
		JRST HSYS51]	;YES, SPECIAL MESSAGE
	MOVEI 1,1(P)		;USE STACK TO HOLD STRING
	ADD P,BHC+2
	HRLI 1,440700
	PUSH P,1
	MOVEI 3,^D10
	NOUT
	JFCL
	POP P,2			;POINTER TO STRING
	SETO 1,
	TTMSG			;PRINT NUMBER
	SUB P,BHC+2		;FLUSH TEMPS FROM STACK
	HRROI 2,[ASCIZ / MINUTES. ***
/]
HSYS51:	SETO 1,
	TTMSG
	POP P,1			;RETURN NUMBER OF MINUTES
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

CHKR:	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADDI 1,^D240000		;NOW PLUS TWO MINUTES
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SKIPE BUGHLT		;BUGHLTS LATELY?
	CALL CHKHLT		;REPORT
	SKIPE BUGCHK		;BUGCHK?
	CALL CHKBUG		;YES
	SKIPE BUGNTE		;BUGNOTES LATELY?
	CALL CHKNTE		;YES

IFDEF TYMSW,<CALL TYMJB0>

	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE 1,DRMCFE		;DRUM ERROR COUNT
	CAME 1,CHKDMC		;DIFFERENT FROM LAST TIME?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT FROM LAST CHECK?
	CALL CHKDE1		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK		;PRINT INFO

IFN SUMEX,<CALL TTYPCK>		;CHECK TTY HARDLINE INITIAL TYPE TABLE
				;!! MAH @ SUMEX !!

IFDEF IMPCHN,<
	CALL CHKNET		;YES, LOG IT
>
	CALL DDERJ		;CHECK FOR DISK/DRUM RECOVERABLE ERRORS
				;!! MAH @ SUMEX 7/75 !!
	CALL DDMP		;DISK BACKUP
	SKIPE HSYST2		;SYSTEM SHUTTING DOWN?
	CALL CHKHSY		;YES. CHECK HSYS TIMERS.
	MOVE 2,TODCLK		;SETUP DISMISS CONDITION FOR
	ANDI 2,377777		;NOW PLUS 30 SEC
	MOVSI 1,^D30000(2)
	HRRI 1,JB0TST		;OR JB0FLG
	JSYS EDISMS
	JRST CHKR

	RESCD

JB0TST:	MOVE 3,4		;SAVE RETURN
	JSP 4,BLOCKW		;TEST CLOCK
	SKIPE JB0FLG		;OR FLAG
	JRST 1(3)		;RUN
	JRST 0(3)

	SWAPCD

CHKH1:	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
CHKR1:	GTAD			;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	MOVEI 1,37
	PBOUT
	RET

CHKHLT:	HRROI 1,[ASCIZ /
*****BUGHLT AT /]
	PSOUT
	HRRZ 2,BUGHLT
	SETZM BUGHLT
	JRST CHKBG1


;BUGNOTE OUTPUT

CHKNTE:	HRROI 1,[ASCIZ /
***** BUGNOTE AT /]
	PSOUT
	HRRZ 2,BUGNTE
	SETZM	BUGNTE		;CLEAR IT SO WE DONT PRINT IT AGAIN
	SOJA 2,CHKBG1		;SUB TO POINT AT JSR AND GO FIND BUGSTRING

CHKBUG:	HRROI 1,[ASCIZ /
*****BUGCHK AT /]
	PSOUT
	HRRZ 2,BUGCHK
	SUBI 2,1		;TO POINT AT JSR
	SETZM BUGCHK
CHKBG1:	PUSH P,2		;SAVE ADDRESS
	CALL CHKH1		;PRINT IT
	SKIPE NBUGTP		;HAVE BUG TABLE NOW?
	JRST BUGLK5		;YES
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>BUGTABLE.>,<\>)]
	GTJFN
	JRST BUGLK0
	MOVE 2,[44B5+1B19]
	OPENF
	JRST BUGLK0
	BIN			;FIRST WORD IS (NEG) COUNT OF PTRS
	MOVEM 2,NBUGTP
	MOVE 7,[XWD -SBUGTF,BUGTAB]
BUGLK3:	BIN
	JUMPN 2,BUGLK2
	GTSTS
	TLNE 2,(1B8)		;EOF?
	JRST BUGLK4		;YES
	SETZ 2,
BUGLK2:	MOVEM 2,0(7)
	AOBJN 7,BUGLK3
BUGLK4:	CLOSF
	JFCL
BUGLK5:	POP P,1			;BUG ADDRESS
	HRLZ 7,NBUGTP
BUGLK1:	MOVE 6,BUGTAB(7)
	HLRZ 2,6
	CAME 1,2
	AOBJN 7,BUGLK1
	JUMPGE 7,R		;FAILED TO FIND ADDRESS, PRINT NOTHING
	HRROI 1,[ASCIZ / - /]
	PSOUT
	HRROI 1,BUGTAB(6)	;STRING STORAGE RELATIVE TO START OF TABLE
	PSOUT
	JRST CHKR2		;PRINT EOL AND RETURN

BUGLK0:	HRROI 1,[ASCIZ @ - (FAILED TO GTJFN/OPEN BUGTABLE FILE)
@]
	PSOUT
	POP P,1
	RET

LS NBUGTP,1		;NEG COUNT OF PTRS IN BUGTABLE

;CHECK IF SYSTEM SHUTDOWN MESSAGE NEEDS TO BE TYPED.
;CALLED ONLY FROM JOB 0, CHKR ROUTINE.

CHKHSY:	SKIPE HSYST1		;HAS SOMEONE ABORTED THE SHUTDOWN?
	JRST CHKHS1		;NO.
	SETZM HSYST2		;YES. CLEAR THESE TWO FLAGS
	SETZM HSYST3		; ..
	RET			;AND BACK TO CHKR

CHKHS1:	SKIPE HSYST3		;ANY MESSAGES BEEN SENT AT ALL?
	JRST CHKHS2		;YES.
	MOVE 1,HSYST2		;NO, SEE IF ONE SHOULD BE SENT NOW.
	SUB 1,TODCLK		;TIME TO SHUTDOWN
	MOVE 2,HSYST2		;ALSO COMPUTE 1 HR BEFORE SHUTDOWN
	SUB 2,[^D<60*60*1000>]	; ..
	CAMG 1,[^D7200000]	;IS IT OVER 2 HRS TILL SHUTDOWN?
	MOVE 2,TODCLK		;NO. NOTIFY NOW, ELSE AT 1 HR BEFORE.
	MOVEM 2,HSYST3		;STORE NOTIFY TIME.
CHKHS2:	MOVE 1,TODCLK		;TIME NOW.
	CAMGE 1,HSYST3		;UP TO NOTIFICATION TIME?
	JRST CHKHS3		;NO. DO NOTHING.
	MOVE 1,HSYST2		;YES. COMPUTE TIME TILL SHUTDOWN.
	SUB 1,TODCLK		; ..
	ADDI 1,^D30000		;ROUND TO NEAREST MINUTE
	IDIVI 1,^D60000		;TO INTEGER MINUTES
	JUMPLE 1,CHKHS4		;GO KILL TENEX IF IT'S TIME.
	CALL THSYS		;NOT TIME YET. SAY HOW LONG TO ALL TTY'S
	MOVE 3,[POINT 9,CTIMS]	;FIND WHEN NEXT NOTIFY SHOULD BE
	ILDB 2,3		;LOOK THRU LIST OF TIMES
	CAMG 1,2		;SHORTER TIME?
	JUMPG 2,.-2		;NO. LOOK ON. (JUMPG IN CASE IMPOS ERR)
	IMULI 2,^D60000		;BACK TO MILLISECONDS
	MOVNS 2			;TIME BEFORE DEATH
	ADD 2,HSYST2		; ..
	MOVEM 2,HSYST3		;STORE FOR NEXT TYPEOUT TEST
CHKHS3:	RET			;DONE FOR THIS TIME.

CHKHS4:	SETZM ENTFLG		;THE TIME HAS COME. START SHUTDOWN.
	SETZM HSYST1		;CLEAR FLAGS IN CASE RESTARTED,
	SETZM HSYST2		; AND TO PREVENT MULTIPLE HSYS4 FORKS
	SETZM HSYST3		; ..
	MOVSI 1,(1B1)		;CREATE A FORK WITH CAPABILITIES
	CFORK			; ..
	  BUG (HLT,<JOB 0 CFORK FAILED - HSYS>)	;OH WELL, TIME TO QUIT..
	MOVEI 2,HSYS4		;WHERE TO START INFERIOR, EXEC MODE.
	MSFRK			;START IT.
	RET			;AND THATS ALL CHKR DOES ABOUT IT.

CHKDRM:	MOVEM 1,CHKDMC		;STORE NEW COUNT
	HRROI 1,[ASCIZ /
*****DRUM ERR: /]
	PSOUT
	MOVEI 6,DRMCFE
	JRST CHKDE2

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****DRUM SPACE LOW, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****SPT SPACE LOW, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1

CHKDSK:	MOVEM 1,CHKDNE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
***NON-REC DISK ERROR: /]
	MOVEI 6,DSKNRE		;5 WORD BLOCK OF COMMANDS AND ERR BITS
CHKDE2:	PSOUT
	MOVEI 1,101
	HRLI 6,-5		;REPORT 5 WORDS (COUNT + 4 STATUS WORDS)
	MOVE 3,[1B0+1B2+1B3+^D12B17+^D8] ;IN MAGNITUDE OCTAL WITH LEADING 0's
CHKD1:	MOVE 2,0(6)
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
	AOBJN 6,CHKD1
	JRST CHKR1

CHKDE1:	MOVEM 1,CHKDRE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
*DISK ERROR: /]
	MOVEI 6,DSKRCE		;5 WORD BLOCK OF COMMANDS, ETC.
	JRST CHKDE2

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****JOB 0 CRASH, CONTINUING
/]
	PSOUT
	JRST CHKR

LS CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
LS CHKDNE,1			; "" NON-REC. ""
LS CHKDMC,1

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO
;code from getpat+1 thru getpa1-1 added to support interlisp
;feature of finding out what system it's running on without
;mapping in pa1050

GETPAT:	JSYS MENTR		;GETS HERE FROM UUO HANDLER

;the following check allows lisp to determine that it's
;running on a 10x without mapping in pa1050

	MOVE 1,KI40		; Pick up user's call
	TLZ 1,777
	CAME 1,[47000,,41]	; CALLI 41?
	 JRST GETPA1
	LDB 2,[POINT 4,KI40,12]	; Pick up AC
	UMOVE 1,0(2)
	CAME 1,[112,,11]	; Want system type?
	 JRST GETPA1		; No
	MOVEI 1,30000		; Say a TENEX
	UMOVEM 1,0(2)		; Return to user
	JRST SKMRTN
GETPA1:	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCTUU PATUPC
	MOVE 1,KI40
	XCTUU PATU40
	JRST MRETN		;GO TO COMPATIBILITY

;INFO JSYS'S

.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.JOBTM:
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
	SUB 1,OLDTCK
	ADD 1,TODCLK
	ADD 1,JOBRTT
	XCT MJRSTF

.RUNTM:	JSYS MENTR
	JSP 3,UCLOCK		;UPDATE CLOCKS
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	JSYS MENTR
	CALL SETLFK
	MOVE 3,PTTIM(1)	;FIX SUGGESTED BY R. SCHULTZ
	MOVE 2,USWPCT(1)
	MOVE 1,UTRPCT(1)
	JRST RETA3

;GET DIRECTORY ALLOCATION

.GTDAL:	JSYS MENTR

IFN SUMEX,<
	JUMPN 1,[PUSH P,1		;SAVE DIR NUM
		 CALL GETDDB		;DIR NUM OK?
		  JRST [POP P,1		;NO, RESET STACK
			SETO 1,
			UMOVEM 1,1
			JRST MRETN]
		 CALL USTDIR		;UNLOCK DIR
		 POP P,1		;GET DIR NUM AGAIN
		 JRST GTDAL1]
> ;END IFN SUMEX

	MOVE 1,JOBNO
	HLRZ 1,JOBDIR(1)	;1 ZERO, USE CONNECTED DIR
GTDAL1:	SETO 2,
	CALL MAPDIR
	HLRZ 1,DIRDSK		; GET MAXIMUM ALLOCATION
	UMOVEM 1,1
	HRRZ 1,DIRDSK		;CURRENT IN-USE COUNT
				;(DOESN'T INCLUDE PAGES CREATED FOR
				; FILES WHICH ARE STILL OPEN)
	UMOVEM 1,2
	JRST MRETN


;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

REPEAT 0,<
.SYSGT:	JSYS MENTR
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ 1,GTTAB(4)		;ADDRESS OF FIRST WORD
	MOVE 1,0(1)
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

.GETAB:	JSYS MENTR
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR GTABX3		;NO  *** CHANGE TO GTABX3 ASAP ***
	HLRE 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR GTABX1		;NO
	HLRZ 1,GTTAB(3)		;GET SIZE OF TABLE
	JUMPL 2,RETN1		;RETURN SIZE IF INDEX .LESS.0
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR GTABX2
	ADD 2,GTTAB(3)		;COMPUTE ADDRESS OF DESIRED WORD
	MOVE 1,0(2)		;GET WORD
RET1:	UMOVEM 1,1		;RETURN IT TO USER
URSKP:	AOS 0(P)		;SKIP RETURN
	JRST MRETN

RETN1:	XCTUU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	JRST URSKP		;SKIP RETURN
> ;END REPEAT 0

.SYSGT:	MOVSI 2,-GTBSIZ
	CAMN 1,SYMTAB(2)
	JRST SYSGT1
	AOBJN 2,.-2
	SETZ 2,0
	XCT MJRSTF
SYSGT1:	HLRZ 1,GTTAB(2)
	MOVN 1,1
	HRLI 2,(1)
	HRRZ 1,GTTAB(2)
	MOVE 1,(1)
	XCT MJRSTF

.GETAB:	MOVEM 2,TW1
	MOVEM 3,TW2
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK
	JRST	[MOVE 2,TW1
		 JSYS MENTR
		JRST RETN14 ]
	HLRE 2,1
	MOVEI 3,(1)
	CAIL 3,GTBSIZ
	JRST	[MOVE 2,TW1
		 MOVE 3,TW2
		 JSYS MENTR
		JRST RETN12 ]
	HLRZ 1,GTTAB(3)
	JUMPL 2,RETN10
	CAIL 2,(1)
	JRST	[MOVE 2,TW1
		MOVE 3,TW2
		JSYS MENTR
		JRST RETN13]
	CAIL 2,4
	JRST RETN15		;NO SYSTAT
	MOVEI 1,GTTAB(3)
	CAIN 1,GST0
	JRST 	[MOVEI 1,-KIEPT+KIEPT0
		JRST RETN16 ]
	CAIN 1,GST1
	JRST	[MOVEI 1,-KIEPT+KIEPT1
		JRST RETN16]
RETN15:	ADD 2,GTTAB(3)
	MOVE 1,(2)
RETN11:	HRRZ 2,FPC
	CAIE 2,777777
	AOS FPC
	MOVE 2,TW1
	MOVE 3,TW2
	XCT MJRSTF
RETN10:	MOVNM 1,1
	JRST RETN11
RETN16:	ADDI 2,SKDTM0(1)
	MOVE 1,(2)
	JRST RETN11

RETN12:	RETERR GTABX1
RETN13:	RETERR GTABX2
RETN14:	RETERR GTABX3
IFN SUMEX+IMSSS,<	;code by RON @ IMSSS, inserted by MAH @ SUMEX 11/74
;GTBLT -- BLT PIECE OF TABLE TO USER -- GET MANY ENTRIES AT ONCE
;AC1 LH: IDX TO BEGIN, RH: TABLE NO.
;AC2 LH: NO. OF ENTRIES TO MOVE, RH: BUFFER ADR IN USER SPACE
;IF LH OF AC1 = -1, THEN IGNORE LH OF AC2 AND BLT WHOLE TABLE

.GTBLT:: JSYS MENTR		;SLOW DOWN
	MOVSI 3,(1B1)
	TDNN 3,CAPMSK	;GETAB CAPABILITY?
	 RETERR GTABX3	;NO
	HLRE 3,1	;INDEX OR -1
	MOVEI 4,(1)	;TABLE NUMBER
	CAIL 4,GTBSIZ	;LEGAL NUMBER?
	 RETERR GTABX1	;NO
	HLRZ 1,GTTAB(4)	;GET SIZE OF TABLE
	JUMPL 3,WHOLTB	;BLT WHOLE TABLE IF INDEX .LESS. 0
	HLRZ 5,2	;GET NO. OF ENTRIES
	JUMPE 5,GTBLT1	;LH 2 .EQ. 0 IS A NOP
	ADDI 5,(3)	;PLUS BEGINNING IDX TO GET END
	CAILE 5,(1)	;INDEX WITHIN BOUNDS?
	 RETERR GTABX2	;NO
	ADD 3,GTTAB(4)	;COMPUTE ADDRESS 0F DESIRED BEGINNING
	HLRZ 5,2	;GET COUNT TO BLT
	ADDI 5,(2)	;ADD BUFFER ADR TO GET LAST ENTRY +1
	HRL 2,3		;PUT BEGINNING ADR IN LH OF 2

BLTAB1:	HLRZ 6,2
	CAIGE 6,SKDTMX+4
	CAIGE 6,SKDTMX
	JRST BLTABL
	MOVEI 1,GTTAB(4)
	CAIN 1,GST0
	JRST GTBLTA
	CAIN 1,GST1
	JRST GTBLTB

BLTABL:	XCTMU [BLT 2,-1(5)] ;DO THE BLT
GTBLT1:	AOS (P)		;SKIP RETURN
	JRST MRETN

WHOLTB:	HRL 2,GTTAB(4)	;BEGINNING OF TABLE
	ADDI 1,(2)	;BUFFER ADR + SIZE IS END OF BLT +1
	MOVEI 5,(1)	;INTO 5 FOR THE BLT
	JRST BLTAB1	;DO THE BLT

GTBLTA:	MOVE 1,[XWD -KIEPT+KIEPT0,SKDTMX]
	SKIPA
GTBLTB:	MOVE 1,[XWD -KIEPT+KIEPT1,SKDTMX]
	ADD 1,[XWD SKDTM0,0]
	BLT 1,SKDTMX+3
	JRST BLTABL

>;end SUMEX+IMSSS 

;TABLE OF TABLES

	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN NSTAT,SKDTM0,TOTRC,MAXQ,QSUM,SKDTMX

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKRCE
	XWD NDRMEW,DRMCFE
	XWD SVNN,SVN
	XWD 1,SVNUM
	XWD 3,UTRPCT
GST0:	XWD NSTAT,SKDTMX
GST1:	XWD NSTAT,SKDTMX
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
	XWD 2,DBUGSW		;DBUGSW AND DCHKSW
	XWD 2,LOGDES
	XWD GTBSIZ,SYMTAB	;THE 6BIT SYMBOLS
	XWD 1,[ CTYLIN ]
	XWD 4,DRMFRE
	XWD NJOBS,JOBISK
	XWD NJOBS,JOBQNT
IFN IMSSS,<
	XWD NJOBS,KIDNUM
	EXTERN KIDNUM
>
IFN SUMEX+IMSSS,<
	EXTERN FKSTAT,FKWSP,FKPGST,FKQ,FKPT,FKJOB,FKNR,FKTIME
	XWD NFKS,FKSTAT
	XWD NFKS,FKWSP
	XWD NFKS,FKPGST
	XWD NFKS,FKQ
	XWD NFKS,FKPT
	XWD NFKS,FKJOB
	XWD NFKS,FKNR
	XWD NFKS,FKTIME
>
IFN SUMEX,<
	XWD 1,[DTYLO+NDTY-1,,DTYLO]
	XWD 1,[TYMTTL+NTYMTT-1,,TYMTTL]
	XWD 1,[NVTLO+NNVTLN-1,,NVTLO]
	XWD 3,SPTIM1		;SPECIAL I/O WAIT TIMERS
	XWD NJOBS,JOBAL		;JOB TIME IN BALANCE SET
	XWD NJOBS,JOBGO		;JOB TIME ON GOLIST
	XWD NJOBS,JOBTAL	;INTERGAL OF FORKS AND TIME IN BALANCE SET
	XWD NJOBS,JOBTGO	;INTERGAL OF FORKS AND TIME ON GOLIST
	XWD 2,PAGMOV		;PAGE MIGRATION STATISTICS
	XWD 1,TOPDIR		;COPY OF LSTDNO
	XWD NDVMAX,DSKSTS	;DSK STATUS
	XWD NDVMAX,DRIVTB	;LOG TO PHYS DRIVE TABLE
	XWD DSKTSZ,DSKTAB	;VARIOUS DSK PARMS
	XWD NLINES,TTLINK
	XWD SPYSIZ,SPYTAB	;PC SAMPLER
>
IFDEF IMPCHN,<		;NETWORK RELATED TABLES
	EXTERN NHOSTS,HOSTN,LSKT,FSKT,NETAWD,NETBAL,NETSTS,NETBUF
	EXTERN NHSTN,HSTNAM,NETBTC
	XWD 3,IMPRDY
	XWD IMPLBT,IMPHRT
GTBNHN::	XWD NHSTN,HSTNAM
GTBHST::	XWD NHOSTS,HOSTN
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD NSKT,NETAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
	XWD NSKT,NETBTC
	XWD IMPNLK,IMPLT1
	XWD IMPNLK,IMPLT2
	XWD IMPNLK,IMPLT3
	XWD IMPNLK,IMPLT4
	XWD 2,NLHOST		;HOST NUMBER, NVT COUNTER
>
GTBSIZ==.-GTTAB
	BLOCK 10

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB:	SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
	SIXBIT /DRMERR/
	SIXBIT /SYSVER/
	SIXBIT /VERNUM/
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /SYSTA1/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
	SIXBIT /DBUGSW/
	SIXBIT /LOGDES/
	SIXBIT /SYMTAB/
	SIXBIT /CTYLIN/	;OPERATOR CONSOLE TTY LINE
	SIXBIT /SWPSTS/	;SWAPPING STATISTICS
	SIXBIT /JOBISK/	;RESERVATION SYSTEM--HEAVY OR LIGHT 
	SIXBIT /JOBQNT/	;QUANTUM LEFT FOR JOB
IFN IMSSS,<
	SIXBIT/STUNUM/
>
IFN SUMEX+IMSSS,<
	SIXBIT /FKSTAT/
	SIXBIT /FKWSP/
	SIXBIT /FKPGST/
	SIXBIT /FKQ/
	SIXBIT /FKPT/
	SIXBIT /FKJOB/
	SIXBIT /FKNR/
	SIXBIT /FKTIME/
>
IFN SUMEX,<
	SIXBIT /DIALIN/
	SIXBIT /TYMLIN/
	SIXBIT /NVTLIN/
	SIXBIT /SPTIME/
	SIXBIT /JOBAL/
	SIXBIT /JOBGO/
	SIXBIT /JOBTAL/
	SIXBIT /JOBTGO/
	SIXBIT /PAGMOV/
	SIXBIT /TOPDIR/
	SIXBIT /DSKSTS/
	SIXBIT /DRIVTB/
	SIXBIT /DSKTAB/
	SIXBIT /TTLINK/
	SIXBIT /SPYTAB/
>
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HSTNAM/
	SIXBIT /HOSTN/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
	SIXBIT /NETBTC/
	SIXBIT /IMPLT1/
	SIXBIT /IMPLT2/
	SIXBIT /IMPLT3/
	SIXBIT /IMPLT4/
	SIXBIT /LHOSTN/
>
IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>
	BLOCK 10

;SUBSYSTEM STATISTICS LOGIC

.SETNM:
IFN SUMEX,<
	CAMN 1,SNAMES		;QUICKIE CHECK FOR EXEC
	 JRST	[MOVE	1,JOBNO
		SETZM	JOBNAM(1)
		MOVE	1,SNAMES ;IN CASE USER COUNTING ON NO CHANGE
		XCT	MJRSTF]
> ;END IFN SUMEX
	JSYS MENTR
	NOINT
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOS SNMPT		;UPDATE POINTER
	MOVEM 1,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	JRST MRETN

GS SNMPT,1		;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1		;LOCK FOR SNAMES TABLE

.GETNM:	MOVE 1,JOBNO
	HRRZ 1,JOBNAM(1)
	MOVE 1,SNAMES(1)
	XCT MJRSTF

.SWTCH:
	DATAI APR,1
	XCT MJRSTF

.LITES:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER+MAINT	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

.USRIO:	JSYS MENTR
	MOVEI 1,WHEEL+OPER+MAINT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR CAPX1
	SCPU0
	MOVE 1,FORKX
	MOVSI 2,(1B3)
	IORM 2,FKCNO(1)		;SET BIT TO RUN ON CPU0 ONLY
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	JRST SKMRTN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK:	JSYS MENTR
	MOVEI 3,WHEEL+OPER+MAINT
	TDNN 3,CAPMSK		;HAS NECESSARY CAPS?
CAPX:	ITERR CAPX1		;NO.
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	ADDI 6,-1(3)		; .. TO LIMIT
	ADDI 3,-1(1)		;FROM LIMIT
	XORI 3,0(1)		;SEE IF BLOCK CROSSES PAGE BOUNDARY
	TRNE 3,777000
	RETERR PEEKX1		;CAN'T CROSS PAGE BOUNDARY
	MOVEI 1,0(1)
	MRPAC			;GET ACCESS OF PAGE
	TLNN 2,READB		;READ ALLOWED?
	RETERR PEEKX2		;NO
	XCTMU [BLT 5,0(6)]	;TRANSFER WORD(S)
	AOS 0(P)
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;LOGOUT
INTERN LOG7
.LGOUT:	JSYS MENTR
LOG7:	NOINT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO
LOGO:	SKIPE FORKN		;TOP FORK?
	JRST [	MOVSI 1,LOG
		TDNN 1,CAPMSK	;LOG PERMITTED?
		JRST LOGOE1	;NO, ERROR RETURN
		HLRZ 1,FORKN	;NO, GET ITS NUMBER
		HRRZ 2,SYSFK(1)
		NOSKED
		NOPI
		HLOCK PSILCK
		MOVSI 1,400000+PSILOB
		IORM 1,FKINT(2)	;REQUEST LOGOUT
		CALL PSIR4
		OKSKED
		RESKED
		OKINT
		JRST HALTF1]	;HALT THIS ONE
FLOGO1:				;LOGOUT PSI REQUEST ENTERS HERE
IFDEF DSPCHN,<
	SETO 1,
	RELDP
	RELDC>
	MOVEI 1,-4
	KFORK			;DELETE FORKS
	SETO 1,			;CLEAR USER MAP OF TOP FORK
	MOVSI 2,400000
FLOGO2:	SKIPE UPTA(2)
	PMAP
	ADDI 2,1
	TRNN 2,1000
	JRST FLOGO2
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
IFE SUMEX,<
	MOVE 1,[1B5+400000]	;INSIST + THIS FORK
	CLZFF
	MOVE 1,JOBNO
	HLRZ 1,JOBDIR(1)	;CONNECTED DIRECTORY
	DELDF			;DELETE DELETED FILES
>;END IFE SUMEX
IFN SUMEX,<
L.EXP:	MOVE 1,[1B5+400000]
	CLZFF
	MOVE 1,JOBNO
	HRRZ 1,JOBDIR(1)
	MOVEI 2,L.EXPT		;TABLE OF EXCEPTIONS
L.EXP1:	SKIPG 3,(2)
	JRST L.EXP2		;END OF TABLE
	CAIN 1,(3)
	JRST L.EXP4		;NO EXPUNGE
	AOJA 2,L.EXP1		;KEEP LOOPING
L.EXP2:	MOVSI 2,-NJOBS		;SEARCH FOR OTHER JOB LOGGED IN
	SETO 3,0
L.EXP3:	HRRZ 4,JOBDIR(2)
	CAIN 1,(4)
	AOJG 3,L.EXP4		;MORE THAN ONE EXIT
	AOBJN 2,L.EXP3
	DELDF
	JRST L.EXP4

L.EXPT:	13			;LEDERBERG'S PRIME DIR
	-1
	-1
	-1			;SPARES

L.EXP4:
>; END OF IFN SUMEX

	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
IFN IMSSS,<
	SKIPGE CTRLTT
	JRST LOG6		;DETACHED
	MOVEI 1,100		;TEST FOR KIDDY
	RFMOD
	TRNN 2,4
	JRST LOG6		;DONT DO ANYTHING FOR NOW
	TRZ 2,3B29		;SET BINARY MODE
	SFMOD
	MOVEI 2,4
	BOUT			;SEND CONTROL D FOR KIDDIES
	MOVNI 1,5
	RUNTM
	MOVE 5,2
	IDIVI 1,(5)		;GET SECONDS
	HRR 2,1
	IDIVI 3,(5)	
	HRL 2,3
	SETZB 3,4
	MOVE 1,JOBNO
	HRRZ 1,KIDNUM(1)
	LSH 1,^D21
	TLO 1,400000		;SET LOGOUT BOOK
	LOGSV			;DO LOGSAV
LOG3:	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK
	JFCL
	JRST LOG2
>
LOG6:	MOVE 1,JOBNO
	HRRZ 1,JOBDIR(1)
	JUMPE 1,LOG1		;IF JOB NOT LOGGED IN
	MOVE 1,LOGDES
	CALL LOGTOT		;SUMMARY TO LOG TTY
LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
;*****KI-10 CHANGE DECLINED (HANG-UP AFTER AOUTOLOGOUT? ****
;
;
;	BUGFIX--PRINT MSG AFTER BREAKING LINKS SO STACK WONT OVERFLW
	HRRZ 1,CTRLTT
	MOVEI 1,400000(1)
	CALL LOGTOT	;PRINT LOGOUT MESSAGE
;
	MOVE 2,CTRLTT
	CALL TTHNGU		;HANG UP LINE
LOG2:	JRST HLTJB

ELOGO:	MOVE 2,JOBNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN 2,0(1)		;SELF?
LOGOE1:	RETERR LOUTX1		;YES, CAN'T SAY IT THAT WAY
	CAIGE 1,NJOBS		;REASONABLE NUMBER?
	CAIG 1,0
LOGOE2:	RETERR LOUTX2		;NO
	SKIPGE JOBRT(1)		;EXISTS?
	JRST LOGOE2
	HRRZ 3,JOBDIR(1)	;LOGIN DIRECTORY OF OBJECT JOB
	XOR 3,JOBDIR(2)
	TRNN 3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	MOVEI 3,WHEEL+OPER+MAINT	;OTHERWISE MUST BE WHEEL
	TDNN 3,CAPENB
	JRST LOGOE1		;ILLEGAL
ELOGO1:	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	NOSKED
	JRST  [	NOPI
		HLOCK PSILCK
		MOVSI 1,400000+PSILOB
		IORM 1,FKINT(2)		;REQUEST LOGOUT
		CALL PSIR4
		JRST .+1]
	OKSKED
	RESKED
	AOS 0(P)		;RETURN GOOD
	JRST MRETN

FLOGO:	SKIPGE SLOWF		;ALREADY IN JSYS?
	JSYS MENTR		;NO, DUMMY UP ENTRY
	NOINT
	MOVE P,UPP		;MAKE SURE WE HAVE EMPTY STACK
	ADD P,BHC+2
	JRST FLOGO1

;LOGGING FUNCTIONS

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT:	CAIL 1,0
	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /KILLED/]
	CALL LOGMES
	CALL LOGJOB		;PRINTS JOB NO, TTY NO, TIME
	HRROI 2,[ASCIZ /
  USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5		;FOR WHOLE JOB
	RUNTM
	MOVEM 1,3(7)		;RUNTIME FOR EFACT
	MOVEM 3,4(7)		;CONSOLE TIME FOR EFACT
	MOVE 2,1
	POP P,1
	PUSH P,3
	CALL LOGTIM		;PRINT CPU TIME
	HRROI 2,[ASCIZ / IN /]
	CALL LOGMES
	POP P,2
	CALL LOGTIM		;PRINT CONSOLE TIME
	CAME 1,LOGDES		;ON LOG TTY?
	JRST LOGCR		;NO
	MOVEI 2,141		;LOGOUT CODE
	DPB 2,[POINT 9,0(7),8]
	PUSH P,1
	MOVSI 1,-5		;SIZE OF LOGOUT BLOCK
LOGFCT:	HRRI 1,0(7)		;LOC OF LOGOUT BLOCK
	EXCH 1,0(P)		;OUTPUT DESIGNATOR
	CALL LOGCR
	EXCH 1,0(P)
	NOINT
	PUSH P,CAPENB
	MOVSI 2,LOG
	IORM 2,CAPENB		;BE SURE WE HAVE LOG CAPABILITY
	EFACT
	JSP 2,XEFACT		;CHECK EFACT FAILURE
	POP P,CAPENB		;RESTORE CAPS
	OKINT
	POP P,1
	RET

;CHECK EFACT FAILURE

XEFACT:	SKIPE ACCIFG		;ACCOUNTS SUPPOSEDLY INITIALIZED?
	BUG(CHK,<EFACT FAILURE>)
	JRST 0(2)		;NO, ALLOW EFACT FAILURE

LOGONM:
;LOGON MESSAGE, CALLED FROM .LOGIN
IFN IMSSS,<
	SKIPGE CTRLTT
	JRST .+5
	MOVEI 1,100
	RFMOD
	TRNE 2,4
	RET>

	SKIPL 1,LOGDES

	DOBE			;WAIT FOR OTHER USE OF TTY TO FINISH
	HRROI 2,[ASCIZ /LOGIN/]
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,501		;LOGIN CODE
LOGCJ1:	DPB 1,[POINT 9,0(7),8]
	MOVE 1,4(7)		;ACCOUNT WORD
	JUMPL 1,[SUBI 1,4	;STRING ACCOUNT, ROUND CHAR COUNT
		IDIVI 1,5	;COMPUTE WORD COUNT
		MOVSI 1,-5(1)	;ADD WORD COUNTS FOR STRING AND BLOCK
		JRST .+2]
	MOVSI 1,-5		;WORD COUND INCLUDES BLOCK ONLY
	JRST LOGFCT

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM:	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /CHANGED/]
	CALL LOGMES
	CALL LOGJOB
	HRROI 2,[ASCIZ /
 USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5
	RUNTM			;RUNTIME OF JOB
	MOVEM 1,3(7)		;SAVE FOR FACT FILE
	MOVE 2,1
	POP P,1
	CALL LOGTIM		;PRINT ON LOG TTY
	PUSH P,1
	MOVEI 1,502
	JRST LOGCJ1

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

DETMSG:	HRROI 2,[ASCIZ /DETACHED/] ;WORD FOR LOG TTY
	SKIPL 1,LOGDES
	DOBE
	CALL LOGMES
	CALL LOGJOB
	PUSH P,1
	MOVEI 1,143		;DETACH CODE
ATAMS2:	DPB 1,[POINT 9,0(7),8]
	MOVSI 1,-3		;SIZE OF BLOCK
	JRST LOGFCT

ATAMSG:	MOVEI 7,LOGBUF
	SKIPL 1,LOGDES
	DOBE
	HRROI 2,[ASCIZ /ATACHED JOB /]
	CALL LOGMES
	HLRZ 2,0(7)		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / TO TTY /]
	CALL LOGMES
	LDB 2,[POINT 12,0(7),29] ;TTY NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
	PUSH P,1
	MOVEI 1,142		;ATACH CODE
	JRST ATAMS2

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

LOGJOB:	MOVEI 7,LOGBUF		;BLOCK FOR EFACT
	HRROI 2,[ASCIZ / JOB /]
	CALL LOGMES
	MOVE 2,JOBNO
	DPB 2,[POINT 9,0(7),17]	;JOB NUMBER FOR EFACT
	CALL LOGNUM
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, USER /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRRM 2,1(7)		;DIRECT NUMBER FOR EFACT
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	JFCL
	HRROI 2,[ASCIZ /, ACCT /]
	CALL LOGMES
	MOVE 2,ACCTPT
	CALL LOGACC
LOGJ3:	MOVE 2,CTRLTT
	DPB 2,[POINT 12,0(7),29] ;TTY NUMBER FOR EFACT
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,CTRLTT
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:	HRROI 2,[ASCIZ /, AT /]
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	GTAD
	MOVEM 1,2(7)		;TOD FOR EFACT
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	MOVSI 3,045240		;MOST ABBREVIATED DATE AND TIME
	CAIL 2,0
	ODTIM
	RET

LOGJ1:	HRROI 2,[ASCIZ /, DETACHED/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	LDB 3,[POINT 3,2,2]
	CAIE 3,5		;STRING OR NUMBER?
	JRST LOGAC1		;STRING
	TLZ 2,700000
	MOVEM 2,4(7)		;ACCOUNT NUMBER FOR EFACT
	JRST LOGNUM		;PRINT NUMBER

LOGAC1:	SETZ 4,			;TO COUNT CHARS
	MOVE 3,2		;STRING PTR
LOGAC2:	ILDB 2,3		;CHAR OF ACCOUNT STRING
	JUMPE 2,LOGAC3		;NULL IS END OF STRING
	CAIL 1,0
	BOUT			;PRINT IT ON LOG TTY
	AOJA 4,LOGAC2		;COUNT IT

LOGAC3:	MOVNM 4,4(7)		;LEAVE NEG OF WORD COUNT FOR EFACT
	RET

LOGMES:	SETZ 3,
	JUMPL 1,R
	SOUT
	RET

LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	JUMPL 1,R
	NOUT
	BUG(CHK,<LGNOUT - NOUT FAILED>)
	RET

LOGCR:	MOVEI 2,EOL
	JUMPL 1,R
	BOUT
	RET

;FORK CREATION AND CONTROL JSYS'S

.CFORK:	JSYS MENTR
	NOINT
	MOVEI 1,-1
	CALL GFKH		;GET LOCAL HANDLE
	RETERR FRKHX6		;NONE
	PUSH P,1		;SAVE IT
	NOSKED
	MOVE 2,SPTC		;CURRENT SPT COUNT
	CAML 2,SPC1		;ROOM LEFT?
	JRST CFBAD		;NO
	SKIPE FREFK		;ROOM IN SYSTEM?
	SKIPN FREJFK		;ROOM IN JOB?
	JRST CFBAD		;NO
	JLOCK			;LOCK JOBLCK FOR THIS JOB
	CALL ASSFK		;ASSIGN FORK IN SYSTEM
	MOVE 1,FORKX
	MOVE 1,FKJOB(1)		;GET JOB NO AND JSB
	MOVEM 1,FKJOB(7)	;SET FOR NEW FORK
	JULOCK			;RELEASE JOBLCK
	OKSKED
	MOVSI 1,0(7)
	CALL WAITFK		;WAIT FOR IT TO INITIALIZE
	JLOCK			;LOCK JOBLCK AGAIN
	CALL ASSJFK		;ASSIGN JOB FORK SLOT
	HRRZM 7,SYSFK(1)
	SETZM FKPTRS(1)
	SETZM FKPSIE(1)
	SETZM FKDPSI(1)
	HRRZ 2,FORKN		;PUT NEW FORK INTO STRUCTURE LISTS
	MOVEI 6,FKPTRS(2)
	HLL 6,INFERP
	LDB 3,6			;GET INFERIORS OF THIS FORK
	DPB 1,6			;PUT NEW FORK AT HEAD OF IT
	MOVEI 6,FKPTRS(1)
	HLL 6,SUPERP
	DPB 2,6			;THIS FORK IS SUPERIOR OF NEW FORK
	HLL 6,PARALP
	DPB 3,6			;OTHER INFERIORS ARE PARALLEL TO NEW FORK
	PUSH P,1
	CALL SETLF1		;MAP PSB OF NEW FORK
	MOVE 2,0(P)		;NEW FORK'S JOB HANDLE
	MOVEM 2,FORKN(1)
	MOVE 2,JOBNO
	MOVEM 2,JOBNO(1)
	MOVE 2,PRIMRY
	MOVEM 2,PRIMRY(1)
	MOVE 2,JOBBIT
	MOVEM 2,JOBBIT(1)	;PASS PRIORITY
	SETZM CAPMSK(1)
	SETZM CAPENB(1)
	UMOVE 2,1		;GET ARG
	TLNE 2,(1B0)		;SAME MAP?
	CALL CFK4		;YES
	TLNE 2,(1B1)		;GIVE SPEC CAP?
	CALL CFK3
	TLNE 2,(1B3)		;INIT AC'S?
	CALL CFK1		;YES
	TLNE 2,(1B4)		;START FORK
	CALL CFK2
	CALL CLRLFK		;UNMAP PSB
	POP P,1
	MOVE 2,0(P)		;LOCAL HANDLE
	ANDI 2,377777
	IDIVI 2,2
	ADD 2,FKPTAB(3)
	DPB 1,2			;PUT JOB INDEX IN LOCAL TABLE
	JULOCK			;UNLOCK JOBLCK FOR THIS JOB
	POP P,1			;RETURN LOCAL HANDLE
	UMOVEM 1,1
	AOS 0(P)
	JRST MRETN

CFBAD:	OKSKED
	RETERR CFRKX3		;NO ROOM

;FORK CONTROL SUBRS

CFK1:	XCTUU [HRLZ 3,2]	;GET LOC OF INITIAL AC'S
	HRRI 3,PAC(1)		;MOVE TO NEW FORK'S PSB
	XCTUM [BLT 3,PAC+17(1)]
	RET

CFK2:	MOVEI 3,0(2)		;START ADDRESS
	HRLI 3,UMODF		;IN USER MODE
	MOVEM 3,PPC(1)
	MOVEI 3,JSKP
	MOVEM 3,FKSTAT(7)	;MAKE FORK RUNNABLE
	RET

CFK3:	MOVE 3,CAPMSK		;GIVE NEW FORK SAME SPEC CAP
	MOVEM 3,CAPMSK(1)
	MOVE 3,CAPENB
	MOVEM 3,CAPENB(1)
	RET

;'SAME MAP' BIT - CAUSES MAP OF INFERIOR TO BE FILLED WITH
;IND PTRS TO SUPERIOR

CFK4:	PUSH P,1
	PUSH P,2
	MOVSI 4,-1000		;SIZE OF MAP
	MOVE 1,FORKX
	HLLZ 1,FKPGS(1)		;SOURCE IS THIS FORK
	HLLZ 2,FKPGS(7)		;DEST IS NEW FORK
	MOVSI 3,RWX
CFK41:	HRRI 1,0(4)
	HRRI 2,0(4)		;EQUIV EACH PAGE
	CALL SETPT
	AOBJN 4,CFK41
	POP P,2
	POP P,1
	RET

; SPLICE FORK STRUCTURE
; 1/  FORK HANDLE OF NEW SUPERIOR
; 2/  FORK HANDLE OF FORK TO BECOME INFERIOR
; FORK SPECIFIED BY 2 IS MADE AN IMMEDIATE INFERIOR OF THAT SPECIFIED
; BY 1
; RETURNS FORK HANDLE OF 2 RELATIVE TO 1

.SPLFK:	JSYS MENTR
	NOINT
	JLOCK			;LOCK JOBLCK FOR THIS JOB
	HRRZS 1
	CALL SETJFK		; FIND JOB FORK HANDLE
	PUSH P,1		; SAVE IT
	CALL SKIIF		; MUST SELF OR INFERIOR
	 RETERR(SPLFX1)		; NOT, FAIL
	XCTUU [HRRZ 1,2]
	CALL SETJFK		; FIND JOB HANDLE FOR F2
	PUSH P,1		; SAVE IT
	CAME 1,FORKN		; MUST BE STRICTLY INFERIOR
	CALL SKIIF
	 RETERR(SPLFX2)
	MOVE 1,-1(P)		; ADDITIONALLY
	MOVE 2,0(P)		; F1 MUST NOT EQUAL OR INFERIOR TO
	CALL SKIIFA		; F2
	 SKIPA
	 RETERR(SPLFX3)
	NOSKED			;  REVENT FOULUPS WHILE WE MUNG
	MOVE 1,0(P)		; POINTERS
	ADD 1,SUPERP		; POINTER TO SUPERIOR OF F2
	LDB 1,1
	ADD 1,INFERP
SPLFK1:	LDB 2,1			; SEARCH FOR F2
	CAMN 2,0(P)
	 JRST SPLFK2		; FOUND F2
	MOVE 1,2
	ADD 1,PARALP
	JRST SPLFK1

SPLFK2:	ADD 2,PARALP
	LDB 3,2			; GET SUCCESSOR
	DPB 3,1			; AND PATCH AROUND F2
	MOVE 1,0(P)		; GET F2 AGAIN
	MOVE 2,-1(P)		; AND F1
	ADD 2,INFERP
	LDB 3,2			; GET FIRST INFERIOR OF F1
	DPB 1,2			; MAKE F2 NEW FIRST INFERIOR OF F1
	ADD 1,PARALP
	DPB 3,1			; APPEND OLD INFERIORS OF F1 TO F2
	MOVE 1,0(P)		; F1
	ADD 1,SUPERP
	MOVE 2,-1(P)		; F2
	DPB 2,1			; MAKE F1 SUPERIOR OF F1
	OKSKED			; POINTERS FIXED UP
	MOVE 1,-1(P)		; GET FORK HANDLE OF F1
	CALL SETLF1		; MAP PSB
	HRL 1,0(P)
	MOVSS 1			; SET UP ARG FOR GRFKH
	CALL GRFKH		; GET FORK HANDLE F2 RELATIVE TO F1
	 SETZ 1,		; RETURN 0 IF FAILED
	UMOVEM 1,1
	CALL CLRLFK
	SUB P,BHC+2		; STACK BACK TO RIGHT LEVEL
	JULOCK			;RELEASE JOBLCK
	JRST SKMRTN

WAITFK:	HRRI 1,WTFKT
	JSYS EDISMS
	RET

	RESCD			;SCHEDULER TEST, MUST BE RESIDENT

WTFKT:	HRRZ 2,FKPGS(1)
	JUMPE 2,0(4)		;NOT INITIALIZED YET
	HLRZ 2,FKPT(1)		;SCHEDULER TEST - GET STATE OF FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	JRST 1(4)		;YES

ASSJFK:	NOSKED
	MOVE 1,@FREJFK
	EXCH 1,FREJFK
	OKSKED
	SUBI 1,FKPTRS
	RET

	SWAPCD

.SEVEC:	JSYS MENTR
	CALL SETLFK
	JUMPE 2,SEV1		;ALL-0 IS LEGAL
	HLRZ 3,2		;GET SIZE
	CAIN 3,<JRST>B53	;10/50 STYLE?
	JRST SEV1		;YES
	CAIL 3,1000
ESVX1:	ITERR SEVEX1		;NOT LEGAL
SEV1:	MOVEM 2,ENTVEC(1)
	JRST CLFRET

.GEVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,ENTVEC(1)
GCV1:	UMOVEM 2,2
	JRST CLFRET

;GET/SET COMPATIBILITY ENTRY VECTOR AND PARAMETERS

.GCVEC:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PATADR(1)
	MOVE 3,PATUPC(1)
	HRL 3,PATU40(1)
	UMOVEM 3,3
	JRST GCV1

.SCVEC:	JSYS MENTR
	CALL SETLFK
	MOVEM 2,PATADR(1)
	HRRM 3,PATUPC(1)
	HLRM 3,PATU40(1)
	JRST MRETN

;GET TRAP WORDS FROM FORK

.GTRPW:	JSYS MENTR
	CALL SETLFK		;MAP PSB
	MOVE 2,UTRSW(1)		;TRAP STATUS WORD
	UMOVEM 2,1		;RETURNED IN 1
	MOVE 2,UTRWD(1)		;WRITE DATA
	UMOVEM 2,2		;RETURNED IN 2
	JRST CLFRET

;SET SCHEDULER PRIORITY WORD

.SPRIW:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX		;MUST BE PRIVILEGED
	CALL SETLFK
SPRI1:	UMOVE 2,2
	MOVEM 2,JOBBIT(1)
	JRST CLFRET

;SET PRIORITY WORD FOR ANOTHER JOB

.SJPRI:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER
	JRST WHEELX
	NOINT
	CAIL 1,0		;LEGAL JOB NUMBER?
	CAIL 1,NJOBS
	JRST MRETN		;NO
	SKIPGE JOBRT(1)		;JOB EXISTS?
	JRST MRETN		;NO
	HRRZ 1,JOBPT(1)		;TOP FORK
	HRRZ 1,FKPGS(1)		;ITS PSB
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB
	AOS 0(P)		;DO SKIP RETURN FOR OK
	JRST SPRI1

;GET AND SET PRIMARY IO JFN'S

.GPJFN:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PRIMRY(1)
	UMOVEM 2,2
	JRST CLFRET

.SPJFN:	JSYS MENTR
	CALL MAPFKH
	 CALL SPJFN1
	JRST MRETN

SPJFN1:	CALL SKIIF
	JRST FRKE2
	CALL SETLF1
	UMOVE 2,2
	MOVEM 2,PRIMRY(1)
	JRST CLRLFK

;KILL FORKS

.KFORK:	JSYS MENTR
	NOINT
	JLOCK			;LOCK JOBLCK FOR THIS JOB
	MOVEI 1,0(1)
	CAIN 1,-4		;ALL INFERIORS?
	JRST KFORK2		;YES
	CALL SETJFK		;NO, ANY ONE FORK
	CAMN 1,FORKN		;SELF?
	ITERR KFRKX2		;YES, NOT PERMITTED
	CALL SKIIF		;INFERIOR?
	JRST FRKE2		;NO, NOT PERMITTED
	CALL KFORK1		;KILL IT
	JULOCK			;RELEASE LOCK
	JRST MRETN

KFORK2:	HRRZ 1,FORKN
	CALL MAPINF		;FREEZE ALL TO INSURE INTERRUPTIBILITY
	 CALL FFORK1
	CALL KALLI		;KILL ALL INFERIORS
	JULOCK			;RELEASE JOBLCK
	JRST MRETN

KFORK1:	HRLM 1,0(P)
	CALL FFORK1		;FREEZE ALL TO INSURE INTERRUPTIBILITY
	HLRZ 1,0(P)
KFORK0:	CALL DASFKH		;DEASSIGN LOCAL FORK HANDLE
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS FORK?
	ITERR KFRKX2		;CAN'T KILL SELF
	MOVE 5,6		;REMOVE FORK FROM STRUCTURE
	ADD 5,SUPERP
	LDB 5,5			;GET SUPERIOR
	ADD 5,INFERP
KFK01:	LDB 4,5			;GET NEXT PARALLEL
	CAIN 4,0(6)		;DESIRED FORK?
	JRST KFK02		;YES
	MOVE 5,4
	ADD 5,PARALP
	JRST KFK01

KFK02:	ADD 4,PARALP		;FOUND FORK TO BE KILLED IN LIST
	LDB 4,4
	DPB 4,5			;PUT NEXT IN LAST, REMOVING FORK FROM LIST
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;SUSPEND FORK
;
;	PERFORMANCE FIX
	MOVE  2,PPC(1)
;
	NOSKED
	MOVEI 2,KSELF
	MOVEM 2,PPC(1)		;START IT SO AS TO KILL ITSELF
	MOVEI 2,JSKP
	HRRM 2,FKSTAT(7)
	OKSKED
	RESKED
	CALL CLRLFK
	JULOCK			;RELEASE JOBLCK
	MOVSI 1,0(7)
	HRRI 1,KFK0T
	JSYS EDISMS		;WAIT TILL FORK IS KILLED
	JLOCK			;LOCK JOBLCK AGAIN
	MOVEI 1,JSKP
	HRRM 1,FKSTAT(7)	;LET IT FINISH UP
	MOVEI 1,FKPTRS(6)
	EXCH 1,FREJFK		;PUT JOB SLOT BACK ON LIST
	MOVEM 1,@FREJFK
	RET

;FORK KILL SELF

KSELF:	MOVE 7,FORKX
	MOVSI 1,200000
	MOVEM 1,FKINT(7)	;DISABLE ANY FURTHER INTERRUPTS
	MOVSI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR		;GET INTO REASONABLE MONITOR STATE
	SETZM PSIBW
;;;	AQMMP			;ACQUIRE MMP SLOT
;;;	CAIA			;ALREADY HAD SLOT
;;;	JRST .+3		;NO SLOT AVAILABLE
;;;	RLMMP			;RELEASE SLOT
;;;	JFCL			;HMMM?
	CALL DTIALL		;DEASSIGN TERM INTERRUPTS
	SETOM PRIMRY		;RELEASE PRIMARY INPUT,OUTPUT FILE
	MOVE 1,[1B4+400000]	;REASSIGN STILL-MAPPED FILES
	CLZFF			;CLOSE FILES HERE AND BELOW
IFDEF IMPCHN,<
	CALL NETKFK>		;FLUSH FORK FROM NET TABLES
IFDEF DSPCHN,<
	CALL DSPKFK>		; RELEASE DISPLAY PROCESSES OF THIS FORK
	JLOCK			;LOCK JOBLCK
	CALL KALLI
	JULOCK			;RELEASE JOBLCK
	MOVE 7,FORKX
	HLRZ 1,FKPGS(7)
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT OF UPT
	PUSH P,2		;SAVE IT FOR LATER CHECK
	SETO 1,
	MOVSI 2,400000
KSEF1:	SKIPE UPTA(2)		;QUICK CHECK FOR ALREADY EMPTY
	PMAP			;CLEAR ALL PAGES FROM USER MAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF1
	HRRZ 1,FORKN
	SETOM SYSFK(1)		;INDICATE FORK NOW KILLED
	MOVEI 1,KRET
	JSYS EDISMS		;AND WAIT TILL NOTIFICATION SEEN
KSEF2:	POP P,2			;SHARE COUNT OF UPT
	CAIE 2,1		;UNSHARED?
	JRST KSEF3
	MOVE 7,FORKX
	SETZM PSB+UPTPG
	SETZM PSB+UACPG
	SETZM PSB+JSBPG		;CLEAR SPECIAL MAP WORDS
	MOVE 6,[XWD CPTPG+1-PSBPG,CPTPG+1]
	HRLZ 2,FKPGS(7)
	CALL CLRM0		;CLEAR PP AREA OF MON MAP
	CALL WTFPGS		;WAIT FOR UPT AND PSB TO BE UNMAPPED
	JRST HLTFK1		;GO DELETE UPT AND PSB

KSEF3:	MOVEI 1,^D5000
	DISMS			;WAIT FOR 5 SECS
	HLRZ 1,FKPGS(7)		;THEN CLEAR MAP AGAIN
	LDB 2,[POINT 14,SPT(1),13]
	PUSH P,2
	SETZ 1,
	HLLZ 2,FKPGS(7)
KSEF4:	SKIPE UPTA(2)		;QUICK CHECK FOR ALREADY EMPTY
	CALL SETPT		;BUT NOT USING PMAP
	MOVEI 6,0(2)
	CAIGE 6,777
	AOJA 2,KSEF4
	JRST KSEF2

	RESCD

KFK0T:	HRRZ 2,FKSTAT(1)
	CAIE 2,KRET		;WAIT TILL FORK ALMOST KILLED STATE
KRET:	JRST 0(4)
	JRST 1(4)

FRZWT:	JRST 0(4)

	SWAPCD

KALLI:	HRRZ 1,FORKN
	ADD 1,INFERP
	LDB 1,1			;GET NEXT INFERIOR
	JUMPE 1,R		;NO MORE
	CALL KFORK0		;KILL ALL INFERIORS TOO
	JRST KALLI

;FREEZE FORK

.FFORK:	JSYS MENTR
	NOINT
	JLOCK			;LOCK JOBLCK
	MOVEI 1,0(1)
	CAIN 1,-4		;ALL INFERIORS?
	JRST FFORK5		;YES
	CALL SETJFK		;OTHERWISE, ANY SINGLE INFERIOR
	CAME 1,FORKN
	CALL SKIIF
	JRST FRKE1		;NOT INFERIOR
	CALL FFORK1
	JRST UPDTIR

FFORK5:	HRRZ 1,FORKN		;SELF
	CALL MAPINF		;MAP ALL IMMED INFERIORS
	 CALL FFORK1		;THROUGH FFORK1
	JRST UPDTIR

FFORK3:	SKIPA 2,[XWD FRZB2,0]	;INDIRECT FREEZE BIT
FFORK1:	MOVSI 2,FRZB1		;DIRECT FREEZE BIT
	HRRZ 7,SYSFK(1)
	TDNE 2,FKINT(7)		;ALREADY DONE?
	RET			;YES
	TLNE 2,FRZB1		;REMEMBER WHICH BIT - B1?
	TRO 1,1B18		;YES
	HRLM 1,0(P)		;SAVE CURRENT FORK
	TRZ 1,1B18
	CALL MAPINF		;DO INDIRECT FREEZE OF INFERIORS
	 CALL FFORK3
	HLRZ 1,0(P)
	MOVSI 2,FRZB1		;RESTORE BIT
	TRZN 1,1B18		;B1?
	MOVSI 2,FRZB2		;NO, B2
	HRRZ 7,SYSFK(1)
	CALL SUSFK		;SUSPEND FORK
	NOSKED
	IORM 2,FKINT(7)
	MOVEI 2,FRZWT
	HRRM 2,FKSTAT(7)	;SET FROZEN STATE
	OKSKED
	RET

;RESUME FORK

.RFORK:	JSYS MENTR
	NOINT
	JLOCK
	MOVEI 1,0(1)
	CAIN 1,-4		;ALL INFERIORS?
	JRST RFORK5		;YES
	CALL SETJFK
	CAME 1,FORKN		;CHECK RELITIVITY
	CALL SKIIF
	JRST FRKE1		;NOT INFERIOR
	CALL RFORK1
	JRST UPDTIR

RFORK5:	HRRZ 1,FORKN
	CALL MAPINF		;DO ALL IMMED INFERIORS
	 CALL RFORK1
	JRST UPDTIR

RFORK3:	SKIPA 2,[XWD FRZB2,0]	;INDIRECT FREEZE BIT
RFORK1:	MOVSI 2,FRZB1		;DIRECT FREEZE BIT
	HRRZ 7,SYSFK(1)
	TDNN 2,FKINT(7)		;FROZEN THIS WAY?
	RET			;NO
	ANDCAB 2,FKINT(7)	;CLEAR THIS TYPE OF FREEZE
	TLNE 2,FRZBB	;ALL TYPES OF FREEZE NOW CLEARED?
	RET			;NO, LEAVE FORK FROZEN
	HRLM 1,0(P)		;SAVE CURRENT FORK
	CALL MAPINF		;CLEAR INDIRECT FREEZE ON INFERIORS
	 CALL RFORK3
	HLRZ 1,0(P)
	CALL STPFK1		;SET TO UNFREEZE THIS FORK
	SKIPN 2,PIOLDS(1)	;WAS ON WTLST BEFORE FREEZE?
	MOVEI 2,JSKP		;NO, SET TO RUNNING
	MOVEM 2,FKSTAT(7)
	CALL CLRSFK		;UNSUSPEND FORK
	OKSKED
	JRST CLRLFK

;BREAKPOINT JSYS FOR IDDT

.BPT:	JSYS MENTR
	JRST HALTF1		;MAKE LIKE HALTF

;PERPETUAL WAIT - INTERRUPTABLE

.WAIT:	JSYS MENTR
	MOVEI 1,JRET
	JSYS EDISMS
	JRST MRETN

;READ FORK STATUS

.RFSTS:	JSYS MENTR
	RESKED			;TO BE SURE OWN STATUS IS UP TO DATE
	JLOCK
	TRNE 1,200000		;LOCAL DESIGNATOR?
	JRST RFST9		;NO
	ANDI 1,377777
	JUMPE 1,RFST9		;THIS FORK
	CAIL 1,NLFKS		;LEGAL?
	ITERR FRKHX1		;NO
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	CAIA
	JRST RFST8		;YES
	SETO 1,			;NOT ASSIGNED, RETURN -1
	JRST RFSTSR

RFST9:	CALL SETJFK		;NOT MULTIPLE FORKS
RFST8:
	CALL RFSTSA
RFSTSR:	UMOVEM 1,1
	JULOCK
	JRST MRETN
;
;   I4 CHANGE--MAKE THIS A SUBROUTINE
RFSTSA::
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	MOVE 2,PPC(1)		;GET PC
	TLNN 2,UMODF		;USER MODE?
	JRST [	MOVE 2,UPDL(1)	;NO, USER PC IS FIRST ON STACK
		TLZ 2,UMODF	;BUT TURN OFF USER BIT FOR INFO
		JRST .+1]
	UMOVEM 2,2
	CALL CLRLFK
	HLRZ 1,FKPT(7)
	CAIN 1,WTLST		;WAITING?
	JRST RFST1		;YES
	SETZ 1,			;RUNNING, RETURN 0
XXX:	RET
;
;
RFST1:	HRRZ 2,FKSTAT(7)	;IS WAITING, GET STATE
	SETZ 1,
	CAIN 2,FRZWT		;FROZEN?
	JRST RFST4		;YES
RFST5:	CAIN 2,FORCTM		;FORCED TERMINATION?
	JRST RFST3		;YES
	CAIN 2,HALTT		;REGULAR TERMINATION?
	JRST RFST2		;YES
	CAIE 2,TRMTST		;WAITING FOR FORK TERMINATION
	CAIN 2,TRMTS1		;EITHER FLAVOR?
	JRST RFST6		;YES
	TLO 1,1			;N.O.T.A., MUST BE I/O
;;;	JRST RFSTSR
	JRST XXX

RFST2:	TLO 1,2			;REGULAR TERMINATION GIVES 2
;;;	JRST RFSTSR
	JRST XXX

RFST6:	TLO 1,4
;;;	JRST RFSTSR
	JRST XXX

RFST3:	PUSH P,1
	MOVE 1,6
	CALL SETLF1		;MAP PSB
	MOVE 2,FORCTC(1)	;GET CHANNEL CAUSING FORCED TERM
	HRRM 2,0(P)		;PUT IN RH OF STATUS WORD
	CALL CLRLFK
	POP P,1
	TLO 1,3			;WITH 3 INDICATING FORCED TERM
;;;	JRST RFSTSR
	JRST XXX

RFST4:	TLO 1,400000		;FROZEN, INDICATE IN BIT 0
	HLRZ 2,FKSTAT(7)	;AND GET OLD STATUS
;;;	JUMPE 2,RFSTSR
	JUMPE 2,XXX
	JRST RFST5

;START FORK VIA ENTRY VECTOR

.SFRKV:	JSYS MENTR
	JLOCK
	CALL SETJFK
	PUSH P,1
	CALL SETLF1
	UMOVE 2,2		;GET RELATIVE POSITION
	HLRZ 3,ENTVEC(1)	;SIZE OF VEC IN DEST FORK
	CAIN 3,<JRST>B53	;OLD TYPE?
	MOVEI 3,2		;YES, IMPLIES 2
	CAIL 3,1		;REASONABLE VECTOR LENGTH?
	CAIL 3,1000
	JRST SFRKV2		;NO
	CAIL 2,0(3)		;LEGAL ARG?
	JRST SFRKV2		;NO
	MOVEM 2,FORCTC(1)	;LEAVE FOR FOR TO START SELF
	CALL CLRLFK
	POP P,1			;RECOVER JOB HANDLE
	CALL STPFK
	MOVEI 2,SFRKV1		;START FORK IN MONITOR
	IFN KIFLG,< HRLI 2,(1B6) >	;SET USER IN/OUT
	JRST SFORK1

SFRKV2:	CALL CLRLFK
	ITERR SFRVX1		;ILLEGAL RELATIVE NUMBER

SFRKV1:	MOVEM 1,FPC		;ENTER HERE FORK STARTS SELF
	MOVSI 1,UMODF		;AT ENTVEC + C(FORTCT)
	EXCH 1,FPC
	JSYS MENTR
	HRRZ 1,ENTVEC
	MOVE 2,FORCTC		;RELATIVE ADDRESS
	HLRZ 3,ENTVEC		;SIZE OR JRST
	CAIN 3,<JRST>B53	;OLD STYLE?
	JRST SFRKV3		;YES
	ADDI 1,0(2)
SFRKV4:	HRRM 1,0(P)
	JRST MRETN		;START IN USER MODE

SFRKV3:	CAIN 2,0		;0 MEANS JOBSA
	UMOVE 1,120
	CAIN 2,1		;1 MEANS JOBREN
	UMOVE 1,124
	JRST SFRKV4

;START FORK

.SFORK:	JSYS MENTR
	JLOCK
	CALL SETJFK
	CALL STPFK		;STOP FORK
	UMOVE 2,2
	TLZ 2,UIOF+2037		;USER I/O, CALFRMMON, IDX AND IND OFF
	TLO 2,UMODF		;AND USER ON
SFORK1:	SETOM SLOWF(1)		;NORMALIZE FLAG
	EXCH 2,PPC(1)		;SET PC
	TLNE 2,UMODF		;WAS IN USER MODE?
	JRST SFORK2		;YES
	MOVSI 2,UACB(1)		;NO, MOVE AC'S
	HRRI 2,PAC(1)
	BLT 2,PAC+17(1)
SFORK2:	HRRZS FKSTAT(7)		;CLEAR LH IN CASE FROZEN
	MOVSI 2,FRZBB
	TDNE 2,FKINT(7)		;FORK FROZEN?
	JRST SFORK3		;YES, DON'T START IT NOW
	MOVEI 2,JSKP
	MOVEM 2,FKSTAT(7)	;MAKE FORK RUNNABLE
	CALL CLRSFK		;AND CLEAR SUSPENSION
SFORK3:	SETZM PIOLDS(1)		;SET PRE-FREEZE STATE TO RUNNING
	CALL UPDTI
	JULOCK
	OKSKED
	RESKED
	JRST CLFRET

;MONITOR SFORK, CAN START IN MONITOR SPACE

.MSFRK:	JSYS MENTR
	MOVE 3,0(P)		;THIS IS LEGAL IF CALLED FROM
	MOVE 4,CAPENB		;MONITOR MODE, OR IF WHEEL OR
	TLNE 3,UMODF		;OPERATOR CAPABILITIES ARE PRESENT
	TLNE 4,WHEEL+OPER
	JRST .+2
	JRST CAPX		;LACKS CAPABILITY
	JLOCK
	CALL SETJFK
	CALL STPFK		;SAME STUFF AS SFORK
	UMOVE 2,2		;EXCEPT BELIEVE PC AND ALL FLAGS
	JRST SFORK1

;STOP FORK, USED BY SEVERAL FORK JSYS'S

STPFK:	CALL SKIIF		;JOB FORK NUMBER IN 1, IS INFERIOR?
	JRST FRKE2		;NO
STPFK1:	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CAMN 7,FORKX		;THIS SAME FORK?
	ITERR			;YES
	CALL SETLF1		;MAP PSB
	CALL SUSFK		;NO, SUSPEND FORK
;
;	PERFORMANCE FIX
	PUSH P,1
	MOVE 1,PPC(1)
	POP P,1
;
;
	NOSKED
	RET

;READ/SET FORK AC'S

.RFACS:	JSYS MENTR
	JLOCK
	CALL FACS
	MOVS 3,3
	MOVEI 2,17(3)
	XCTMU [BLT 3,0(2)]	;FROM FORK'S PSB TO USER
	JULOCK
	OKSKED
	JRST MRETN

.SFACS:	JSYS MENTR
	JLOCK
	CALL FACS
	MOVEI 2,17(3)
	XCTUM [BLT 3,0(2)]	;FROM USER TO FORK'S PSB
	JULOCK
	OKSKED
	JRST MRETN

;COMMON AC ROUTINE

FACS:	CALL SETJFK		;ONE FORK ONLY
	CALL SKIIF		;AND IT MUST BE INFERIOR
FRKE2:	ITERR FRKHX2
	MOVE 6,1
	HRRZ 7,SYSFK(6)
	CALL SETLF1		;MAP PSB
	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING?
	ITERR FRKHX4		;YES
	MOVE 2,PPC(1)		;GET PC
	MOVEI 3,PAC(1)		;LOC OF AC'S
	TLNN 2,UMODF		;IF IN USER MODE, OTHERWISE
	MOVEI 3,UACB(1)		;AC'S ARE IN FIRST AC BLOCK
	XCTUU [HRL 3,2]		;GET ADDRESS OF USER'S BLOCK
	RET

;HALT FORK

.HFORK:	JSYS MENTR
	JLOCK
	CALL MAPFKH
	 CALL HFORK1
	JULOCK
	JRST MRETN

HFORK1:	JUMPE 1,R		;NOT TOP SORK
	CAMN 1,FORKN		;THIS FORK?
	JRST  [ JULOCK
		JRST HALTF1]	;YES, MAKE LIKE HALTF
	CALL STPFK		;STOP THE FORK
	MOVEI 2,HALTT
	MOVSI 3,FRZBB
	TDNE 3,FKINT(7)		;FROZEN?
	JRST [	HRLM 2,FKSTAT(7) ;YET, UPDATE PRE-FREEZE STATE
		MOVEM 2,PIOLDS(1)
		JRST HFORK2]
	MOVEM 2,FKSTAT(7)	;TERMINATED STATE
	CALL CLRSFK		;BUT INTERRUPTABLE
HFORK2:	OKSKED
	CALL CLRLFK
	JRST UPDTI		;UPDATE TERM INT WORD

;CALL FROM TTY SERVICE TO RESOLVE FORK CONFLICT

TTFRKT:	SKIPGE FKPT(1)		;FORK STILL EXISTS?
	RET			;NO
	HRRZ 2,FKSTAT(1)	;GET ITS STATUS
	CAIE 2,TCITST		;STILL WAITING FOR TTY?
	RET			;NO
	JLOCK
	MOVSI 3,-NUFKS		;SETUP TO SEARCH FOR FORK
	SKIPL 2,SYSFK(3)	;THIS SLOT IN USE?
	CAIE 1,0(2)		;AND HAS CORRECT FORKX?
	AOBJN 3,.-2		;NO
	JUMPGE 3,[ JULOCK	;RETURN IF NOT FOUND IN THIS JOB
		   RET ]
	MOVEI 1,0(3)		;FORKN OF OTHER FORK
	CALL SKIIF		;IS IT INFERIOR
	JRST [	JULOCK
		JRST HALTF1 ]	;NO, HALT OURSELF
	CALL HFORK1		;HALT THE OTHER GUY
	JULOCK
	RET

;WAIT FOR FORK TO TERMINATE

.WFORK:	JSYS MENTR
	CAIN 1,-4		;ALL INFERIORS?
	JRST WFORK2		;YES
	CALL SETJFK		;ONE FORK, GET ITS JOB HANDLE
	HRLZ 1,SYSFK(1)		;SETUP TEST ON FORK INDEX
	HRRI 1,TRMTST
	JSYS EDISMS		;AND DISMISS
	JRST MRETN

WFORK2:	MOVEI 1,TRMTS1		;SETUP TEST TO WAIT UNTIL CHANGED
	JSYS EDISMS
	JRST MRETN

	RESCD

TRMTST:	HLRZ 2,FKPT(1)		;SCHEDULER TEST, GET LOC OF FORK  NOW
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)		;NO
	HRRZ 2,FKSTAT(1)
	CAIE 2,HALTT		;WAITING BECAUSE TERMINATION?
	CAIN 2,FORCTM		;OR FORCED TERM?
	JRST 1(4)		;YES
	JRST 0(4)		;NO, KEEP WAITING

TRMTS1:	JRST 0(4)

	SWAPCD

;SUSPEND FORK SO IT CAN BE DIDDLED

SUSFK:	PUSH P,1
	PUSH P,2
	CAMN 7,FORKX
	BUG(HLT,<SUSFK - GIVEN SELF AS ARG>)
SUSF6:	NOSKED
	HLRZ 2,FKPT(7)
	CAIE 2,WTLST		;WAITING NOW?
	JRST SUSF4		;NO
	HRRZ 2,FKSTAT(7)	;GET WAITING STATUS
	CAIE 2,SUSWT		;ALREADY SUSPENDED OR FROZEN?
	CAIN 2,FRZWT
	JRST SUSF2		;YES
	CAIN 2,TCITST		;WAS IN TTYIN WAIT?
	JRST [	HLRZ 2,FKSTAT(7) ;YES, MUST RESET LINE STATE
		HLLOS TTFORK(2)
		JRST .+1]
SUSF5:	MOVSI 1,400000+SUSFKR	;SUSPEND FORK REQUEST BIT FOR PSI
	JRST [	NOPI
		HLOCK PSILCK
		IORM 1,FKINT(7)		;LEAVE IT FOR SPECIFIED FORK
		MOVEI 2,0(7)
		CALL PSIR4		;INTERRUPT THE FORK
		JRST .+1]
	JULOCK			;UNLOCK JOBLCK
	OKSKED
	MOVSI 1,0(7)		;SETUP SCHEDULER TEST TO WAIT
	HRRI 1,SUSFKT		;UNTIL FORK HAS SUSPENDED ITSELF
	JSYS EDISMS
	JLOCK			;LOCK JOBLCK FOR JOB AGAIN
SUSF3:	POP P,2
	POP P,1
	RET

SUSF2:	OKSKED
	JRST SUSF3

SUSF4:	SKIPN FKINT(7)		;TRANSITIONAL STATE?
	JRST SUSF5		;NO
	MOVSI 1,400000+SUSFKR	;YES, REQUEST INTERRUPT
	JRST   [NOPI
		HLOCK PSILCK
		IORM 1,FKINT(7)
		MOVEI 2,0(7)
		CALL PSIR4
		JRST .+1]
	JULOCK			;UNLOCK JOBLCK
	OKSKED			;THEN WAIT TO BE SURE IT WAS RECEIVED
	MOVEI 1,^D500
	DISMS
	JLOCK			;LOCK JOBLCK
	JRST SUSF6		;AND CHECK AGAIN

;SCHEDULER TEST FOR SUSPENSION

	RESCD

SUSFKT:	HLRZ 2,FKPT(1)		;GET LOC OF SPECIFIED FORK
	CAIE 2,WTLST		;WAITING?
	JRST 0(4)
	HRRZ 2,FKSTAT(1)
	CAIE 2,SUSWT		;SUSPENSION?
	CAIN 2,FRZWT
	JRST 1(4)
	JRST 0(4)

	SWAPCD

;CLEAR FORK WHICH HAD BEEN SUSPENDED

CLRSFK:	MOVSI 2,200000
	ANDCAM 2,FKINT(7)	;CLEAR PSI STARTING STATE
	RET

;MAP ALL IMMEDIATE INFERIORS OF FORK IN 1
; EXECUTES +1 FOR EACH FORK
; RETURNS +2

MAPINF:	MOVE 16,@0(P)		;INSTRUCTION TO EXECUTE
	ADD 1,INFERP
MAPIF1:	LDB 1,1
	JUMPE 1,RSKP
	HRLM 1,0(P)
	XCT 16
	HLRZ 1,0(P)
	ADD 1,PARALP
	JRST MAPIF1

;PERFORM MAPPING FOR FORK CONTROL FUNCTION WHICH OPERATE ON SEVERAL
;FORKS

MAPFKH:	HRROI 1,0(1)		;GET FORK HANDLE
	TRNN 1,200000		;SPECIAL?
	ANDI 1,377777		;NO
	JUMPLE 1,MAPFK1
	CAIL 1,NLFKS
	ITERR FRKHX1
	IDIVI 1,2		;REGULAR HANDLE, GET JOB HANDLE
	ADD 1,FKPTAB(2)
	LDB 1,1
	CAIGE 1,NUFKS		;ASSIGNED?
	SKIPG SYSFK(1)
	ITERR FRKHX1		;NO
	RET			;RETURN AND DO FUNCTION ONCE

MAPFK1:	ADDI 1,2
	JUMPL 1,MAPFK2		;MULTIPLE INDICATION
	XCT SETJFT(1)		;SINGLE, GET JOB HANDLE
	RET

MAPFK2:	ADDI 1,3
	JUMPGE 1,MAPFT(1)	;GO TO ROUTINE
	ITERR FRKHX1		;HANDLE ILLEGAL

MAPFT:	JRST MAPF5		;-5, ALL FORKS IN JOB
	JRST MAPF4		;-4, ALL INFERIORS
	JRST MAPF3		;-3, SELF AND ALL INFERIORS

MAPF3:	HRRZ 1,FORKN		;SELF
MAPF51:	PUSH P,1
	XCT @-1(P)		;DO THIS FORK
	POP P,1
MAPFI:	MOVE 16,@0(P)		;GET INSTRUCTION, WILL STAY IN 16
MAPF41:	ADD 1,INFERP		;DO INFERIORS
MAPF42:	LDB 1,1			;GET NEXT IN LIST
	JUMPE 1,RSKP		;END OF LIST, RETURN AND SKIP INSTR
	HRLM 1,0(P)		;SAVE THIS FORK NUMBER
	CALL MAPF41		;DO INFERIORS OF IT
	BUG(HLT,<MAPF41 FAILED TO SKIP>)
	HLRZ 1,0(P)		;GET FORK NUMBER BACK
	XCT 16			;DO THIS FORK
	HLRZ 1,0(P)
	ADD 1,PARALP		;POINT TO NEXT IN LIST
	JRST MAPF42

MAPF4:	HRRZ 1,FORKN		;GET SELF
	JRST MAPFI		;DO INFERIORS

MAPF5:	HLRZ 1,FORKN		;GET TOP
	JRST MAPF51		;DO THAT AND INFERIORS

;FORK RELATIVITY TESTS

;SKIP IF FORK IN 1 IS SELF OR INFERIOR TO SELF

SKIIF:	PUSH P,2
	HRRZ 2,FORKN		;GET SELF
	CALL SKIIFA		;DO TEST
	JRST POP2		;RETURN NO SKIP
SKISF2:	POP P,2
	JRST RSKP

;SKIP IF FORK IN 1 IS SAME AS OR INFERIOR TO FORK IN 2

SKIIFA:	HRLM 2,0(P)		;SAVE FORK NUMBER
SKIIF4:	CAIN 1,0(2)		;SAME?
	JRST SKIIF1		;YES
	ADD 2,INFERP		;NO, GET POINTER TO INFERIOR LIST
SKIIF2:	LDB 2,2			;NEXT INFERIOR
	JUMPE 2,SKIIF6		;END OF LIST
	CALL SKIIFA		;IS THIS FORK OR INFERIOR?
	JRST SKIIF5		;NO
SKIIF1:	HLRZ 2,0(P)		;SUCCEEDS, RETURN +2
	JRST RSKP

SKIIF6:	HLRZ 2,0(P)
	RET			;FAILS RETURN +1

SKIIF5:	ADD 2,PARALP		;LOOK PARALLEL
	JRST SKIIF2

;SKIP IF FORK IN 1 IS SUPERIOR OF THIS FORK

SKISF:	PUSH P,2
	HRRZ 2,FORKN
SKISF1:	CAIN 1,0(2)
	JRST SKISF2		;SAME, RETURN GOOD
	JUMPE 2,POP2		;END OF LIST, RETURN BAD
	ADD 2,SUPERP		;GET SUPERIOR POINTER
	LDB 2,2
	JRST SKISF1

;JSYS'S FOR CONTROLLING PSI SYSTEM

;MAP PSB OF FORK, GIVEN USER HANDLE IN 1
;RETURN WITH OFFSET TO MAPPED PSB IN 1

SETLFK:	TRNE 1,200000		;SPECIAL DESIGNATOR?
	JRST FRKE1		;NOT ALLOWED
	CALL SETJFK		;GET JOB FORK INDEX
SETLF1:	NOINT
	HRRZ 1,SYSFK(1)		;GET SYSTEM FORK INDEX
	CAMN 1,FORKX		;CURRENT FORK?
	JRST SETLF2		;YES
	HRRZ 1,FKPGS(1)		;GET PSB OF DESIGNATED FORK
	PUSH P,2
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	MOVEI 1,FPBPGA-PSB	;RETURN OFFSET USUAL PSB TO MAP PSB
	JRST POP2

SETLF2:	SETZ 1,			;USE CURRENT PSB, NO OFFSET
	RET

CLRLFK:	SKIPN PSB+FPBPG		;NOW MAPPED?
	JRST CLRLFX		;NO
	SETZ 1,
	MOVEI 2,FPBPGA
	CALL SETMPG
CLRLFX:	OKINT
	RET

;GET JOB FORK HANDLE GIVEN USER HANDLE IN 1
;FOR SINGLE (NOT MULTIPLE) FORK HANDLES ONLY

SETJFK::	HRROI 1,0(1)
	TRNN 1,200000
	ANDI 1,377777
	JUMPLE 1,SETJF1
	CAIL 1,NLFKS
FRKE1::	ITERR FRKHX1
	PUSH P,2
	IDIVI 1,2
	ADD 1,FKPTAB(2)
	LDB 1,1			;GET JOB FORK INDEX (HALF WORD)
	CAIGE 1,NUFKS		;FORK HANDLE ASSIGNED?
	SKIPG SYSFK(1)
	JRST FRKE1		;NO
	JRST POP2

SETJF1:	ADDI 1,2
	JUMPL 1,ITRAP
	XCT SETJFT(1)
	RET

SETJFT:	HLRZ 1,FORKN		;-2, TOP FORK
	CALL GETSPF		;-1, SUPERIOR
	HRRZ 1,FORKN		;0, CURRENT

GETSPF:	HRRZ 1,FORKN		;GET SUPERIOR FORK
	MOVE 1,FKPTRS(1)
	LSH 1,-^D24
	RET

.SIR:	JSYS MENTR
	CALL SETLFK
	JUMPE 2,SIR1		;ALL 0 IS LEGAL
	HLRZ 3,2		;GET ADDRESSES GIVEN
	MOVEI 4,0(2)
	CAIL 3,20		;BOTH .GE. 20?
	CAIGE 4,20
	ITERR SIRX1		;NO
SIR1:	MOVEM 2,LEVCHN(1)
CLFRET:	CALL CLRLFK
	JRST MRETN

.EIR:	JSYS MENTR
	TRNE 1,200000		;SPECIAL?
	ITERR FRKHX1		;ILLEGAL
	CALL SETJFK
	PUSH P,SYSFK(1)		;REMEMBER FORK INDEX
	CALL SETLF1		;MAP PSB
	SETZM PSISYS(1)		;0 IS ON
	POP P,2
	SKIPN PSIBW(1)		;ANY BREAKS WAITING?
	JRST CLFRET		;NO
	SETZ 1,			;YES, INITIATE SERVICE
	NOSKED
	CALL PSIRQB
	OKSKED
	JRST CLFRET

.SKPIR:	JSYS MENTR
	CALL SETLFK
	SKIPN PSISYS(1)
	AOS 0(P)
	JRST CLFRET

.DIR:	JSYS MENTR
	CALL SETLFK
	SETOM PSISYS(1)
	JRST CLFRET

.AIC:	JSYS MENTR
	CALL SETLFK
	IORM 2,PSICHM(1)
ICR:	CAIN 1,0		;SELF?
	CALL SETOVF		;YES, POSSIBLE CHANGE TO APR FLAGS
	JRST CLFRET

.DIC:	JSYS MENTR
	CALL SETLFK
	ANDCM 2,MONCHN(1)		;NOR MONITOR RESERVED CHANNELS
	ANDCAM 2,PSICHM(1)
	JRST ICR

.IIC:	JSYS MENTR
	CALL SETJFK
	PUSH P,1
	CALL SETLF1		;MAP DEST PSB
	UMOVE 2,2
	ANDCM 2,MONCHN(1)	;DISALLOW MON RESERVED CHANS
	PUSH P,2
	CALL CLRLFK
	POP P,2
	POP P,1
	MOVE 1,SYSFK(1)
	EXCH 1,2
	NOSKED
	CALL PSIRQB
	OKSKED
	RESKED			;INITIATE RESCHEDULE TO GET INTERRUPT
	JRST MRETN

.RCM:	JSYS MENTR
	CALL SETLFK
	MOVE 1,PSICHM(1)
	JRST RETA1

.RWM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,PSIBIP(1)
	UMOVEM 2,2		;REPORT BREAKS IN PROGRESS IN 2
	MOVE 1,PSIBW(1)
RETA1:	UMOVEM 1,1		;RETURN VALUE IN 1
	JRST CLFRET

.SIRCM:	JSYS MENTR
	CALL SETLFK
	CAIN 1,0		;SELF?
	JRST FRKE1		;ILLEGAL
	MOVEM 2,SUPCHN(1)
	JRST CLFRET

.RIRCM:	JSYS MENTR
	CALL SETLFK
	MOVE 2,SUPCHN(1)
RETA2:	UMOVEM 2,2
	JRST CLFRET

.RIR:	JSYS MENTR
	CALL SETLFK
	MOVE 2,LEVCHN(1)	;RETURN LEVEL AND CHANNEL DISPATCHES
	JRST RETA2

.IIT::	JSYS MENTR	;TIMER INTERRUPT
	CALL SETJFK
	PUSH P,1
	CALL SETLF1
	UMOVE 2,2	;GET INTERRUPT BITS
	ANDCM 2,MONCHN(1)
	PUSH P,2
	CALL CLRLFK
	POP P,2
	POP P,1
	MOVE 1,SYSFK(1)
	UMOVE 3,3	;GET TIME 
	SKIPE 3		;RESET IF ZERO
	ADD 3,TODCLK
	NOSKED
	MOVEM 2,FKINTW(1)
	MOVEM 3,FKINTT(1)
	OKSKED
	JRST MRETN

.ATI:	JSYS MENTR
	NOINT
	PUSH P,1
	HLRZ 1,1
	CAIL 1,^D36		;REASONABLE TERM CODE?
	JRST ATIE1		;NO
	CAIE 1,3		;CONTROL-C?
	JRST .+4		;NO
	MOVE 3,CAPENB		;YES, SEE IF LEGAL
	TLNN 3,(1B0)
ATX2E:	ITERR ATIX2		;ISN'T
	JLOCK
	HRRZ 4,FORKN
	MOVE 3,BITS(1)
	IORM 3,FKPSIE(4)
	CALL GETCHA
	HRRZ 3,0(P)		;GET REQUESTED CHANNEL NUMBER
	DPB 3,2			;ASSIGN IT TO THIS CODE
	CALL UPDTI		;UPDATE JOB WORD
	JULOCK
ATI2:	OKINT
	POP P,1
	JRST MRETN

GETTCD:	CAIGE 1,PSICHL		;IN LOW GROUP?
	JRST GTCD1		;YES
	CAIGE 1,PSICHU		;IN HIGH GROUP?
ATIE1:	ITERR TERMX1		;NO, ERROR
	SUBI 1,PSICHO		;OFFSET HIGH GROUP
GTCD1:	MOVE 1,PSICH(1)
	RET

.DTI:	JSYS MENTR
	NOINT
	CAIL 1,^D36		;REASONABLE CODE?
	JRST ATIE1		;NO
	JLOCK
	HRRZ 2,FORKN
	MOVE 6,BITS(1)
	ANDCAM 6,FKPSIE(2)	;CLEAR FROM THIS FORK
UPDTIR:	CALL UPDTI		;UPDATE JOB WORDS
	JULOCK
	JRST MRETN

;UPDATE JOB TPSI WORDS BY SCANNING FORK WORDS

UPDTI:	MOVSI 3,-NUFKS		;SETUP TO SCAN ALL FORKS OF JOB
	SETZB 4,5		;IOR PSI AND DPSI WORDS
	SKIPL 2,SYSFK(3)	;FORK EXISTS?
	JRST UPDT1		;YES
UPDT2:	AOBJN 3,.-2
	AND 4,TTJTIW		;ALLOW ONLY ENABLED BITS
	MOVEM 4,TTSPSI
	AND 5,TTJTIW
	MOVEM 5,TTSDPS		;DEFERRED CODES
	SKIPGE 2,CTRLTT		;IF ATTACHED
	RET
	MOVEM 4,TTPSI(2)	;SET FOR TTY LINE
	MOVEM 5,TTDPSI(2)
	RET

UPDT1:	HLRZ 1,FKPT(2)		;SEE IF FORK FROZEN OR HALTED
	CAIE 1,WTLST
	JRST UPDT3		;NOT ON WAIT LIST
	HRRZ 1,FKSTAT(2)
	CAIN 1,FRZWT		;FROZEN?
	JRST UPDT2		;YES
	CAIE 1,HALTT		;HALTF OR FORCED TERM?
	CAIN 1,FORCTM
	JRST UPDT2		;YES
UPDT3:	IOR 4,FKPSIE(3)		;INCLUDE FORK'S TI'S
	IOR 5,FKDPSI(3)
	JRST UPDT2

;DEASSIGN ALL TERMINAL INTERRUPTS FOR THIS FORK

DTIALL:	HRRZ 1,FORKN
	JLOCK
	SETZM FKPSIE(1)
	CALL UPDTI		;UPDATE AND RETURN
	JULOCK
	RET

.CIS:	SETZM PSIBIP
	SETZM PSIBW
	MOVEM 1,PSIPT
	MOVE 1,[IOWD 1000,PSIPGA]
	EXCH 1,PSIPT		;RESET PSI STORAGE
	XCT MJRSTF

;READ/SET TERMINAL INTERRUPT WORD

.RTIW:	JSYS MENTR
	MOVEI 1,0(1)
	CAIN 1,-5		;WHOLE JOB?
	JRST [	MOVE 2,TTJTIW	;YES
		JRST RTIW1]
	CALL SETJFK		;GET JOB INDEX
	MOVE 2,FKDPSI(1)	;DEFERRED CODES
	UMOVE 4,1		;SEE IF USER WANTS THEM
	TLNE 4,(1B0)		;HE DOES IF SIGN OF 1 IS ON.
	UMOVEM 2,3		;RETURNED IN 3
	MOVE 2,FKPSIE(1)
RTIW1:	UMOVEM 2,2
	JRST MRETN

.STIW:	JSYS MENTR
	JLOCK
	MOVEI 1,0(1)
	CAIN 1,-5
	JRST [	MOVE 3,CAPENB
		TLNN 3,(1B0)	;^C CAPABILITY?
		JRST ATX2E	;NO, DON'T PERMIT CHANGE TO JOB TI
		MOVEM 2,TTJTIW	;SET JOB MASK WORD
		JRST STIW1]	;GO UPDATE AND RET
	CALL SETJFK
	UMOVE 4,1		;SEE IF USER SUPPLIED THE DEFERRED CODES
	TLNE 4,(1B0)		;AND IF SO, UPDATE THEM.
	MOVEM 3,FKDPSI(1)	;DEFERRED CODES
	EXCH 2,FKPSIE(1)	;SET NEW, REMEMBER OLD
	XOR 2,FKPSIE(1)		;DIFFERENCES
	SKIPE MONCHN(1)		;RESERVED MON CHANS EXIST?
	TRZN 2,1B20		;AND ^P BEING CHANGED?
	JRST STIW1		;NO
	MOVE 3,BITS+20		;YES, PUT ^P BACK LIKE IT WAS
	XORM 3,FKPSIE(1)
STIW1:	CALL UPDTI		;UPDATE JOB TIW
	JULOCK
	JRST MRETN

;FORK HANDLE - PTN CONVERSION ROUTINES

;TRANSLATE FKH.PN TO PTN.PN

FKHPTN:	PUSH P,2
	PUSH P,1
	TRNE 1,777000		;LEGAL PAGE NUMBER?
	JRST FRKE1		;NO
	HLRZ 1,1
	CALL SETJFK		;GET JOB FORK INDEX
	CALL SKIIF
	JRST [	MOVSI 2,(1B9)	;NOT INFERIOR
		TDNN 2,CAPENB	;ALLOWED TO MAP SUPERIOR?
		JRST FRKE2	;NO
		MOVE 2,1	;YES, SAVE OBJECT FORK
		CALL GETSPF	;GET HANDLE OF SUPERIOR
		EXCH 1,2
		CAME 1,2	;IS OBJECT FORK IMMED SUPERIOR?
		JRST FRKE2	;NO
		JRST .+1]
	HRRZ 2,SYSFK(1)		;GET SYSTEM FORK INDEX
	POP P,1
FKHP2:	HLL 1,FKPGS(2)		;GET PAGE TABLE PTN
	TLNE 1,-1		;IS ONE?
	JRST FKHP3		;YES
	BUG(HLT,<FKHPTN - FORK HAS NO PAGE TABLE>)

FKHP3:	POP P,2
	RET

;TRANSLATE PTN TO FKH

PTNFKH:	PUSH P,2
	PUSH P,3
	PUSH P,1
	HLRZ 2,1		;GIVEN PTN
	MOVSI 3,-NUFKS		;SETUP FOR SCAN OF JOB FORK TABLE
PTNF3:	HRRE 1,SYSFK(3)
	JUMPL 1,PTNF2		;UNUSED
	HLRZ 1,FKPGS(1)
	CAIN 2,0(1)		;IS PT?
	JRST PTNF1		;YES
PTNF2:	AOBJN 3,PTNF3
	SETOM 0(P)		;NOT FOUND, RETURN -1
	JRST PTNF4

PTNF1:	MOVEI 1,0(3)		;JOB INDEX
	CALL GFKH		;CONVERT TO LOCAL HANDLE
	ITERR FRKHX6
	HRLM 1,0(P)		;CONSTRUCT FHK,,PN
PTNF4:	POP P,1
POP32:	POP P,3
POP2:	POP P,2
	RET

;FIND OR INSERT LOCAL FORK HANDLE
; RH(1)/  JOB FORK INDEX
; LH(1)/  PSB OFFSET (GRFKH ONLY)

GFKH:	TLZ 1,777777		; ENTER HERE FOR RELATIVE TO SELF
GRFKH:	PUSH P,2		; ENTER HERE WITH LH OFFSET TO PSB
	PUSH P,3
	PUSH P,4
	HLRE 3,1		; INDEX TO CORRECT PSB (FULL WD NUMBER)
	HRRZ 2,FORKN(3)		; GET CORRECT FORKN
	PUSH P,3		; SAVE FOR LATER
	ADD 3,FKPTAB		; OFFSET POINTER
	MOVE 4,[XWD -NLFKS+1,1]
	CAIN 2,0(1)		;IS IT SELF?
	SOJA 4,GFKH4		;YES, 0
	HRLI 1,400000		;USE LH TO REMEMBER ANY EMPTY ENTRIES
GFKH1::	ILDB 2,3		;LOOK AT NEXT HALF-WORD
	CAIN 2,-1		;ASSIGNED?
	JRST GFKH2		;NO
	CAIN 2,0(1)		;IS GIVEN?
	JRST GFKH4		;YES
GFKH3:	AOBJN 4,GFKH1
	TLNE 1,400000		;NOT FOUND, ROOM TO ADD ENTRY?
	JRST POP41		;NO, RETURN NOSKIP
	HLRZ 3,1		;GET INDEX OF FIRST FREE ENTRY
	IDIVI 3,2		;CONSTRUCT POINTER TO IT
	ADD 3,FKPTAB(4)
	ADD 3,0(P)
	DPB 1,3			;STORE JOB INDEX IN ENTRY
	HLRZ 4,1
GFKH4::	MOVEI 1,400000(4)	;RETURN LOCAL HANDLE WITH BIT
	AOS -4(P)
POP41:	SUB P,BHC+1
POP4:	POP P,4
	JRST POP32

GFKH2:	TLNE 1,400000		;FIRST EMPTY SLOT?
	HRLI 1,0(4)		;YES, SAVE INDEX
	JRST GFKH3

;DEASSIGN LOCAL FORK HANDLE GIVEN JOB HANDLE IN 1

DASFKH:	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 3,FKPTAB
	MOVE 4,[XWD -NLFKS+1,1]
DASFK1:	ILDB 2,3		;GET THIS ENTRY
	CAIN 2,0(1)		;THE ONE WE WANT?
	JRST DASFK2		;YES
	AOBJN 4,DASFK1		;NO, KEEP LOOKING
	JRST POP4		;NOT FOUND, SO IGNORE IT

DASFK2:	MOVEI 2,-1		;PUT A -1 WHERE ENTRY WAS
	DPB 2,3
	JRST POP4

;TABLE OF BYTE POINTERS, HALF WORD

	POINT 18,FKTAB,-1
FKPTAB::	POINT 18,FKTAB,17
	POINT 18,FKTAB,35

;SPECIAL CAPABILITIES CONTROL

.RPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SETLF1
	MOVE 2,CAPMSK(1)
	UMOVEM 2,2		;RETURN POSSIBLE IN 2
	MOVE 3,CAPENB(1)
	UMOVEM 3,3		;ENABLED IN 3
	JRST CLFRET

.EPCAP:	JSYS MENTR
	CALL SETJFK
	CALL SKIIF
	ITERR FRKHX2		;INFERIORS ONLY
	CALL SETLF1
	JUMPE 1,[XOR 3,CAPMSK(1) ;IF SELF, DON'T MODIFY 14-17
		TLZ 3,(17B17)
		XOR 3,CAPMSK(1)
		JRST EPC1]
	MOVE 4,CAPMSK
	TLO 4,(777B17)		;9-17 DETERMINED BY SUPERIOR
	AND 2,4
	MOVEM 2,CAPMSK(1)
EPC1:	AND 3,CAPMSK(1)
	MOVEM 3,CAPENB(1)
	JRST CLFRET

;DETACH FROM CONTROLLING TTY

.DTACH:	JSYS MENTR
	NOINT
	SKIPGE CTRLTT		;IS ONE?
	JRST MRETN		;NO, DO NOTHING
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK			;BREAK LINKS
	JFCL
	MOVE 1,JOBNO
	HRRE 2,JOBDIR(1)
	CAIE 2,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	MOVE 2,CTRLTT
	SETOM CTRLTT
IFE SUMEX,<
	SETOM TTFORK(2)
	SETZM TTPSI(2)
>
IFN SUMEX,<
	CALL TTCLZ
>
	MOVE 1,JOBNO
	HRROS JOBPT(1)
	JRST MRETN

;ATTACH JOB TO TTY

	EXTERN ATACX4

.ATACH:	JSYS MENTR
	NOINT
	PUSH P,1		;SAVE JOB NO
	MOVEI 1,WHEEL+OPER
	TDNE 1,CAPENB		;PRIVILEGED?
	JRST ATACH3		;YES, NO PASSWORD CHECK
	PUSH P,2
	MOVEI 1,0(2)
	MOVE 2,3
	CALL PASSWC		;CHECK PASSWORD
	JRST [	MOVEI 1,^D3000
		DISMS		;WRONG PASSWORD, DELAY TO FOIL THIEVES
		MOVEI 1,ATACX4
		JRST MRETNE]
	POP P,2
ATACH3:	HRRZ 1,0(P)
	CAIL 1,0
	CAIL 1,NJOBS		;LEGAL JOB NO?
	JRST .+2		;NO, NOT IN RANGE
	SKIPGE JOBRT(1)		;DOES IT EXIST?
	RETERR ATACX1		;NO
	HRRZ 3,JOBDIR(1)	;DIRECTORY OF  OTHER JOB
	PUSH P,3		;SAVE FOR FACT FILE
	CAIE 3,0(2)		;SAME AS SPECIFIED?
	RETERR ATACX3		;NO
	SKIPGE CTRLTT		;THIS JOB NOT ATTACHED? OR
	RETERR ATACX2		;YES
	HRRZ 1,JOBPT(1)		;TOP FORK OF OTHER JOB
	HRRZ 1,FKPGS(1)		;GET PSB OF IT
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	LDB 1,[POINT 13,FPBPGA+JSBPG,26]	;GET JSB NO
	CALL SETMPG
	MOVEI 6,FPBPGA-JSB
	SKIPL 4,CTRLTT(6)	;OTHER JOB NOW UNATACHED?
	JRST [	NOSKED		;NO, MUST DETACH IT FIRST
		MOVE 3,PSICH+3	;CONTROL-C INTERRUPT CODE
		MOVEI 2,0(4)	;LINE NUMBER
		CALL TTPSRQ	;FAKE A CONTROL-C ON OTHER JOB
		SETZM TTPSI(4)	;CLEAR TTY WORDS
		SETOM TTFORK(4)
		SETOM CTRLTT(6)
		MOVE 1,-1(P)	;OTHER JOB NUMBER
		HRROS JOBPT(1)
		OKSKED
		JRST ATACH2]

ATACH2:	PUSH P,CTRLTT
	DTACH
	NOSKED
	POP P,5			;TTY
	DPB 5,[POINT 12,LOGBUF,29] ;TTY NUMBER FOR EFACT
	POP P,4			;OTHER JOB'S DIRECTORY NUMBER
	HRRM 4,LOGBUF+1		;PUT IN EFACT BLOCK
	POP P,4			;DESTINATION JOB NO
	HRLM 4,LOGBUF		;PUT IN EFACT BLOCK
	MOVEM 5,CTRLTT(6)	;SET CTRLTT IN DEST JOB
	HRLM 5,JOBPT(4)
	HRLM 4,TTFORK(5)
	MOVE 1,TTSPSI(6)
	MOVEM 1,TTPSI(5)
	MOVE 1,TTSDPS(6)	;RESTORE INT CODE WORDS TO TTY LINE
	MOVEM 1,TTDPSI(5)
	CALL CLRLFK
	OKSKED
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE 1,JOBNO
	HRRE 1,JOBDIR(1)
	JUMPE 1,LOGO		;VANISH IF NOT LOGGED IN
	JRST SKMRTN		;RETURN SKIP

;GET AND SAVE ROUTINES

;AC USAGE IN GET ROUTINE:
; 4 - PAGE NUMBER IN USER SPACE CURRENTLY MAPPED TO FTPG1
; 5 - POINTER TO ADDRESS IN FTPG1 CORRESPONDING TO AC 6
; 6 - AOBJN (NOT IOWD) POINTER TO USER SPACE WHERE CURRENTLY READING
;14 - SETPT ARGUMENT FOR FTPG1
;15 - FORK HANDLE BEING GET'ED INTO
;16 - JFN BEING READ FROM

.GET:	JSYS MENTR
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST RD,XCT ACCESS AND THAWED
	PUSH P,2		;SAVE THE DESIRED OPENING BITS
	GTSTS			;SEE IF THE FILE IS OPEN ALREADY
	TLNN 2,(1B0)		; ..
	JRST GET2A		;NO. GO OPEN IT.
	TLNE 3,777		;IT'S OPEN. IS IT A DISK?
	JRST GET2B		;NO. ASSUME HE OPENED IT RIGHT
	TLC 2,(1B0+1B1+1B3)	;SEE IF RD & XCT BOTH ON
	TLNE 2,(1B0+1B1+1B3)	; ..
	JRST GETE2		;NO.
GET2B:	RFBSZ			;AND CORRECT BYTE SIZE?
	CAIE 2,44		; ..
	JRST GETE2		;NO
	POP P,2			;OK. CLEAR STACK
	JRST GET2C		;AND GO READ THE OPEN FILE.

GET2A:	POP P,2			;RETRIEVE OPENING MODE BITS
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
GET2C:	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
;FALL THRU

;FALLS THRU
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	JUMPE 2,[GTSTS		;ZERO. PROBABLY EOF.
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES. TRUNCATED FILE.
		MOVEI 2,0	;NO, A ZERO ENTRY VECTOR.
		JRST .+1]	;HANDLE IT
	MOVE 6,2
	HLRZ 2,2
	CAIN 2,1776		; Is it TOPS20 style save file?
	 JRST GETEXE		; Yes, get file
	CAIL 2,1000		;LEFT HALF IMPLYING SSAVE?
	CAIL 2,10000
	JRST .+2		; NO
	JRST SGET		; YES.
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1		; CHANGE IOWD TO AOBJN POINTER
GET5:	CALL GET3		;SET MAP FOR THIS PAGE, SET AC 5
	MOVEI 2,0(6)		;ADDRESS IN USER SPACE
	ORCMI 2,777		;MINUS NUMBER OF WORDS IN THAT PAGE
	HLRE 3,6		;LENGTH OF THE IOWD
	CAMLE 2,3		;WILL IT FIT IN THE WINDOW PAGE?
	MOVE 3,2		;NO. JUST READ WHAT WILL FIT
	MOVM 2,3		;POSITIVE FOR UPDATING POINTERS
	HRL 2,2			;IN BOTH HALVES. THIS IS +N,,+N
	ADD 6,2			;UPDATE THE AOBJN WORD. MAY OR MAY NOT GO +
	MOVE 2,5		;ADDRESS IN WINDOW PAGE
	HRLI 2,444400		;BYTE POINTER TO IT.
	SUB 5,3			;3 IS ALREADY -N FOR SIN. COUNT WINDOW ADDR.
	SIN			;NOW READ INTO THE WINDOW
	JUMPL 6,GET5		;JUMP IF POINTER CROSSED PAGE BOUNDARY
	JRST GET2		;DONE THIS POINTER. READ NEXT ONE.

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
				;DO THIS FIRST IN CASE OF ITRAP
	HLRZ 3,2		;SEE WHAT KIND OF DEVICE. PREVENT
	ANDI 3,777		; TTY'S, CAUSE FORK HANDLES ARE OFTEN
	CAIN 3,12		; MISPLACED INTO JFN AND LOOK LIKE TTY.
	ITERR (DESX4)		; THEN JOB HANGS NOINT ON TTY BIN
	PUSH P,2
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	POP P,3			;DEVICE BITS
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE - 4/ CURRENT PAGE (-1 FIRST TIME)
; SET FTPG1 TO POINT INDIRECT TO USER PAGE ADDRESSED BY AC6

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE2:	MOVEI 1,GETX3##		;FILE NOT PROPERLY OPENED
	JRST GETE0		;RETURN THIS ERROR CODE
GETE1:	MOVEI 1,GETX1##		;RETURN ERROR CODE
GETE0:	PUSH P,1		;SAVE THE ERROR CODE
	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	POP P,1
	JRST ITRAP1		;RETURN ERROR CODE WITH ITRAP

; GETEXE - Get routine for TOPS20 style (.EXE) sharable save files
;	   See TOPS20 Monitor Calls handbook for file format
;
; AC usage (different from above):
;
;	4) Temporary
;	5) Repeat count of number of pages to map
;	6) Count of number of words in directory section

GETEXE:	MOVEI 6,(6)		; Get count of number of entries
	SOJL 6,GETE1		; Minus one for header (must be positive)
	LSH 6,-1		; ...at two words per entry
	MOVEI 1,(16)		; Check for disk device
	DVCHR
	TLNE 2,777
	 ITERR SSAVX1		; If not, error
GETEX2:	JUMPE 6,GETEX5		; If no more entries left, then done
	CALL GETWRD
	MOVEM 2,4		; Save first word
	CALL GETWRD
	HRRZ 1,4		; Get page number in file
	JUMPE 1,GETEX4		; If zero, means "no page" so skip
	HRLI 1,(16)		; Get file handle
	MOVSI 3,READB!XCTB	; Give read and execute access at least
	TLNE 4,(1B1+1B2)	; If wanted write or share, give copy-on-write
	TLO 3,COPYB
	LDB 5,[POINT 9,2,8]	; Get repeat count
	HRLI 2,(15)		; AC2 set up from BIN, get fork handle
GETEX3:	HRRZ 4,2		; Get fork page number
	CAILE 4,777		; Is it a reasonable number?
	 JRST GETEX4		; No, go to next entry
	MOVE 4,SPTC		; Check share count
	CAML 4,SPC1		; If too high, abort
	 ITERR GETX2
	PMAP			; Map the page in
	SOJL 5,GETEX4		; If count goes negative, then done
	ADDI 1,1		; Otherwise, increment page numbers and repeat
	AOJA 2,GETEX3
GETEX4:	SOJA 6,GETEX2		; Decrement entry counter and go back
	;.....

; Now get entry vector and "end of directory" block
; AC usage	4) Temporary
;		5) B0 - Flag to denote entry vector encountered
;		6) Contains entry vector word

	;.....
GETEX5:	MOVSI 6,(JRST)		; Set up default entry vector
	SETZB 4,5		; Clear 4 (count) and 5 (flag)
GETEX6:	CALL GETWRD		; Get next directory word
	SOJGE 4,GETEX6		; Loop through until start of block
	HLRZ 4,2		; Get block type into 4
	CAIN 4,1775		; Is it entry vector?
	 JRST GETEX7		; Yes, go process
	CAIN 4,1777		; Is it end of file?
	 JRST GET1		; Yes, go store entry vector. We're done
	MOVEI 4,(2)		; Don't recognize this block, ignore
	SOJA 4,GETEX6
GETEX7:	TLOE 5,(1B0)		; Set and check if we've evec yet...
	 JRST GETE1		; Yes, we did.  Syntax error
	MOVEI 4,(2)		; Check count of this block
	SUBI 4,3		; Minus header and two for evec spec
	JUMPL 4,GETE1		; If not big enough, error
	CALL GETWRD		; Get a word
	MOVSI 6,(2)		; This is address
	CALL GETWRD
	HRRI 6,(2)		; Next word is count
	JRST GETEX6		; Fall through remaining words, and go on

; GETWRD - Gets word from file and checks for EOF

GETWRD:	MOVEI 1,(16)		; Get JFN
	BIN			; Get byte from file
	JUMPN 2,R		; Return if something there
	GTSTS			; Zero byte, check for EOF
	TLNE 2,1000		; Is flag set?
	 JRST GETE1		; Yes, error
	SETZ 2,			; Restore register
	POPJ P,			; And return

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR
;
; AC USAGE IN THIS ROUTINE --
; 16/ JFN BEING SAVED ONTO
; 15/ FORK HANDLE BEING SAVED FROM
; 10/ USER'S AC2 -- A SINGLE +N,,ADDR OR A
;     POINTER TO A LIST OF THEM, COUNTED AS THEY ARE PROCESSED.
;  7/ CURRENT +N,,ADDR FROM USER TABLE. MADE -N,,ADDR AT SAVEB
;  6/ -N,,ADDR FOR A GROUP OF NON-ZERO WORDS, OR WORDS UP TO PAGE END
;  5/ POINTER TO WINDOW PAGE (FTPG1), OFFSET VERSION OF RH OF 6

.SAVE:	JSYS MENTR
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	MOVEI 2,31
	MOVEI 3,2
	MTOPR			; SET BLOCK SPACING TO 2 IF DTA
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK
; ARGUMENT IS +N,,ADDR IN 7 . SEE AC USAGE COMMENT ABOVE

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK. 6/ -N,,ADDR

;WRITE ALL OR PART OF ONE PAGE. ARGS ARE -N,,ADDR IN 6 AND
; OFFSET ADDR IN 5. ALSO -N',,ADDR IN 7.
;VALUES ARE UPDATED 5 AND 7


SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
	MOVEI 2,(5)		;FORM BYTE POINTER TO WINDOW
	HRLI 2,444400		; FOR 36 BIT SOUT
	HLRO 3,6		;NEGATIVE COUNT
	SOUT			;OUTPUT THIS BLOCK OF DATA
	HLRO 6,6		;NOW UPDATE THE POINTERS. - NUM WDS SENT
	MOVM 6,6		;POSITIVE NUMBER OF WORDS SENT
	ADDI 5,(6)		;UPDATE POINTER TO WINDOW
	HRLI 6,(6)		;PLUS N IN BOTH HALVES
	ADD 7,6			;UPDATE MAJOR AOBJN CTR. MAY BE SOME LEFT
	RET

;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	JSYS MENTR
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;PUT ENTRY VECTOR IN FILE
	MOVEI 1,0(16)		;JFN
	BOUT
	HLRZ 2,13		;NEXT FREE PAGE IN FILE
	ASH 2,^D9		;FIRST WORD OF THAT PAGE
	SFPTR			;SET EOF AFTER ALL EXISTING PAGES
	BUG(CHK,<SSAVE - UNEXPECTED BAD RETURN FROM SFPTR>)
	JRST SAVER		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET
;OPERATOR FUNCTION CALL JSYS "OPRFN". THIS JSYS EXISTS TO BE
;USED BY THE EXEC OR EPHEMERONS TO DO OPERATOR TASKS, SO THE OP
;DOES NOT NEED TO GET INTO MDDT MOST OF THE TIME.
;
;THE FUNCTIONS ARE CALLED BY SIXBIT NAME, WHICH REQUIRES A TABLE
;SEARCH BUT IS OK BECAUSE THESE FUNCTIONS SHOULD ONLY BE CALLED
;ONCE A DAY OR SO. 
;
;FIELD SITES NOTE -- BBN WILL NEVER ADD ANY SIXBIT NAMES STARTING WITH
;THE LETTER "X". FIELD SITES CAN USE THAT CLASS OF NAMES WITHOUT 
;NEEDING TO WORRY ABOUT CONFLICT WITH FUTURE BBN FUNCTIONS.

;CALL - MOVE 1,[SIXBIT .FUNCTION-NAME.]
;	MOVE 2,ARGUMENT DEPENDENT ON FUNCTION. (MORE IN 3 &4...)
;	OPRFN
;	  FAIL RETURN, ERROR CODE IN 1
;	GOOD RETURN

IFE SUMEX,<			;!! MAH @ SUMEX 4/75 !! COULDN'T GET NEW
	EXTERN OPRFX1,OPRFX2	;STENEX FILE
>
IFN SUMEX,<
OPRFX1==0
OPRFX2==0
>
INTERN .OPRFN

.OPRFN:	JSYS MENTR		;ESTABLISH MONITOR CONTEXT
	MOVSI 10,-NOPRFS	;COUNT THRU NAME TABLE
	CAMN 1,OPRFTB(10)	;SEARCH. THIS ONE?
	JRST OPRFN1		;YES.
	AOBJN 10,.-2		;NO, SEARCH ONWARDS.
	MOVEI 1,OPRFX1		;NOT IN TABLE.
	JRST MRETNE##		;FAIL, NONSKIP, CODE TO LSTERR AND 1

OPRFN1:	HLRZ 7,OPRFT2(10)	;SEE WHAT CAPABILITIES ARE NEEDED
	TDNN 7,CAPENB		;ARE THEY ON IN THIS FORK?
	JRST CAPX		;NO. FAIL.
	HRRZ 7,OPRFT2(10)	;YES. GO DO THE FUNCTION
	PUSHJ P,0(7)		; ..
	  JRST MRETNE		;FAILED. ERROR CODE IN 1
	JRST SKMRTN		;SUCCESS RETURN.
;HERE ARE THE FUNCTIONS DEFINED SO FAR. ARGS TO THE "X" MACRO
; ARE SIXBIT NAME, CAPABILITIES NEEDED, TAG TO CALL.

IFN SUMEX,<			;!! MAH @ SUMEX 4/75 !!
PIESLC==0
JTRPSW==0
>
DEFINE OPRFNS <
IFN PIESLC,<
	X(KFACT,WHEEL+OPER,OPRKFC)>
IFDEF IMPCHN,<
	X(IMPDRQ,WHEEL+OPER,OPRDRQ)
	X(NETON,WHEEL+OPER+MAINT,OPRNTN)>
IFN JTRPSW,<
	X(JTRPON,WHEEL+OPER,OPRJTN)>
	X(ENTFLG,WHEEL+OPER+MAINT,OPRENT)
IFE SUMEX,<			;!! MAH @ SUMEX 4/75 !! 
	X(MKPGSA,WHEEL+OPER+MAINT,OPRMPA)
>
	X(MKPGSU,WHEEL+OPER+MAINT,OPRMPU)
	X(DDTRCL,WHEEL+OPER,OPRRCD)
	X(DDTFSH,WHEEL+OPER,OPRFSD)
	X(DBUGSW,WHEEL+OPER,OPRBSW)
	X(DCHKSW,WHEEL+OPER,OPRCSW)
	X(USRSPC,WHEEL+OPER,OPRUSP)
	X(SYSSPC,WHEEL+OPER,OPRSSP)
	X(XSPMAP,WHEEL+OPER,OPRMAP)
;ADD MORE HERE
>

DEFINE X(NAME,CAPS,ROUTIN)<	<SIXBIT \NAME\>>
OPRFTB:	OPRFNS
NOPRFS==.-OPRFTB

DEFINE X(NAME,CAPS,ROUTIN)<	XWD CAPS,ROUTIN>
OPRFT2:	OPRFNS

IFN PIESLC,<

OPRKFC:	FMPRI 2,(1.0)		;MAKE SURE IT'S A NORMALIZED FP NUMBER
	CAIL 2,0		;AND IN RANGE 0 THRU 1
	CAMLE 2,[1.0]
	JRST OPRFXX		;NO GOOD.
	MOVEM 2,KFACT##		;OK, SET IT.
	JRST RSKP		;GOOD RETURN.
>
IFDEF IMPCHN,<
OPRDRQ:	JUMPE 2,OPRFXX		;DON'T ALLOW RESET OF IMPDRQ
	MOVEM 2,IMPDRQ##	;SET IT
	JRST RSKP
	
OPRNTN:	SKIPE 3,2		;SET NETON TO 0 OR -1
	AOJN 3,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM 2,NETON##		;OK, SET IT.
	JRST RSKP
>
OPRENT:	
IFE SUMEX,<			;!! MAH @ SUMEX 4/75 !! SET ENTFLG TO ANYTHING
	SKIPE 3,2		;SET ENTFLG TO 0 OR -1
	AOJN 3,OPRFXX		;JUMP IF NOT 0 OR -1
>
	MOVEM 2,ENTFLG##	;OK, SET IT.
	JRST RSKP
IFN JTRPSW,<
OPRJTN:	SKIPE 3,2		;SET JTRPON TO 0 OR -1
	AOJN 3,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM 2,JTRPON##	;OK, SET IT.
	JRST RSKP
>
OPRRCD:	PUSHJ P,DDTRCL		;RECLAIM DDT
	JRST RSKP

OPRFSD:	PUSHJ P,DDTFSH		;FLUSH DDT
	JRST RSKP

OPRBSW:	CAIL 2,0		;SET DEBUGSWITCH TO 0 THRU 2
	CAILE 2,2		; ..
	JRST OPRFXX		;BAD VALUE
	MOVEM 2,DBUGSW		;OK. SET IT
	JRST RSKP

OPRCSW:	CAIE 2,0		;0 OR 1 TO DCHKSW
	CAIN 2,1
	JRST OPRCS1		;OK
OPRFXX:	MOVEI 1,OPRFX2			;BAD ARG ERROR CODE
	POPJ P,0		;NON-SKIP RETURN
OPRCS1:	MOVEM 2,DCHKSW		;STORE GOOD DCHKSW
	JRST RSKP

IFE SUMEX,<			;!! REMOVE THIS 1.33 CODE FROM 1.31
				;FOR THE MOMENT
OPRMPA:	MOVE 1,2		;MOVE ARGUMENTS OVER TO 1 AND 2
	MOVE 2,3
	CAMLE 1,2		;PAGES IN RIGHT ORDER?
	JRST OPRFXX
	CAMLE 1,SWPCOR		;AND IN REASONABLE AREA?
	CAIL 2,MAXCOR		; ..
	JRST OPRFXX		;NO
	PUSHJ P,MKPGSA		;PUT PAGES ON LINE
	JRST RSKP

>
OPRMPU:	MOVE 1,2		;PUT PAGES ON LINE
	MOVE 2,3
	CAMLE 1,2
	JRST OPRFXX
	CAML 1,SWPCOR
	CAIL 2,MAXCOR
	JRST OPRFXX
IFE SUMEX,<
	PUSHJ P,MKPGSU
>
IFN SUMEX,<
	PUSHJ P,MAKPGU
	UMOVEM 1,2
>
	JRST RSKP

OPRUSP:	JUMPL 2,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM 2,USRSPC##	;SET USER DISK LIMIT
	JRST RSKP

OPRSSP:	JUMPL 2,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM 2,SYSSPC##	;SET SYSTEM DISK LIMIT
	JRST RSKP

SPTM==17777
OPRMAP:	MOVE 1,2		;SPECIAL PMAP, MOVE AC'S 1 AND 2
	MOVE 2,3
	AND 2,[TRAPUB+COPYB,,777000] ; ALLOW CW AND TRAP ACCESS OPT
	TLO 2,400000+READB+ACCESB ;AND MAP FOR READS INTO USER SPACE
	HLRZ 3,1		;GET OFN
	JUMPE 3,OPRSP1		;SPT PAGE
	TDNE 1,[-SPTM-1,,777000] ;LEGAL ID?
	 JRST OPRFXX		;NO
	MOVSI 4,-NFKS
	NOSKED
OPRSP3:	HLRZ 5,FKPGS(4)		;CHECK TO SEE IF OFN IS UPT
	SKIPL FKPT(4)		;ONLY CHECK LEGAL FORKS
	CAIE 5,(3)		;THIS ONE?
	JRST .+2
	 JRST OPRSP2		;YES
	AOBJN 4,OPRSP3		;NO
	OKSKED
	JRST OPRFXX

OPRSP1:	CAIL 1,SSPT		;SPT INDEX LEGAL?
	 JRST OPRFXX
	NOSKED
	MOVSI 3,(-1B13)		;SPT IN USE?
	TDNN 3,SPT(1)
	 JRST 	[OKSKED		;NO
		JRST OPRFXX]

OPRSP2:	PUSHJ P,SETMPG		;MAP IT
	OKSKED
	AOS (P)
	POPJ P,

	END



COMMENT ⊗   VALID 00021 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	BEGIN "LINK11"
C00014 00003
C00016 00004
C00019 00005	    SIMPLE INTEGER PROCEDURE PICKONE
C00022 00006	    ! PROCEDURE TO CONVERT RAD50 VALUE TO ASCII
C00025 00007	    ! PROCEDURE TO READ IN OCTAL VALUES
C00027 00008	    ! NOW FOR SOME TIMING ROUTINES
C00029 00009		PROCEDURE DOSWITCH(REFERENCE STRING SWITCHSTR)
C00031 00010	    ! PROCEDURE TO READ COMMAND STRING
C00038 00011	    ! PROCEDURE TO READ IN STANDARD MACX11 LOAD BLOCK
C00040 00012	    ! PROCEDURE  TO SERVICE  ONE GSD ENTRY
C00047 00013	    ! PROCEDURE TO READ IN ALL OF THE GSD BLOCKS
C00048 00014	    ! PROCEDURE TO READ IN ALL DATA
C00050 00015	    TTYUP(TRUE)
C00054 00016		    ! PROCEDURE TO DUMP A BLOCK IN LNKX11 FORMAT (LESS CMD)
C00056 00017		    ! PROCEDURE TO LOAD A BYTE IN CORE
C00058 00018		    ! PROCEDURE THAT REALLY DOES THE DUMP
C00059 00019		    ! THE MAIN LOOP PROCEDURE
C00064 00020		    ! HERE BEGINS  EXECUTION STATEMENTS FOR PROCEDURE READDATA
C00070 00021		IF LSTAR THEN
C00077 ENDMK
C⊗;
BEGIN "LINK11"
    REQUIRE "BAYSAI.SAI[A710SA00]" SOURCE!FILE;
    SOURCE!L(TMPFIL);
    SOURCE!(FILE[a711pd11]);	! Differs from standard FILE.SAI in that DEVICE is returned;
    SOURCE!(QKSORT[A711PD11]);	! Sorting for symbol table output;
    LOAD!(QKSORT[A711PD11]);

    DEFINE	ID20 = "COMMENT";
    ! PROGRAM TO LINK MACY11 OBJECT FILES FOR GRAPHIC SYSTEMS
    WRITTEN BY DONN BIHARY
    L* ADDITIONS BY GEORGE ROBERTSON
    DDT AND OTHER MINOR CONSIDERATIONS BY STEVEN RUBIN
    Minor modifications for correct processing of RLD types 15, 16  by Richard H. Gumpertz (RG02)
    Rework of Command Processing by Rick Gumpertz
    Correction of internal symbol processing by Rick Gumpertz
    Fix of RLD loop limits by Rick Gumpertz, 21 Feb 75
    Changes for giving Register SYMBOLS to DDT by Rick Gumpertz, 31 May 75
    Changes for new DDT symbol table creation by Rick Gumpertz, 31 May 75
    LoadAddress computation fixed, SECOFF deleted by Rick Gumpertz, 3 July 75
    Graphic Monitor calls changed to delete the extra 0 word by Rick Gumpertz, 4 July 75
    /T:n added to set Transfer address (not to be confused with /T) by Rick Gumpertz, 4 July 75
    2.14: WANTREAD/WANTWRITE calls added by Rick Gumpertz, 22 July 75
    2.15: New LOADTR, RELOCA graphic monitor messages used, Rick Gumpertz, 30 July 75
    2.16: Added code to handle .IDENT, Rick Gumpertz, 11 Aug 75
    2.17: made graphics relocation skip blocks not needing relocation, Rick Gumpertz, 26 Aug 75
    2.18: prepared for making CSECTS whose name is of the form G.xxxx be loaded into graphics space, Rick Gumpertz, 26 Aug 75
    2.18: also made "'" in map follow the val, rather than precede. Rick Gumpertz, 26 Aug 75
    2.19: made internal symbols appear in map, Rick Gumpertz, 13 Sept 75
    2.19: suppressed .MACN. if defined internal, Rick Gumpertz, 13 Sept 75
    2.20: printed symbol table size in .MAP file, Rick Gumpertz, 19 Sept 75
    2.21: Fixed bug in folding of switches to upper case, Rick Gumpertz, 20 Oct 75
    2.22: Fixed ReadBlk to adjust BYTCOUNT by 4 before looping, to allow
	  for the 2 words it has already read, Rick Gumpertz, 1 June 77
    2.23  Inserted the Warn (%), Error (?) and FatalError(?) routines
	  to tidy up messages. ID20.
    3.0   Changed map file format to imrpove readability of module
	  descriptions. Added Global symbols table to Map file.
    ;
    REQUIRE (3 LSH 6)+0 VERSION;	ID20: September 11, 1978;
    DEFINE VERSION=" ""Link11 Version 3.0"" ";
    DEFINE PASS1="NOT PASS2";
    DEFINE GSDLIM="1000";			! UPPER LIMIT ON NUMBER OF GLOBALS;
    DEFINE INTLIM="3000";			! UPPER LIMIT ON NUMBER OF INTERNALS;
    DEFINE CSECTLIM="300";			! UPPER LIMIT ON NUMBER OF CSECTS;
    DEFINE FILELIM="100";			! UPPER LIMIT ON NUMBER OF FILES;
    DEFINE SYBLSZ="256%6-8";			! Number of symbols per load record;
    DEFINE LOADR="'104407";
    DEFINE LOADA="'104410";
    DEFINE MOVB!R0!ATR1="'110011";	! MOVB R0,@R1;
    DEFINE LOADTR="'104411";
    DEFINE RELOCA="'104454";
!    DEFINE RELOC="'104425";
    DEFINE ABSSYM= "('127401+('007624 LSH 16))";! RAD50 FOR ". ABS.";
    DEFINE DDTKSR33="""DDT[A711PD11]""";	! KSR33 DDT;
    DEFINE DDTGRAPH="""DDTG[A711PD11]""";	! GRAPHICS DDT;
    DEFINE DDTGT40="""DDTUCB[A711PD11]""";	! GT40 DDT;
    DEFINE D!DDT="'14664+(0 LSH 16)";		! RAD50 FOR "DDT   ";
    DEFINE D!JOBSA="'40332+('73350 LSH 16)";	! RAD50 FOR "JOBSA ";
    DEFINE D!SYMT="'16563+('117134 LSH 16)";	! RAD50 FOR "D.SYMT";
    DEFINE D!JOBDDT="('40332+('14664 LSH 16))";	! RAD50 FOR "JOBDDT";
    DEFINE D!R0="('72460+('0 LSH 16))";		! RAD50 for "R0";
    DEFINE D!SP="('74500+('0 LSH 16))";		! RAD50 for "SP";
    DEFINE D!PC="('62170+('0 LSH 16))";		! RAD50 for "PC";
    DEFINE D!MACN="('130411+('12414 LSH 16))";	! RAD50 for ".MACN.";
    DEFINE RELOC!BIT = "'200000";		! BIT TO INDICATE RELOCATABLE;
    DEFINE GRAPHIC!RELOC!BIT = "'400000";	! BIT TO INDICATE RELOCATABLE RELATIVE TO A GRAPHIC CSECT;
    DEFINE ALL!RELOC!BITS = "(RELOC!BIT LOR GRAPHIC!RELOC!BIT)";	! ANY SORT OF RELOCATION;
    DEFINE REGISTER!BIT = "'1000000";		! BIT TO INDICATE A REGISTER VALUE;
    DEFINE ARRTYP="SAFE";

    ARRTYP INTEGER ARRAY LOADBLOCK[0:100],BLOCK[0:50];	! THIS HOLDS STANDARD MACX11 BLOCK FOR READIN;
    ARRTYP INTEGER ARRAY GSDSYM,GSDVAL[0:GSDLIM];	! HOLD GLOBAL SYMBOLS;
    ARRTYP INTEGER ARRAY INTSYM,INTVAL[0:INTLIM];	! HOLD INTERNAL SYMBOLS;
    ARRTYP INTEGER ARRAY CSECTSYM,CSECTVAL[0:CSECTLIM];	! HOLD CSECT VALUES;
    ARRTYP INTEGER ARRAY SFILE,EFILE[0:FILELIM];	! START AND END POINTERS TO CSECTS FOR EACH FILE;
    ARRTYP INTEGER ARRAY BUFFER[0:255];			! OUTPUT BUFFER;
    ARRTYP INTEGER ARRAY GLONAM[0:50];			! HOLDS SYMS FOR L* REFS;
    ARRTYP INTEGER ARRAY GLOREF[0:50,0:50];		! HOLDS REFS TO L* SYMS;

    EXTERNAL INTEGER RPGSW;				! FOR CCL CALLS;
    INTEGER EI,EO,BI,BO,FI,FO,EM,BM,FM,
    ET,BT,FT,CI,CO,CM,CT;
    INTEGER SUM,MAPFIL;
    INTEGER I,J,K,L,SCANR;
    STRING OUTFILE,INFILES,S;
    STRING ROUTFILE,RINFILES,COMFILES;
    STRING INFILE,REPTFILE;
    INTEGER SEDSUM;			! CHECKSUM FOR OUTPUT;
    INTEGER GSD!SYMT,GSD!DDT,GSD!JOBSA;	! LOCATIONS OF D.SYMT,DDT, AND JOBSA;
    INTEGER IDENT;			! PROGRAM IDENTIFICATION (IN RAD50);
    INTEGER COMD;			! TRUE FOR COMD TABLE OUTPUT;
    INTEGER BUFPOI;			! POINTER INTO OUTPUT BUFFER;
    INTEGER PACKER;
    INTEGER PACKVALS;
    INTEGER TELLALL;			! IF TRUE, TELL ALL TO TTY;
    INTEGER FILEADD;			! CURRENT FILE BEING PROCESSED;
    INTEGER CSECTADD;			! CURRENT CSECT BEING PROCESSED;
    INTEGER LASTCSECTVAL;		! FIRST ADDRESS OF LAST CSECT PROCESSED;
    INTEGER CSECTNUM,GLOBNUM;		! NUMBER OF CSECTS, AND NUMBER OF GLOBS;
    INTEGER PROGGLOB;
    INTEGER GRAPHONLY;			! TRUE TO LOAD PROGRAM INTO GRAPHICS SPACE;
    INTEGER DDT,DDTUCB;			! FLAGS TO DENOTE DDT PACKAGES TO LOAD;
   INTEGER DDTEMPTYSYMS;		! Count of extra slots to put in DDT Symbol table;
    INTEGER PACKED,OBYT,OWRD;		! PACKED OUTPUT INDICATORS;
    INTEGER GSDADD,INTADD;		! CURRENT ADDRESS IN GSD AND INT ARRAY (INTITALLY 0);
    INTEGER COREADD,COREPOS,GCOREPOS;	! CURRENT CORE ADDRESS FOR DATA;
    INTEGER LOWEND;			! LOW END OF RELATIVE CODE;
    INTEGER DoReloc;			! SENDS RELOCATION MESSAGE IF ON;
    INTEGER MESTYPE;			! SEND LOAD IN MESSAGE FORMAT IF ON;
    INTEGER LSTAR;			! OUTPUT L*11 LOAD FORMAT IF ON;
    INTEGER FORCEMAP;			! FORCE A MAP, EVEN IF NO NAME GIVEN;
    INTEGER SUPPRESSINTERNAL;		! SUPRESS INTERNAL SYMBOLS IN THE DDT SYMBOL TABLE;
    INTEGER SUPPRESSBLISS;		! SUPPRESS BLISS-11 GENERATED INTERNAL SYMBOLS IN THE DDT SYMBOL TABLE;
    INTEGER TOTSIZ,GTOTSIZ;		! TOTAL SIZE OF RELOCATION;
    INTEGER ABSSIZ;			! NUMBER OF ABSOLUTE LOCATIONS LOADED;
    INTEGER TRNVAL;			! TRANSFER ADDRESS;
    INTEGER FORCETRNVAL;		! TRANSFER ADDRESS SET BY /T:n;
    INTEGER STRTADD;
    INTEGER SECSIZ;
    INTEGER GLOADD;			! CURRENT ADDRESS IN GLONAM ARRAY;

!---------------------------------------------------------------------
     The following  routines  are for  issuing error  messages.  Warn
 types the string with a '%' in front. Error and Fatal error describe
 the message with '?' in front. FatalError exits from the program.
!---------------------------------------------------------------------;

SIMPLE PROCEDURE Warn(STRING Text);
 BEGIN
  STRING ErrorMessage;

  ErrorMessage ← "% "&Text&CRLF;
  Print(ErrorMessage);

  IF MapFil
    THEN Out(CM,ErrorMessage)

 END;

SIMPLE PROCEDURE Error(STRING Text);
 BEGIN
  STRING ErrorMessage;

  ErrorMessage ← "? "&Text&CRLF;
  Print(ErrorMessage);

  IF MapFil
    THEN Out(CM,ErrorMessage)

 END;

SIMPLE PROCEDURE FatalError(STRING Text);
 BEGIN

  Error(Text);

  CallExit

 END;

!---------------------------------------------------------------------
     The Print!Symbols  routine will print a  table of global symbols
 if the 'X' switch was set in the command line.

     The format of the table is ? columns of symbol-value pairs.
!---------------------------------------------------------------------;

FORWARD STRING PROCEDURE CNVRAD(INTEGER RAD);

PROCEDURE Print!Symbols;
 BEGIN
  INTEGER Symbol!Number, Remember!Symbol!Number;

  STRING ARRAY Symbol!Names[ 1 : GSDADD ];

  SIMPLE PROCEDURE Print!Symbol(INTEGER Symbol);
   BEGIN
    Out(CM,Symbol!Names[Symbol]&" "&CVOS(GSDVAL[Symbol] LAND '177777)&Tab);
   END;

  DEFINE Num!Columns = 4;

  INTEGER Orphans, Rows, i, j;

  IF NOT MapFil
    THEN RETURN;

  SetFormat(-6,0);
  Out(CM,FormFeed&"
		      Global Symbol Table
		      -------------------

"     );

  FOR i ← 1 THRU GSDADD DO
   Symbol!Names[i] ← CNVRAD(GSDSYM[i]);

  SC!Qsort(Symbol!Names,GSDVAL,GSDADD);

  Symbol!Number ← 1;

  WHILE (Symbol!Number LEQ GSDADD) AND Length(Symbol!Names[Symbol!Number]) = 0 DO
    BEGIN
     Symbol!Number ← Symbol!Number + 1;
     GSDADD ← GSDADD - 1
    END;

  Orphans ← GSDADD MOD Num!Columns;

  Rows ← (GSDAdd + (IF Orphans NEQ 0 THEN (Num!Columns - Orphans) ELSE 0)) / Num!Columns;

  FOR i ← 1 THRU Rows DO
   BEGIN
    Remember!Symbol!Number ← Symbol!Number;
    FOR j ← 1 THRU Num!Columns DO
       BEGIN
	IF Symbol!Number LEQ GSDADD
	  THEN Print!Symbol(Symbol!Number);
        Symbol!Number ← Symbol!Number + Rows;
       END;

    Symbol!Number ← Remember!Symbol!Number + 1;

    Out(CM,CRLF)
   END;

 END;
    SIMPLE INTEGER PROCEDURE PICKONE;
    BEGIN "PICKONE"
	INTEGER A;
	CASE PACKER OF 
	BEGIN
	    BEGIN
		PACKVALS←WORDIN(CI);
		A←(PACKVALS LAND '377000000) LSH -18;
	    END;
	    A←(PACKVALS LAND '177400000000) LSH -26;
	    A←PACKVALS LAND '377;
	    A←(PACKVALS LAND '177400) LSH -8
	END;
	PACKER←(PACKER+1) MOD 4;
	RETURN(A);
    END "PICKONE";

    SIMPLE INTEGER PROCEDURE READBYT;
    BEGIN "READBYT"
	INTEGER A;
	SUM←SUM+(A←PICKONE);
	RETURN(A);
    END "READBYT";

    SIMPLE INTEGER PROCEDURE READWOD;
    BEGIN "READWOD"
	INTEGER A;
	A←READBYT;
	RETURN(A+(READBYT LSH 8));
    END "READWOD";

    SIMPLE PROCEDURE BUFDUMP;
    BEGIN "BUFDUMP"
	IF BUFPOI THEN ARRYOUT(CO,BUFFER[0],BUFPOI);
	BUFPOI←0;
    END "BUFDUMP";

    SIMPLE PROCEDURE BYTOUT(INTEGER B);
    BEGIN "BYTOUT"
	IF PACKED THEN
	BEGIN "PACKED.OUT"
	    DPB(B LAND '377,(POINT(8,OWRD,(CASE OBYT OF (17,9,35,27)))));
	    IF (OBYT←OBYT+1) GEQ 4 THEN
	    BEGIN "LAST.BYTE"
		BUFFER[BUFPOI]←OWRD;
		IF (BUFPOI←BUFPOI+1) > 255 THEN BUFDUMP;
		OBYT←OWRD←0;
	    END "LAST.BYTE" 
	END "PACKED.OUT" ELSE
	BEGIN
	    BUFFER[BUFPOI]←B; ! LAND '377;
	    IF (BUFPOI←BUFPOI+1) > 255 THEN BUFDUMP;
	END;
	SEDSUM←SEDSUM+B;
    END "BYTOUT";

    SIMPLE PROCEDURE WODOUT(INTEGER W);
    BEGIN "WODOUT"
	BYTOUT(W);
	BYTOUT(W LSH -8);
    END "WODOUT";
    ! PROCEDURE TO CONVERT RAD50 VALUE TO ASCII;

    STRING PROCEDURE CNVRAD(INTEGER RAD);
    BEGIN "CNVRAD"
	STRING ASC;
	INTEGER I,J;
	ASC←NULL;
	RAD←(RAD LAND '177777)*'50*'50*'50 +(((RAD LSH -16) LAND '177777));
	FOR  I←1 THRU 6 DO
	BEGIN
	    J←RAD MOD '50;
	    RAD←RAD DIV '50;
	    IF J=0 THEN J←" " ELSE
	    IF J<'33 THEN J←J+'100 ELSE
	    IF J='33 THEN J←"$" ELSE
	    IF J='34 THEN J←"." ELSE
	    IF J='35 THEN J←"?" ELSE
	    J←J+'22;
	    ASC←J&ASC;
	END;
	RETURN(ASC);
    END "CNVRAD";

    ! PROCEDURE TO RETURN SYMBOL VALUE;

    INTEGER PROCEDURE GETSYM(INTEGER SYM,OFFSET);
    BEGIN "GETSYM"
	INTEGER I,J,K;

	FOR I←1 THRU GSDADD DO IF SYM=GSDSYM[I] THEN RETURN(GSDVAL[I]);

	IF LSTAR THEN
	BEGIN "LSGLO"
	    K←0;
	    FOR I←1 THRU GLOADD DO IF SYM=GLONAM[I] THEN
	    BEGIN
		K←I;
		DONE
	    END;
	    IF K=0 THEN
	    BEGIN
		GLOADD←GLOADD+1;
		GLONAM[GLOADD]←SYM;
		K←GLOADD;
	    END;
	    J←(GLOREF[K,0]←GLOREF[K,0]+1);
	    GLOREF[K,J]←OFFSET;
	    RETURN(0);
	END "LSGLO";
	Warn("Undefined External Reference to "&CNVRAD(SYM)&" in file "&INFILE);
	RETURN(0);
    END "GETSYM";

    ! RETURN A CSECT VALUE WITHIN GIVEN MODULE;
    INTEGER PROCEDURE GETSEC(INTEGER SECT);
    BEGIN "GETSEC"
	INTEGER I;
	IF SECT=ABSSYM THEN RETURN(0);
	FOR I←SFILE[FILEADD] THRU EFILE[FILEADD] DO IF SECT=CSECTSYM[I] THEN RETURN(CSECTVAL[I]);
	FatalError("Failed to file CSECT "&CNVRAD(SECT)&" in file "&INFILE);
    END "GETSEC";
    ! PROCEDURE TO READ IN OCTAL VALUES;

    INTEGER PROCEDURE OCTGET(REFERENCE STRING S);
    BEGIN "OCTGET"
	INTEGER I,J,K;
	I←0;
	IF S[1 TO 1]=":" THEN S←S[2 TO INF];
	WHILE S DO
	BEGIN
	    J←S[1 FOR 1];
	    IF J>"7" OR J<"0" THEN DONE;
	    J←LOP(S) LAND '7;
	    I←(I LSH 3) + J;
	END;
	RETURN(I);
    END "OCTGET";

    ! PROCEDURES FOR READING IN STRING OF FILES;
    ! FIRST THE ADD EXTENSION PROCEDURE;

    STRING PROCEDURE ADDEXT(STRING FILE,EXT);
    BEGIN "ADDEXT"
	STRING OFILE,NFILE;
	INTEGER A;
	OFILE←FILE;
	NFILE←NULL;
	WHILE TRUE DO
	BEGIN
	    IF NOT FILE THEN RETURN(OFILE&"."&EXT);
	    A←LOP(FILE);
	    IF A="." THEN RETURN(OFILE);
	    IF A="[" THEN RETURN (NFILE&"."&EXT&"["&FILE);
	    NFILE←NFILE&A;
	END;
    END "ADDEXT";
    ! NOW FOR SOME TIMING ROUTINES;

    PRELOAD!WITH "January",	"February",	"March",
		 "April",	"May",		"June",
		 "July",	"August",	"September",
		 "October",	"November",	"December";

     STRING ARRAY Months[1:12];

    INTERNAL STRING PROCEDURE DATIT;
    BEGIN "DATIT"
	INTEGER DATE,D,M,Y;
	DATE←CALL(1,"DATE");	! GET DATE;
	D←(DATE MOD 31)+1;
	DATE←DATE DIV 31;
	M←(DATE MOD 12) +1;
	DATE ←DATE DIV 12;
	Y←64+DATE;
	SETFORMAT(0,0);
	RETURN(Months[M]&" "&CVS(D)&", 19"&CVS(Y));
    END "DATIT";

    INTERNAL STRING PROCEDURE TIMEDAY;
    BEGIN "TIMEDAY"
	INTEGER TIME;
	SETFORMAT(0,0);
	TIME←CALL(1,"MSTIME");
	RETURN(CVS(TIME DIV 3600000)&":"&CVS((TIME DIV 60000)MOD 60)&
	":"&CVS((TIME DIV 1000) MOD 60));
    END "TIMEDAY";
	PROCEDURE DOSWITCH(REFERENCE STRING SWITCHSTR);
	BEGIN "DOSWITCH"
	    WHILE SWITCHSTR DO
		BEGIN
		    INTEGER S;
		    S←LOP(SWITCHSTR);
		    IF S GEQ "a" AND S LEQ "z" THEN S←S-("a"-"A");
		    IF S="B" THEN COREADD←OCTGET(SWITCHSTR)  ELSE
		    IF S="C" THEN COMD←TRUE ELSE
		    IF S="D" THEN BEGIN
			DDT←TRUE;
			IF SWITCHSTR[1 TO 1] = ":"
			    THEN DDTEMPTYSYMS←OCTGET(SWITCHSTR);
		    END ELSE
		    IF S="E" THEN ! /E IGNORED FOR LNKX11 COMPATIBILTIY; ELSE
		    IF S="G" THEN GRAPHONLY←TRUE ELSE 
		    IF S="L" THEN FORCEMAP←TRUE ELSE
		    IF S="*" THEN DoReloc←LSTAR←TRUE ELSE
		    IF S="M" THEN DoReloc←MESTYPE←TRUE ELSE
		    IF S="P" THEN PACKED←TRUE ELSE
		    IF S="S" THEN SUPPRESSINTERNAL←TRUE ELSE
		    IF S="$" THEN SUPPRESSBLISS←TRUE ELSE
		    IF S="T"
			THEN IF SWITCHSTR[1 to 1] = ":"
			    THEN FORCETRNVAL←OCTGET(SWITCHSTR)
			    ELSE TELLALL←TRUE
			ELSE
		    IF S="U" THEN DDTUCB←TRUE ELSE
		    Error("Illegal switch: """&S&"""");
		END
	END "DOSWITCH";
    ! PROCEDURE TO READ COMMAND STRING;

    PROCEDURE COMSTR;
    BEGIN "COMSTR"
	STRING BEGSTR;
	INTEGER SCANB;

	SETBREAK(1,"#"," "&CRLF&TAB,"KISN"); ! BREAK TABLE FOR READING CMD FILES;
	SETBREAK(2,"←=/%("," ","IS");	! BREAK TABLE FOR FINDING MAP FILE;
	SETBREAK(3,"←=,"," ","IS");	! BREAK TABLE FOR READING OUTPUT FILE;
	SETBREAK(4,",/%([",NULL,"IS"); ! BREAK TABLE FOR FINDING .CMD FILE;
	SETBREAK(5,",["," ","IS");	! BREAK TABLE FOR FILES;
	SETBREAK(6,"]"," ","IA");	! BREAK TABLE FOR PPN SCAN;
	SETBREAK(7,"←="," ","IA");	! BREAK TABLE FOR FINDING OUTPUT LINE FOR MAP;
	SETBREAK(8,"/%("," ","IS");	! BREAK TABLE FOR FINDING SWITCHES;
	SETBREAK(9,")"," ","IS");	! BREAK TABLE FOR FINDING END OF ( SWITCHES;
	SETBREAK(10,"←,/%( ",NULL,"IR"); ! BREAK TABLE FOR FINDING END OF / SWITCHES;
	SETBREAK(11,"@",NULL,"IS");	! BREAK TABLE FOR FINDIN @;
	SETBREAK(12,"=←,)",NULL,"IA");
	SETBREAK(13,".",NULL,"IS");	! BREAK TABLE FOR STRIPPING OFF EXTENSIONS;
	COMD←GRAPHONLY←PROGGLOB←DoReloc←MESTYPE←LSTAR←SUPPRESSINTERNAL←SUPPRESSBLISS←FORCEMAP←TELLALL←PACKED←DDT←DDTUCB←MAPFIL←0;
	DDTEMPTYSYMS←5;
	COREADD←-1;
	TRNVAL←1;
	IF RPGSW THEN RPGSW←RTMPFILE("LNK",COMFILES,TRUE,TRUE);
	IF RPGSW THEN Print(VERSION,": ") ELSE
	BEGIN
	    Print(VERSION,CRLF);
	    COMFILES←NULL;
	    WHILE NOT COMFILES
		DO BEGIN Print("*"); COMFILES←INCHWL END;
	END;

	WHILE TRUE DO BEGIN
	    STRING ATFILE,ATSTR,BEGSTR;
	    ATSTR←COMFILES;
	    ATFILE←SCAN(ATSTR,11,SCANB);
	    IF SCANB LEQ 0 THEN DONE;
	    BEGSTR←NULL;
	    IF ATFILE THEN WHILE TRUE DO BEGIN
		STRING S;
		S←SCAN(ATFILE,12,SCANB);
		IF SCANB LEQ 0
		    THEN BEGIN
			ATFILE←S;
			DONE
			END;
		BEGSTR←BEGSTR&S;
		END;
	    IF NOT ATFILE THEN BEGIN
		ATFILE←SCAN(ATSTR,4,SCANB);
		IF SCANB="["
		    THEN ATFILE←ATFILE&"["&SCAN(ATSTR,6,SCANB)
		    ELSE IF SCANB > 0 THEN ATSTR←SCANB&ATSTR
		END;
	    ATFILE←ADDEXT(ATFILE,"CMD");
	    IF WANTREAD(CT←-1,0,BT,ET,ATFILE)
		THEN S←NULL
		ELSE S←INPUT(CT,1);
	    COMFILES←BEGSTR&S&ATSTR;
	    RELEASE(CT);
	    END;

	BEGSTR←COMFILES;
	RINFILES←NULL;
	WHILE TRUE DO
	    BEGIN
	    RINFILES←RINFILES&SCAN(BEGSTR,8,SCANB);	! READ INPUT FILES;
	    IF (SCANB = "/") OR (SCANB = "%")
		THEN DOSWITCH(S←SCAN(BEGSTR,10,SCANB))
		ELSE IF SCANB = "("
		    THEN DOSWITCH(S←SCAN(BEGSTR,9,SCANB))
		    ELSE DONE
	    END;

	ROUTFILE←SCAN(RINFILES,3,SCANB);	! READ OUTPUT FILE NAME;

	IF (SCANB=",") OR FORCEMAP THEN
	BEGIN
	    STRING MAPFILE;
	    IF SCANB = ","
		THEN MAPFILE←SCAN(RINFILES,2,SCANB)
		ELSE MAPFILE←SCAN(S←ROUTFILE,13,0);
	    MAPFILE←ADDEXT(MAPFILE,"MAP");
	    MAPFIL←NOT WANTWRITE(CM←-1,0,MAPFILE);
	END;

	IF (SCANB NEQ "=") AND (SCANB NEQ "←")
	  THEN BEGIN
		Error("Missing ""="" or ""←"" in command line.");
		FatalError("Command line was '"&COMFILES&"'")
	       END;

	IF COREADD < 0 THEN COREADD←(IF DoReloc THEN 0 ELSE '10000);
	COREPOS←COREADD;
	GCOREPOS←0;

	IF MESTYPE AND (COMD OR DDTUCB OR COREADD OR PACKED) THEN Error("Illegal Graphics switch.");

	IF DDT THEN RINFILES←RINFILES&","&(IF DDTUCB THEN DDTGT40 ELSE
		IF MESTYPE THEN DDTGRAPH ELSE DDTKSR33);
	OUTFILE←ADDEXT(ROUTFILE,(IF LSTAR THEN "LS" ELSE IF MESTYPE THEN "LNK" ELSE IF PACKED THEN "LDA" ELSE "BIN"));
	IF WANTWRITE(CO←-1,'14,OUTFILE)
	    THEN FatalError("Cannot continue without output file.");
	Print(OUTFILE,CRLF);
	IF MAPFIL THEN BEGIN
	    INTEGER CH;
	    BOOLEAN INPPN;
	    OUT(CM,CRLF&VERSION&" at "&TimeDay&" on "&DatIt&CRLF&LF&LF&
		"*"&SCAN(COMFILES,7,CH)&CRLF&TAB);
	    INPPN←FALSE;
	    WHILE COMFILES DO
		begin
		    CH←LOP(COMFILES);
		    IF (CH=",") AND NOT INPPN
			THEN OUT(CM, ","&CRLF&TAB)
			ELSE BEGIN
			    IF CH="[" THEN INPPN←TRUE
			    ELSE IF CH="]" THEN INPPN←FALSE;
			    OUT(CM, CH)
			END;
		end;
	    OUT(CM,CRLF&CRLF&"Program: "&OUTFILE&CRLF&CRLF);
	    END;
	SETFORMAT(10,0);
    END "COMSTR";
    ! PROCEDURE TO READ IN STANDARD MACX11 LOAD BLOCK;

    PROCEDURE READBLK;
    BEGIN "READBLK"
	INTEGER ADDR,BYTCOUNT;
	SUM←0;
	ARRBLT(BLOCK[1],BLOCK[0],50);		! CLEAR TO ZEROS;
	WHILE READBYT NEQ 1 DO;
	READBYT;
	BLOCK[1]←1;
	BYTCOUNT←(BLOCK[2]←READWOD)-4;
	IF BYTCOUNT>190 THEN FatalError("Block of length "&CVS(BytCount)&" in file "&InFile&" is too big.");
	ADDR←6;
	WHILE BYTCOUNT DO
	BEGIN
	    INTEGER A,B;
	    A←READBYT;
	    IF (ADDR MOD 2) = 0 THEN BLOCK[ADDR DIV 2]←A ELSE
	    BEGIN
		B←BLOCK[ADDR DIV 2] LAND '377;
		B←B LOR (A LSH 8);
		BLOCK[ADDR DIV 2]←B;
	    END;
	    ADDR←ADDR+1;
	    BYTCOUNT←BYTCOUNT-1;
	END;
	READBYT;
	IF SUM LAND '377 THEN 
	BEGIN
	    FatalError("Checksum error in file "&InFile&".")
	END;
    END "READBLK";

    SIMPLE PROCEDURE BLOCKEND;
    BEGIN "BLOCKEND"
	BYTOUT(-SEDSUM);
	IF NOT MESTYPE THEN
	BEGIN
	    IF PACKED
		THEN IF OBYT LAND 1
		    THEN BYTOUT(0);	! MAKE PDP-10 OCTAL DUMP READABLE;
	    WODOUT(0);
	    WODOUT(0);
	    WODOUT(0);
	END;
    END "BLOCKEND";
    ! PROCEDURE  TO SERVICE  ONE GSD ENTRY;

    PROCEDURE CHECKVAL(INTEGER VAL);
    BEGIN "CHECKVAL"
	INTEGER SYM,TYP,FLG,I,REPT,VALUE;
	STRING SYMNAM;

	PROCEDURE DEFGLBL;
	    BEGIN
		    FOR I←1 THRU GSDADD DO IF SYM=GSDSYM[I] THEN	! DUPLICATE GLOBAL;
		    BEGIN
			IF GSDVAL[I] = VALUE THEN RETURN;
			Warn("Duplicate Global Symbol:        "&SYMNAM&" in file "&INFILE);
			! Print("Old value = ",CVOS(GSDVAL[I])," New value = ",CVOS(VALUE),CRLF);
			RETURN;
		    END;
		    IF (GSDADD←GSDADD+1)>GSDLIM THEN FatalError("Too many globals");
		    GSDSYM[GSDADD]←SYM;
		    GSDVAL[GSDADD]←VALUE;
	    END;

	SYM←BLOCK[VAL]+(BLOCK[VAL+1] LSH 16) ;
	SYMNAM←CNVRAD(SYM);		! ASCII CONVERSION;

	VALUE←BLOCK[VAL+3];	! ENTRY VALUE;

	FLG←BLOCK[VAL+2] LAND '377;	! ENTRY FLAG;
	    ! BIT 3, DEFINING OCCURRENCE (THESE IGNORED ALWAYS);
	    ! BIT 5, RELOCATE;
	    ! BIT 6, GLOBAL (OTHERWISE INTERNAL) ;
		! (ALL NON-NULL CSECTS ARE CONSIDERED GLOBAL FOR NOW);

	TYP←(BLOCK[VAL+2] LSH -8) LAND '377;	! ENTRY TYPE;
	    ! 0 - MODULE;
	    ! 1 - CSECT;
	    ! 2 - INTERNAL;
	    ! 3 - TRANSFER ADDRESS;
	    ! 4 - GLOBAL;
	    ! 5 - PSECT;
	    ! 6 - Program ID;

	IF TYP > 6 OR TYP = 5 THEN FatalError("GSD type "&CVS(TYP)&"not implemented")
	ELSE CASE TYP OF
	BEGIN
	[0] BEGIN
		    S←"Module: "&SYMNAM&"  Size     Address"&Tab&"File: "&INFILE&CRLF;
		    IF TELLALL THEN Print(S);
		    IF MAPFIL
		      THEN OUT(CM,CRLF&"------------------------------------------------------------------"&CRLF&CRLF&S);
		    IDENT←SYM;
	    END;
	[1] BEGIN
		SECSIZ←(VALUE+1) LAND '177776 ;
		IF SYM = ABSSYM
		    THEN BEGIN
! The following won't work since the assembler doesn't set length correctly:
			ABSSIZ←ABSSIZ+SECSIZ;

			LASTCSECTVAL←0
		    END
		    ELSE BEGIN
			VALUE←COREPOS;
			IF (SYM OR SECSIZ) THEN BEGIN
			    S←CRLF&"<"&SYMNAM&">  "&CVOS(SECSIZ)&
				CVOS(VALUE)&(IF DoReloc THEN "'" ELSE " ")&
				CVS(SECSIZ DIV 2)&" words"&CRLF;
			    IF TELLALL THEN Print(S);
			    IF MAPFIL THEN OUT(CM,S)
			    END;
			TOTSIZ←TOTSIZ+SECSIZ;
			COREPOS←COREPOS+SECSIZ;
			IF (CSECTADD←CSECTADD+1)>CSECTLIM THEN FatalError("Too many CSECTS");
			CSECTSYM[CSECTADD]←SYM;
			VALUE←VALUE LOR RELOC!BIT;
			LASTCSECTVAL←CSECTVAL[CSECTADD]←VALUE;
			IF SYM THEN DEFGLBL;
		    END
	    END;
	[2] BEGIN
		    IF (FLG LAND 1)
			THEN BEGIN
			    ! SUPPRESS R0-R7,SP,PC;
			     FOR I←0 THRU 7
				DO IF SYM = D!R0 + ('50*I)
					THEN RETURN;
			    IF SYM = D!SP THEN RETURN;
			    IF SYM = D!PC THEN RETURN;

			    VALUE←VALUE LOR REGISTER!BIT;
			END
			ELSE IF SYM = D!MACN
			    THEN RETURN
			    ELSE VALUE ← VALUE + LASTCSECTVAL;
		    S←"      "&SYMNAM&TAB&
			CVOS(VALUE LAND '177777)&
			(IF VALUE LAND REGISTER!BIT THEN "%"
			    ELSE IF DoReloc THEN IF VALUE LAND RELOC!BIT THEN "'"
			    ELSE IF VALUE LAND GRAPHIC!RELOC!BIT THEN """"
			    ELSE NULL ELSE NULL)&
			CRLF;
		    IF MAPFIL THEN OUT(CM,S);
		    IF SUPPRESSBLISS ! Suppress internal symbols with "$" as 2nd Char;
			THEN IF (((SYM LAND '177777) DIV '50) MOD '50) = '33
			    THEN RETURN;
		    FOR I←1 THRU INTADD
			DO IF SYM = INTSYM[I] THEN RETURN;
		    FOR I←1 THRU GSDADD
			DO IF SYM = GSDSYM[I] THEN RETURN;
		    IF (INTADD←INTADD+1)>INTLIM THEN FatalError("Too many internals");
		    INTSYM[INTADD]←SYM;
		    INTVAL[INTADD]←VALUE;
	    END;
	[3] IF NOT (VALUE = 1) THEN
	    BEGIN
		    INTEGER I,J;
		    IF SYM=ABSSYM
			THEN TRNVAL←VALUE
			ELSE BEGIN
			    FOR I←SFILE[FILEADD] THRU CSECTADD DO IF SYM=CSECTSYM[I] THEN BEGIN
				TRNVAL←VALUE+CSECTVAL[I] ;
				RETURN;
				END;
			    FatalError("Transfer address CSECT "&SYMNAM& " not found");
			END
	    END;
	[4] IF FLG LAND '10 THEN
	    BEGIN
		    IF FLG LAND '40 THEN VALUE←VALUE+LASTCSECTVAL;
		    S←"      "&SYMNAM&
			TAB&CVOS(VALUE LAND '177777)&
			(IF (FLG LAND '40) AND DoReloc THEN "'" ELSE NULL)&
			CRLF;
		    IF MAPFIL THEN OUT(CM,S);
		    DEFGLBL;
	    END;
	[6] BEGIN
		S←"Program Version ID: "&SYMNAM&CRLF;
		IF MAPFIL THEN OUT(CM,S);
		IF TELLALL THEN Print(S);
	    END
	END;
    END "CHECKVAL";
    ! PROCEDURE TO READ IN ALL OF THE GSD BLOCKS;

    PROCEDURE READGSD(INTEGER PASS2 );
    BEGIN "READGSD"
	INTEGER NUMENT,I,VAL;
	WHILE TRUE DO 
	BEGIN
	    READBLK;		! READ IN A MACX11 OUTPUT BLOCK;
	    IF BLOCK[3]=2 THEN DONE;
	    IF BLOCK[3] NEQ 1 THEN FatalError("Non-GSD Entry ("&CVS(Block[3])&")");
	    NUMENT←(BLOCK[2] DIV 2);
	    IF PASS1 THEN FOR VAL←4 STEP 4 UNTIL NUMENT DO CHECKVAL(VAL);
	END;
    END "READGSD";
    ! PROCEDURE TO READ IN ALL DATA;

    PROCEDURE PASS(INTEGER PASS2;PROCEDURE VARPROC);
    BEGIN "PASS"
	IF TELLALL THEN IF PASS1
	    THEN Print(CRLF,"Pass 1:",CRLF)
	    ELSE Print(CRLF,"Pass 2:",CRLF);
	FILEADD←0;
	IF PASS2
	    THEN RINFILES←REPTFILE;
	REPTFILE←NULL;
	WHILE RINFILES DO
	BEGIN
	    INFILE←SCAN(RINFILES,5,SCANR);
	    IF SCANR="[" THEN INFILE←INFILE&"["&SCAN(RINFILES,6,SCANR);
	    IF INFILE THEN
	    BEGIN "GETOBJ"
		INFILE←ADDEXT(INFILE,"OBJ");
		IF WANTREAD(CI←-1,'14,BI,EI,INFILE)
		    THEN CONTINUE;
		IF PASS1
		    THEN REPTFILE←REPTFILE&","&INFILE
		    ELSE IF TELLALL THEN Print("  ",INFILE,CRLF);
		PACKER←0;
		IF (FILEADD←FILEADD+1)>FILELIM THEN FatalError("Too many files");
		IF PASS1 THEN SFILE[FILEADD]←CSECTADD+1;
		READGSD(PASS2);
		IF PASS1 THEN EFILE[FILEADD]←CSECTADD;
		IF PASS2 THEN VARPROC;
		RELEASE(CI);
	    END "GETOBJ";
	END;
    END "PASS";

    PROCEDURE NOTHING;;
    TTYUP(TRUE);
    INTADD←GSDADD←CSECTADD←TOTSIZ←GTOTSIZ←ABSSIZ←BUFPOI←GSD!SYMT←GSD!DDT←GSD!JOBSA←0;
    FORCETRNVAL←-1;
    COMSTR;
    PASS(0,NOTHING);
    CSECTNUM←CSECTADD;
    GLOBNUM←GSDADD;

    FOR I←1 THRU GSDADD DO
    IF GSDSYM[I]=D!SYMT THEN GSD!SYMT←I ELSE
    IF GSDSYM[I]=D!DDT THEN GSD!DDT←I ELSE
    IF GSDSYM[I]=D!JOBSA THEN GSD!JOBSA←I;

    IF GSD!DDT AND GSD!JOBSA
	THEN BEGIN
	    INTEGER SYMTABSIZ;
	    DDT←TRUE;
	    IF GSD!SYMT = 0
		THEN BEGIN
		    IF (GSDADD←GSDADD+1)>GSDLIM THEN FatalError("Too many globals");
		    GSD!SYMT←GSDADD;
		    GSDSYM[GSDADD]←D!SYMT;
		    GSDVAL[GSDADD]←(COREADD+TOTSIZ) LOR RELOC!BIT;
		    TOTSIZ←TOTSIZ+4;
		END;
	    IF GSDVAL[GSD!SYMT] NEQ ((COREADD+TOTSIZ-4) LOR RELOC!BIT)
		THEN FatalError("DDT must be loaded last!");
	    SYMTABSIZ ← GSDADD*6;
	    IF NOT SUPPRESSINTERNAL
		THEN SYMTABSIZ←SYMTABSIZ + INTADD*6;
	    SYMTABSIZ←SYMTABSIZ+6*DDTEMPTYSYMS;
	    TOTSIZ←TOTSIZ + SYMTABSIZ;
	    S←"(Room for Symbols)"&CVOS(SYMTABSIZ)&
		CVOS((GSDVAL[GSD!SYMT] + 4) LAND '177777)&(IF DoReloc THEN "'" ELSE " ")&
		CVS(SYMTABSIZ DIV 2)&" words"&CRLF;
	    IF TELLALL THEN Print(S);
	    IF MAPFIL THEN OUT(CM,S)
	END
	ELSE DDT←FALSE;

    IF COMD THEN
    BEGIN
	SEDSUM←0;
	FOR I←1,26,COREADD,'3401,COREADD,TOTSIZ,TRNVAL,
	(IF GSD!DDT THEN GSDVAL[GSD!DDT]+2 ELSE 0),0,IDENT,
	(IDENT LSH -16),2,0 DO WODOUT(I);
	BLOCKEND;
    END;

    BEGIN "INNER"
	INTEGER ARRAY COREIMAGE[0: IF MESTYPE THEN 200+(TOTSIZ DIV 2) ELSE 0];

	PROCEDURE READDATA;	! THE BIG WORKHORSE;
	BEGIN "READDATA"
	    INTEGER
	    SECADD,		! CURRENT SECTION ADDRESS;
! 	    SECOFF,		! CURRENT SECTION OFFSET (NOT CURRENTLY USED);
	    SECSYM,		! CURRENT SECTION SYMBOL NAME;
	    SECREL,		! SECTION RELOCATION;
	    LOADADDRESS,	! REAL ADDRESS FOR BLOCK TO BE LOADED;
	    BYTECOUNT,		! COUNT OF REAL DATA BYTES (LESS ADDRESS);
	    ACTIV,		! TRUE IF DATA BUFFER READY FOR RLD ALRERATION;
	    HSYM,L1,L2;		! TEMPORARY;

	    ! GETBLOCK TAKES MACX11 STANDARD BLOCK AND CREATES SEGMENTO FBYTES
	    IN A NEW ARRAY;

	    PROCEDURE GETBLOCK;
	    BEGIN "GETBLOCK"
		INTEGER I,E;
		LOADADDRESS←SECADD+BLOCK[4];
		BYTECOUNT←BLOCK[2]-8;		! THROW AWAY HEADERS;
		E←BYTECOUNT-1;			  ! OFFSET TO ZERO;
		FOR I←0 THRU E DO LOADBLOCK[I]←
		(BLOCK[(I+10) LSH -1] LSH (IF I LAND 1 THEN -8 ELSE 0))
		LAND '377;
	    END "GETBLOCK";
	    ! PROCEDURE TO DUMP A BLOCK IN LNKX11 FORMAT (LESS CMD);

	    PROCEDURE ABSDUMP;
	    BEGIN "ABSDUMP"
		INTEGER I,E;
		SEDSUM←0;	! START CHECKSUM;
		FOR I←1,(BYTECOUNT+6),LOADADDRESS DO WODOUT(I);
		E←BYTECOUNT-1;
		FOR I←0 THRU E DO BYTOUT(LOADBLOCK[I]);
		BLOCKEND;
	    END "ABSDUMP";

	    ! PROCEDURE TO ASSEMBLE CORE IMAGE FOR MESSAGE RELOCATED OUTPUT;

	    PROCEDURE MESDUMP;
	    BEGIN "MESDUMP"
		INTEGER I,E,ADDR,WORD,OFFB,VALL,VALC;
		E←BYTECOUNT-1;
		ADDR←LOADADDRESS LAND '177777;
		FOR I←0 THRU E DO
		BEGIN "INMES"
		    WORD←(ADDR LSH -1);
		    OFFB←ADDR LAND 1;
		    VALL←LOADBLOCK[I];
		    VALC←COREIMAGE[WORD];
		    VALC←VALC LAND (IF OFFB THEN '377 ELSE '177400);
		    VALC←VALC LOR (VALL LAND ALL!RELOC!BITS);	! ASSUMES ONLY FULL WORD RELOCATION POSSIBLE;
		    VALC←VALC LOR ((VALL LAND '377) LSH (IF OFFB THEN 8 ELSE 0));
		    COREIMAGE[WORD]←VALC;
		    ADDR←ADDR+1;
		END "INMES";
	    END "MESDUMP";
	    ! PROCEDURE TO LOAD A BYTE IN CORE;

	    SIMPLE PROCEDURE LOADB(INTEGER A,B);
	    BEGIN "LOADB"
		INTEGER I,J;
		SEDSUM←0;
		FOR I←1,MOVB!R0!ATR1,2,2,B,A DO WODOUT(I);
		BLOCKEND;
	    END "LOADB";

	    ! PROCEDURE TO LOAD AN ABSOLUTE MESSAGE;

	    PROCEDURE MESABSDUMP;
	    BEGIN "MESABSDUMP"
		INTEGER I,FST,E,WODS,J;
		IF (E←BYTECOUNT) = 0 THEN RETURN;
		FST←0;
		IF LOADADDRESS LAND 1 THEN
		BEGIN
		    LOADB(LOADADDRESS,LOADBLOCK[0]);
		    IF (E←E-1) = 0 THEN RETURN;
		    LOADADDRESS←LOADADDRESS+1;
		    FST←1;
		END;
		IF E LAND 1 THEN 
		BEGIN
		    E←E-1;
		    LOADB(LOADADDRESS+E,LOADBLOCK[FST+E]);
		END;

		SEDSUM←0;
		IF E = 0 THEN RETURN;
		FOR I←1,LOADA,0,(E LSH -1)+1,LOADADDRESS DO 
		WODOUT(I);
		FOR I←FST THRU E-1+FST DO BYTOUT(LOADBLOCK[I]);
		BLOCKEND;
	    END "MESABSDUMP";
	    ! PROCEDURE THAT REALLY DOES THE DUMP;

	    PROCEDURE DUMP; IF ACTIV THEN
	    BEGIN "DUMP"
!		SECOFF←SECOFF+BYTECOUNT;
		IF LSTAR THEN MESDUMP ELSE
		IF MESTYPE THEN
		BEGIN
		    IF (LOADADDRESS LAND RELOC!BIT) THEN MESDUMP ELSE MESABSDUMP;
		END
		ELSE ABSDUMP;
		ACTIV←0;
	    END "DUMP";
	    ! THE MAIN LOOP PROCEDURE;

	    PROCEDURE LOADRLD;
	    BEGIN "LOADRLD"
		INTEGER RLDEND,RLDOFF,RLDB,RLDTYPE,RLDADD;
		PROCEDURE   LOADIT( INTEGER VAL,REL);	
		BEGIN 
		    LOADBLOCK[RLDOFF]←((VAL) LAND '377)+(REL);
		    IF NOT RLDB THEN LOADBLOCK[RLDOFF+1]←((VAL LSH -8) LAND '377)+REL;
		END ;

		RLDEND←(BLOCK[2] LSH -1);	! SIZE OF RLD BLOCK;
		RLDADD←4;			! START HERE;
		WHILE RLDADD LEQ RLDEND DO
		BEGIN "RLDLOP"
		    PROCEDURE UNIMP;
			Warn("Unimplemented RLD type: "&CVOS(RLDTYPE));
		    RLDTYPE←BLOCK[RLDADD];
		    RLDB←(RLDTYPE LSH -7) LAND 1;
		    RLDOFF←(RLDTYPE LSH -8) - 4;
		    RLDTYPE←RLDTYPE LAND '177;
		    ! Print("RLD Type ",CVOS(RLDTYPE),CRLF);
		    IF RLDTYPE > '16 THEN UNIMP ELSE CASE RLDTYPE OF
		    BEGIN "CASIT"
		    ['0] UNIMP;
		    ['1] BEGIN "RLD1"
			    LOADIT(BLOCK[RLDADD+1]+SECADD,SECREL);
			    RLDADD←RLDADD+2;
			END "RLD1";
		    ['2] UNIMP;
		    ['3] BEGIN "RLD3"
			    LOADIT(BLOCK[RLDADD+1]-(LOADADDRESS+RLDOFF+2),0);
			    RLDADD←RLDADD+2;
			END "RLD3";
		    ['4] UNIMP;
		    ['5] BEGIN "RLD5"
			    INTEGER TMP;
			    HSYM←GETSYM(TMP←(BLOCK[RLDADD+1]+(BLOCK[RLDADD+2] LSH 16)),LOADADDRESS+RLDOFF);
			    LOADIT(BLOCK[RLDADD+3]+HSYM, HSYM LAND ALL!RELOC!BITS);
			    RLDADD←RLDADD+4;
			END "RLD5";
		    ['6] BEGIN "RLD6"
			    INTEGER TMP;
			    HSYM←GETSYM(TMP←(BLOCK[RLDADD+1]+(BLOCK[RLDADD+2] LSH 16)),LOADADDRESS+RLDOFF);
			    ! Print(CNVRAD(I)," is ","HSYM=",CVOS(HSYM),CRLF);
			    ! Print("LOAD ADDR =",CVOS(LOADADDRESS),CRLF,
			    "RLDOFF="&CVOS8rLDOFF)&CRLF);
			    LOADIT(BLOCK[RLDADD+3]+HSYM-(LOADADDRESS+RLDOFF+2),0);
			    RLDADD←RLDADD+4;
			END "RLD6";
		    ['7] BEGIN "RLD7"
			    SECSYM←BLOCK[RLDADD+1]+(BLOCK[RLDADD+2] LSH 16);
			    SECREL←IF SECSYM=ABSSYM THEN 0 ELSE RELOC!BIT;
			    SECADD←GETSEC(SECSYM);
!			    SECOFF←SECADD+BLOCK[RLDADD+3];
			    RLDADD←RLDADD+4;
			END "RLD7";
		    ['10] BEGIN "RLD10"
!			    SECOFF←SECADD+BLOCK[RLDADD+1];
			    RLDADD←RLDADD+2;
			END "RLD10";
		    ['11] BEGIN "RLD11"
			    LOADIT(COREADD,RELOC!BIT);
			    RLDOFF←RLDOFF+2;
			    LOADIT(COREADD+TOTSIZ,RELOC!BIT);
			    RLDADD←RLDADD+1;
			    ! Print("CORE LIMITS: ",CVOS(COREADD)," AND ",CVOS(COREADD+TOTSIZ),CRLF);
			END "RLD11";
		    ['12] UNIMP;
		    ['13] UNIMP;
		    ['14] UNIMP;
		    ['15] BEGIN "RLD15"
			    INTEGER TMP;
			    HSYM←GETSEC(TMP←(BLOCK[RLDADD+1]+(BLOCK[RLDADD+2] LSH 16)));
			    LOADIT(BLOCK[RLDADD+3]+HSYM, HSYM LAND ALL!RELOC!BITS);
			    RLDADD←RLDADD+4;
			END "RLD15";
		    ['16] BEGIN "RLD16"
			    INTEGER TMP;
			    HSYM←GETSEC(TMP←(BLOCK[RLDADD+1]+(BLOCK[RLDADD+2] LSH 16)));
			    ! Print(CNVRAD(I)," IS ","HSYM=",CVOS(HSYM),CRLF);
			    ! Print("LOAD ADDR =",CVOS(LOADADDRESS),CRLF,
			    "RLDOFF="&CVOS(RLDOFF)&CRLF);
			    LOADIT(BLOCK[RLDADD+3]+HSYM-(LOADADDRESS+RLDOFF+2),0);
			    RLDADD←RLDADD+4;
			END "RLD16"
		    END "CASIT";
		END "RLDLOP";
	    END "LOADRLD";
	    ! HERE BEGINS  EXECUTION STATEMENTS FOR PROCEDURE READDATA;

	    ACTIV←SECREL←SECSYM←0;
	    SECADD←0;
!	    SECOFF←SECADD;

	    WHILE TRUE DO
	    BEGIN
		READBLK;
		! Print("BLOCK TYPE ",CVOS(BLOCK[3]),CRLF);
		IF BLOCK[3]=6 THEN
		BEGIN
		    DUMP;
		    DONE;
		END;
		IF BLOCK[3]=3 THEN
		BEGIN
		    DUMP;
		    GETBLOCK;
		    IF SECREL = 0
			THEN ABSSIZ ← ABSSIZ + BYTECOUNT;
		    ACTIV←1;
		END
		ELSE IF BLOCK[3] = 4
		    THEN LOADRLD
		ELSE FatalError("Illegal block:"&CVOS(BLOCK[3]))
	    END;
	END "READDATA";
	PASS(TRUE,READDATA);
	IF FORCETRNVAL GEQ 0
	    THEN TRNVAL←FORCETRNVAL;
	STRTADD←TRNVAL;

	IF DDT THEN
	BEGIN
	    IF GSD!JOBSA THEN
	    IF MESTYPE THEN
	    COREIMAGE[(GSDVAL[GSD!JOBSA] LAND '177777) LSH -1]←TRNVAL ELSE 
	    BEGIN
		SEDSUM←0;
		FOR J←1,8,GSDVAL[GSD!JOBSA] LAND '177777,TRNVAL DO WODOUT(J);
		BLOCKEND;
	    END;
	    IF GSD!DDT THEN
	    BEGIN
		TRNVAL←GSDVAL[GSD!DDT];
		FOR J←1 THRU GSDADD DO IF GSDSYM[J]=D!JOBDDT THEN
		BEGIN
		    IF MESTYPE THEN
		    COREIMAGE[(GSDVAL[J] LAND '177777) LSH -1]←TRNVAL+2 ELSE 
		    BEGIN
			SEDSUM←0;
			FOR K←1,8,GSDVAL[J] LAND '177777,TRNVAL+2 DO WODOUT(K);
			BLOCKEND;
		    END;
		    DONE;
		END
	    END;
	    IF GSD!SYMT THEN
	    IF MESTYPE THEN
	    BEGIN
		J←((GSDVAL[GSD!SYMT] LAND '177777) LSH -1)-1;
		FOR K←1 THRU GSDADD DO
		BEGIN
		    COREIMAGE[J←J+1]←GSDSYM[K] LAND '177777;
		    COREIMAGE[J←J+1]←GSDSYM[K] LSH -16;
		    COREIMAGE[J←J+1]←GSDVAL[K];
		END;
		IF NOT SUPPRESSINTERNAL THEN FOR K←1 THRU INTADD DO
		BEGIN
		    COREIMAGE[J←J+1]←INTSYM[K] LAND '177777;
		    COREIMAGE[J←J+1]←INTSYM[K] LSH -16;
		    COREIMAGE[J←J+1]←(IF NOT (INTVAL[K] LAND REGISTER!BIT)
			THEN INTVAL[K]
			ELSE GSDVAL[GSD!JOBSA]+2*((INTVAL[K] LAND '7)-8));
		END;
		FOR K←1 THRU DDTEMPTYSYMS DO
		BEGIN
		    COREIMAGE[J←J+1]←'177777;
		    COREIMAGE[J←J+1]←'177777;
		    COREIMAGE[J←J+1]←0;
		END;
		COREIMAGE[J+1]←COREIMAGE[J+2]←0;
	    END ELSE
	    BEGIN
		L←GSDVAL[GSD!SYMT] LAND '177777;
		FOR J←1 STEP SYBLSZ UNTIL GSDADD DO
		BEGIN
		    SEDSUM←0;
		    FOR K←1,(SYBLSZ MIN GSDADD-J+1)*6+6,L DO WODOUT(K);
		    FOR K←J THRU (J+SYBLSZ-1 MIN GSDADD) DO
		    BEGIN
			WODOUT(GSDSYM[K] LAND '177777);
			WODOUT(GSDSYM[K] LSH -16);
			WODOUT(GSDVAL[K]);
			L←L+6;
		    END;
		    BLOCKEND;
		END;
		IF NOT SUPPRESSINTERNAL THEN FOR J←1 STEP SYBLSZ UNTIL INTADD DO
		BEGIN
		    SEDSUM←0;
		    FOR K←1,(SYBLSZ MIN INTADD-J+1)*6+6,L DO WODOUT(K);
		    FOR K←J THRU (J+SYBLSZ-1 MIN INTADD) DO
		    BEGIN
			WODOUT(INTSYM[K] LAND '177777);
			WODOUT(INTSYM[K] LSH -16);
			WODOUT(IF NOT (INTVAL[K] LAND REGISTER!BIT)
			    THEN INTVAL[K]
			    ELSE GSDVAL[GSD!JOBSA]+2*((INTVAL[K] LAND '7)-8));
			L←L+6;
		    END;
		    BLOCKEND;
		END;
		FOR J←1 STEP SYBLSZ UNTIL DDTEMPTYSYMS DO
		BEGIN
		    SEDSUM←0;
		    FOR K←1,(SYBLSZ MIN DDTEMPTYSYMS-J+1)*6+6,L DO WODOUT(K);
		    FOR K←J THRU (J+SYBLSZ-1 MIN DDTEMPTYSYMS) DO
		    BEGIN
			WODOUT('177777);
			WODOUT('177777);
			WODOUT(0);
			L←L+6;
		    END;
		    BLOCKEND;
		END;
		SEDSUM←0;
		FOR K←1,5*2,L,0,0 DO WODOUT(K);
		BLOCKEND;
	    END;
	END;
	IF LSTAR THEN
	BEGIN "LSTAR"
	    INTEGER I,SIZE;

	    IF TOTSIZ THEN 
	    BEGIN "CSECT"

		SEDSUM←0;
		BYTOUT(1);	! LOAD BLOCK;
		WODOUT(TOTSIZ);
		SIZE←TOTSIZ LSH -1;
		FOR I←0 THRU SIZE-1 DO WODOUT(COREIMAGE[I]);
		BLOCKEND;		!  SEND THE LOAD MESSAGE;

		IF DoReloc THEN
		BEGIN				! READY TO SEND THE RELOCATION INFO;
		    INTEGER J,K,WORD,REL;
		    SEDSUM←0;
		    BYTOUT(2);
		    WODOUT ((((SIZE-2)LSH -4)+1) LSH 1);
		    FOR J←0 STEP 16 UNTIL SIZE-1 DO
		    BEGIN
			WORD←0;
			FOR K←15 STEP -1 UNTIL 0 DO
			BEGIN

			    WORD←WORD LSH 1;
			    REL←COREIMAGE [J+K] LSH -16;
			    IF REL=1 THEN WORD←WORD+1 ;
			END;
			WODOUT(WORD);
		    END;
		    BLOCKEND;
		END;
	    END "CSECT";

	    IF GSDADD THEN
	    BEGIN 		! GLOBAL SYMBOL DEFS;
		INTEGER I,J;
		STRING SYMNAM,K;

		BYTOUT(3);
		WODOUT(GSDADD LSH 3);
		FOR I←1 THRU GSDADD DO
		BEGIN
		    SYMNAM←CNVRAD(GSDSYM[I]);
		    FOR J←1 THRU 6 DO 
		    BEGIN
			K←LOP(SYMNAM);
			BYTOUT(IF K=" " THEN 0 ELSE K);
		    END;
		    WODOUT(GSDVAL[I]);
		END;
		BLOCKEND;
	    END;

	    IF GLOADD THEN
	    BEGIN
		INTEGER I,J,REFS;
		STRING K,SYMNAM;

		BYTOUT(4);		! GLOBAL REFS;
		J←0;
		FOR I←1 THRU GLOADD DO J←J+GLOREF[I,0];
		WODOUT(GLOADD*8 + 2*J);

		FOR I←1 THRU GLOADD DO
		BEGIN
		    SYMNAM←CNVRAD(GLONAM[I]);
		    FOR J←1 THRU 6 DO
		    BEGIN
			K←LOP(SYMNAM);
			BYTOUT(IF K=" " THEN 0 ELSE K);
		    END;
		    WODOUT(REFS←GLOREF[I,0]);
		    FOR J←1 THRU REFS DO WODOUT(GLOREF[I,J]);
		END;
		BLOCKEND;
	    END;

	    SEDSUM←0;
	    BYTOUT(5);	! SEND END MESSAGE;
	    WODOUT(1);
	    BLOCKEND;
	END "LSTAR"
	ELSE

	IF MESTYPE THEN
	BEGIN
	    INTEGER I,SIZE;

	    IF TOTSIZ THEN 
	    BEGIN "CSECT"

		SEDSUM←0;
		WODOUT(1);
		WODOUT(LOADR);
		WODOUT(IF GRAPHONLY THEN '4 ELSE 0);		! BUFFERED MESSAGE OUTPUT;
		WODOUT(SIZE←TOTSIZ LSH -1);
		FOR I←0 THRU SIZE-1 DO WODOUT(COREIMAGE[I]);
		BLOCKEND;		!  SEND THE LOAD MESSAGE;

		IF DoReloc THEN
		BEGIN				! READY TO SEND THE RELOCATION INFO;
		    INTEGER I,J,K,WORD,REL;
		    FOR I←0 THRU SIZE-1 DO IF COREIMAGE[i] LAND RELOC!BIT THEN
		    BEGIN
			SEDSUM←0;
			WODOUT(1);
			WODOUT(RELOCA);
			WODOUT(0);			! BUFFERED MESSAGE;
			WODOUT(12);			! MESSAGE SIZE;
			WODOUT(IF NOT GRAPHONLY THEN 0 ELSE '100200);	! WHAT TO RELOCATE;
			WODOUT(I LSH 1);		! OFFSET TO START OF PROGRAM;
			FOR J←0 STEP 16 UNTIL 159 DO
			BEGIN
			    WORD←0;
			    FOR K←15 STEP -1 UNTIL 0 DO
			    BEGIN
				WORD←WORD LSH 1;
				IF COREIMAGE [I+J+K] LAND RELOC!BIT
				    THEN WORD←WORD+1 ;
			    END;
			    WODOUT(WORD);
			END;
			BLOCKEND;
			I←I + 159;
		    END;
		END;
	    END "CSECT";

	    SEDSUM←0;
	    WODOUT(1);			! SEND THE TRANSFER MESSAGE;
	    WODOUT(LOADTR);
	    WODOUT(2);
	    WODOUT(2);
	    WODOUT(TRNVAL);
	    WODOUT(((TRNVAL LAND RELOC!BIT) LSH -1)+
		(IF TOTSIZ THEN '200 ELSE 0)+
		(IF NOT GRAPHONLY THEN 1 ELSE 2));
	    BLOCKEND;

	END
	ELSE					! DEC LOADER FORMAT END BLOCK;
	BEGIN
	    INTEGER I;
	    SEDSUM←0;
	    FOR I←1,6,TRNVAL DO WODOUT(I);
	    BLOCKEND;
	END;
	IF PACKED AND MESTYPE THEN
	BEGIN
	    BYTOUT(0);
	    BYTOUT(0);
	    BYTOUT(0);
	END;
	BUFDUMP;
	SETFORMAT(0,0);
	S←CRLF&
	    "Program Size:      "&CVS((ABSSIZ + TOTSIZ + GTOTSIZ) DIV 2)&" words";
	IF ABSSIZ THEN IF TOTSIZ THEN S←S&
	    TAB&"("&CVS(TOTSIZ DIV 2)&" Relocatable + "&
	    CVS(ABSSIZ DIV 2)&" Absolute)";
	S←S&CRLF&
	    "Transfer Address:  "&
		CVOS(STRTADD LAND '177777)&
		(IF DoReloc
		    THEN IF STRTADD LAND RELOC!BIT THEN "'"
		    ELSE IF STRTADD LAND GRAPHIC!RELOC!BIT THEN """"
		    ELSE NULL
		    ELSE NULL);
	IF GSD!DDT
	    THEN S←S&"    "&TAB&"(DDT Start:  "&
		CVOS(TRNVAL LAND '177777)&
		(IF DoReloc
		    THEN IF TRNVAL LAND RELOC!BIT THEN "'"
		    ELSE IF TRNVAL LAND GRAPHIC!RELOC!BIT THEN """"
		    ELSE NULL
		    ELSE NULL)&
		")";
	S←S&CRLF;
	IF TOTSIZ
	    THEN S←S&
		"High Address:      "&
		CVOS(COREADD+TOTSIZ)&
		(IF DoReloc THEN "'" ELSE NULL)&
		CRLF;
	Print(S);
	IF MAPFIL THEN OUT(CM,S);
	IF GSDADD > 0
   	  THEN Print!Symbols;
	CALLEXIT;
    END "INNER";
END "LINK11";

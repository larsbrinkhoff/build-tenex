;<MON>JSYS.MAC;8    21-JUN-77 16:58:59    EDIT BY SWEER
; REMOVED CALL TO I4CDIR
;<MON>JSYS.MAC;7	16-APR-77 14:14:00	EDIT BY RINDFLEISCH
;  Added fixes to JFNS for extended wild cards and ;S files
;<MON>JSYS.MAC;6    20-MAR-77 11:48:35    EDIT BY SWEER
; FIXED RENAME TTY: BUG
; <mon>jsys.mac fixed message.txt fix edit by sweer 3/14/77
;<MON>JSYS.MAC;5	13-MAR-77 20:40:00	EDIT BY RINDFLEISCH
; Fix at JFNSS+15 for ;S files under SMXGTJ switch
;<MON>JSYS.MAC;4    15-FEB-77 16:20:35    EDIT BY SWEER
;FIX FOR MESSAGE.TXT IN CRDIR AND TOPDIR IN FNN00:
;<SCHULZ>JSYS.MAC;2    24-NOV-76 10:23:34    EDIT BY SWEER
;FIXED ROUTINE FNN00 TO CHECK FOR TOO MANY DIRECTORIES CREATED
;<MON>JSYS.MAC		7/75			EDIT BY HEATHMAN
;ADDED CALL TO TYMNET HANGUP ROUTINE IN RELD FOR AUX CIRCUITS
;<MON>JSYS.NEW;1    29-APR-75 17:33:19    EDIT BY LIEB
;FIXED TIME HONORED BUG IN PASSWORD CHECKING
;<MON>JSYS.MAC;		14-FEB-75		EDIT BY HEATHMAN
;FIXED SACTF BUG
;<MON>JSYS.NEW;2    20-NOV-74 17:18:19    EDIT BY LIEB
;EDIT TO CATCH BAD DESIG IN DIRST JSYS BEFORE BOUT DOES
;<NEWMON>JSYS.MAC;10    13-AUG-74 15:20:58	EDIT BY MANN
;<MAILBOX>JSYS.MAC;151     2-NOV-73 09:31:45	EDIT BY DURHAM
;ONE-LINER TO FIX GACTF (LEAVE 5B2 ON FOR NUM. ACCTS)
;<TENEX-131>JSYS.MAC;134    10-JAN-73 13:21:07	EDIT BY TOMLINSON
;<TENEX-131>JSYS.MAC;133    10-JAN-73 11:04:12	EDIT BY TOMLINSON
;<TENEX-130>JSYS.MAC;132    28-DEC-72 15:26:53	EDIT BY TOMLINSON
;<TENEX-130>JSYS.MAC;131    29-NOV-72 22:51:02	EDIT BY CLEMENTS
;<TENEX-130>JSYS.MAC;130    29-NOV-72 13:58:23	EDIT BY CLEMENTS
;FIXES TO ERSTR AND .DELDF
;<TENEX-130>JSYS.MAC;129    21-NOV-72 12:01:22	EDIT BY TOMLINSON
;<TENEX-130>JSYS.MAC;128    21-NOV-72  7:10:50	EDIT BY WALLACE
;<TENEX-130>JSYS.MAC;127    20-NOV-72 17:05:16	EDIT BY WALLACE
;<TENEX-130>JSYS.MAC;126    18-NOV-72 17:49:59	EDIT BY WALLACE
;<DLM/TEMP>JSYS.MAC;125    31-OCT-72 22:51:16	EDIT BY TOMLINSON
; FIX JFNS4 TO CHECK NETNAM PROPERLY
;<DLM/TEMP>JSYS.MAC;124    25-OCT-72  9:00:59	EDIT BY TOMLINSON
;<DLM/TEMP>JSYS.MAC;123    19-OCT-72 19:17:16	EDIT BY TOMLINSON
;<DLM/TEMP>JSYS.MAC;122    15-OCT-72 14:34:01	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;121    25-AUG-72 17:43:14	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;120    25-AUG-72 16:48:36	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;119    25-AUG-72 16:37:45	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;118    22-AUG-72 10:26:04	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;117    22-AUG-72 10:13:29	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;116    25-JUL-72 10:24:04	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;115    17-JUL-72 14:02:53	EDIT BY TOMLINSON
;<FILESYSTEM>JSYS.MAC;114    17-JUL-72 13:50:52	EDIT BY TOMLINSON

	SEARCH	FILEDEF,STENEX
	TITLE	JSYS
	SUBTTL	R.S.Tomlinson

EXTERN I4LOGI		;I4
EXTERN	PFILPC
EXTERN	PBYTSZ,PBYTPO
IFDEF DTAN,< EXTERN DRWAIT,DTADTB,DIRIC,DTASTS>
EXTERN	NDEV
IFDEF NETN,<EXTERN NVTDET,NTSIBE,NETDTB,NETNAM>
EXTERN	CTRLTT,EDISMS,CLTTST
EXTERN	ACCCHK,CPYDIR,DIRCHK,DIRLUK,DIRLUU,GDIRST,GETDDB,GETFDB,HSHLUK
EXTERN	DEVCHR,DEVDSP,DEVLCK,DEVLUK,DEVNAM,DEVUNT
EXTERN	INIBLK,INSACT,MAPDIR,MDDNAM,SETDIR,SETMSK,USTDIR
EXTERN	ASGDFR,ASGJFR,ASGPAG,GCDIR,RELDFR,RELFRE,RELPAG
EXTERN	CPYFU1,CPYFUS,CPYTUS,RESAC,SAVAC,XPAND
EXTERN	BOUTN,BYTOUA,CCSIZE,CHKJFN,CPOPJ,CPTAB,DBP,DISGET
IFDEF LPTN, <EXTERNAL LPTDTB >
EXTERN	DSKDTB,TTYDTB,JFNOFN,JFNOF1,OFNJFN,OFNJFX
EXTERN	NEWWND,NOUTX,RELJFN,SKPRET,UNLCKF,BHC
IFDEF TYMSW,<EXTERN  TYHNGU>

	USE	SWAPPC

WHEEL==:400000
OPR==:200000
LOG==:040000

EXTERN	NXTDMP	; Zero to dump open files
EXTERN	MAPFKH	; Maps over a fork handle
EXTERN	SKIIFA	; Skips if fork(a) < fork(b)
EXTERN	ACCTPT	; Login account string pointer or number
EXTERN	ACCTSR	; Account string storage
EXTERN	LOGONM	; Dlm's logon message typer
EXTERN	LOGCJM	; Type change job number on logtty
EXTERN	JOBRT	; Job runtime table
EXTERN	CONSTO	; Console time on word
EXTERN	MJRSTF	; Thing to execute to leave fast jsys code

LS(FACTSW)	; Fact switches

JS(ACCTSL)

EXTERN	JOBDIR
EXTERN	TODCLK	; Time since system start in msec
EXTERN	SKIIF	; Skip if forkn in a is inferior or equal to self
JS(MODES)	; Ddbmod word from login
JS(GROUPS)	; Groups to which login user belongs
EXTERN	TTBKPT	; Routine to backup tty pointer one character
EXTERN	JOBPMF	; Jfn of pmf
EXTERN	MRPT	; Read page table
EXTERN	SETPT	; Map manipulator routine
EXTERN	MSPACS	; Set access of a page
EXTERN	FKHPTN	; Converts fork handle to ptn
EXTERN	PTNFKH	; Converts ptn to fork handle
EXTERN	SETLFK,DELOFN
EXTERN	TTCIBF,TTCOBF,TTSIBE,TTDIBE,TTSOBE,TTSOBF,TTDOBE,TTGTBS,TTSTBS
EXTERN	TTRMOD,TTSMOD,TTRPOS,TTSPOS,TTRCOC,TTSCOC,TTSTI,TTILIN,TTSOBF
EXTERN	SYSIFG,LOGBUF	; Logging stuff
EXTERN	SYSFK	; Table of job forks
EXTERN	NORMTF,TTICB1,TTICB2,TAB81,TAB82	; Tty modes
EXTERN CHKJFN,IOERR	;[EDIT]LINKAGE TO IO.MAC  ---EDIT BY LIEB

; Entries to this section

INTERN	BOUTA,NOUTXX,CHKTTM,JFNDCR,CHKTTY,UNL
INTERN	.GDSTS,.SDSTS
INTERN	.OPENF,.CLOSF,.RLJFN,.GTSTS,.STSTS,.DELF,.SFPTR,.RFPTR
INTERN	.DELNF,.DELDF,.CLZFF,.RESET
INTERN	.JFNS,.RNAMF,.SIZEF,.GACTF,.SACTF,.BKJFN,.RFBSZ,.SFBSZ,.SWJFN
INTERN	.STDIR,.DIRST,.PMAP,.RPACS,.SPACS,.RMAP,.FFFFP,.FFUFP,.FDFRE
INTERN	.GTFDB,.CHFDB
INTERN	.ASND,.RELD
INTERN	.DVCHR,.STDEV,.DEVST,.MOUNT,.DSMNT
INTERN	.INIDR,.RDDIR,.MTOPR,.CRDIR,.GTDIR
INTERN	.CFIBF,.CFOBF,.SIBE,.SOBE,.DIBE,.DOBE,.GTABS,.STABS
INTERN	.RFPOS,.SFPOS,.RFCOC,.SFCOC,.STI,.SOBF
INTERN	.RFMOD,.SFMOD,.ERSTR,.GETER,.STAD,.GTAD
INTERN	.LOGIN,.CNDIR,.CACCT,.EFACT,.SMON,.TMON
INTERN	DELDEL,PASSWC,CHKTTC
INTERN SETACT

; Error macro definitions

DEFINE	ERUNLK(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERUNLD]>

DEFINE	ERR(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERRD]>

DEFINE	ERABRT(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERABRD]>

ERUNLD::PUSH P,A
	MOVEM A,LSTERR
	PUSHJ P,UNLCKF
	XCTMU [POP P,1]
	JRST MRETN

ERRD::	UMOVEM A,1
	MOVEM A,LSTERR
	JRST MRETN

ERABRD:	MOVEM A,LSTERR
	JRST ITRAP

; Open a file
; Call:	1	; Job file number
;	2(0-5)	; Byte size
;	2(6-9)	; Data mode
;	RH(2)	; Access flags (see jsys manual or filsts description)
;	OPENF
; Return
;	+1	; Cannot open file, error code in 1
;	+2	; Successful

.OPENF::JSYS MENTR		; Become slow, save ac's
	MOVE JFN,1		; Get jfn
	PUSHJ P,CHKJFN		; What kind of designator is this?
	 ERR()			; Garbage designator
	 JFCL
	 JRST OPENFZ		; Tty and byte pointer are always good
	TEST(NE,OPNF)
	ERUNLK OPNX1		; Already open
	TEST(NE,ASTF)
	 ERUNLK(DESX7)		; Output stars not allowed
	UMOVE B,2
		; Get access bits
	LDB A,[POINT 6,B,5]	; Get byte size
	CAILE A,^D36
	ERUNLK SFBSX2
	DPB A,PBYTSZ		; Store as byte size of pointer
	MOVNI A,NDEV		; Movsi a,-ndev the hard way...
	HRLZS A
	HRRZ B,DEVDSP(A)
	CAIE B,0(DEV)
	 AOBJN A,.-2
	MOVE C,DEVCHR(A)
	UMOVE B,2
	LDB A,[POINT 4,B,9]
	MOVN D,A
	ROT C,-1(D)
	JUMPGE C,[ERUNLK(OPNX14)]	; Illegal mode
	HRRM A,FILSTS(JFN)
	HRR STS,A
	ANDCM STS,[XWD READF!WRTF!XCTF!RNDF!ASPF!CALLF!LONGF!EOFF!ERRF!HLTF!WNDF!ENDF!SIZF,777760]
	ANDI B,774000		; Ignore bits user cant set
	TRZE B,400000		; Bit 18 = 1?
	TRO B,HLTF		; Yes, move it down to hltf
	TLO STS,(B)		; Put user's bits into sts
	UMOVE B,2
	ANDI B,17B28
	IORI STS,(B)
	MOVE A,CAPENB
	TRNN  A,OPR!WHEEL	; Have operator or wheel status?
	TRNN STS,1B27		; Or is he not trying to cheat
	JRST OPNFOK
	ERUNLK OPNX11		; Illegal

OPNFOK:	SETZM FILCNT(JFN)
	PUSHJ P,@OPEND(DEV)	; Call the device dependent routine
	 JRST OPENR		; Cannot open
	TEST(O,OPNF)		; Success
	MOVSI B,1
	HLLM B,FILLFW(JFN)
OPENFZ:	AOS (P)
	PUSHJ P,UNLCKF
	JRST MRETN

OPENR:	CAIE A,OPNX9
	ERUNLK()
	HRRZ B,DEV
IFDEF LPTN,<	CAIN B,LPTDTB
	TRO STS,1B26>
	TRNN STS,1B28
	TRNN STS,1B26
	ERUNLK()
	PUSHJ P,UNLCKF
	SETZM INTDF
	XCT INTDFF
	MOVEI A,"["
	PBOUT
	MOVEI A,101
	UMOVE B,1
	MOVEI C,0
	JFNS
	HRROI A,[ASCIZ / Busy-/]
	PSOUT
OPENR1:	MOVEI A,^D3000
	DISMS
	UMOVE A,A
	UMOVE 2,2
	TRO B,1B28
	JSYS 21
	JRST OPENR1
	UMOVEM 1,1
	HRROI 1,[ASCIZ /Go]
/]
	PSOUT
	JRST SKMRTN

; Close a file
; Call:	RH(1)	; Jfn
;	1(0)	; If 1 do not release jfn
;	CLOSF
; Returns
;	+1	; Cannot close
;	+2	; Ok

.CLOSF::JSYS MENTR
	CAMN 1,[-1]		; -1 means all
	JRST CLZALL
	HRRZ JFN,1
	PUSHJ P,CLZF
	 ERR()			; Can't close, reason in a
	XCTUU [SKIPL 1]		; Don't release jfn
	TEST(NE,OPNF)		; Or still open?
	JRST SKMRTN		; Yes. all done.
	PUSHJ P,RELJFN		; No, release jfn.
	JRST SKMRTN

CLZALL:	MOVE A,[1B2+400000]
	CLZFF
	JRST SKMRTN

CLZF::	MOVEI A,CLSX2
	HRRZ B,PRIMRY
	CAME JFN,JOBPMF
	CAMN JFN,B
	POPJ P,
	HLRZ B,PRIMRY
	CAME JFN,B
	PUSHJ P,CHKJFN
	 POPJ P,		; Garbage
	 JFCL
	 JRST SKPRET		; Byte and tty always succeeds
	TEST(NN,OPNF)
	JRST [	MOVEI A,CLSX1
		JRST UNLCKF]
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNE B,777777
	JRST CLZF2
	PUSHJ P,@CLOSD(DEV)	; Call device dependent stuff
	 JRST UNLCKF
	TEST(Z,OPNF)
CLZF2:	AOS (P)
	JRST UNLCKF

; Release jfn
; Call:	1	; Jfn
;	RLJFN
; Returns
;	+1	; Error
;	+2	; Success
; Cannot release jfn if being assigned unless this same process as
; Assigner, and not at interrupt level

.RLJFN::JSYS MENTR
	CAMN 1,[-1]		; Release all
	JRST RLALL
	HRRZ JFN,1
	PUSHJ P,RLJF
	 ERR()
	JRST SKMRTN

RLALL:	MOVN JFN,MAXJFN
	HRLZS JFN
RLAL1:	PUSHJ P,RLJF
	 JFCL			; Ignore errors
	AOBJN JFN,RLAL1
	JRST SKMRTN

RLJF:	PUSH P,JFN
	HRRZS JFN
	PUSHJ P,CHKJFN
	 JRST RLJF1		; Garbage jfn
	 JFCL
	 JRST [	MOVEI A,DESX4	; Tty or byte illegal
		JRST RLJF3]
	TEST(NE,OPNF)
	JRST [	MOVEI A,OPNX1	; File is open
		JRST RLJF4]
RLJF2:	PUSHJ P,RELJFN		; Finally we can release it
	AOSA -1(P)
RLJF4:	PUSHJ P,UNLCKF
RLJF3:	POP P,JFN
	POPJ P,

RLJF1:	CAIE A,DESX3		; Is no name attached to this jfn?
	JRST RLJF3		; Some other error
	HLRZ B,FILVER(JFN)	; Get fork number of originator
	SKIPGE SYSFK(B)		; Fork still exists?
	JRST RLJF2		; No, ok to release
	CAME B,FORKN		; Is it me?
	JRST RLJF3		; No
	SKIPE PSIBIP		; Test if pi in progress
	JRST RLJF3		; Yes
	JRST RLJF2		; No pi in progress, ok to release

; Close files given fork handle
; Call:	RH(1)	; Fork handle
;	B0(1)	; Not below the fork(s) specified
;	B1(1)	; Not at the fork(s) specified
;	B2(1)	; Close only (no release)
;	B3(1)	; Release only (no close)
;	B4(1)	; Unrestrict file
;	B5(1)	; Close regardless of map count
;	CLZFF
; Return
;	+1	; Always
; Traps if fork handle is bad

.CLZFF::JSYS MENTR
	HRRZS A
	PUSHJ P,MAPFKH		; Call routine to map over the fork hdl
	PUSHJ P,CLZFF1		; Call this for each fork
	JRST MRETN

CLZFF1:	MOVN JFN,MAXJFN
	HRLZS JFN
CLZFF2:	HLRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3		; Don't affect primary files
	HRRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3
	MOVE B,JOBPMF
	CAIN B,(JFN)
	JRST CLZFF3		; Or pmf
	PUSH P,JFN
	PUSH P,1
	HRRZS 1,JFN
	LSH 1,SJFN
	SKIPL FILLCK(1)
	 JRST CLZFF4
	PUSHJ P,CHKJFN		; See if this jfn is in use
	 JRST CLZFF8		; No name check for asgf
	 JRST CLZFF4		; Should not happen
	 JRST CLZFF4
	MOVSI B,777777
	TEST(NE,OPNF)		; If file is open
	TDNE B,FILLFW(JFN)	; And map count is zero
	SKIPA
	 JRST CLZFF5		; Then it's ok to close it
	HLRZ B,FILVER(JFN)
	MOVE A,(P)
	CAMN B,A		; Was this jfn created by this fork
	JRST [	UMOVE C,1
		TLNE C,(1B1)	; Are we to close files at the fork?
		JRST CLZFF7	; No, skip this jfn
		JRST CLZFF5]	; Yes, do it
	EXCH A,B
	PUSHJ P,SKIIFA		; Skip if fork(a) < fork(b)
	JRST CLZFF7

CLZFF5:	UMOVE C,1
	TLNE C,(1B4)		; Un restrict this file?
	TEST(Z,FRKF)		; Yes
	TEST(NE,OPNF)
	TLNE C,(1B3)
	JRST CLZFF6
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNN C,(1B5)
	TLNN B,777777
	PUSHJ P,@CLOSD(DEV)
	 JRST CLZFF7
	TEST(Z,OPNF)
CLZFF6:	UMOVE C,1
	TEST(NN,OPNF)
	TLNE C,(1B2)
	JRST CLZFF7
CLZFF9:	PUSHJ P,RELJFN
	JRST CLZFF4

CLZFF7:	PUSHJ P,UNLCKF
CLZFF4:	POP P,1
	POP P,JFN
CLZFF3:	AOBJN JFN,CLZFF2
	POPJ P,

CLZFF8:	CAIE A,DESX3
	JRST CLZFF4		; ??
	HLRZ B,FILVER(JFN)
	SKIPGE SYSFK(B)
	JRST CLZFF9
	CAME B,FORKN
	JRST CLZFF4
	SKIPE PSIBIP
	JRST CLZFF4
	JRST CLZFF9

; Reset jsys
; Call:	RESET
; Closes all files, resets tty status etc

.RESET::JSYS MENTR
	MOVNI A,4
	KFORK			; Kill all inferior forks

REPEAT 0,<

;
;  I4 CHANGE
;	AQMMP	;ACQUIRE MMP SLOT
	JSYS 351
	CAIA	;ALREADY HAD SLOT
	JRST .+3  ;NO SLOT AVAILABLE
;	RLMMP	;RELEASE SLOT
	JSYS 356
	JFCL	;HMMMMM?
;
;
>;END REPEAT 0

	SKIPGE CTRLTT
	 JRST RSTFK		; Skip tty reset if not ctrltt
	MOVEI A,101
	MOVE B,NORMTF		; Normal modes
	SFMOD
	MOVE B,TTICB1
	MOVE C,TTICB2		; Normal cc modes
	SFCOC
	MOVE B,TAB81		; 8 chars/tab
	MOVE C,TAB82
	MOVE D,B
	STABS
	MOVE B,CTRLTT
	PUSHJ P,CLTTST	;CLEAR TTY STOP
RSTFK:	MOVEI A,400000
	CIS
	DIR
	MOVEI 2,0
	STIW
	MOVNI 2,1
	DIC
	MOVEI 1,400000
	CLZFF
	RWSET			;RELEASE WORKING SET
	SETZB 2,3
	SCVEC
	JRST MRETN

; Get open file status
; Call:	1	; Jfn
;	GTSTS
; Return
;	+1
;	1	; Status word as in filsts

.GTSTS::NOINT
	JUMPL 1,GTST1
	CAML 1,MAXJFN
	 JRST GTST1
	LSH 1,SJFN
	AOSE FILLCK(1)
	JRST GTST2
	EXCH 2,FILSTS(1)
	TLNN 2,NAMEF
	JRST [	MOVEM 2,FILSTS(1)
		SETZ 2,
		JRST GTST0]
	MOVEM 2,FILSTS(1)
GTST0:	SETOM FILLCK(1)
	LSH 1,-SJFN
	OKINT
	XCT MJRSTF

GTST2:	LSH 1,-SJFN
GTST1:	OKINT
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST GTSTS1		; Illegal, return 0
	 JRST GTSTS2		; Illegal, return 0
	 JRST GTSTS2		; Illegal, return 0
	PUSHJ P,UNLCKF
	UMOVEM STS,2
	JRST MRETN

GTSTS2:	PUSHJ P,UNLCKF
GTSTS1:	XCTUU [SETZM 2]
	JRST MRETN

; Set status
; Call:	1	; Jfn
;	2	; New status
;	STSTS
; Returns
;	+1	; Erro2
;	+2	; Ok (only errf, hltf, and frkf can be changed)

.STSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()			; Bad jfn
	 JFCL
	 ERR(DESX4)		; Tty and byte bad
	UMOVE A,2		; Get new status
	ANDCA A,[XWD ERRF!HLTF!FRKF,0]
	TDZ STS,A
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get device status
; Call:	1	; Jfn
;	GDSTS
; Returns
;	+1	; Error
;	+2	; Ok

.GDSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	MOVE A,STS
	ANDI A,17
	PUSHJ P,@GDSTD(DEV)
	UMOVEM A,2
	JRST UNL

; Set device status
; Call:	1	; Jfn
;	SDSTS
; Returns
;	+1	; Always unless traps

.SDSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	UMOVE A,2
	TEST(NE,OPNF)
	PUSHJ P,@SDSTD(DEV)
	JRST UNL

; Delete file
; Call:	1	; Jfn
;	DELF
; Return
;	+1	; Error, cannot delete
;	+2	; Success

.DELF::	JSYS MENTR		; Become slow
	HRRZ JFN,1
	PUSHJ P,CHKJFN		; Check it out
	 JRST GBGJFN
	 JFCL
	 ERUNLK DESX4		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERUNLK(DESX7)		; Output stars not allowed
	PUSHJ P,@DELD(DEV)	; Call device dependent routine
	 ERUNLK()		; Couldn't delete
	UMOVE A,1
	TLNE A,777777
	JRST DELF1
	TEST(NN,OPNF)
	JRST [	PUSHJ P,RELJFN
		JRST SKMRTN]
DELF1:	PUSHJ P,UNLCKF
	JRST SKMRTN

; Rename file
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	RNAMF
; Return
;	+1	; Error
;	+2	; Ok

.RNAMF::JSYS MENTR
	CAMN 1,2
	JRST SKMRTN
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)		; Cannot rename tty or byte
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	TEST(NE,OPNF)
	ERUNLK(OPNX1)		; File must not be open
	PUSH P,JFN
	PUSH P,DEV
	UMOVE JFN,2
	PUSHJ P,CHKJFN		; Check the second jfn
	 ERUNLK(,<POP P,DEV
		POP P,JFN>)
	JFCL
	 ERUNLK(DESX4,<POP P,DEV
		POP P,JFN>)
	TEST(NE,ASTF)
	ERUNLK(DESX7,<PUSHJ P,UNLCKF
		POP P,DEV
		POP P,JFN>)
	TEST(NE,OPNF)
	ERUNLK(OPNX1,<PUSHJ P,UNLCKF
		POP P,DEV
		POP P,JFN>)
IFE SUMEX,<
	POP P,A
	CAME A,DEV		; Can only rename on the same device
	ERUNLK(RNAMX1,<PUSHJ P,UNLCKF
		POP P,JFN>)
>
IFN SUMEX,<
	CAME	DEV,0(P)
	ERUNLK(RNAMX1,<PUSHJ P,UNLCKF
			POP	P,DEV
			POP	P,JFN>)
	POP	P,DEV
>
	MOVE A,(P)
	PUSH P,JFN
	PUSHJ P,@REND(DEV)
	 ERUNLK(,<POP P,JFN
		PUSHJ P,UNLCKF
		POP P,JFN>)
	POP P,JFN
	PUSHJ P,UNLCKF
	POP P,JFN
	PUSHJ P,RELJFN
	AOS (P)
	JRST MRETN

; Convert jfn to string
; Call:	1	; Jfn
;	2	; String pointer
;	3	; Format specification (see jsys manual)

.JFNS::	JSYS MENTR
	HRRZ JFN,2
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	PUSHJ P,UNLCKF
	UMOVE A,1
	TLNN A,777777
	 JRST JFNSZ		; Not byte pointer
	TLC A,777777
	TLCN A,777777
	 HRLI A,440700		; -1 in lh, fill in
	SETZ B,
	XCTBU [IDPB B,A]	; Deposit initial null in case
JFNSZ:	XCTUM [HLLZ F1,2]
	XCTUU [SKIPN E,3]
	MOVE E,[BYTE (3)2,2,1,1,2,0,0(1)1(4)0(5)0,11]
	HLRZ A,FILDDN(JFN)	; Get pointer to device block
	MOVN B,(A)
	HRLI A,-2(B)
	PUSHJ P,DEVLUK
	MOVEI A,0
	TLNE A,(1B2)
	TROA E,100
	TRZ E,100
	TLNE A,(1B4)
	TROA E,200
	TRZ E,200
	HLRZ A,FILDDN(JFN)
	MOVE C,1(A)		; The first word of the device name
	ANDCMI C,377		; Get rid of low byte
	LDB D,[POINT 3,E,2]	; Get format control byte for device
	PUSHJ P,TAB4
	CAIN D,2		; If it is suppress system default
	CAME C,[ASCIZ /DSK/]	; And the device is dsk, then skip
	CAIN D,0		; Or if control is "no print"
	JRST JFNS0		; Don't print
	PUSHJ P,JFNSS		; Output the string in a
	MOVEI B,":"
	PUSHJ P,PUNCT
JFNS0:	HRRZ A,FILDDN(JFN)	; Get directory number
	LDB D,[POINT 3,E,5]	; And format control
	PUSHJ P,TAB4		; Tab before field if desired
	TEST(NE,DIRSF)
	JRST JFNS0A
	CAIN D,2		; If suppressing default,
	CAME A,JOBDNO		; And it is default

JFNS0A:	HRRZ B,FILDEV(JFN)
	CAIN B,DSKDTB		;IGNORE NON-DISK
	CAIN D,0		; Or if no print is wanted
	JRST JFNS1		; Then don't print
	MOVEI B,"<"
	PUSHJ P,PUNCT		; Print punctuation if desired
	TEST(NE,DIRSF)
	JRST   [
IFN SMXGTJ,<
		HLRZ A,FILDNW(JFN)	; Print wild card if there
	>
		PUSHJ P,JFSTAR
		JRST JFNS0B]
	HRRZ A,FILDDN(JFN)
	PUSHJ P,GDIRST		; Get string for this number
	BUG(HLT,<JFNS: GDIRST CANNOT FIND STRING FOR DIRECTORY.>)
	UNLOCK DIRLCK
	PUSHJ P,JFNSS		; Copy string to output
	OKINT
JFNS0B:	MOVEI B,">"
	PUSHJ P,PUNCT		; And output terminating punct

JFNS1:	HLRZ A,FILNEN(JFN)	; Get location of file name block
	LDB D,[POINT 3,E,8]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS2		; No print wanted
	TEST(NE,NAMSF)
	JRST [
IFN SMXGTJ,<
		HRRZ A,FILDNW(JFN)	; Print wild card if there
	>
		PUSHJ P,JFSTAR
		JRST JFNS2]
	PUSHJ P,JFNSS		; Copy string to output
JFNS2:	HRRZ A,FILNEN(JFN)	; Get location of extension block
	LDB D,[POINT 3,E,11]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS3		; No print wanted
	MOVEI B,"."
	TRNE E,100
	PUSHJ P,PUNCT		; Output punctuation if desired
	TEST(NE,EXTSF)
	JRST [
IFN SMXGTJ,<
		HLRZ A,FILEXW(JFN)	; Print wild card if there
	>
		PUSHJ P,JFSTAR
		JRST JFNS3]
	PUSHJ P,JFNSS		; Copy to output
JFNS3:	HRRZ A,FILVER(JFN)	; Get version number
	LDB D,[POINT 3,E,14]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS4		; No print wanted
	TRNN E,200
	JRST JFNS4
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVE B,A
	MOVEI C,12
	TEST(NE,VERSF)
	JRST [
IFN SMXGTJ,<
		SETZ A,			; Only print star
	>
		PUSHJ P,JFSTAR
		JRST MRETN]
	TEST(NE,RVERF)
	MOVNI B,0
	TEST(NE,HVERF)
	MOVNI B,1
	TEST(NE,LVERF)
	MOVNI B,2
	PUSHJ P,NOUTXX

JFNS4:	TEST(NE,ASTF)
	 JRST MRETN
	HRRZ A,NLUKD(DEV)
IFDEF NETN,<
	CAIN A,NETNAM
	 JRST JFNSNT>
	CAIN A,MDDNAM
	PUSHJ P,GETFDB		; Get a pointer to the fdb
	 JRST MRETN
	PUSH P,FDBREF(A)
	PUSH P,FDBWRT(A)
	PUSH P,FDBCRV(A)
	LDB B,PFILPC
	PUSH P,B
	PUSH P,FDBCTL(A)
	MOVE B,FDBACT(A)	; Get account
	SETZ C,			; 0 words of string
	TLNN B,-1		; String account?
	 JRST [	HRRZ C,DIRORG(B); Get length of string block
		SUBI C,2	; Skip header and share count
		HRL C,C		; To both halves
		MOVEI D,1(P)	; Where to put string on stack
		HRLI D,DIRORG+2(B); Where to get string from
		HRR B,P		; Point to just before string on stack
		ADD P,C		; Bump to beyond string
		JUMPGE P,MSTKOV
		BLT D,0(P)	; Blt onto stack
		JRST .+1]
	PUSH P,C		; Save size of string
	PUSH P,B		; And account or pointer
	PUSH P,DIRDPW
	PUSH P,FDBPRT(A)
	PUSHJ P,USTDIR		; Unlock directory (done with it)
	LDB D,[POINT 3,E,17]
	PUSHJ P,TAB4
	MOVE B,0(P)
	CAIN D,2
	CAME B,-1(P)
	CAIN D,0
	JRST JFNS5
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"P"
	PUSHJ P,PUNCT
	MOVE A,0(P)		; Get protection
	MOVEI C,10
	PUSHJ P,JFNSN

JFNS5:	SUB P,[XWD 2,2]		; Flush protection and def prot
	LDB D,[POINT 3,E,20]
	PUSHJ P,TAB4
	JUMPE D,JFNS6
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"A"
	PUSHJ P,PUNCT
	MOVE A,(P)		; Get account or pointer
	MOVEI C,^D10
	PUSHJ P,JFNSN

JFNS6:	SUB P,[XWD 1,1]		; Flush account or pointer
	POP P,C			; Get size of saved string
	SUB P,C			; Flush string from stack
	LDB D,[POINT 1,E,21]
	POP P,B
	TLNE B,FDBTMP
	CAIN D,0
	JRST JFNS7
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"T"
IFN SMXGTJ,<
	HRRZ A,FILVER(JFN)		; Check to see if ;S
	CAIGE A,^D100000
	 MOVEI B,"S"
	>
	PUSHJ P,BOUTA
JFNS7:	LDB D,[POINT 1,E,22]
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	JUMPE D,JFNS8
	MOVE B,0(P)
	MOVEI C,^D10
	PUSHJ P,NOUTXX

JFNS8:	SUB P,[XWD 1,1]
	POP P,B
	TRNE E,1B23
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	POP P,B
	TRNE E,1B24
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	POP P,B
	TRNE E,1B25
	PUSHJ P,JFNDAT
	 JFCL
	JRST MRETN

IFDEF NETN,<
JFNSNT:	MOVE B,JOBNO
	ADDI B,^D100000
	HRRZ A,FILVER(JFN)
	CAME A,B
	 JRST MRETN
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"T"
	PUSHJ P,PUNCT
	JRST MRETN>

JFNSN:	JUMPG A,JFNSS		; Copy to output
	MOVE B,A
	TLZ B,700000
NOUTXX:	PUSH P,JFN
	PUSH P,DEV
	PUSH P,STS
	PUSH P,F1
	PUSH P,E
	PUSH P,D
	PUSH P,F
	PUSH P,C
	PUSH P,B
	PUSHJ P,NOUTX
	 JFCL
	POP P,B
	POP P,C
	POP P,F
	POP P,D
	POP P,E
	POP P,F1
	POP P,STS
	POP P,DEV
	POP P,JFN
	POPJ P,

JFNDAT:	PUSH P,B
	MOVEI D,1
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	POP P,B
	PUSH P,A
	SETZ C,
	HRROI A,1(P)
	ADD P,[XWD 4,4]
	ODTIM
	MOVEI C,-3(P)
	HRLI C,(<POINT 7,0>)
JFNDA1:	ILDB B,C
	JUMPE B,[SUB P,[XWD 4,4]
		POP P,A
		POPJ P,]
	PUSHJ P,BOUTN
	JRST JFNDA1

JFNCOM:	MOVEI B,","
	CAIE D,0
	TRNN E,10
	POPJ P,
	JRST BOUTA

JFSTAR:	MOVEI B,"*"
IFE SMXGTJ,<
	JRST BOUTA
	>
IFN SMXGTJ,<
	JUMPE A,BOUTA
	MOVE C,A		; Print whole wild card template
	HRLI C,(<POINT 7,0,35>)	; Ptr into string block
JFSTR0:	ILDB B,C		; Fetch a char
	JUMPE B,CPOPJ		; 0 ends it all
	PUSHJ P,BOUTA		; Otherwise print it
	JRST JFSTR0		; Do them all
	>

PUNCT:	TRNE E,1
	JRST BOUTA
	POPJ P,

TAB4:	MOVEI B,11
	TRNE E,2
	CAIG D,0
	TRNE E,4
	TRON E,40
	POPJ P,
BOUTA:	JRST BOUTN

JFNSS::	MOVE C,A
	HRLI C,(<POINT 7,0,35>)
JFNSS1:	ILDB B,C
	JUMPE B,CPOPJ
	PUSH P,C		; Prepare to compute char class
	PUSH P,B

;	IDIVI B,^D36/CCSIZE	; Ccsize and cptab and char type
	MOVEI B,^D36		; Have to do it the hard way cause
	IDIVI B,CCSIZE		; Macro can't divide externals
	MOVE C,B
	MOVE B,0(P)
	IDIV B,C		; And finally the real divide
	LDB B,CPTAB(B+1)	;  are found in gtjfn.fai
	JUMPE B,NTSPC		; 0 clas is normal alphas
IFN SMXGTJ,<
	CAIE B,32		; S not special
	>
	CAIN B,30		; Minus sign not special
	 JRST NTSPC
	CAIL B,21		; Digits t, p, a
	CAILE B,24
	 JRST [	MOVEI B,"V"-100	; Special char
		PUSHJ P,BOUTA	; Prefix with control-v
		JRST NTSPC]
NTSPC:	POP P,B
	POP P,C
	PUSHJ P,BOUTA
	JRST JFNSS1

; Get size of file
; Call:	1	; Jfn
;	SIZEF
; Return
;	+1	; Error, cannot get size of file
;	+2	; Success
;	1	; Size in bytes
;	2	; Size in pages

.SIZEF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST GBGJFN
	 JFCL
	 ERUNLK DESX4
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ B,DEV		; Get dispatch address
	MOVEI A,DESX8
	CAIE B,DSKDTB
	ERUNLK()
	PUSHJ P,GETFDB		; Get pointer to fdb
	 ERUNLK OPNX2
	LDB B,PFILPC		; Get number of pages
	MOVE A,FDBSIZ(A)	; And length
	UMOVEM A,2
	UMOVEM B,3
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST SKMRTN

GBGJFN:	UMOVEM A,1
	JRST MRETN

; Backup file pointer by 1 byte
; Call:	1	JFN
;	BKJFN
; Returns
;	+1	; Error, cannot backup this designator
;	+2	; Ok.

.BKJFN::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JRST BKJTTY
	 JRST BKJBYT
	HRRZ A,DEV
	CAIN A,TTYDTB		; Tty?
	JRST BKJTT1
	TEST(NN,OPNF)
	ERR(DESX5,<PUSHJ P,UNLCKF>)
	MOVE A,FILBYN(JFN)
	SOJL A,[ERR(SFPTX3,<PUSHJ P,UNLCKF>)]
	PUSHJ P,SFBNR
	 ERR(,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	JRST SKMRTN

BKJTT1:	PUSHJ P,UNLCKF
BKJTTY:	HLRZ 2,DEV
	PUSHJ P,TTBKPT
	 ERR(BKJFX1)
	JRST SKMRTN

BKJBYT:	MOVE A,JFN
	PUSHJ P,DBP
	UMOVEM A,1
SKMRTN::AOS (P)
	JRST MRETN

; Read file byte number
; Call:	1	; Jfn
;	RFPTR
; Return
;	+1	; Error
; 	+2	; Success
;	2	; File byte number

.RFPTR::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NN,OPNF)
	ERUNLK(DESX5)
	MOVE A,FILBYN(JFN)
	UMOVEM A,2
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Set file byte number
; Call:	1	; Job file number
;	2	; Byte number
;	SFPTR
; Return
;	+1	; Error
;	+2	; Successful

.SFPTR::JSYS MENTR		; Become slow etc.
	MOVE JFN,1
	PUSHJ P,CHKJFN		; Find out what we are dealing with
	 ERR()
	 JFCL
	 ERR(DESX4)		; Tty or byte pointer illegal
	TEST(NN,OPNF)
	ERUNLK(CLSX1)
	UMOVE A,2
	PUSHJ P,SFBNR		; Set the byte number
	 ERUNLK()
	AOS (P)			; Skip return
	PUSHJ P,UNLCKF
	JRST MRETN

; Set file byte number common code
; Call:	A	; Byte number
;	PUSHJ P,SFBNR
; Return
;	+1	; Error of some sort, error number in a
;	+2	; Success
; Clobbers most temps

SFBNR::	TEST(NN,RNDF)
	JRST [	MOVEI A,SFPTX2
		POPJ P,]	; Illegal to reset pointer for this file
	CAMN A,[-1]
	MOVE A,FILLEN(JFN)	; Set to end of file if -1
	JUMPL A,[MOVEI A,SFPTX3
		POPJ P,]	; Illegal byte number
	MOVEM A,FILBYN(JFN)
	TEST(Z,EOFF)
	CAML A,FILLEN(JFN)
	TEST(O,EOFF)
	PUSHJ P,NEWWND		; Set window pointers
	AOS (P)
	POPJ P,

NFBSZ::	MOVEI C,^D36
	IDIVM C,A		; Number of bytes per word
	MOVEI C,^D36
	IDIV C,B		; New number of bytes per word
	PUSH P,C
	IMUL C,FILBYN(JFN)	; Adjust byte number
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILBYN(JFN)
	POP P,C
	IMUL C,FILLEN(JFN)	; And adjust file length
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILLEN(JFN)
	DPB B,PBYTSZ		; Deposit new byte size
	POPJ P,

; Read file byte size
; Call:	1	; Jfn
;	RFBSZ

.RFBSZ::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	TEST(NN,OPNF)
	ERABRT(DESX5)
	LDB A,PBYTSZ
	UMOVEM A,2
	PUSHJ P,UNLCKF
	JRST MRETN

; Set file byte size jsys
; Call:	1	; Job file number
;	2	; Byte size (1 to 36)
;	SFBSZ
; Return
;	+1	; Error number in a
;	+2	; Success

.SFBSZ::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)		; Tty and byte pointers illegal
	TEST(NN,OPNF)
	ERABRT(CLSX1,<PUSHJ P,UNLCKF>)
	XCTUU [SKIPLE B,2]
	CAILE B,^D36
	ERABRT(SFBSX2,<PUSHJ P,UNLCKF>)	; Illegal byte size
	TEST(NE,SIZF)
	ERABRT(SFBSX1,<PUSHJ P,UNLCKF>)	; Illegal to change byte size
	LDB A,PBYTSZ		; Get previous byte size
	PUSHJ P,NFBSZ
	PUSHJ P,NEWWND		; Recompute window pointers
	PUSHJ P,UNLCKF		; Unlock file
	JRST MRETN

; Swap jfn's
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	SWJFN

.SWJFN::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST ERABRD
	 JFCL
	 ERABRT(DESX4)
	PUSH P,JFN
	UMOVE JFN,2
	PUSHJ P,CHKJFN
	 ERABRT(,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	 JFCL
	 ERABRT(DESX4,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	POP P,A

	MOVEI B,[FILBYT
		FILBYN
		FILLEN
		FILCNT
		FILWND
		FILSTS
		FILDEV
		FILOFN
		FILLFW
		FILDDN
		FILNEN
		FILVER]
	HRLI B,-^D12
	HRLI A,D
	HRLI JFN,D
SWJFNL:	MOVE D,(B)
	MOVE C,@JFN
	EXCH C,@A
	MOVEM C,@JFN
	AOBJN B,SWJFNL
	SETOM FILLCK(JFN)
	SETOM FILLCK(A)
	JRST MRETN

; Get fdb entry
; Call:	1	JFN
;	LH(2)	; Number of words to read
;	RH(2)	; First word to read
;	3	; Location to store words
;	GTJFN

.GTFDB::JSYS MENTR
	UMOVE A,2
	HLRZ B,A		; Get count
	HRRZS A			; Offset
	CAIL A,FDBLEN
	ERABRT(GFDBX1)		; Offset too big
	ADD A,B
	CAIE B,0		; 0 words illegal
	CAILE A,FDBLEN
	ERABRT(GFDBX2)		; Count too big
	UMOVE JFN,1
	PUSHJ P,CHKJFN		; Check the jfn
	 ERABRT()		; Garbage
	 JFCL
	 ERABRT(DESX4)		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERABRT(DESX7)
	HRRZ A,NLUKD(DEV)	; Get name lookup dispatch
	CAIE A,MDDNAM		; Must be mddnam
	ERABRT(GFDBX1,<PUSHJ P,UNLCKF>)	; Cannot read fdb for device
	PUSHJ P,GETFDB		; Get pointer to the fdb
	 ERABRT(DESX3,<PUSHJ P,UNLCKF>)

	UMOVE B,2
	ADDI A,(B)		; Offset pointer to fd
	UMOVE C,3		; To address
	HRL C,A			; From address
	HLRZS B			; Count
	ADDI B,(C)		; Last address+1
	XCTMU [BLT C,-1(B)]
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST MRETN

; Change fdb
; Call:	LH(1)	; Offset
;	RH(1)	; Jfn
;	2	; Mask
;	3	; Data
;	CHFDB

.CHFDB::JSYS MENTR
	UMOVE A,1
	HRRZ JFN,A
	HLRZS A
	CAIL A,FDBLEN
	ERABRT(CFDBX1)		; Offset too big
	PUSHJ P,CHKJFN		; Check jfn
	 ERABRT()		; Garbage
	 JFCL
	 ERABRT(DESX4)		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERABRT(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERABRT(CFDBX1)		; No fdb fon non mdd devices
	PUSHJ P,GETFDB		; Get the fdb
	 ERABRT(DESX3,<PUSHJ P,UNLCKF>)
	XCTUU [HLRZ D,1]
	PUSH P,A		; Save fdb loc
	UMOVE B,2		; Mask
	ANDCM B,WRTR(D)		; Writer bits?
	JUMPN B,CHFDB1		; No, check owner and wheel
	HRLI A,100000		; Yes check for write access
	PUSHJ P,ACCCHK
	 JRST CHFDB3		; No write access, still ok if owner
	JRST CHFDB2		; Ok, go ahead

CHFDB1:	ANDCM B,OWNER(D)
	JUMPN B,CHFDB4		; Requires mor than owner status
CHFDB3:	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Check if we have owner rights
	 JRST CHFDB5
	JRST CHFDB2

CHFDB4:	ANDCM B,WOPR(D)
	JUMPN B,CHFDB6		; Can't be done
CHFDB5:	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CHFDB2
CHFDB6:	MOVEI A,CFDBX2
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST ERABRD

CHFDB2:	POP P,A
	ADD A,D
	UMOVE C,3		; Data
	MOVE B,(A)		; Old data
	UMOVE D,2		; Mask
	AND C,D			; Retain masked bits of new data
	ANDCM B,D		; Flush bits to be replaced from old
	IOR B,C
	MOVEM B,(A)
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST MRETN

; Access tables for chfdb

WRTR:	0
	0
	0
	0
	0
	0
	0
	0
	0
	007700000000
	777777777777
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0

OWNER:	0		; Fdbctl
	463001000000	; Fdbctl
	0		; Fdbext
	0		; Fdbadr
	000000777777	; Fdbprt
	0		; Fdbcre
	777777000000	; Fdbuse
	0		; Fdbver
	0		; Fdbact
	777700000000	; Fdbbyv (byte size and # backups)
	777777777777	; Fdbsiz
	0		; Fdbcrv
	0		; Fdbwrt
	0		; Fdbref
	0		; Fdbcnt
	310000000000	; Backup (ALLOW ARCHIVE FLAGS - BSYS)
	0
	0
	0
	0
	777777777777	; Fdbusw

WOPR:	0		; Header
	200000000000
	0
	0
	0
	777777777777	; Creation date
	0
	0
	0
	0
	0
	777777777777	; Fdbcrv
	777777777777	; Fdbwrt
	777777777777	; Fdbref
	777777777777	; Fdbcnt
	777777777777
	777777777777
	777777777777
	777777777777
	777777777777
	0

; String to directory
; Call:	1	; Positive for no recognition
;	2	; Source designato$
;	STDIR
; Return
;	+1	; No match
;	+2	; Ambiguous
;	+3	; Unique match

.STDIR::JSYS MENTR
;	UMOVE A,1		; NOT NECESSARY..BUT LOGICAL
	UMOVE B,3		; DEVICE DESIGNATOR IF ANY
	PUSHJ P,SETUNT
	 ERR()
	UMOVE A,2		; STRING POINTER
	PUSHJ P,CPYFUS
	 JRST MRETN
	PUSH P,A		; Save location of the temp block
	PUSH P,B		; Save string pointer to tail
;	MOVEI JFN,-FILOPT(P)	; Set jfn so filopt(jfn) refers to pdl
	MOVNI JFN,FILOPT	; Gotta do it the hard way
	ADD JFN,P
	HRRZS JFN
	XCTUU [SKIPL 1]
	TEST(OA,NREC)
	TEST(Z,NREC)
	PUSHJ P,DIRLUK
	SOS -2(P)		; Undo one skip
	JRST STDIR1
	XCTUU [EXCH A,1]	; Return the directory number
	SUB P,[XWD 1,1]
	JUMPGE A,STDIR4		; If no recognition, then no tail to copy
	UMOVE A,2		; Get the user's pointer
	MOVE B,(P)
	PUSHJ P,CPYTUS
STDIR4:	UMOVE A,1		; Get the directory number back
	PUSHJ P,GETDDB
	BUG(HLT,<STDIR: GETDDB FAILED WHEN DIRLUK DIDN'T.>)
	MOVE A,DDBMOD(A)
	XCTUU [HLLM A,1]
	PUSHJ P,USTDIR
	AOSA -1(P)
STDIR1:	POP P,B
	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	JRST SKMRTN

; Directory number to string conversion
; Call:	1	; Sink designator
;	2	; Directory number
;	DIRST
; Return
;	+1	; Error
;	+2	; Ok

.DIRST::JSYS MENTR
;[EDIT]ADD 6 LINES TO CATCH BAD DESIGNATORS BEFORE BOUT DOES---EDIT BY LIEB
	UMOVE	JFN,1		;[EDIT]GET THE DESIGNATOR
	PUSHJ P,CHKJFN		;[EDIT]IS IT ANY GOOD?
	JRST IOERR		;[EDIT]NO,FORCE PSI
	JFCL			;[EDIT]A TTY
	SKIPA			;[EDIT]A STRPTR
	SETOM	FILLCK(JFN)	;[EDIT]A FILE UNLOCK IT
	UMOVE A,2		; DIRNUM & BIT
	UMOVE B,3
	PUSHJ P,SETUNT
	 ERR()
	XCTUU [HRRZ A,2]
	PUSHJ P,GDIRST
	 JRST MRETN
	UNLOCK DIRLCK
	PUSHJ P,JFNSS
	AOS (P)
	JRST MRETN

; Make a new fd
; Call:	A	; Pointer to parameter block
;	MAKFD
; Return
;	+1	; Error
;	+2	; Success
;	1	; User number
; In parameter block
;	0	; Pointer to name string
;	1	; Pointer to password string, 0 if none
;	2-N	; Copy of ddb image

.CRDIR::JSYS MENTR
	UMOVE A,2		; BIT
	UMOVE B,3		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()
;;;	MOVE A,CAPENB
;;;	TRNN A,WHEEL!OPR
;;;	ERABRT(CRDIX1)
	UMOVE E,2
	UMOVE A,1
	PUSHJ P,CPYFUS		; Copy directory name string
	 ERR CRDIX3		; No room in jsb
	MOVE B,1(A)
	TLNN B,774000
	ERR CRDIX5		; Null name illegal
	PUSHJ P,DIRLUU		; Look up the name in directory
;;;	 JRST MAKNFD		; Non-existent, must make a new one
	JRST CRDIRA
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CRDIRB
	MOVE B,JOBNO
	HRRZ B,JOBDIR(B)
	CAIN B,(A)
	TLNE E,577777		; ONLY PASSWORD CHANGE
	JRST CRDIRC
CRDIRB:
	PUSH P,A
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release free storage used for name
	TLNE E,(1B16)		; Delete wanted?
	 JRST DELDIR		; Yes
	UNLOCK DIRLCK
	POP P,A
	TLNE E,(1B6)
	XCTUU [CAMN A,6(E)]
	JRST CRDIR1
	ERABRT(CRDIX2)		; Directory number disagrees

CRDIRA:	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST MAKNFD
CRDIRC:	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; RELEASE FREE STORAGE
	UNLOCK DIRLCK
	ERABRT(CRDIX1)

CRDIR1:	PUSHJ P,GETDDB		; Setup a pointer to the ddb
	BUG(HLT,<CRDIR: GETDDB FAILED WHEN DIRLUU DIDN'T.>)
	MOVE NUM,A		; Save pointer in num
MAKFD0:	TLNN E,(1B1)
	JRST CRDIR3		; No password change
	UMOVE A,1(E)		; Get pointer to password
	PUSHJ P,CPYFUS		; Copy new password to free storage
	 ERR CRDIX3,<UNLOCK DIRLCK>
	PUSHJ P,SETMSK		; Store in directory
	PUSHJ P,CPYDIR		; And copy string to directory
	 ERR(CRDIX4,<MOVE B,DIRINP
		MOVEI B,1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE	; Release job storage
		UNLOCK DIRLCK>)
	HLRZ B,DDBNAM(NUM)	; Get old password pointer
	HRRZS DDBNAM(NUM)	; Zero old pntr
	PUSH P,A
	JUMPE B,MAKFD1
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release storage if any
MAKFD1:	POP P,A
	SUBI A,DIRORG
	HRLM A,DDBNAM(NUM)	; Store as password
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release jsb storage

CRDIR3:
	UMOVE A,3(E)		; Get privilege bits
	TLNE E,(1B3)
	MOVEM A,DDBPRV(NUM)
	UMOVE A,4(E)
	TLNE E,(1B4)
	MOVEM A,DDBMOD(NUM)
	SETZM DDBRES(NUM)
	UMOVE A,12(E)		; GET LAST LOGIN
	TLNE E,(1B10)		; WANT TO SET IT?
	 MOVEM A,DDBDAT(NUM)	; YES, SET IT
	UMOVE A,13(E)
	TLNE E,(1B11)
	MOVEM A,DDBGRP(NUM)
	MOVE A,DDBNUM(NUM)
	UNLOCK DIRLCK
	PUSHJ P,SETDIR
	BUG(HLT,<CRDIR: SETDIR FAILED ON DIRECTORY FOUND IN INDEX.>)
	UMOVE A,2(E)		; GET MAX ALOCATION
	TLNE E,(1B2)		; SET THIS ONE ?
	HRLM A,DIRDSK		; YUP
	UMOVE A,7(E)		; Default file protection
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B7)
	MOVEM A,DIRDPW
	UMOVE A,10(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B8)
	MOVEM A,DIRPRT
	UMOVE A,11(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B9)
	MOVEM A,DIRDBK
	UMOVE A,14(E)
	TLNE E,(1B12)
	MOVEM A,DIRGRP
	UNLOCK DIRLCK
	JUMPG UNIT,CRDIR4	; NO MESSAGE FILE IF NOT DSK:
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	JRST CRDIR4		; NO MESSAGE FILE FOR PASSW. CH.

	MOVEI B,20
	PUSHJ P,ASGJFR
	 JRST CRDIR4
	PUSH P,A
	HRLI A,(<POINT 7,0,34>)
	HRROI B,[ASCIZ /DSK:</]
	SETZ C,
	SOUT
	MOVE B,DIRNUM
ifn sumex,<
	move	c,b		;save for test below
>
	DIRST
	 JRST CRDIR5
	PUSH P,A
	MOVE B,-1(P)
	ADDI B,1
	HRLI B,(<POINT 7,0,34>)
	SETZ A,
	STDIR
	 JFCL
	 JRST [	POP P,A
		JRST CRDIR5]
	TLNE A,(1B0)
	 JRST [	POP P,A
		JRST CRDIR5]
 IFN SUMEX,<
	TLNN E,4000			;CHANGING NUMBER?
	JRST	[
		SKIPE B,TOPDIR		;HIGHEST DIR #
		CAMN B,C		;COMPARE WITH DIRNUM FROM MAKFND
		JRST .+1
		POP P,A
		JRST CRDIR5]		;DO NOT CREATE MESAGE.TXT
>
	POP P,A
	HRROI B,[ASCIZ />MESSAGE.TXT;1/]
	SETZ C,
	SOUT
	MOVE B,(P)
	HRLI B,(<POINT 7,0,34>)
;
;   I4 CHANGE
	MOVSI A,101001		;SEE IF MESSAGE.TXT EXISTS
	GTJFN
	SKIPA			;IT DOESN'T--CREATE IT
	JRST CRDI12		;IT DOES--DON'T DELETE CURRENT MSGS
	MOVE B,(P)
	HRLI B,(<POINT 7,0,34>)  ;RESTORE REGISTERS
;
	MOVSI A,400001
	GTJFN
	 JRST CRDIR5
	HRLI A,FDBCTL
	MOVSI B,FDBPRM!FDBNXF!FDBDEL
	MOVSI C,FDBPRM!FDBDEL
	CHFDB
;
;   I4 CHANGE
	HRLI  A,FDBPRT		;SET UP PROTECTION FOR MESSAGE.TXT
	MOVEI 3,770404		;NORMAL MESSAGE.TXT PROTECTION
	MOVE 2,DIRNUM
	CAIN 2,1		;SYSTEM HAS REGULAR PROTECTION
	MOVEI 3,777752
	MOVEI 2,-1		;PROTECTION FIELD BITS
	CHFDB
;
CRDI12:
	HRRZS A
	RLJFN
	 JFCL

CRDIR5:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
CRDIR4:	SETZM NXTDMP
	JRST MRETN

DELDIR:	PUSH P,DIRNUM		; Remember where we are
	MOVE JFN,-1(P)		; Get directory number to delete

	PUSHJ P,DELALL		; Try very hard to delete all files
	MOVE A,SYMBOT
	CAME A,SYMTOP		; Did we succeed?
	 JRST [	MOVE A,DIRORG(A) ;!!BBN PATCH VIA SRI 9/25/74 MICHAEL!!
		TRNE A,700000
		JRST .+1
		POP P,A
		PUSHJ P,MAPDIR
		UNLOCK(DIRLCK)
		ERABRT(CRDIX7)]
	POP P,A
	PUSHJ P,MAPDIR		; Return to subindex
	MOVE A,DIRLOC		; Get sym tab loc
	PUSH P,DIRORG(A)	; Save content
DELDI0:	CAMGE A,SYMBOT		; At bottom?
	 JRST DELDI1		; Yes
	MOVE B,DIRORG-1(A)	; No move symbol table up
	MOVEM B,DIRORG+0(A)
	SOJA A,DELDI0

DELDI1:	AOS SYMBOT		; Point to new bottom
	HLRZ B,0(P)		; Get pointer to string
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release free storage
	SUB P,[XWD 1,1]
	POP P,A			; Get directory number
	PUSHJ P,HSHLUK		; Find it in hash table
	 BUG(HLT,<CRDIR: HSHLUK FAILURE FOR EXISTENT USER>)
	MOVSI A,-1
	EXCH A,DIRORG(B)	; Get hash table entry, delete entry
	UNLOCK DIRLCK		; Unlock
	HLRZS A
	PUSH P,A		; Save
	LSH A,-^D12		; Get subindex number
	MOVNS A			; Negate
	PUSHJ P,MAPDIR		; Back to the subdirectory
	MOVEI A,7777
	ANDB A,0(P)		; Extract ddb location
	HLRZ B,DDBNAM+DIRORG(A)	; Get pointer to password
	ADDI B,DIRORG
	CAIE B,DIRORG
	 PUSHJ P,RELDFR		; Release free storage if any
	POP P,B
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release free storage for ddb
	UNLOCK DIRLCK
	JRST MRETN

MAKNFD:	MOVE A,SYMBOT
	SUBI A,2
	CAML A,FRETOP
	JRST .+3
	PUSHJ P,XPAND
	 BUG(HLT,<CRDIR: SUBINDEX FULL>)
	MOVEI B,DDBLEN
	PUSHJ P,ASGDFR		; Assign space for the ddb
	 ERABRT(CRDIX4,<UNLOCK DIRLCK
		MOVE B,DIRINP
		MOVEI B,-1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE>)
	MOVEI NUM,(A)		; Point num to the ddb
	SETZM DDBNAM(NUM)	; Clear name pointers
	SETZM DDBNUM(NUM)	; Clear number
	SETZM DDBPRV(NUM)	; Default privileges
	SETZM DDBDAT(NUM)	; CLEAR LAST LOGIN
	SETZM DDBMOD(NUM)	; Default modes
	SETZM DDBGRP(NUM)
	SETZM DDBRES(NUM)
	PUSHJ P,CPYDIR		; Copy name to directory
	 ERR CRDIX4,<MOVE B,NUM
		PUSHJ P,RELDFR
		UNLOCK DIRLCK>
	SUBI A,DIRORG		; Convert to relative pointer
	HRRM A,DDBNAM(NUM)	; Save as name
	HRLZ C,A		; Right half yet to be filled in
	SOS B,DIRLOC
	SOS A,SYMBOT
	CAML A,B
	JRST MAKNFZ
	ADDI A,DIRORG
	HRLI A,1(A)
	BLT A,DIRORG-1(B)
MAKNFZ:	MOVEM C,DIRORG(B)
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	MOVN A,DIRNUM		; Get subindex number
	IMULI A,10000		; Convert to position in file
	ADD NUM,A		; Of the ddb
	SUBI NUM,DIRORG
	MOVEI A,0
	PUSHJ P,SETDIR		; Look at block 0
	BUG(HLT,<CRDIR: SETDIR FAILED FOR BLOCK 0.>)
	UMOVE A,6(E)
	TLNE E,(1B6)
	JRST FNN01

	PUSH P,[-1]		;FLAG TO CONTROL LOOP
FNN00:	MOVE A,LSTDNO		; HIGHEST ASSIGNED NUMBER
	AOS A			; PLUS 1
	CAIL A,NFDIB*40
	 JRST [AOSE (P)		;SHOULD WE RECYCLE?
		JRST [POP P,(P)	;NO
			JRST FNN05]	;ALL NUMBERS USED UP
		SETZM LSTDNO	;YES. CYCLE AROUND ONCE
		JRST FNN00]
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK		; Is this number available?
	 JRST [POP P,0(P)	;RESTORE STACK
		SKIPG DIRORG(B)	;CHECK FOR HASH TABLE FULL CONDITION
		JRST FNN2	;NOT FULL-USE THIS ENTRY
		JRST FNN05]	;CAN'T CREATE NEW DIRECTORY
	AOS LSTDNO
	JRST FNN00		; No, try another

FNN2:	CAIL A,1
	CAIL A,NFDIB*40
	BUG(HLT,<CRDIR: HSHLUK RETURN INVALID DIRECTORY NUMBER.>)
	CAML A,LSTDNO
IFE SUMEX,<
	  MOVEM A,LSTDNO
>
IFN SUMEX,<
	JRST [MOVEM A,LSTDNO
		MOVEM A,TOPDIR##
		JRST .+1]
>
	MOVEM A,DIRORG(B)	; Store directory number in rh
	HRLM NUM,DIRORG(B)	; And ddb location in left
	MOVE B,NUM
	IDIVI B,10000		; Recover block containing ddb
	ADDI B+1,DIRORG
	PUSH P,B+1
	PUSH P,A
	UNLOCK DIRLCK
	MOVN A,B
	PUSHJ P,MAPDIR		; Return to original subindex
	POP P,A
	POP P,NUM
	HRRM A,DDBNUM(NUM)
	MOVE B,DIRLOC
	HRRM A,DIRORG(B)
	HRRZS A			; Retain only directory number
	PUSH P,DIRNUM		; Save current directory number
	PUSH P,A		; And new directory number
	PUSHJ P,MAPDIR		; Map the new directory
	MOVE A,DIRNUM
	CAME A,0(P)		; See if directory looks like
	 JRST CRWIPE		; It already exists
	SETO A,
	CAMN A,DIRLCK
	CAME A,DIRFRE+1
	 JRST CRWIPE
	MOVE A,SYMTOP
	TRNN A,777
	CAMGE A,SYMBOT
	 JRST CRWIPE
	MOVE A,SYMBOT
	CAMGE A,FRETOP
	 JRST CRWIPE
	JRST CRNWIP

CRWIPE:	MOVEI A,25
	MOVEI B,1000
	MOVE C,0(P)
	PUSHJ P,INIBLK		; Initialize it
CRNWIP:	POP P,DIRNUM		; Set its directory number
	MOVEI A,^D500		; DEFAULT MAX ALOCATION = 250
	HRLM A,DIRDSK
	MOVE A,[500000,,777752]
	MOVEM A,DIRDPW		; SET DEFAULT PROTECTION
	HRRI A,777740
	MOVEM A,DIRPRT		; AND DIRECTORY PROTECTION
	MOVEI A,4
	MOVEM A,DIRDBK		; AND DEFAULT BACKUP
	SETZM DIRGRP		; AND GROUPS
	POP P,A
	UNLOCK DIRLCK		; Unlock the new directory
	PUSHJ P,MAPDIR		; Restore to mapping current di
	JRST MAKFD0

FNN01:	CAIL A,1
	CAIL A,NFDIB*40
	JRST FNN05
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK
	JRST FNN2
FNN05:	UNLOCK DIRLCK		; Number unavailable, abort
	MOVE B,NUM
	IDIVI B,10000
	MOVEI C,DIRORG(B+1)	; Location in subindex of ddb
	PUSH P,C
	MOVN A,B		; Subindex number
	PUSHJ P,MAPDIR		; Get back to it
	POP P,NUM
	HRRZ B,DDBNAM(NUM)	; Get location of name string
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release it
	MOVE B,NUM		; Location of ddb
	PUSHJ P,RELDFR		; Release it
	MOVE B,DIRLOC		; Location where symtab entry was put
FNN03:	CAMG B,SYMBOT		; Something left to move?
	JRST FNN04		; No
	MOVE A,DIRORG-1(B)
	MOVEM A,DIRORG(B)
	SOJA B,FNN03

FNN04:	AOS SYMBOT
	UNLOCK DIRLCK
	ERABRT(CRDIX6)

; Get directory info
; Call:	1	; Directory number
;	2	; Pointer to parameter block
;	3	; String pointer for password
;	GTDIR

.GTDIR::JSYS MENTR
	UMOVE A,1		; DIRNUM & BIT
	UMOVE B,4		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()

;	ALLOW ONLY LOGIN DIRECTORY TO GET HIS INFORMATION

	MOVE B,JOBNO
	HRRZ B,JOBDIR(B)
	UMOVE E,1	;GET DESIRED DIRECTORY
	CAMN B,E	;SAME AS CONNECTED?
	JRST GTDIR3	;YES--DONT HAVE TO CHECK WHEEL
;
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	ERABRT(GTDIX1)		; Not wheel or opr

GTDIR3:

	XCTUU [HRRZ A,1]
	PUSHJ P,GETDDB
	 ERABRT(GTDIX2)
	UMOVE E,2
	UMOVE C,3
	JUMPGE C,GTDIR1
	CAML C,[777777000000]
	HRLI C,(<POINT 7,0>)
GTDIR1:	HLRZ B,DDBNAM(A)
	ADDI B,DIRORG
	HRLI B,(<POINT 7,0,35>)
	UMOVEM C,1(E)
	UMOVEM C,3
	ILDB D,B
	XCTBU [IDPB D,C]
	JUMPN D,.-3
	MOVE D,DDBPRV(A)
	UMOVEM D,3(E)
	MOVE D,DDBMOD(A)
	UMOVEM D,4(E)
	MOVEI D,0
	UMOVEM D,5(E)
	MOVE D,DDBNUM(A)
	UMOVEM D,6(E)
	MOVE D,DDBDAT(A)
	UMOVEM D,12(E)

GTDIR2:	MOVE D,DDBGRP(A)
	UMOVEM D,13(E)
	MOVE A,DDBNUM(A)
	UNLOCK DIRLCK
	PUSHJ P,MAPDIR
	HLRZ D,DIRDSK		; GIVE USER MAX DISK ALOCATION
	UMOVEM D,2(E)
	MOVE D,DIRDPW
	UMOVEM D,7(E)
	MOVE D,DIRPRT
	UMOVEM D,10(E)
	MOVE D,DIRDBK
	UMOVEM D,11(E)
	MOVE D,DIRGRP
	UMOVEM D,14(E)
	JRST MRETN

; Pmap jsys
; Call:	1	; Page ident (frk.pn or jfn.pn)
;	2	; Page ident
;	3	; Bits 2,3,4 to set page table access
;	PMAP

.PMAP::	JSYS MENTR
	IOR 1,2
	JUMPGE 1,[MOVEI A,PMAPX2
		JRST PMAPER]	; Neither is fork -- error
	UMOVE A,2		; Get destination designator
	PUSHJ P,CPMAP		; Convert to ptn.pn and get access

REPEAT 0,<

;
;  I4 CHANGE
;		DONT ALLOW PMAP FROM FORK TO BIOM
	MOVNI E,NKLG	;SEE IF PAGE IS IN ANY OF THE KLUDGES
	HRLZ E,E
I4PMAP:
	MOVE D,KLGRA(E)	;GET ITS FIRST CST ENTRY
	MOVE D,CST2(D)
	TLNN D,-1
	JRST PMAP5		;NO KLUDGE FILE
	XOR D,A		;AS THIS WILL CAUSE CRASH IN RELMPG
	LSH D,-^D18	;SEE IF OFN=OFN OF KLUDGE
	JUMPE D,PMPER1
PMAP5:	AOBJN E,I4PMAP
;   END FIX
;
>;END REPEAT 0

	TLNN C,(1B3)
;;;	ERABRT(PMAPX1)		; Must be able to write destination
;  I4 CHANGE
	JRST PMPER1
;
	PUSH P,A		; Save destination ptn.pn
	UMOVE A,1		; Get source designator
	CAMN A,[-1]		; Delete wanted?
	 JRST [	PUSH P,[0]	; 0 access
		PUSH P,[0]	; And 0 source
		JRST PMAP2]	; Then skip the following
	PUSHJ P,CPMAP		; Convert source and get it's access
	PUSH P,C		; Save access
	PUSH P,A		; And ptn.pn
	XCTUU [SKIPGE 2]	; Is "to" a file?
	 JRST PMAP2		; No, ok to do
	PUSHJ P,MRPACS		; Yes, get access
	TLNN A,(1B10)		; Better be private
	 JUMPN A,[MOVEI A,PMAPX2; Or empty
		JRST PMAPER]	; Else error
PMAP2:	XCTUU [SKIPGE A,1]	; Is from a file?
	JRST PMAP4		; No.
	HLRZS A			; Yes, get jfn
	LSH A,SJFN		; Convert to index
	MOVSI B,2
	ADDM B,FILLFW(A)	; Increment count of reasons for opening

PMAP4:	XCTUU [SKIPL A,2]	; Is "to" a file?
	JRST [	XCTUU [SKIPL B,1]
		ERABRT(PMAPX2)
		HLRZS A
		LSH A,SJFN	; Convert to index
		MOVSI C,2
		CAME B,[-1]
		ADDM C,FILLFW(A)
		JRST PMAP3]
	MOVE A,-2(P)		; Get ptn.pn of "to"
	PUSHJ P,MRPACS		; Find out what's currently there.
	JUMPE A,PMAP3		; Jump if empty
	TLNE A,(1B10)
	JRST PMAP3		; Or if private
	MOVE A,-2(P)		; Is indirect or share
	PUSHJ P,MRPT		; Get it's id
	 JRST PMAP3		; Not file
	PUSHJ P,OFNJFX		; Convert to jfn
	JRST PMAP3		; No jfn
	MOVSI B,-2
	HLRZS A
	LSH A,SJFN		; Convert to index
	ADDB B,FILLFW(A)
	LSH A,-SJFN		; Convert back to jfn
	TLNN B,777777
	CLOSF			; Close the file if count goes to 0
	JFCL

PMAP3:	POP P,A
	POP P,C
	POP P,B
	TLO C,1407		; Retain write copy bit and disposal
	XCTUU [AND C,3]
	PUSHJ P,SETPT
	 JFCL
	JRST MRETN

PMAPER:	MOVEM A,LSTERR
	MOVEM B,ERRSAV
	JRST ITRAP
;
;   I4 CHANGE
PMPER1:
	ERABRT(PMAPX1)		;CANT WRITE DESTINATION
;

CPMAP:	JUMPL A,FRKMAP
	PUSHJ P,JFNOFN
	 ERABRT(,<MOVEM JFN,ERRSAV>)
	MOVE C,STS
	AND C,[XWD READF!WRTF!XCTF,0]
	LSH C,-1
	TEST(NN,ASPF)
	POPJ P,
	PUSH P,A
	PUSHJ P,MRPACS
	MOVE C,A
	POP P,A
	AND C,[XWD 160000,0]
	POPJ P,

FRKMAP:	PUSHJ P,FKHPTN
	MOVSI C,160000
	POPJ P,

; Rhis routine is called from write copy code in pagem to reduce the
; The map count of a page
; Call:	1	; Ofn.pn
;	PUSHJ P,JFNDCR
; Returns +1 always

JFNDCR:	PUSHJ P,OFNJFX
	POPJ P,
	HLRZS A
	LSH A,SJFN		; Convert to index
	MOVSI B,-2
	ADDB B,FILLFW(A)
	TLNE B,777777
	 POPJ P,
	MOVSI B,FRKF
	ANDCAM B,FILSTS(A)
	POPJ P,

; Read map
; Call:	LH(1)	; Fork handle
;	RH(1)	; Page number
;	RMAP
; Retrn
;	+1
;	LH(1)	; Jfn
;	RH(1)	; Page number
;	2	; Access read, write,execute,nonexistent in bits 2-5

.RMAP::	JSYS MENTR
	PUSHJ P,FRKMAP		; Convert frk.pn to ptn.pn
	PUSHJ P,MRPT		; Call map routine
	 JRST RMAPFK
	PUSH P,B
	PUSHJ P,OFNJFN
RMAP0:	 SETO A,		; Unidentifiable
RMAP1:	POP P,B
	UMOVEM A,1
	UMOVEM B,2
	JRST MRETN

RMAPFK:	PUSH P,B
	JUMPE A,RMAP0
	PUSHJ P,PTNFKH
	JRST RMAP1

; Read accessiblity of page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	RPACS

.RPACS::JSYS MENTR
	TRNE 1,777000
	SKIPGE 1
	JRST RPACS1
	HLRZS A
	LSH A,SJFN		; Convert to index
	MOVE A,FILSTS(A)
	TLNN A,LONGF
	JRST [	XCTUU [SETZM 2]	; File not long
		JRST MRETN]
	UMOVE 1,1
RPACS1:	PUSHJ P,CPMAP
	PUSHJ P,MRPACS
	UMOVEM 1,2
	JRST MRETN

; Set accessibility of a page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	SPACS

.SPACS::JSYS MENTR
	PUSHJ P,CPMAP		; Convert to ptn.pn
	UMOVE B,1
	JUMPL B,SPACFK
	TEST(NN,WRTF)		; Must be able to write
SPACER:	JRST [	MOVEI A,SPACX1
		MOVEM A,LSTERR
		JRST ITRAP]
	MOVSI C,160000
	JRST SPAC1

SPACFK:	PUSH P,A		; Save page handle
	PUSHJ P,MRPACS		; Get access of page
	TLNN A,(1B5)
	JRST SPACER		; Non-existent page
	TLNE A,(1B10)
	JRST SPACPR		; Private page
	PUSH P,A		; Save access
	MOVE A,-1(P)		; Get back the page handle
	PUSHJ P,MRPT		; Get map contents
	 JRST SPACP1		; Indirect or shared to fork
	PUSHJ P,OFNJFN		; Convert to jfn.pn
	JRST SPACCF		; Closed file
	PUSHJ P,CPMAP		; Get allowable access
	SUB P,[XWD 1,1]
	JRST SPAC2

SPACCF:	POP P,C
	AND C,[XWD 160000,0]
	JRST SPAC2

SPACP1:	SUB P,[XWD 1,1]
SPACPR:	MOVSI C,160000
SPAC2:	TLO C,1400
	POP P,A
SPAC1:	UMOVE B,2
	AND B,C
	PUSHJ P,MSPACS
	JRST MRETN

; Find first free file page
; Call:	1	; Jfn
;	FFFFP
; Return
;	+1
;	1	; Jfn.pn of first free page

.FFFFP::JSYS MENTR
	HRLZS A
FFFFPL:	RPACS
	JUMPE B,FFFFP1
	AOJA A,FFFFPL

FFFFP1:	UMOVEM A,1
	JRST MRETN

; Find first used file page
; Call:	LH(1)	; Jfn
;	RH(1)	; Page number to start with
;	FFUFP
; Returns
;	+1	; Error
;	+2	; Success jfn.pn of first used page in 1

.FFUFP::JSYS MENTR
FFUF0:	HLRZ JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)		; Tty and byte no good
	TEST(NE,ASTF)
	 ERR(DESX7)
	TEST(NN,OPNF)
	ERUNLK(FFUFX1)		; Not open
	MOVEI A,@NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(FFUFX2)		; Not disk
	TEST(NE,LONGF)
	JRST FFUFPL
	UMOVE A,1
	TRNE A,777000
	ERUNLK(FFUFX3)		; Page beyond 777 of short can't exist
	HLL A,FILOFN(JFN)
	PUSHJ P,FFUFF
	ERUNLK(FFUFX3)		; No pages in use

FFUFPX:	XCTUU [HRRM A,1]
	PUSHJ P,UNLCKF
	UMOVE 1,1		; GET THE ARG BACK
	RPACS			; CHECK ACTUAL ACCESS
	TLNE 2,(1B5)		; EXISTS?
	 JRST SKMRTN		; YES, SUCCEED
	XCTUU [AOS 1,1]		; NO, TO NEXT PAGE
	TRNE 1,777777		; OFF THE END OF THE WORLD
	 JRST FFUF0		; NO, FIND NEXT ONE
	ERR(FFUFX3)
	JRST SKMRTN

FFUFPL:	UMOVE A,1
	HRRZS A
FFUFP1:	MOVE B,A
	LSH B,-9		; Get ptt number
	ADD B,FILLFW(JFN)
	SKIPE (B)		; Check for pt existence
	JRST FFUFP2		; Exists, scan it
FFUFP3:	ADDI A,1000
	ANDCMI A,777
	TLNN A,777777
	JRST FFUFP1
	ERUNLK(FFUFX3)

FFUFP2:	PUSH P,A
	PUSHJ P,JFNOF1		; Get ofn.pn for this page
	BUG(HLT,<FFUFP: IMPOSSIBLE FAILURE OF JFNOF1.>)
	PUSHJ P,FFUFF		; Scan the pt for stuff
	 JRST [	POP P,A	; None found
		JRST FFUFP3]
	POP P,B
	ANDI B,777000
	ADD A,B
	JRST FFUFPX		; Success

FFUFF:	PUSH P,A
	PUSHJ P,ASGPAG		; Get a page to map the pt
	 JRST [	POP P,A
		POPJ P,]
	MOVE B,A
	HRLI B,100000
	HLRZ A,(P)
	PUSHJ P,SETMPG		; Map the pt
	HRRZ A,(P)		; Get starting page number
	ADDI A,(B)		; Location of disc address
FFUFF0:	SKIPE (A)		; Empty?
	JRST FFUFF1		; No, found it
	CAIGE A,777(B)		; Whole pt scanned?
	AOJA A,FFUFF0		; No, try next one.
FFUFF2:	MOVEI A,0
	PUSHJ P,SETMPG		; Unmap the pt
	HRRZ A,B
	PUSHJ P,RELPAG		; Release the page
	POP P,A
	POPJ P,

FFUFF1:	ANDI A,777		; Get pn part
	MOVEM A,(P)
	AOS -1(P)		; Skip return
	JRST FFUFF2

; Check for tty designator

CHKTTM:	MOVE JFN,1
	PUSHJ P,CHKTTC
	 JRST [	PUSHJ P,UNLCKF
		ERABRT(DESX1)]
	PUSHJ P,UNLCKF
	POPJ P,

CHKTTY:	UMOVE JFN,1
CHKTTC:	PUSHJ P,CHKJFN
	 ERABRT()
	 JRST .+2
	 ERABRT(DESX6)
	TEST(NE,ASTF)
	 ERABRT(DESX7)
	HRRZ A,DEV
	CAIE A,TTYDTB
	 JRST CPOPJ		; Not tty, no skip
	HLRZ 2,DEV
	JRST SKPRET

; Jsys's see jsys manual for description of calling sequences

; Clear input buffer

.CFIBF::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTCIBF
UNL:	PUSHJ P,UNLCKF
	JRST MRETN

; Clear file output buffer

.CFOBF::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTCOBF
	JRST UNL

; Skip if input buffer empty

.SIBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST SIBE1
	PUSHJ P,TTSIBE
	JRST UNL1		; Return no. of bytes in buffer
SKPUNL:	AOS (P)
	JRST UNL

SIBE1:	TEST(NE,OPNF)
	TEST(NN,READF)
	 JRST SKPUNL
	SKIPLE A,FILCNT(JFN)
	 JRST UNL1
IFDEF NETN,<HRRZ A,DEV
	CAIE A,NETDTB
	 JRST SKPUNL
	PUSHJ P,NTSIBE
	 JRST UNL1>
	JRST SKPUNL

; Dismiss until input buffer is empty

.DIBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST MRETN
	PUSHJ P,TTDIBE
	JRST UNL

; Skip if output buffer full

.SOBF::	JSYS MENTR
	PUSHJ P,CHKTTY
	TDZA A,A		; Return +1 with 0
	PUSHJ P,TTSOBF
	 JRST UNL1		; Return +1 with no. bytes in buffer
	AOS (P)
UNL1:	UMOVEM 1,2		; Return count of bytes in buffer
	JRST UNL

; Skip if output buffer is empty

.SOBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST SOBE1
	PUSHJ P,TTSOBE
	JRST UNL1
SOBE1:	AOS (P)
	JRST UNL

; Dismiss until output buffer is empty

.DOBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTDOBE
	JRST UNL

; Get tab settings

.GTABS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST [	XCTUU [SETZB A,2]
		UMOVEM A,3
		UMOVEM A,4
		JRST UNL]
	PUSHJ P,TTGTBS
	UMOVEM 1,2
	UMOVEM 3,3
	UMOVEM 4,4
	JRST UNL

; Set tab stops

.STABS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	UMOVE 4,4
	PUSHJ P,TTSTBS
	JRST UNL

; Read modes

.RFMOD::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST RFMOD1
	PUSHJ P,TTRMOD
	UMOVEM 1,2
	JRST UNL

RFMOD1:	MOVE A,STS
	ANDI A,17
	ADD A,[^D66B10+^D72B17+^D7B3]
	UMOVEM A,2
	JRST UNL

; Set file modes

.SFMOD::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSMOD
	JRST UNL

; Read file position

.RFPOS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST [	XCTUU [SETZM 2]
		JRST UNL]
	PUSHJ P,TTRPOS
	UMOVEM 1,2
	JRST UNL

; Set file position

.SFPOS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSPOS
	JRST UNL

; Read control character output control

.RFCOC::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST RFCOC1
	PUSHJ P,TTRCOC
	UMOVEM 1,2
	UMOVEM 3,3
	JRST UNL

RFCOC1:	MOVE A,[BYTE (2)2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
	UMOVEM A,2
	UMOVEM A,3
	JRST UNL

; Set control character output control

.SFCOC::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	PUSHJ P,TTSCOC
	JRST UNL

; Simulate teletype input

.STI::	JSYS MENTR
	PUSHJ P,CHKTTY
	 ERABRT(TTYX1)
	UMOVE 1,2
	PUSHJ P,TTSTI
	JRST UNL

; Check device designator
; Call:	A	; Device designator
;	PUSHJ P,CHKDEV
; Return
;	+1	; Error, number in a
;	+2	; Ok
;	B	; Index into device tables
;	C	; Device characteristics word
;	A	; Unit number
;	LH(DEV)	; Unit
;	RH(DEV)	; Dispatch address

CHKDEV::TLNN A,777777		; Left half zero means tty designator
	JRST TTYDEV
	TLZ A,600000		; These bits always on
	MOVNI B,NDEV		; Movsi b,-ndev the hard way...
	HRLZS B
	MOVNI B,NDEV		; Movsi b,-ndev the hard way...
	HRLZS B
CHKDVL:	HLLZ C,DEVCHR(B)	; Construct device designator for this dev
	TLZ C,777000
	HRR C,DEVUNT(B)
	CAME C,A		; Is it the same as user's
	AOBJN B,CHKDVL		; No, continue scan
	JUMPGE B,[MOVEI A,DEVX1
		POPJ P,]	; Illegal designator
	HLRZ A,DEVUNT(B)	; Get device assignment
	CAME A,JOBNO
	CAIN A,777777
	JRST CHKDV1		; Assigned this job or unassigned
	MOVEI A,DEVX2
	POPJ P,			; Device not available

CHKDV1:	HRRZ A,C		; Leave unit in a
	MOVEM A,UNIT
	MOVE DEV,DEVDSP(B)
	HRL DEV,A		; Dispatch in dev
	MOVE C,DEVCHR(B)	; And characteristics in c
	JRST SKPRET

TTYDEV:	CAIN A,777777
	JRST CTTYDV
	TRZ A,400000		; Convert tty designator to
	HRLI A,600000+12	; To ordinary device designator
	JRST CHKDEV		; And try again

CTTYDV:	MOVE B,JOBNO
	HRLZI A,JOBPT(B)
	HRRI A,DISGET
	SKIPGE B,JOBPT(B)
	JSYS EDISMS
	HLRZ A,B
	JRST TTYDEV

; SET UP UNIT
; CALL:	A	; BIT 17 IF NOT DEFAULT
;	B	; DEVICE DESIGNATOR
;	PUSHJ P,SETUNT
; RETURNS
;	+1	; FAIL
;	+2	; SUCCESS, UNIT LOADED

SETUNT:	EXCH A,B
	MOVE UNIT,JOBUNT
	TLNN B,(1B17)
	 JRST SKPRET
	PUSHJ P,CHKDEV
	 POPJ P,
	JRST SKPRET

; Assign device
; Call:	1	; Device designator
;	ASND
; Return
;	+1	; Error, not assignable or bad designator etc.
;	+2	; Ok, the device specified is now assigned to this job

.ASND::	JSYS MENTR
	LOCK DEVLCK
	PUSHJ P,CHKDEV
	 ERR(,<UNLOCK DEVLCK>)
	TLNN C,(1B3)		; Is this an assignable device?
	ERR(ASNDX1,<UNLOCK DEVLCK>)
	LDB D,[POINT 9,C,17]
	CAIN D,12
	JRST [	HLRZ D,TTFORK(A)
		CAIE D,777777
		CAMN D,JOBNO
		CAMN A,CTRLTT
		ERR(DEVX2,<UNLOCK DEVLCK>)
		MOVE D,JOBNO
		HRLM D,TTFORK(A)
		JRST .+1]
	MOVSI A,(1B6)
	IORM A,DEVCHR(B)	; Mark this device as assigned by asnd
	MOVE A,JOBNO
	HRLM A,DEVUNT(B)	; Assign to this job
	UNLOCK DEVLCK
	JRST SKMRTN

; Release device
; Call:	1	; Device designator or -1 to release all devices
;	RELD
; Returns
;	+1	; Error, bad designator or not assigned to this job
;	+2	; Ok.

.RELD::	JSYS MENTR
	LOCK DEVLCK
	CAMN 1,[-1]
	JRST RELDAL
	PUSHJ P,CHKDEV
	 ERR(,<UNLOCK DEVLCK>)
	PUSHJ P,RELDD
	UNLOCK DEVLCK
	JRST SKMRTN

RELDAL:
;
;  I4 CHANGE
;	REPTY		;RELEASE ALL PSEUDO TTYS
	JSYS 361
	JFCL
;
	MOVNI B,NDEV		; Movsi b,-ndev the hard way...
	HRLZS B
RELDA1:	HLRZ A,DEVUNT(B)
	CAME A,JOBNO
	JRST RELDA2
	PUSHJ P,RELDD
RELDA2:	AOBJN B,RELDA1
	UNLOCK DEVLCK
	JRST SKMRTN

RELDD:	HRROS DEVUNT(B)
	MOVSI D,(1B6)
	ANDCA D,DEVCHR(B)
	EXCH D,DEVCHR(B)
	TLNN D,(1B6)
	POPJ P,
	LDB D,[POINT 9,D,17]
	HRRZ A,DEVUNT(B)
	CAIN D,12
	CAMN A,CTRLTT
	POPJ P,
	PUSH P,B
	MOVE B,A
IFDEF TYMSW,<			;!! MAH @ SUMEX 7/75 !!
	CAIL B,TYMTTL
	CAIL B,TYMTTL+NTYMTT
	JRST .+2
	PUSHJ P,TYHNGU		;HANG UP LINE BEFORE RELEASING TTFORK
>
	HRROS TTFORK(B)
IFDEF NETN,<
IFNDEF I4SW,<
	CAIL B,NTTYS
>
IFDEF I4SW,<
	CAIL B,NVTLO
>
	PUSHJ P,NVTDET
>
	POP P,B
	POPJ P,

; Get device characteristics
; Call:	1	; Device designator
;	DVCHR
; Return
;	+1	; Ok
;	2	; Device characteristics word
;	LH(3)	; Job to which device is assigned
;	RH(3)	; Unit number

.DVCHR::JSYS MENTR
	HLRZ B,1
	TRZ B,777
	CAIL 1,400000		; Is this a tty designator?
	CAIL 1,400000+NLINES
	CAIN B,600000		; Or a device designator
	JRST DVCHR1		; Yes, do directly
	UMOVE JFN,1		; No. translate first
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 JRST [	UMOVEM JFN,1
		JRST DVCHR1]
	HLRZ A,FILDDN(JFN)	; Get pointer to device name block
	HRLI A,(<POINT 7,0,35>)
	STDEV			; Convert string to device designator
	ERABRT(<(2)>,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	UMOVEM 2,1
DVCHR1:	UMOVE A,1
	PUSHJ P,CHKDEV
	 JRST [	CAIE A,DEVX2	; Was error due to unavailablity
		JRST ERABRD	; No, abort
		MOVE C,DEVCHR(B)
		JRST .+2]
	TLO C,(1B5)
	UMOVEM C,2
	MOVE A,DEVUNT(B)
	UMOVEM A,3
	JRST MRETN

; String to device
; Call:	1	; Device designator
;	STDEV
; Return
;	+1	; Error
;	+2	; Ok
;	2	; Device designator

.STDEV::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CPYFUS
	 ERR(GJFX22)
	PUSH P,A
	PUSHJ P,DEVLUK		; Look up the device name
	 JRST [	CAIE A,GJFX16
		JRST .+1
		MOVEI A,STDVX1
		UMOVEM A,2
		JRST STDEV1]	; No such device
	AOS -1(P)
	HRRZ A,DEVUNT(B)
	HLL A,DEVCHR(B)
	TLZ A,777000
	TLO A,600000
	UMOVEM A,2
STDEV1:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	JRST MRETN

; Device to string
; Call:	1	; Destination designator
;	2	; Device designator
;	DEVST
; Return
;	+1	; Ok

.DEVST::JSYS MENTR
	UMOVE A,2
	PUSHJ P,CHKDEV
	 JRST [	CAIE A,DEVX2
		ERR()
		JRST .+1]
	MOVE C,DEVNAM(B)
	MOVE D,[POINT 6,C]
DEVST0:	ILDB B,D
	JUMPE B,DEVST1
	ADDI B,40
	PUSHJ P,BOUTN
	TLNE D,(77B5)		;HAVE WE PROCESSED ALL OF THE CHARACTERS
	JRST DEVST0

DEVST1:	UMOVE A,1		; Preserve user 1
	PUSHJ P,BOUTN		; Write the null
	UMOVEM A,1		; Restore user 1
	AOS (P)
	JRST MRETN

; Mount device
; Call:	1	; Device designator
;	MOUNT
; Return
;	+1	; Error
;	+2	; Ok

.MOUNT::JSYS MENTR
	UMOVE A,1
	TLZN A,(1B3)		; Directory to be read?
	TDZA B,B		; Yes
	SETO B,			; No
	PUSH P,B
	PUSHJ P,CHKDEV
	 ERR()
	UMOVE 1,1
	TLZ 1,(1B3)
	TLNE C,(1B8)		; Already mounted?
	 JRST [	DSMNT		; Attempt to dismount first
		 ERR()		; Error if can't
		JRST .+1]
	TLNN C,(1B7)		; Mountable?
	ERR(MNTX3)		; No
	EXCH B,(P)		; Save b, get directory read flag
	NOINT
	PUSHJ P,@MNTD(DEV)	; Call device mount routine
	 ERR(MNTX2)		; Not mountable
	POP P,B
	MOVSI C,(1B8)
	IORB C,DEVCHR(B)	; Mark device as mounted
	JRST SKMRTN

; Dismount device
; Call:	1	; Device designator
;	DSMNT
; Return
;	+1	; Error
;	+2	; Ok

.DSMNT::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	 ERR()			; Illegal designator or not available
	TLNN C,(1B8)		; Mounted?
	ERR(DEVX3)		; No, can't dismount
	PUSH P,B
	NOINT
	PUSHJ P,@DSMD(DEV)	; Call device dismount
	 ERR(DSMX1)		; Files open, can't dismount
	MOVSI C,(1B8)
	POP P,B
	ANDCAM C,DEVCHR(B)	; Mark as not mounted
	AOS (P)
	JRST MRETN

; Initialize directory
; Call:	1	; Device designator
;	INIDR
; Return
;	+1	; Error
;	+2	; Ok

.INIDR::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	 ERR()
	TLNN C,(1B8)
	ERR(DEVX3)		; Not mounted
	PUSHJ P,@INDD(DEV)
	AOS (P)
	JRST MRETN

; Read directory

.RDDIR::JSYS MENTR
	PUSHJ P,CHKDEV
	 JRST MRETN
	MOVEI B,(DEV)
IFDEF DTAN,<CAIE B,DTADTB>
	ERR(RDDIX1)
IFDEF DTAN,<
	PUSH P,A
	PUSHJ P,DRWAIT
	POP P,A
	MOVS B,DTASTS(A)
	TRNE B,DIRIC
	TLNN B,777777
	ERR(RDDIX1)
	UMOVE A,2
	HRR B,A
	XCTMU [BLT B,177(A)]
	JRST SKMRTN>

; File directory free space
; Call:	1	; Device designator (must be dsk for now)
;	2	; User number
;	FDFRE
; Returns
;	+1	; Error
;	+2	; Success, in 2 the space left in the specified fd
.FDFRE::JSYS MENTR
	PUSHJ P,CHKDEV
	 ERR()			; Some kind of error
	MOVEM A,UNIT
	TLNN C,(1B4)
	ERR(FDFRX1)		; Don't know about non-mdd stuff
	UMOVE A,2		; Get directory number
	PUSHJ P,GETDDB
	 ERR(FDFRX2)		; No such user
	UNLOCK DIRLCK
	UMOVE A,2
	MOVEI B,-1		; Need real dsk index here
	PUSHJ P,MAPDIR
	MOVE A,DIRFRE+2
	UMOVEM A,2
	JRST SKMRTN

; Special file operation
; Call:	1	; Jfn
;	2	; Operation desired
;	MTOPR

.MTOPR::JSYS MENTR
	UMOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	TEST(NN,OPNF)
	ERABRT(CLSX1,<PUSHJ P,UNLCKF>)
	TEST(Z,ERRF,EOFF)
	UMOVE B,2
	PUSHJ P,@MTPD(DEV)
	PUSHJ P,UNLCKF
	JRST MRETN

; Error number to string
; Call:	1	; Output designator
;	2	; FORK,,ERROR NUMBER
;	3	; -N CHARS,,BITS
;	ERSTR

.ERSTR::JSYS MENTR
	HLRZ 1,2
	PUSHJ P,SETLFK		; Map psb of the fork
	UMOVE B,3
	HRLZI C,ERRSAV(1)
	HRRI C,4
	TRNN B,1B19
	BLT C,10
	XCTUU [HRRZ C,2]
	CAIN C,777777
	MOVE C,LSTERR(1)
	ANDI C,37777
	CAIL C,10000
	JRST MRETN		; Illegal error number
; We now have error number in c, parameters in 4-10, bits and count in b
	PUSH P,B
	HRROI 2,[ASCIZ /DSK:<SYSTEM>ERROR.MNEMONICS/]
	MOVSI 1,100001
	GTJFN			; Get jfn for error mnemonics
	JRST NOFIL
	MOVE 2,[XWD 440000,200000]
	PUSH P,1
	OPENF
	JRST [	POP P,1
		RLJFN
		JFCL
		JRST NOFIL]
	POP P,1
	ANDI C,7777
	RIN			; Read byte number of message
	JUMPE 2,NOFIL2
	PUSH P,2
	MOVEI 2,7
	SFBSZ
	POP P,2
	SFPTR			; Start reading here
	JRST NOFIL2
	POP P,C
	HLRES C
	MOVMS C			;DUE TO CODE AND MANUAL DISAGREEING
	SKIPE C
	SOS C

CPYER1:	BIN
	CAIN 2,"@"
	JRST ERSTDN
	CAIN 2,"%"
	JRST EXPND
	PUSHJ P,ERST9
	 JRST [	AOS (P)
		JRST NOFIL2]
	JRST CPYER1

ERST9:	SKIPE C
	SOJLE C,CPOPJ
	PUSHJ P,SAVAC
	UMOVE JFN,1
	PUSHJ P,ERBOUT
	SOS -NSAC(P)
	TLNE JFN,-1		;ONLY IF A BYTE PTR
	UMOVEM JFN,1
	PUSHJ P,RESAC
	JRST SKPRET

ERBOUT:	PUSHJ P,CHKJFN
	POPJ P,
	JFCL
	 JFCL
	TEST(NE,ENDF)
	JRST UNLCKF
	TEST(NE,OPNF)
	TEST(NN,WRTF)
	JRST UNLCKF
	AOS (P)
	JRST BYTOUA

NOFIL:	POP P,B
	MOVE D,[POINT 7,[ASCIZ /CANNOT FIND ERROR MESSAGE FILE/]]
NOFILL:	ILDB B,D
	JUMPE B,MRETN
	PUSHJ P,ERST9
	 JRST MRETN
	JRST NOFILL

EXPND:	MOVEI D,0
	BIN
	CAIN B,"%"
	JRST CPYER1
EXPND1:	CAIG 2,"9"
	CAIGE 2,"0"
	JRST EXPNDD
	IMULI D,^D10
	ADDI D,-60(B)
	BIN
	JRST EXPND1

EXPNDD:	CAIN B,"E"
	JRST EXPEXP
	CAIL D,5
	JRST EXPND
	CAIN B,"A"
	JRST EXPASC
	CAIN B,"O"
	JRST EXPOCT
	CAIN B,"D"
	JRST EXPDEC
	CAIN B,"H"
	JRST EXPHLF
	CAIN B,"F"
	JRST EXPFLT
	CAIN B,"L"
	JRST EXPLOC
	CAIN B,"N"
	JRST EXPJFN
	CAIE B,"@"
	JRST EXPND
	JRST EXPND

EXPEXP:	JRST EXPND

EXPASC:	MOVE B,ERRSAV(D)
	PUSHJ P,ERST9
	 JRST ERSTD0
	JRST EXPND

EXPOCT:	MOVE B,ERRSAV(D)
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

EXPDEC:	MOVE B,ERRSAV(D)
	MOVEI D,12
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

ERNOUT:	PUSH P,A
	MOVE A,B
	PUSHJ P,ERNOU1
	SOS -1(P)
	POP P,A
	JRST SKPRET

ERNOU1:	IDIV A,D
	HRLM A+1,(P)
	JUMPE A,.+3
	PUSHJ P,ERNOU1
	POPJ P,
	HLRZ B,(P)
	ADDI B,"0"
	JRST ERST9

EXPHLF:	MOVE D,ERRSAV(D)
	PUSH P,D
	HLRZ B,D
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD1
	POP P,D
	MOVEI B,","
	PUSHJ P,ERST9
	 JRST ERSTD0
	PUSHJ P,ERST9
	JRST ERSTD0
	HRRZ B,D
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

EXPFLT:
EXPLOC:
EXPJFN:	JRST EXPND

ERSTD1:	POP P,D
	JRST ERSTD0

ERSTDN:	AOS (P)
	AOS (P)
ERSTD0:NOFIL2:	CLOSF
	JFCL
	JRST MRETN

NOFIL1:	RLJFN
	 JFCL
	JRST MRETN

; Get last error
; Call:	1	; Fork designator
;	GETER

.GETER::JSYS MENTR
	PUSHJ P,SETLFK
	MOVE B,LSTERR(1)
	XCTUU [HRL B,1]
	UMOVEM B,2
	MOVEI B,4
	HRLI B,ERRSAV(1)
	XCTMU [BLT B,10]
	JRST MRETN


; DELETE ALL BUT N VERSIONS OF FILE

; ACCEPTS: 1) JFN
;	   2) NUMBER OF VERSIONS TO KEEP

; RETURNS: +1) ERROR
;	   +2) SUCCESS, WITH NEGATIVE NUMBER OF VERSIONS DELETED IN 2

.DELNF:
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN	;CHECK IT
	JRST GBGJFN
	JFCL
	ERUNLK DESX4	;TTY OR BYTE ILLEGAL
	HRRZ A,NLUKD(DEV)	;CHECK IF NAME LOOKUP DISPATCH
	CAIE 1,MDDNAM		;IS MDDNAM
	ERUNLK GFDBX1
	PUSHJ P,GETFDB
	ERUNLK DESX3
	UMOVE B,2		;NO. VERSIONS TO KEEP
DELNF2:
; ADDED WRITE ACCESS CHECK TO DELNF TO CORRECT HORRIBLE BUG.
	PUSH P,A		;SAVE FDB ADDRESS  !! MAH @ SUMEX 11/74 !!
	PUSH P,B		;SAVE # VERSIONS TO RETAIN
	HRLI A,WRTF		;CHECK FOR WRITE ACCESS
	PUSHJ P,ACCCHK
	ERUNLK (DELFX1,<SUB P,[XWD 2,2]
			UNLOCK DIRLCK>)
	POP P,B		;RESTORE # VERSIONS TO RETAIN
	POP P,A			;RESTORE FDB ADDRESS

	HLLZ C,FDBCTL(A)		;GET FLAG WORD
	TLNE C,FDBTMP		;QUIT IF TEMP FLAG
	JRST DELNF1
	TLNE C,FDBNXF+FDBDEL
	JRST DELNF1
	SOJGE B,DELNF1
	MOVSI C,FDBDEL
	IORM C,FDBCTL(A)
DELNF1:
	HRRZ A,FDBVER(A)
	JUMPE A,DELNFE
	ADDI A,DIRORG
	JRST DELNF2
DELNFE:
	UMOVEM B,2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Delete deleted files

.DELDF::JSYS MENTR
;	UMOVE A,1		; DIRNUM & BIT
;	UMOVE B,2		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 JRST MRETN
	UMOVE A,1
	MOVE B,CAPENB
	CAME A,JOBDNO
	TRNE B,WHEEL!OPR
	JRST .+2
	JRST MRETN
	PUSHJ P,GETDDB
	 JRST MRETN
	UNLOCK DIRLCK
	OKINT
	UMOVE JFN,1
;
;  I4 CHANGE
	SETZ 16,	;NORMAL EXPUNGE ENTRY INTO DELDEL
;
	PUSHJ P,DELDEL
	JRST MRETN

DELALL:	TDZA F,F
DELDEL:	MOVEI F,1
	MOVE A,JFN
	PUSHJ P,SETDIR		; Map the appropriate directory
	POPJ P,
	MOVE D,SYMBOT
DELP1:	CAMGE D,SYMTOP
	JRST DELP2
	PUSHJ P,GCDIR		; Collect remaining good stuff
	PUSHJ P,USTDIR
	POPJ P,

DELP2:	HRRZ A,DIRORG(D)
	TRNE A,700000
	JRST DELPC
	MOVEI B,400100
	PUSHJ P,DELCKB		; Check range and validity of block
	 JRST DELPD		; Skip if bad
	PUSH P,A		; Save
	HLRZ A,DIRORG(D)	; Get pointer to name string
	MOVEI B,400001
	PUSHJ P,DELCKB		; Check validity
	 JRST [	MOVEM D,0(P)
		JRST DELP5]	; Bad -- ignore
	EXCH D,0(P)		; Get back a to d, save d
	PUSHJ P,DELP3
	JUMPE D,DELP4		; No fdb's left?
	POP P,A
	HRRM D,DIRORG(A)
	AOS D,A
	JRST DELP1

DELPC:	ANDI A,700000
	CAIE A,100000
	 AOJA D,DELP1
	HLRZ A,DIRORG(D)
	MOVEI B,777777
	PUSHJ P,DELCKB		; Check block for validity
	 JRST DELPD		; Bad, ignore
	SKIPE DIRORG+1(A)	; Account string still used?
	 AOJA D,DELP1		; Yes
DELPD:	PUSH P,D
DELP4:	MOVE D,(P)
DELP5:	CAMG D,SYMBOT
	JRST DELP6
	MOVE A,DIRORG-1(D)
	MOVEM A,DIRORG(D)
	SOJA D,DELP5

DELP6:	AOS SYMBOT
	POP P,D
	AOJA D,DELP1

DELCKB:	PUSH P,A
	CAIL A,DIFREE-DIRORG
	CAML A,FRETOP
	 JRST DELCKF		; Bad
	HLRZ A,DIRORG(A)
	CAME A,B
	 JRST DELCKF
	POP P,A
	AOS (P)
	POPJ P,

DELCKF:	BUG(CHK,<DELDEL: BAD BLOCK TYPE IN DIRECTORY>)
	POP P,A
	POPJ P,

DELP3:	PUSH P,[0]		; Where first extension is
	HRRZ A,P		; Initial value of ind pointer
	PUSH P,A		; Onto stack too

DELP7:	HRRZ A,DIRORG+FDBEXT(D)	; Get pointer to other extensions
	MOVEI B,400100
	SKIPE A
	PUSHJ P,DELCKB		; Check validity
	 SETZ A,		; Truncate chain if bad
	PUSH P,A		; Save for later
	PUSH P,[0]		; Remember where first version is
	HRRZ A,P		; Initial value of ind pointer
	PUSH P,A		; Onto stack

DELPA:	HRRZ A,FDBVER+DIRORG(D)	; Get pointer to other versions
	MOVEI B,400100
	SKIPE A
	PUSHJ P,DELCKB		; Check validity
	 SETZ A,		; Truncate chain if bad
	PUSH P,A		; Save for later
	HLRZ A,DIRORG+FDBEXT(D)
	MOVSI B,FDBNEX
	TDNE B,FDBCTL+DIRORG(D)
	JUMPE A,DELPG
	MOVEI B,400002
	PUSHJ P,DELCKB		; Check if this has a valid extension
	 JRST [	MOVSI A,FDBDEL
		IORM A,FDBCTL+DIRORG(D)
		MOVSI A,FDBPRM
		ANDCAM A,FDBCTL+DIRORG(D)
		JRST .+1]	; Deletion assured
DELPG:	PUSHJ P,DELTST		; Do we want to delete this?
	 JRST DELP8		; No.
	PUSHJ P,DELFIL
	 JRST DELP8
	JRST DELP9

DELP8:	HRRM D,@-1(P)		; Put this pointer where it belongs
	MOVEI A,FDBVER+DIRORG(D)
	MOVEM A,-1(P)		; Save where to put next pointer
DELP9:	POP P,D			; Get next fdb
	JUMPN D,DELPA		; Loop for all versions
	HRRM D,@0(P)		; End of chain
	SUB P,[XWD 1,1]		; Flush ind pointer
	POP P,D			; Get first version
	JUMPE D,DELPB		; None
	HRRM D,@-1(P)		; Store where it needs to be
	MOVEI A,DIRORG+FDBEXT(D)
	MOVEM A,-1(P)		; Remember where to put next one
DELPB:	POP P,D			; Get loc of next ext
	JUMPN D,DELP7		; Loop thru all extensions
	HRRM D,@0(P)		; End of chain
	SUB P,[XWD 1,1]		; Flush ind pointer
	POP P,D			; Get first extension
	POPJ P,

DELTST:	JUMPE F,[MOVSI A,FDBPRM
		ANDCAM A,FDBCTL+DIRORG(D)	; Insure its deletion
		JRST SKPRET]
	MOVE A,FDBCTL+DIRORG(D)
;
;  I4 CHANGE
	JUMPE 16,DELTS2		;JUMP IF FULL EXPUNGE
	TLZN A,FDBSDL		;SEL. EXP--THIS FILE?
	POPJ P,		;NO--RETURN
DELTS2:
;
	TLNE A,FDBDEL!FDBNXF!FDBNEX
	JRST SKPRET
	TLNN A,FDBTMP
	POPJ P,
	HLRZ A,FDBVER+DIRORG(D)
	SUBI A,^D100000
	SKIPL A			; If not normal temporary
	CAMN A,JOBNO		; Or temp for this job
	JRST SKPRET		; Then skip
	CAIL A,NJOBS
	JRST SKPRET
	PUSH P,B
	HLRZ B,JOBDIR(A)
	CAMN B,DIRNUM
	JRST DELTS1
	HRRZ B,JOBDIR(A)
	CAME B,DIRNUM
	AOS -1(P)
DELTS1:	POP P,B
	POPJ P,

DELFIL::PUSH P,F
	PUSH P,E
	PUSH P,D
	SKIPN A,FDBADR+DIRORG(D)
	JRST DELFI3
	TLO A,(1B1)
	PUSHJ P,ASOFN
	 JRST [	CAIN A,OPNX16
		JRST DELFI3	; Bad index block, forget it
		JRST DELFI1]	; File is open, cannot expunge
	MOVE D,(P)
	PUSH P,A
	MOVEI A,DIRORG(D)	; SET A=FDB ADDR FOR BYTE PTR
	LDB E,PFILPC		; GET PAGES THIS FILE
	POP P,A
	HRRE F,DIRDSK		; GET CURRENT COUNT
	SUB F,E			; COMPUTE NEW CURRENT COUNT
	HRRM F,DIRDSK		; AND SAVE IT
	MOVE E,FDBCTL+DIRORG(D)
	TLNE E,FDBLNG
	JRST DELFI4		; Long file
	PUSHJ P,DELPT
DELFI3:	MOVE D,(P)
	SETZM FDBADR+DIRORG(D)
	SETZM FDBSIZ+DIRORG(D)
	HRLOI B,7777
	ANDCAM B,FDBBYV+DIRORG(D)
	SKIPLE B,DIRORG+FDBACT(D)
	SOS DIRORG+1(B)
	MOVSI B,FDBLNG!FDBSHT
	ANDCAB B,FDBCTL+DIRORG(D)
	TLNN B,FDBPRM
	AOS -3(P)
DELFI1:	POP P,D
	POP P,E
	POP P,F
	POPJ P,

DELPT:	HRLZ 2,1
	MOVEI 1,0
	PUSHJ P,SETPT
	AOS 2
	TRNN 2,777000
	JRST .-3
	HLRZ 1,2
	PUSHJ P,DELOFN
	POPJ P,

DELFI4:	PUSH P,A
	PUSHJ P,ASGPAG
	 JRST [	POP P,A
		PUSHJ P,RELOFN
		JRST DELFI1]
	PUSH P,A
	MOVE B,A
	HRLI B,140000
	MOVE A,-1(P)
	PUSHJ P,SETMPG
	HRLI B,-1000
DELFI6:	SKIPN A,(B)
	JRST DELFI5
	PUSH P,B
	MOVE B,-2(P)		; Get ofn of pt table
	HLLZ B,SPTH(B)		; Get class field
	TLZ B,760017
	TLZ A,40
	IOR A,B
	PUSHJ P,ASOFN
	JRST DELFI8
	PUSHJ P,DELPT
DELFI7:	POP P,B
	SETZM (B)
DELFI5:	AOBJN B,DELFI6
	MOVE B,(P)
	MOVEI A,0
	PUSHJ P,SETMPG
	POP P,A
	PUSHJ P,RELPAG
	POP P,A
	PUSHJ P,DELOFN
	JRST DELFI3
DELFI8:
	CAIN A,OPNX16
	JRST DELFI7
	BUG(HLT,<DELFIL: ASOFN GAVE FAIL RETURN (BUSY) FOR A LONG FILE PAGE TABLE.>)

; Set time and date
; Call:	1	; Date and time in standard format
;	STAD
; Return
;	+1	; Can't set because not wheel or opr
;	+2	; Ok

.STAD::	JSYS MENTR
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	SKIPGE TADSEC
	JRST STAD1
	MOVEI A,STADX1
	JRST ERRD

STAD1:	SETZ C,
	MOVE A,TODCLK
	IDIVI A,^D1000		; Convert to seconds
	XCTUU [HRRZ B,1]	; Get time
	SUB B,A			; Compute offset
	JUMPGE B,.+3
	ADDI B,^D24*^D3600	; If less than 0, augment
	AOJA C,.-2
	XCTUU [HLRZ A,1]
	SUB A,C
	MOVEM A,TADDAY
	MOVEM B,TADSEC
STAD2:	MOVE A,JOBNO		; This job
	HRRZ B,JOBDIR(A)	; User number
	MOVEM B,LOGBUF+1
	UMOVE B,1		; Tad as given
	MOVEM B,LOGBUF+2
	IORI A,(741B8)		; Tad reset code for fact file
	MOVSM A,LOGBUF
	MOVE A,CTRLTT
	DPB A,[POINT 12,LOGBUF,29] ; Tty
	MOVE 1,[XWD -3,LOGBUF]	; Make fact file entry for time set
	EFACT
	 JFCL
	JRST SKMRTN

; Read time and date
; Call:	RTAD
; Return
;	+1
;	1	; Current date and time or -1 if not set

.GTAD::	JSYS MENTR
	SKIPGE A+1,TADSEC
	JRST GTAD1		; Not set
	MOVE A,TODCLK
	IDIVI A,^D1000
	ADD A,TADSEC
	IDIVI A,^D24*^D3600
	ADD A,TADDAY
	HRL A+1,A
GTAD1:	UMOVEM A+1,1
	JRST MRETN

LS(TADDAY)
LS(TADSEC)

; Set fact switch
; Call:	1	; New setting
;	SMON
; Traps if process hasn't log privilege

.SMON::JSYS MENTR
	MOVE C,CAPENB
	TLNN C,LOG
	ERABRT(EFCTX1)
	ANDCAM 1,FACTSW
	AND 2,1
	IORM 2,FACTSW
	JRST MRETN

; Read fact switch
; Call:	TMON
; Return
;	+1	; Always
;	1	; The current fact switch setting

.TMON::	TDNE 1,FACTSW
	AOS FPC
	XCT MJRSTF

; Enter fact file
; Call:	LH(1)	; Minus entry size
;	RH(1)	; Location of entry
;	EFACT
; Return
;	+1	; Error
;	+2	; Ok

.EFACT::JSYS MENTR
	MOVE B,CAPENB
	TLNN B,LOG
	ERR(EFCTX1)
	MOVE B,FACTSW
	TLNN B,(FACTON)
	JRST SKMRTN		; Fact file not on
	HLRO B,A		; Get size
	CAMG B,[-^D64]
	ERR(EFCTX2)		; Too big
	NOINT
	PUSH P,CAPENB		; Save current caps
	MOVEI A,WHEEL+OPR	; Set bits to ensure access to
	IORM A,CAPENB		; Accounts directory and fact file
	MOVEI C,^D30
EFACT2:	HRROI B,[ASCIZ /DSK:<ACCOUNTS>FACT/]
	MOVSI A,1
	GTJFN
	 JRST EFACT3
	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	JSYS 21			; Open for append
	JRST EFACT4
EFACT6:	POP P,1
	POP P,CAPENB		; Restore caps
	UMOVE C,1
	UMOVE B,(C)
	HLRE D,C
	MOVNS D
	DPB D,[POINT 6,B,35]
	JRST .+2
EFACT1:	UMOVE B,(C)
	BOUT
	AOBJN C,EFACT1
	CLOSF
	BUG(CHK,<EFACT: CLOSF FAILED TO CLOSE FACT FILE.>)
	JRST SKMRTN

EFACT4:	CAIE A,OPNX9
	SETZ C,
	POP P,1
	RLJFN
	 JFCL
	SOJLE C,EFACT3
	MOVEI A,^D4000
	DISMS
	JRST EFACT2

EFACT3:	HRROI 2,[ASCIZ /DSK:<ACCOUNTS>FACT/]
	MOVSI 1,400001
	GTJFN
	 JRST EFACT9
	MOVEI C,^D30
EFACT8:	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	JSYS 21
	JRST EFACT5
	JRST EFACT6

EFACT5:	CAIE A,OPNX9
	JRST EFACT7
	SOJLE C,EFACT7
	MOVEI A,^D4000
	DISMS
	POP P,1
	JRST EFACT8

EFACT7:	POP P,1
	RLJFN
	JFCL
EFACT9:	POP P,CAPENB		; Restore caps
	ERR(EFCTX3)

; Set account for file
; Call:	1	; Jfn
;	2	; String pointer OR 500000000000+account number
;	SACTF
; Return
;	+1	; Error
;	+2	; Ok

.SACTF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(SACTX1)
	PUSHJ P,GETFDB
	 ERUNLK(SACTX4)
	HRLI A,40000
	PUSHJ P,DIRCHK
	 ERUNLK(SACTX4,<UNLOCK DIRLCK>)
	UNLOCK DIRLCK
	PUSH P,FILACT(JFN)	; Save current contents of this cell
	UMOVE A,2
	TLNN A,777777
	HRLI A,440700

SACTF1:	CAMG A,[577777777777]
	CAMGE A,[500000000000]
	JRST SACTF2		; Pointer
	MOVEM A,FILACT(JFN)
	PUSHJ P,INSACT
	JRST SACTF3

SACTF2:	MOVE B,MODES
	TLNN B,(1B1)
	ERUNLK(SACTX3)		; Alphanumeric accounts not allowed
	PUSHJ P,CPYFUS		; Copy from the user
	 ERUNLK(SACTX2)		; Cannot copy
	HRRZM A,FILACT(JFN)
; !! MAH @ SUMEX 2/75  !! PATCH FROM BBN VIA SRI
	HLRE B,A		;GET -(WORD COUNT -1)  FROM CPYFUS
	SUBI B,2
	PUSH P,(A)		;SAVE BLOCK HEADER FOR RELFRE
	MOVMM B,(A)		;PLANT COUNT AT HEAD OF STRING STORAGE FOR
	PUSHJ P,INSACT		;INSACT
	HRRZ B,FILACT(JFN)
	POP P,(B)		;RESTORE BLOCK HEADER FOR RELFRE
	MOVEI A,JSBFRE
; END PATCH
	PUSHJ P,RELFRE
SACTF3:	POP P,FILACT(JFN)
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get account of file
; Call:	1	; Jfn
;	2	; Core location to put string if any
;	GACTF
; Return
;	+1	; Error
;	+2
;	2	; 0,,NUMBER OF STRING POINTER
		; OR 5B2,,NUMERIC ACCT
.GACTF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERR(GACTX1)
	PUSHJ P,GETFDB
	 ERUNLK(GACTX2)
	SKIPLE B,FDBACT(A)
	JRST GACTF1
	UMOVEM B,2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	AOS (P)
	JRST SKMRTN

GACTF1:	UMOVE E,2
	HRLI E,440700
	UMOVEM E,2
	HRLI E,DIRORG+2(B)
	HRRZ B,DIRORG(B)
	ADDI B,-3(E)
	XCTMU [BLT E,(B)]
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Login

.LOGIN::JSYS MENTR
	MOVE A,JOBNO
	MOVEI B,777777
	TDNE B,JOBDIR(A)	; Is this job currently logged in?
	ERR(LGINX5)
	UMOVE A,1
	PUSHJ P,GETDDB		; Get directory descriptor block
	 ERR(LGINX2)
	MOVE B,DDBGRP(A)
	MOVEM B,GROUPS
	MOVE B,DDBMOD(A)	; Get mode bits
	MOVEM B,MODES
	TLNE B,(1B0)
	ERR(LGINX2,<UNLOCK DIRLCK>)
	PUSHJ P,CHKPSW
	 ERR(LGINX4,<UNLOCK DIRLCK>)
	MOVE B,DDBPRV(A)
	HRRM B,CAPMSK
	HLLOS CAPENB
	PUSH P,A
	UMOVE A,3
	PUSHJ P,SETACT		; Set account number/string
	 ERR(LGINX1,<UNLOCK DIRLCK>)	; Bad account number
	GTAD
	POP P,B
	SKIPL A
	EXCH A,DDBDAT(B)
	XCTUU [EXCH A,1]
	MOVEM A,JOBDNO
	HRLS A
	MOVE B,JOBNO
	MOVEM A,JOBDIR(B)
	UNLOCK DIRLCK
	PUSHJ P,LOGONM		; Type logon message
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	SETZM CAPENB
;;;	JRST SKMRTN
;  I4 CHANGE
	JRST I4LOGI	;FINISH LOGIN FOR RESERVATION SYSTEM

; Change account

.CACCT::JSYS MENTR
	MOVE A,JOBNO
	MOVE B,JOBDIR(A)
	TRNN B,777777
	ERR(CACTX2)
	UMOVE A,1
	PUSHJ P,SETACT
	 ERR(CACTX1)
	PUSHJ P,LOGCJM
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	JRST SKMRTN

SETACT:	CAML A,[500000000000]
	CAMLE A,[577777777777]
	JRST .+2
	JRST SETACN		; Numeric
	MOVE B,MODES
	TLNN B,(1B1)
	POPJ P,			; Numeric account required
	MOVE B,A
	MOVEI A,ACCTSR-1
	PUSHJ P,CPYFU1		; Copy account string
	BUG(HLT,<CACCT: IMPOSSIBLE FAILURE OF CPYFU1.>)
	HLRE B,A
	MOVNS B
	ADDI B,2
	MOVEM B,ACCTSL
	HRLI A,(<POINT 7,0,35>)
SETACN:	MOVEM A,ACCTPT
	JRST SKPRET

;PASSWORD CHECK FOR INTERNAL USE
; 1/ directory number
; 2/ password string ptr

PASSWC:	MOVEI A,0(A)
	PUSH P,2
	PUSHJ P,GETDDB
	 JRST [	POP P,2
		POPJ P,]
	POP P,2
	PUSHJ P,CHKPSX
	CAIA
	AOS 0(P)
	UNLOCK DIRLCK
	POPJ P,

CHKPSW:	UMOVE B,2
CHKPSX:	PUSH P,A
	PUSH P,B 
	PUSH P,[^D39]		;MAX CHARS IN PASWORD
	HLRZ B,DDBNAM(A)	; Get pointer to password
	JUMPE B,CHKPS2		;NO PASSWORD
	MOVE C,DIRORG+1(B)
	TLNN C,774000
	JRST CHKPS2		; Null password never matches
	HRLI B,(<POINT 7,0,35>)
	ADDI B,DIRORG
	EXCH B,-1(P)		;GET BACK POINTER TO USER SUPPLIED PSWD
	TLC B,-1
	TLCN B,-1		;DSP?
	HRLI B,(<POINT 7,0>)	;YES, MAKE INTO REAL ONE
CHKPS1:	TLZ B,37		;BE SURE NO INDIRECTION/INDEXING
	XCTBU [ILDB A,B]
	ILDB C,-1(P)
	CAME A,C
	SETZM -1(P)		;INDICATE FAILURE
	SOSLE 0(P)		;QUIT IF 39 CHARS PROCESSED
	JUMPN A,CHKPS1
	SKIPE -1(P)		;SKIP IF NO MATCH
	AOS -3(P)		;CAUSE SKIP RETURN
CHKPS2:	SUB P,BHC+2		;ADJUST STACK POINTER
	POP P,A
	POPJ P,

; Connect to directory
; Call:	1	; Directory number (b0 for check of pswd only)
;	2	; String pointer to password
;	CNDIR
; Return
;	+1	; Error
;	+2	; Ok

.CNDIR::JSYS MENTR
;	UMOVE A,1		; DIRNUM + BITS
	UMOVE B,3		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()
	MOVE A,JOBNO
	HRRZ B,JOBDIR(A)	; Get directory of login
	UMOVE A,1
	JUMPL A,CNCHK		; Check only wanted
	CAIN B,0		; Must be logged in to connect
	ERR(CNDIX5)
	CAMN A,B
	JRST CNDIR3		; Can always connect to login directory
	PUSHJ P,GETDDB
	 ERR(CNDIX3)		; No such directory
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CNDIR2		; Bypass checks for wheels and oprs
	HLRZ B,DDBNAM(A)	; Does this directory have a password
	JUMPE B,CNDIR1		; No
	PUSHJ P,CHKPSW		; Yes, check it
	 JRST CNDIR1		; Wrong password, still ok if access
	JRST CNDIR2		; Correct password, success

CNDIR1:	UNLOCK DIRLCK
	OKINT
	UMOVE A,1
	HRRZS A
	MOVEI B,-1		; Need to pickk up real dsk unit
	PUSHJ P,SETDIR		; Map the directory
	 JRST CNDIRQ
	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Do we have the proper access to this
	JRST CNDIRE
CNDIR2:	UNLOCK DIRLCK
CNDIR3:	UMOVE A,1
	MOVE B,JOBNO
	HRLM A,JOBDIR(B)
	HRRZM A,JOBDNO
	JRST SKMRTN

CNCHK:	HRRZS A
	PUSHJ P,GETDDB
	 ERR(CNDIX3)
	PUSHJ P,CHKPSW
	JRST CNDIRE
	UNLOCK DIRLCK
	JRST SKMRTN

CNDIRQ:	BUG(CHK,<CNDIR - SETDIR FAILED>)
	MOVEI 1,CNDIX3
	JRST ERRD

CNDIRE:	MOVEI 1,^D3000
	DISMS			; Wait 3 secs to foil password thieves
	UNLOCK DIRLCK
	MOVEI 1,CNDIX1
	JRST ERRD

	END






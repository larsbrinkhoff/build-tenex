;<SCHULZ>PAGEM.MAC;7    23-NOV-76 16:52:03    EDIT BY SWEER
;INSERTED KAFLG CONDITIONAL IN SWPI5
;<MON>PAGEM.MAC;18    18-JUN-75 12:11:22    EDIT BY CROSSLAND
;ADDED DRUM MIGRATION CODE FROM IMSSS
;<TENEX-130>PAGEM.MAC;143    28-DEC-72 13:59:00	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;142    27-DEC-72 14:16:13	EDIT BY TOMLINSON
; ADDED PLCKT SCHEDULER TEST
;<TENEX-130>PAGEM.MAC;141    12-DEC-72 14:55:35	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;140    11-DEC-72 17:32:10	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;139    11-DEC-72 16:36:14	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;138     7-DEC-72 17:08:45	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;137     7-DEC-72 15:27:41	EDIT BY TOMLINSON
;<TENEX-130>PAGEM.MAC;136     7-DEC-72 11:52:46	EDIT BY TOMLINSON
; REWRITE OF PAGE FLUSHING AND RESTORING LOGIC
;<TENEX-130>PAGEM.MAC;135    21-NOV-72 11:55:21	EDIT BY TOMLINSON
; MODIFIED RPACS TO NO SAY "EXISTS" FOR NON-REFERENCED DISK PAGES
;<TENEX-130>PAGEM.MAC;134    18-NOV-72 16:19:27	EDIT BY WALLACE
;<TENEX-130>PAGEM.MAC;133     6-NOV-72 11:43:22	EDIT BY TOMLINSON
; ILRD+2/ TLNE 2...
;<TENEXDLM>PAGEM.MAC;132    29-SEP-72 12:28:53	EDIT BY MURPHY
;<TENEXDLM>PAGEM.MAC;131    22-SEP-72 15:12:49	EDIT BY MURPHY
;<TENEXDLM>PAGEM.MAC;130    14-SEP-72 17:19:58	EDIT BY MURPHY
;<TENEXDLM>PAGEM.MAC;129    23-AUG-72 20:45:21	EDIT BY MURPHY
;<TENEXDLM>PAGEM.MAC;128    21-AUG-72 20:49:24	EDIT BY MURPHY
;<TENEXDLM>PAGEM.MAC;127    21-AUG-72 14:48:46	EDIT BY MURPHY

;14 JUN 72, 1830:

;TENEX PAGE MANAGEMENT MODULE - D. MURPHY

	INTERN MAKPGU,MAKPGA,PLCKT,RELMPG,RELCPT,SETCPT,RELCXB,SETXB1
	INTERN ASOFN,RELOFN,SETMPG,READB,MRPACS,MSPACS,MRMAP,NOFN
	INTERN MLKPG,MULKPG,FPTA,MRPT,SETPT,DISKP,DRUMP,RWX,SWPCOR
	INTERN DDMP,DELOFN,MONCOR,COPYB,SPT,SPTH,CORWB,SPC1,SWPZPG
	INTERN MULKCR,MULKMP,CST0,CST1,CST2,CST3,MLKMA
	INTERN .MRPAC,PRELDF,SWRSAF,POSPGF,.RWSET
	INTERN SWPINT,GETCPP,GETCPA
	INTERN SWPDON,DWRBIT,SWPERR
	INTERN GETONT
	INTERN INDBIT,SHRBIT,SWPIN,SPTM,SWPIN0,PLKV

; LINKAGE TO DSK AND DRM

	EXTERN GDSTX,DRMASN,DSKASN,DASDRM,DEDSK,DRMFRE,DSKFRE

	EXTERN CVDSK,UDSKIO
	EXTERN DRMIO,DSKIO,DRMASD,CHKDRR,DRNSET,DKSWCT,DRBTWD
	EXTERN STBTWD,MAXDRM

; LINKAGE TO DISC AND FILE SYSTEM

	EXTERN JFNOFN,OFNJFN,JFNDCR,OPNX16,OPNX9,OPNX10

;PARAMETERS

DRMOV:	1		;MOVE PAGES FROM DRUM TO SW. DISK
DISKP:	1		;DISK ON SYSTEM
DRUMP:	IFDEF DRMCHN,<1>	;1 = DRUM AVAIL,
	IFNDEF DRMCHN,<0>	;0 = USE DISK, -1 = USE NOTHING
PRELDF:	0		;NO PRELOADING IF 0
SWRSAF:	0		;REASSIGN SWAP ADDRESSES IF .G. 0
POSPGF:	0		;POST PURGE IF .G. 0

NOFN==400		;NUMBER OF OFN SLOTS
SPTM==17777		;MASK FOR SPT INDICES
THAWB==1B20		;THAW BIT
FILWB==1B19		;FILE WRITE BIT
SPTLKB==1B22		;LH OF SPTH(OFN), XB IN USE BY DDMP
NEWFB==1B33		;NEW FILE (OR FILE PAGE) BIT
DRPERM==1B23		;PERMANENT ON DRUM PAGE
BWRBIT==1B31		;WRITTEN (CHANGED) FROM HOME COPY
PLKV==1B27		;FOR LOCK VALUE IN CST1
BP1==^D10		;BIT POSITION OF PROCESS 0 IN CST0
DSKSWB==1B20		;SWAP TO DISK REQUESTED
CORWB==<Z (CORMB)>	;BECAUSE MACRO/LOADER PROHIBIT 36-BIT GLOBALS
DWRBIT=<Z (1B0)>	;WRITE BIT IN CST3
SWPERR=<Z (1B1)>	;SWAP ERROR BIT IN CST3

;BITS IN MAP WORD

SHRBIT==1B19		;SHARE POINTER
INDBIT==1B18		;INDIRECT POINTER

PGR==24


LS NHIPG,1		;HIGEST PAGE USED BY SWAPPER
LS SPTC,1		;COUNT OF SPT (EXCLUDING OFN) ENTRIES IN SPT
LS NOF,1		;COUNT OF ENTRIES IN OFN PART OF SPT
LS FRESPT,1		;FREE SPT LIST
LS MAXSPL,1		;MAX NUMBER OF PROBES TO SPTH
LS MMSPTN,1		;OFN OF MONITOR MAP
GS LOKPGS,1		;COUNT OF LOCKED PAGES, VIA MLKPG
GS LOKSUM,1		;NET NUMBER OF LOCKS, MLKPG-MULKPG
GS MAXLOK,1		;MAX NUMBER OF PAGES TO BE LOCKED
GS NXTDMP,1		;FLAG TO CAUSE DDMP ACTION
GS DDTIME,1		;TIME NEXT DDMP DUE
LS DMOVT,1		;NEXT TIME TO MOVE SWAPPING PAGES
LS DLSTV,1		;LAST COUNT OF SWAPS ON DISK
LS DNOGO,1		;FLAG NO MORE PAGES ON DRUM
LS IOIP,1		;SWAP WRITES IN PROGRESS
GS DRMIN0,1		;MIN DRUM SPACE
GS PRELRQ,1		;PRELOADING SWAPIN IF NON-0

;THE FOLLOWING ARE USED FOR PAGE MIGRATION STATISTICS
LS TMPFR1
LS TMPFR2
GS PAGMOV		;NUMBER OF PAGES MIGRATED
LS NUMMOV		;NUMBER OF TIMES MIGRATION ACTUALLY TOOK PLACE
; FOLLOWING CELLS USED IN REMOVING PAGES FROM SWAPPABLE STORE
GS PGELCT,1	; COUNT OF LOCKED PAGES FOUND TRYING TO REMOVE PAGES

SPC0:	EXP <SSPT-NOFN>*11/12
SPC1:	EXP SSPT-NOFN-40

;INITIALIZATION, SPT, CST, ETC.

PGRINI:	SETZM SPTC
	SETZM NOF
	SETZM MAXSPL
	MOVEI 1,SPT+NOFN
	MOVEI 2,SSPT-NOFN
	CALL ILIST		;MAKE LIST OF FREE SPT ENTRIES
	MOVEM 1,FRESPT
	SETZM SPTH
	MOVE 1,[XWD SPTH,SPTH+1]
	BLT 1,SPTH+NOFN-1	;ZERO OUT SPTH
	CALL ASSPT		;ASSIGN SPT SLOT FOR MMAP
	MOVE 2,[XWD 1B31,MMAP/1000]
	MOVEM 2,SPT(1)
	MOVEM 1,MMSPTN
	MOVSI 2,0(1)
	SETZ 1,			;START WITH CORE PAGE 0
	MOVSI 3,400000
	MOVSI 4,RWXB
PGRI1:	MOVEM 1,MMAP(2)		;MAKE MAPPED MON EQUIVALENT TO UNMAPPED
	HLLM 4,MMAP(2)		;PRIVATE POINTER, ALL ACCESS
	MOVEM 3,CST0(1)		;LEGAL AGE WORD
	MOVEM 1,CST1(1)		;BACKUP ADDRESS IS SELF
	MOVEM 2,CST2(1)		;OFN.PN
	ADDI 1,1
	CAMGE 1,SWPCOR		;FILL TO END OF RES MON
	AOJA 2,PGRI1
	MOVSI 4,WRITEB
	ANDCAM 4,MMAP+1		;PROTECT JSYS TABLE
	MOVEI 3,P2+777
	LSH 3,-^D9		;FIRST PAGE OF RES MON
PGRI5:	CAIGE 3,100		;DON'T PROTECT PAGES ALWAYS MAPPED
	ANDCAM 4,MMAP(3)	;WRITE PROTECT RES MON
	ADDI 3,2
	CAMGE 3,MONCOR		;MON WILL BE WRITE PROTECTED IF
	SOJA 3,PGRI5		;MAPRESMON FLOP MANUALLY TURNED ON

	ADDI 2,MMAP+2
	HRLI 2,-1(2)
	SETZM -1(2)
	BLT 2,MMAP+PJMPG-1	;ZERO REMAINDER OF MON MAP
	SETZM TOTRC
	SETZM NRPLQ
	CONO APR,APNXM		;MAKE SURE NXM OFF
	MOVE 1,SWPCOR
	MOVE 2,[XWD RPLQ,RPLQ]
	MOVEM 2,RPLQ		;REPLACEMENT QUEUE EMPTY
	PGROFF
PGRI2:	SETZM CST1(1)		;CLEAR CST ENTRIES
	SETZM CST2(1)
	SETZM CST3(1)
	MOVE 2,SWPCOR
	ADDI 2,NBP
	CAILE 2,0(1)
	JRST PGRI3 		;RESERVED FOR UPTS
	MOVEI 2,0(1)		;CHECK FOR MEMORY EXISTANT
	LSH 2,^D9
	MOVE 0(2)		;MAY GET NXM
	CONSZ APR,APNXM		;NXM?
	JRST PGRI3		;YES
	SETZM CST0(1)		;NO, PAGE EXISTS
	MOVEM 1,NHIPG		;REMEMBER HIGHEST PAGE FOUND
	JSP 4,ONRQ		;PUT PAGE ON REPLACABLE QUEUE
	PIOFF
	AOS TOTRC		;COUNT PAGES OF CORE FOUND
;;;PGRI4:	CAIGE 1,MAXCOR-1		;CHECK 256K
PGRI4:	CAIGE 1,LSTRPG	;STOP AT LAST REAL PAGE
	AOJA 1,PGRI2
	DATAO PAG,KIPGWA	;TURN PAGER ON MANUALLY

;SETUP VARIOUS CONSTANTS FOR CORE MGT

	MOVE 1,TOTRC
	SUB 1,NRPMX
	MOVEM 1,MAXNR		;MAX VALUE OF SUMNR
	SUBI 1,10
	CAILE 1,240
	MOVEI 1,240		;20 MORE IF BIG SYSTEM	
	MOVEM 1,NPMAX
	CAIL 1,140		;REASONABLY LARGE SYSTEM?
	SUBI 1,40		;YES, SET SNPMAX 16K SMALLER
	MOVEM 1,SNPMAX		;SMALL NPMAX
	SUB 1,NPMAX		;DIFFERENCE OF NPMAX AND SNPMAX
	MOVMM 1,SJSIZ		;FOR 'SMALL' JOB SIZE
	MOVE 1,NRPMX		;INIT NRPMIN
	MOVEM 1,NRPMIN
	MOVE 1,TOTRC		;SETUP CUTOFF LEVEL FOR GCCOR
	ASH 1,-2		;1/4 TOTAL PAGES IS AN ARBITRARY
	MOVEM 1,NRPLEV		;NUMBER
	MOVE 1,TOTRC
	ASH 1,-2		;1/4 REAL CORE
	CAIGE 1,10		;OR 10, WHICHEVER IS LARGER
	MOVEI 1,10
	MOVEM 1,MAXLOK		;IS MAX NUMBER PAGES TO LOCK
	MOVE 1,TOTRC
	LSH 1,-5
	CAIL 1,NBP
	MOVEI 1,NBP-1
	CAIGE 1,7
	MOVEI 1,7		;AT LEAST 7 PROCESSES
	MOVEM 1,MAXBP
	MOVEI 1,NDST		;NUMBER OF PAGES ON DRUM
	IDIVI 1,10
	MOVEM 1,DRMIN0		;TAKE SPECIAL ACTION IF DRUM .GE. 7/8
	SETZM PGR71
	MOVSI 1,400000
	MOVEM 1,PGR72
PGRRST:
	PGRON			;TURN ON AND LOAD PAGER
	PGRCLD
	RET

PGRI3:	CONO APR,APNXM		;TURN OFF NXM FLAG
	MOVSI 2,010000
	MOVEM 2,CST0(1)
	JRST PGRI4

NRPMX:	MINNR*3		;RPLQ MIN, SHOULD BE .G. MINNR

;BOUNDARIES SET BY POSTLD

MONCOR:	0			;NUMBER PAGES OF RES MON
SWPCOR:	0			;FIRST PAGE OF REAL CORE FOR SWAPPING

;RESTART SWAPPER - REINITIATE IO OPERATIONS IN PROGRESS AT TIME OF CRASH

SWPRST:	SETZM IOIP
	MOVE 6,SWPCOR		;SCAN CST AND CHECK STATE OF PAGES
SWPRS1:	LDB 1,[POINT 6,CST0(6),5] ;GET STATE CODE
	CAIN 1,06		;READ IN PROGRESS?
	JRST SWPRSR		;YES, GO RESTART IT
	CAIN 1,04		;WRITE?
	JRST SWPRSW		;YES
SWPRS2:	CAMGE 6,NHIPG		;LOOKED AT ALL PAGES?
	AOJA 6,SWPRS1		;NO
	RET

SWPRSW:	MOVSI 1,DWRBIT		;WRITE OPERATION
	AOSA IOIP		;COUNT WRITES IN PROGRESS
SWPRSR:	SETZ 1,			;READ OPERATION
	HRRI 1,0(6)
	MOVE 2,CST1(6)		;BACKUP ADDRESS
	TLNE 2,10		;DISK?
	JRST SWPRS3		;YES
	TLNN 2,16		;DRUM?
	BUG(HLT,<ILLEGAL ADDRESS IN CST1 ENTRY, CAN'T RESTART>)
	CALL DRMIO
	JRST SWPRS2

SWPRS3:	CALL DSKIO
	JRST SWPRS2

;PERIODIC ROUTINE TO TRICKLE PAGES TO DISK

DDMP:	MOVE 1,TODCLK
	CAMGE 1,DDTIME		;TIME YET?
	JRST DDMP30			;NO
	SKIPE DISKP		;DISK ON SYSTEM, AND
	SKIPE NXTDMP		;DUMP REQUESTED?
	JRST DDMP30			;NO
	ADDI 1,^D90000		;NEXT ONE DUE IN 90 SEC.
	MOVEM 1,DDTIME
	SETZ 0,			;CLEAR FLAGS
	MOVE 1,DRMFRE
	CAMGE 1,DRMIN0		;ENOUGH DRUM SPACE?
	TLO 0,(1B0)		;NO, TAKE SPECIAL ACTION
	AOS NXTDMP		;TO DETECT REQUESTS DURING ROUTINE
	MOVE 11,FORKX		;CONSTRUCT HANDLE FOR DDPG2
	HRLZ 11,FKPGS(11)
	HRRI 11,DDPG2		;WILL BE USED LATER
	MOVSI 10,-NOFN		;PREPARE TO SCAN ALL OFN'S
	AOBJN 10,.+1		;0 NOT USED
DDMP9:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVE 1,SPTH(10)		;GET HASH WORD FOR THIS OFN
	JUMPLE 1,DDMP1S		;NOT IN USE
	MOVE 1,SPT(10)		;IN USE, GET CURRENT ADR
	TLNE 1,10		;XB ON DISK?
	JRST DDMP1E		;FORGET IT
	TLNN 1,-1B31		;NO MORE IN USE
	JRST DDMP1S		;CLEANED UP BY GARBAGE COLLECTOR
	MOVSI 2,SPTLKB
	IORM 2,SPTH(10)		;LOCK OFN AGAINST RELEASE
	ULOCK SYSLCK		;RELEASE LOCK
	MOVEI 1,0(10)		;MAP THE XB
	MOVE 2,[XWD RWX,DDPG1A]
	CALL SETMPG
	SETZ 6,
	SKIP DDPG1A		;MAKE SURE PAGE IN CORE
	DLOCK SYSLCK		;LOCK SYSLCK
	SKIP DDPG1A		;ONE MORE TIME
	CALL DDMPXA		;GET XB DISK ADDRESS
	PUSH P,6		;SAVE WRITE FLAG FOR XB
	CAIGE 7,DST+NDST	;IN DST?
	CAIGE 7,DST
	JRST .+3		;NO
	MOVSI 3,BWRBIT		;YES, CLEAR BACKUP WRITE BIT
	ANDCAM 3,0(7)
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	MOVE 2,[XWD DDPG2A,DDPG2A+1]
	SETZM DDPG2A		;ZERO A PAGE TO GET THE BACKUP XB
	BLT 2,DDPG2A+777
	MOVSI 7,-1000		;SCAN ALL WORDS OF XB
DDMP8:	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP61		;QUICK CHECK FOR NULL
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
DDMP81:
	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP6		;NOT IN USE
	TLNN 1,SHRBIT		;SHARE POINTER?
	JRST DDMP4		;NO, PRIVATE
	LSH 1,-^D9		;GET SPT NUMBER
	ANDI 1,SPTM
	MOVE 1,SPT(1)
	TLZ 1,-1B31		;FLUSH SHARE COUNT
	JRST DDMP4

DDMP6:
	ULOCK SYSLCK
	OKSKED
	JRST DDMP61

DDMP1E:	TLNE 1,-1B31		;SHARE COUNT 0?
	JRST DDMP1S		;NO
	SETOM SPTH(10)		;YES, RELEASE OFN
	SOS NOF
DDMP1S:
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	JRST DDMP1

DDMPXA:	MOVE 1,SPT(10)		;SET ABOUT FINDING DISK ADDRESS
	TLNE 1,17
	JRST DDMPX1		;IN DST
	MOVE 7,CST2(1)
	CAIE 7,0(10)		;ALL CONSISTENT?
	JRST DDBAD1		;NO
	MOVE 7,CST0(1)		;GET CORE WRITE BIT
	TLNE 7,(CORMB)		;WRITTEN IN CORE?
	SETO 6,			;YES
	MOVEI 7,CST1(1)		;IF IN CST, REMEMBER WHERE
DDMPX2:	MOVE 1,0(7)
	TLNE 1,10		;DISK?
	RET			;YES, DONE
DDMPX1:	MOVE 2,1
	CALL GDSTX
	MOVE 7,DST(2)		;GET DRUM WRITE BIT
	TLNE 7,BWRBIT		;WRITTEN ON DRUM?
	SETO 6,			;YES
	MOVEI 7,DST(2)		;REMEMBER WHERE DISK ADDRESS IS
	JRST DDMPX2

DDMP4:	TLNE 1,617700		;ANY STRANGE BITS?
	JRST DDBAD		;YES, SKIP IT
	TLNE 1,10		;DISK?
	JRST DDMP3		;YES, ALL SET
	TLNN 1,16		;DRUM
	TLNN 1,17		;OR CORE?
	JRST DDMP5		;YES, PROCESS IT
	JRST DDMP6		;UNASSIGNED, IGNORE IT

DDMP3:
	ULOCK SYSLCK
	OKSKED
	TLNN 1,10		;JUST MAKE SURE WE HAVE DISK ADR
	JRST DDBAD2
	MOVEM 1,DDPG2A(7)	;STORE DISK ADDRESS IS XB COPY
	LDB 1,[POINT 12,DDPG1A(7),13]	;GET ACCESS BITS FROM ORIG PTR
	DPB 1,[POINT 14,DDPG2A(7),13]	;STORE THEM IN XB COPY
DDMP61:	AOBJN 7,DDMP8		;SCAN OVER WORDS IN XB
DDMPXB:	NOSKED
	POP P,1			;GET XB WRITE FLAG
	JUMPE 1,DDMPX3		;DON'T WRITE XB IF NOT CHANGED
	MOVE 1,11		;GET ID OF COPY PAGE
	CALL MLKPG		;LOCK THE PAGE
	PUSH P,1		;SAVE CORE PAGE NUMBER
	DLOCK SYSLCK		;LOCK SYSLCK
	CALL DDMPXA		;GET XB DISK ADDRESS
	MOVE 2,[1B14+1000]	;DISK IO CONTROL WORD, WRITE+1000 WORDS
	TLZE 1,NEWFB		;CLEAR NEW FILE BIT
	MOVEM 1,0(7)
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	PUSH P,2
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,2
	POP P,3			;CORE PAGE NUMBER
	LSH 3,^D9
	CALL UDSKIO		;OPERATE DISK
	AOS DSKWR		;COUNT OPERATIONS
	MOVE 6,1		;SAVE ERROR BITS
	MOVE 1,11
	CALL MULKPG		;UNLOCK PAGE
	JUMPN 6,.+1		;NON-ZERO MEANS ERRORS
	NOSKED
DDMPX3:
;
;   I4 CHANGE
	OKSKED	;DONT HAVE LONG WAITS DURING NOSKED
	MOVE 1,DDPG1A
	NOSKED
;
	MOVE 1,DDPG1A		;MAKE SURE XB IN CORE BEFORE UNMAPPING
	SETZ 1,
	MOVEI 2,DDPG1A
	CALL SETMPG		;UNMAP XB
	MOVSI 2,SPTLKB
	ANDCAM 2,SPTH(10)	;UNLOCK OFN
	OKSKED
DDMP1:	AOBJN 10,DDMP9		;COUNT OFN'S
DDMP30:	SKIPE DSKFRE		;ANY PAGES TO MOVE INTO
	SKIPN DRMOV		;MOVING PAGES
	JRST DDMP20		;NO
	MOVE 2,DKSWCT
	MOVE 1,TODCLK
	CAMLE 2,DLSTV		;MORE SWAPS TO DISK
	CAMG 1,DMOVT		;TIME YET TO MOVE
	JRST DDMP20		;DONT DO
	MOVEM 2,DLSTV
	ADD 1,[^D600000]	;10 MINUTES
	MOVEM 1,DMOVT
	MOVE 10,DSKFRE		;GET NUMBER OF DISK PAGES AVAILABLE
	MOVEM 10,TMPFR1		;SAVE SO WE DO NOT TRY TO MOVE TOO MANY
	MOVEM 10,TMPFR2		;SO WE CAN CALCULATE HOW MANY WERE USED
	MOVSI 10,-NFKS
	AOBJN 10,.+1		;IGNORE 0
DDMP26:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVE 1,NRPLQ
	CAMG 1,NRPMIN
	JRST	[ ULOCK SYSLCK
		HRROS CGFLG
		OKSKED
		SKIPA
		JRST DDMP26
		JSYS BLOCK0 ]
	SKIPGE FKPT(10)
	JRST DDMP21		;FORK DOESNT EXIST
	HLRZ 1,FKPGS(10)
	JUMPE 1,DDMP21		;NO UPT ASSIGNED
	MOVE 2,[XWD RWX,DDPG1A]
	CALL SETMPG		;MAP UPT
	MOVEI 1,DDPG1A
	CALL MLKMA
	MOVSI 11,-1000		;SCAN UPT
DDMP23:	MOVE 2,DDPG1A(11)
	JUMPE 2,DDMP22		;NO PAGE
	TLNE 2,INDBIT
	JRST DDMP22		;IGNORE IND.
	TLNN 2,SHRBIT
	JRST DDMP24
	LSH 2,-^D9
	ANDI 2,SPTM
	MOVE 2,SPT(2)		;GET PAGE
	TLZ 2,-1B31
DDMP24:	TLNN 2,10
	TLNN 2,16
	JRST DDMP22		;NOT ON DRUM
	HRRZI 2,0(2)
	CAML 2,MAXDRM
	JRST DDMP22		;ON SWAPPING DISK ALREADY
	CALL CHKDRR		;REFERENCED LATELY
	JRST .+2
	JRST DDMP22		;YES
	MOVE 1,NRPLQ
	CAMGE 1,NRPMIN
	JRST [ HRROS CGFLG
		MOVEI 1,JSKP
		JSYS SCHEDP
		JRST DDMP23 ]	;TRY AGAIN
	MOVE 1,DDPG1A(11)
	TLNE 1,SHRBIT
	JRST  [ LSH 1,-^D9
		ANDI 1,SPTM
		JRST .+3 ]
	HLLZ 1,FKPGS(10)
	HRRI 1,0(11)
	SKIPG NRPLQ		;ANY FREE PAGES
	HRROS CGFLG
	SETOM DRNSET		;SET FLAG FOR SWPIN
	CALL SWPIN
	SETZM DRNSET		;RESET FLAG
	SOSG TMPFR1		;DO WE HAVE ANY DISK PAGES LEFT
	SETZB 10,11		;LETS GET OUT, BUT MUST UNMAP THE PAGE
DDMP22:	AOBJN 11,DDMP23		;LOOK AT NEXT PAGE
	MOVE 1,FORKX
	HRLZ 1,FKPGS(1)
	HRRI 1,DDPG1
	CALL MULKPG
	SETZ 1,0
	MOVEI 2,DDPG1A
	CALL SETMPG		;RELEASE UPT
DDMP21:
	ULOCK SYSLCK		;RELEASE SYSLCK
	OKSKED
	AOBJN 10,DDMP26		;LOOP ON UPTS
DDMP27: MOVE 1,TMPFR2		;CALCULATE NUMBER OF PAGES MOVED
	SUB 1,TMPFR1
	JUMPE 1,DDMP28		;NOTHING DONE
	ADDM 1,DLSTV		;UPDATE SWAPP TO DISK COUNT
	ADDM 1,PAGMOV		;UPDATE PAGES MOVED
	AOS NUMMOV		;AND NUMBER OF TIMES MOVED
DDMP28:	MOVE 1,[XWD DRBTWD,DRBTWD]
	ADDI 1,1
	SETZM DRBTWD
	MOVEI 2,NDST/^D36
	BLT 1,DRBTWD(2)		;ZERO OUT USED PAGES TABLE
	SETZM DNOGO		;PAGES MAY BE AVAIL. ON DRUM
DDMP20:	MOVNS NXTDMP		;RESET IF NO INTERVENING REQUESTS
	HRROS CGFLG		;FORCE GC
	RET

DDMP5:	TLNN 1,17		;IN CORE?
	JRST DDMP52		;YES
	MOVE 2,1		;ON DRUM, GET DST WORD
	CALL GDSTX
	MOVE 1,DST(2)
	TLNN 1,BWRBIT		;CHANGED FROM BACKUP?
	JUMPGE 0,DDMP3		;NO, IGNORE IF NOT LOW ON DRUM SPACE
	MOVE 1,DDPG1A(7)	;GET PAGE SWAPPED IN
	TLNE 1,SHRBIT
	JRST DDMP51		;SHARE POINTER, GET SPTN
	MOVSI 1,0(10)		;CONSTRUCT OFN.PN
	HRRI 1,0(7)
DDMP53:	PUSH P,7
	CALL SWPINW		;SWAP IN PAGE AND WAIT
	POP P,7
	JRST DDMP81		;NOW PAGE IS IN CORE

DDMP51:	LSH 1,-^D9		;GET SPTN
	ANDI 1,SPTM
	JRST DDMP53

DDMP52:	TRNE 1,-MAXCOR		;LIKELY PAGE?
	JRST DDBAD		;NO
	MOVSI 6,400000		;FLAG TO NOTE IF WRITING NEEDED
	AND 6,0			;INIT TO DRUM SPACE FLAG
	MOVE 2,CST0(1)
	TLNE 2,(CORMB)		;PAGE WRITTEN WHILE IN CORE?
	SETO 6,			;YES
	MOVE 2,CST1(1)		;GET BACKUP ADR
	TLNE 2,10		;DISK?
	JRST DDMP54		;YES
	CALL GDSTX
	MOVE 2,DST(2)		;GET NEXT BACKUP ADR
	TLNE 2,BWRBIT		;CHANGED ON DRUM?
	SETO 6,			;YES
DDMP54:	JUMPE 6,DDMP55		;DISK ADR NOW IN 2, WRITING NEEDED?
	PUSH P,7
	CALL AGESET		;YES
	POP P,7
	MOVSI 3,DSKSWB
	IORB 3,CST3(1)		;REQUEST DISK SWAP AT NEXT SWAP TIME
	CALL PRSTOP		;STOP THE OTHER PROCESSOR
	CALL SWPOT0		;SWAP IT OUT NOW
	CALL PRGO		;START OTHER PROCESSOR
	SETOM 0(P)		;FORCE WRITING OF XB TOO
DDMP55:	MOVE 1,2
	JRST DDMP3

;LOSSAGE PRINTOUT

DDBAD1:	POP P,1
DDBAD:	POP P,1			;FLUSH JUNK
	ULOCK SYSLCK		;RELEASE LOCK
DDBAD2:
	SETZM NSKED
	HRROI 1,[ASCIZ /
*****BAD INDEX BLOCK, OFN /]
	PSOUT
	MOVEI 1,101
	MOVEI 2,0(10)
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 1,EOL
	PBOUT
	MOVSI 2,SPTLKB
	ANDCAM 2,SPTH(10)	;UNLOCK OFN
	JRST DDMP1

;ASSIGN OFN
; AC1/ 14-35 INDEX BLOCK FILE ADDRESS (DISK, DRUM OR CORE)
;       5-13 CLASS FIELD (IF DISK)
;          1 WRITE BIT
;          2 THAWED BIT
;	   3 NEW FILE BIT
;RETURN SKIP WITH OFN IN AC1 IF PROPER OPENING
;RETURN NO-SKIP IF ILLEGAL SHARED OPENING (ILLEGAL CONFIGURATION
;      OF THAWED AND WRITE BITS)

ASOFN:	TLNN 1,10		;DISK?
	RET			;NO, RETURN BAD
	NOSKED
	PUSH P,1
	TLZ 1,-1B31		;FLUSH CLASS AND BITS
	MOVE 6,1
	MOVE 4,MAXSPL		;MAX NUMBER OF PROBES INTO SPTH
	SETO 5,
	SETZ 1,			;START SEARCH WITH 0
	DLOCK SYSLCK		;LOCK SYSLCK

ASOF1:	ADDI 1,1		;LOOK LINEARLY
	MOVEI 3,0(1)

REPEAT 0,<			;THIS IS HASH LOOKUP NOT CURRENTLY USED
	IMUL 1,[5654123]	;HASH INDEX BLOCK ADDRESS
	HLRZS 3,1		;USE LEFT HALF
	ANDI 3,NOFN-1		;MAX NUMBER OPEN FILES
	JUMPE 3,ASOF1		;DON'T USE SLOT 0
>
	MOVE 2,SPTH(3)		;GET ENTRY
	JUMPLE 2,ASOF2		;0 IS FREE, -1 IS DELETED
	TLZ 2,-1B31		;FLUSH BITS
	CAMN 2,6		;COMPARE ADDRESSES
	JRST ASOF3		;FOUND
ASOF7:	SOJG 4,ASOF1		;COUNT TRYS AND PROBE AGAIN
	JUMPGE 5,ASOF6		;NOT FOUND. DELETED ENTRY ENCOUNTERED?
	CAIL 1,NOFN-1		;NO, OFN TABLE FULL?
	JRST [	ULOCK SYSLCK	;YES,BAD RETURN; RELEASE SYSLCK
		JRST SKORET]
	AOS MAXSPL		;NO, INCREASE MAX LOOK COUNT
	JRST ASOF1		;KEEP LOOKING FOR USABLE SLOT

ASOF2:	JUMPE 2,ASOF4		;FREE => NOT FOUND
	JUMPGE 5,ASOF7		;FIRST DELETED ENCOUNTERED?
	MOVE 5,3		;YES, SAVE IT
	JRST ASOF7

;ASOFN (CONT.)

ASOF4:	JUMPL 5,.+2		;DELETED ENCOUNTERED?
ASOF6:	MOVE 3,5		;YES, USE IT
	POP P,1			;RECOVER CLASS AND BITS
	TLZE 1,1B21		;NEWLY ASSIGNED XB?
	TLO 6,NEWFB		;YES, INDICATE IN DISK ADDRESS
	MOVEM 1,SPTH(3)
	MOVEM 6,SPT(3)		;PUT ADDRESS IN SPT
	AOS NOF			;COUNT OPEN FILES
	MOVSI 1,1B31
	ADDM 1,SPT(3)		;BUMP SHARE COUNT
	PUSH P,3		;SAVE OFN
	CALL SETXB1		;MAP XB
	POP P,3
;
;
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	MOVE 1,CXBPGA
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVE 1,CXBPGA
	MOVE 1,SPT(3)
	TLNE 1,-1B30
	JRST ASCHKA	;SOMEONE ELSE GRABBED IT
;
;;;	MOVE 1,CXBPGA		;GET XB IN CORE
;;;	MOVE 1,SPT(3)		;CORE ADDRESS
	MOVSI 2,SWPERR
	TDNE 2,CST3(1)		;DISK ERROR IN XB?
	JRST ASCHK3		;YES, DON'T OPEN
	MOVSI 1,-1000		;SETUP TO SCAN XB
ASCHK1:	MOVE 2,CXBPGA(1)	;GET WORD FROM XB
	JUMPE 2,ASCHK2		;NOT IN USE
	TLC 2,ACCESB+10		;MUST HAVE ACCESS AND DISK BITS ON,
	TLNE 2,777770-RWX	;RWX AND OTHER ADDRESS BITS DONT CARE,
	JRST ASCHK3		;OTHERS ALL OFF, OTHERWISE DONT OPEN
ASCHK2:	AOBJN 1,ASCHK1
ASCHKA:
	CALL RELCXB		;OK, RELEASE XB
	JRST ASOF9

ASCHK3:	CALL RELCXB		;FILE NO GOOD, RELEASE XB
	MOVE 1,SPT(3)		;CLEAR OFN AND CORE PAGE
	SETOM SPTH(3)
	SOS NOF
	CALL DECOR
	SETZM CST2(1)
	JSP 4,ONRQ
	ULOCK SYSLCK		;RELEASE LOCK
	MOVEI 1,OPNX16		;ERROR NUMBER FOR BAD XB
	JRST SKORET		;RETURN BAD

;SHARED OPEN, CHECK WRITE AND THAWED BITS FOR LEGAL COMBINATION

ASOF3:	MOVSI 2,SPTLKB
	TDNE 2,SPTH(3)		;LOCKED BY DDMP?
	JRST ASOFW1		;YES
	POP P,2			;RECOVER CLASS AND BITS
	MOVSI 1,-1B31
	TDNN 1,SPT(3)		;SHARE COUNT 0?
	JRST ASOF8		;YES (FILE EFFECTIVELY NOT OPEN)
	MOVE 1,SPTH(3)		;GET EXISTING BITS
	XOR 1,2			;XOR PRODUCES 0 IF BITS THE SAME
	TLNE 1,THAWB		;THAWED BITS EQUAL?
	JRST ASOFB		;NO, ILLEGAL OPEN
	MOVE 1,SPTH(3)
	IOR 1,2
	TLNN 1,FILWB		;BOTH WRITE BITS 0?
	JRST ASOF5		;YES, LEGAL OPENING, NO CHANGE TO WB
	TLNN 1,THAWB		;THAWED BITS 1?
	JRST ASOFB		;NO, ILLEGAL TO HAVE SHARED WRITING
	AND 2,[XWD FILWB,0]	;LEGAL OPENING, THAWED BITS BOTH 1
	IORM 2,SPTH(3)		;IOR WRITE BITS
ASOF5:	MOVSI 1,1B31		;INCREMENT SHARE COUNT
	ADDM 1,SPT(3)
ASOF9:
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	MOVEI 1,0(3)		;RETURN OFN (SPT INDEX)
	JRST RSKP

ASOF8:	MOVE 1,SPT(3)
	TLNE 1,17		;NOW IN CORE?
	JRST ASOF81		;NO
	MOVSI 4,DWRBIT		;YES, WAIT FOR ANY WRITE TO COMPLETE
	TDNE 4,CST3(1)
	JRST ASOFW2
ASOF81:	XOR 2,SPTH(3)		;SET THAW AND WRITE BITS TO GIVEN
	AND 2,[XWD FILWB+THAWB,0]
	XORM 2,SPTH(3)
	JRST ASOF5		;RETURN OK

ASOFB:
	ULOCK SYSLCK		;RELEASE LOCK
	MOVEI 1,OPNX9		;ERROR NUMBER FOR FILE BUSY
	JRST SKORET

ASOFW2:	SKIPA 1,2
ASOFW1:	POP P,1
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED			;HAVE TO WAIT FOR SOMETHING
	CAIA			;WAIT A LITTLE WHILE, THEN TRY
	JRST ASOFN		;AGAIN FROM THE TOP
	JSYS BLOCK1		;THIS RETURNS .-1

;RELEASE OPEN FILE NUMBER, OFN IN AC1

RELOFN:	MOVSI 2,SPTLKB
RELOF4:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	TDNE 2,SPTH(1)		;LOCKED BY DDMP?
	JRST [	ULOCK SYSLCK	;YES
		OKSKED
		CAIA		;WAIT A LITTLE, THEN TRY AGAIN
		JRST RELOF4
		JSYS BLOCK1]	;THIS RETURNS CALLER -1
	MOVEI 3,0(1)
	CALL SETXB1		;MAP INDEX BLOCK
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT
	SETO 4,			;RETURN -1 IF NOT COMPLETELY CLOSED
	CAIE 2,1		;IS THIS FINAL CLOSE?
	JRST RELOF1		;NO
;
;   I4 CHANGE
	MOVE 2,SPT(1)
	TLNE 2,17
	JRST RELOF5
	LDB 2,[POINT 6,CST0(2),5]
	CAIN 2,6
	JRST RELOF5
;
	MOVSI 3,-1000		;SCAN XB
	SETZ 4,			;INIT COUNT OF IN-USE PAGES
RELOF3:	MOVE 2,CXBPGA(3)	;GET XB WORD
	JUMPE 2,RELOF2		;EMPTY
	TLNE 2,SHRBIT+INDBIT
	JRST RELBAD
	TLNN 2,10		;ADDRESS OK IF ON DISK OR IN CORE
	TLNN 2,16
;;;	TLNE 2,SHRBIT+INDBIT	;POINTER TYPE OK IF PRIVATE
	JRST .+2
	JRST RELOF7
RELOF6: TLNN 2,10
	TLNN 2,17		;UNREFERENCED PAGE?
	AOJA 4,RELOF2		;NO, COUNT IN-USE PAGE
	SETZM CXBPGA(3)
RELOF2:	AOBJN 3,RELOF3
RELOF1:	MOVSI 2,-1B31		;REDUCE SHARE COUNT OF XB ONCE MORE
	ADDM 2,SPT(1)		;FOR CLOSING
	MOVE 1,SPT(1)
	TLNN 1,-1B31		;STILL IN USE?
	CALL SWPOT0		;NO, SWAP OUT
	ULOCK SYSLCK		;RELEASE LOCK
	MOVE 1,4
	CALL RELCXB		;RELEASE TEMP MAPPING
	OKSKED
	RET

RELBAD:	BUG(CHK,<BAD POINTER TYPE IN INDEX BLOCK>)
	MOVE 2,SPT(1)
	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;INDICATE ERROR IN PAGE SO IT WON'T
	JRST RELOF1		;BE WRITTEN ON DISK
;
;   I4 CHANGE
RELOF5:
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	MOVE 2,CXBPGA
	CALL RELCXB
	JRST RELOFN
;
;
RELOF7:	PUSH P,1
	PUSH P,3
	PUSH P,4
	PUSH P,7
	HRLZ 1,1	;GET AC1 SET UP FOR SWPIN
	HRRI 1,0(3)	;PUT PAGE NO. IN
	MOVE 7,FORKX
	CALL SWPIN	;SWAP IN FROM DRUM
	POP P,7
	POP P,4
	POP P,3
	POP P,1
	MOVE 2,CXBPGA(3);MAKE SURE PAGE NOT ON DRUM
	JUMPE 2,RELOF2
	TLNN 2,10
	TLNN 2,16
	TLNE 2,SHRBIT+INDBIT
	JRST RELBAD	;REALLY BAD
	JRST RELOF6	;CONTINUE

;ASSIGN PSB FOR NEW PROCESS

ASPSB:	NOSKED
	CALL ASSPT
	JRST SKORET

;				;ASSPT ASSUMES SYSLCK LOCKED WHEN CALLED
ASSPT:	SKIPG 1,FRESPT		;ANY FREE CELLS?
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 1,0(1)
	EXCH 1,FRESPT
	SUBI 1,SPT
	AOS SPTC		;ASSIGN SPT SLOT
	MOVSI 2,1B31+1
	MOVEM 2,SPT(1)		;SHARE COUNT OF 1, NO ADDRESS
	SETZM SPTH(1)
	RET

;DEASSIGN SPT AND RELEASE STORAGE

DESPTN:	NOSKED
	CALL DESPT
	JRST SKORET

DESPT:
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVSI 2,-1B31
	ADDB 2,SPT(1)		;REDUCE SHARE COUNT
	TLNE 2,-1B31		;NOW ZERO?
	BUG(HLT,<TRIED TO RELEASE SPT SLOT BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	PUSH P,1
	CALL REMFP1		;RELEASE CORE AND/OR DRUM
	POP P,1
	ADDI 1,SPT
	EXCH 1,FRESPT		;PUT ON FREE LIST
	EXCH 1,@FRESPT
	SOS SPTC
	CALL USYSLK		;RELEASE SYSLCK
	RET


;DELETE XB ASSOCIATED WITH OFN
;LAST STAGE OF DELETE FILE

DELOFN:	CALL WTSPT		;WAIT FOR SPT TO BE UNSHARED
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	JSP 4,WTSPTT		;SHARE COUNT NOW 1?
	JRST DELO1		;NO, GO WAIT SOME MORE
	MOVSI 2,-1B31		;SHARE COUNT SHOULD NOW BE 1
	ADDB 2,SPT(1)		;FOR LAST OPENING
	TLNE 2,-1B31		;NOW 0?
	BUG(HLT,<TRIED TO DELETE INDEX BLOCK BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	SETOM SPTH(1)
	PUSH P,1
	CALL REMFP1		;DELETE ALL STORAGE
	POP P,1
	SOS NOF
	ULOCK SYSLCK		;RELEASE SYSLCK
	OKSKED
	RET

DELO1:
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	JRST DELOFN

;READ MAP GIVEN VIRTUAL ADDRESS

MRMAP:	CALL FPTA		;GET PAGE TABLE ADDRESS

;GENERAL MAP READ
;ENTER HAVING PTN.PN IN 1
; RETURN +1 IF PTN.PN
; RETURN +2 IF OFN.PN

MRPT:	CALL SETCPT
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RDMQ5		;EMPTY
	PUSH P,1		;SAVE ORIG IDENT
	PUSH P,2
	TLNN 2,SHRBIT+INDBIT	;PRIVATE?
	JRST MRMP		;YES
	TLNN 2,SHRBIT		;SHARED OR INDIRECT
	JRST MRMI		;INDIRECT
	LSH 2,-^D9		;GET SPT NUMBER
	ANDI 2,SPTM
	CAIL 2,NOFN		;INDEX BLOCK?
	MOVE 2,SPTH(2)		;NO, GET OFN.PN
MRM1:	MOVE 1,2
	HLRZ 2,1
	CAIL 2,NOFN		;OWNED BY OFN?
	JRST MRMQ		;NO
	AOS -2(P)		;YES, SKIP RETURN
MRMQ1:	POP P,2			;ORIGINAL POINTER
	POP P,3			;FLUSH ORIG IDENT
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	TLO 2,1B23		;EXISTS BIT
	JRST RELCPT

MRMI:	LSHC 2,-^D9		;RE-FORMAT INTO OFN.PN OR PTN.PN
	ANDI 2,SPTM
	LSH 3,-^D9
	LSHC 2,^D18
	JRST MRM1

MRMP3:	SUB P,BHC+3		;CLEAR STACK
RDMQ5:	SETZB 1,2		;RETURN 0
	JRST RELCPT

MRMQ:	CAME 1,-1(P)		;OWNED BY ORIG IDENT?
	JRST MRMQ1		;NO
MRMP:	PUSH P,1
	HLRZ 2,1
	CAMN 2,MMSPTN		;SWP MON MAP?
	JRST MRMP1		;YES, DON'T PUT IN PMF
	CALL RELCPT
	SKIPGE 1,JOBPMF		;ASSIGN NEW PAGE FROM PMF
	JRST MRMP3		;DON'T HAVE ONE, RETURN 0
	FFFFP
	AOS PMFCNT		;INCR. PMF PAGES MAPPED  *****
	CALL JFNOFN
	BUG(HLT,<FAILED TO CONVERT JFN FROM FFFFP TO OFN>)
	MOVSI 3,RWX		;PUT PAGE IN PMF WITH ALL ACCESS
	MOVE 2,1
	EXCH 1,0(P)
	CALL SETPT		;PUT PAGE IN PMF
MRMP1:	POP P,2			;OFN.PN OF NEW PAGE
	JRST MRM1

;READ PAGE ACCESSIBILITY

MRPACS:	PUSH P,[0]
	PUSH P,[XWD RWXB+TRAPUB+COPYB,0]
MRP4:	HLRZ 3,1		;SOURCE PTN
	CAIG 3,0
	BUG(HLT,<ILLEGAL LH OF 1 ARG TO MRPACS>)
	CALL SETXB1		;MAP PT
	MOVE 3,CXBPGA(1)	;GET MAP WORD
	SKIPN -1(P)		;FIRST MAP WORD?
	HLRZM 3,-1(P)		;YES, SAVE FIRST PT ACCESS
	TLC 3,TRAPUB+COPYB	;FOR THESE BITS, WE'RE AND'ING 0'S
	ANDM 3,0(P)		;COMPUTE AND OF ALL MAP WORDS
	TLNN 3,INDBIT		;INDIRECT?
	JRST MRP2		;NO, SHARED OR PRIVATE
	CALL RELCXB
	ROTC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 3,SPTM
	LSH 3,^D9
	ROTC 2,^D9
	MOVE 1,3
	JRST MRP4

MRP2:	POP P,1			;AND OF ALL MAP WORDS
	POP P,2			;FIRST POINTER ACCESS
	TLC 1,TRAPUB+COPYB	;BITS FOR WHICH AND'ING 0'S
	JUMPE 2,RELCXB		;RETURN 0 IF FIRST POINTER WAS 0
	TRNN 2,SHRBIT+INDBIT	;FIRST PTR PRIVATE?
	TLO 1,(1B10)		;YES, SO INDICATE
	TLZE 1,ACCESB		;ANY ACCESS?
	TLO 1,(1B5)		;YES, SET BIT IN RESULT
	TRNE 2,INDBIT		;FIRST POINTER INDIRECT?
	TLO 1,(1B6)		;YES, NOTE
	ANDI 2,RWX+TRAPUB+COPYB	;BITS OF ORIG PTR TO GIVE TO USER
	HRRI 1,1B23(2)		;ORIG PTR ACCESS WITH EXISTS BIT TO RH
	TLNN 3,SHRBIT		; SHARE POINTER?
	JRST RELCXB		;RELEASE PT AND RETURN
	LSH 3,-^D9		; YES, EXTRACT
	ANDI 3,SPTM		; SPT INDEX
	MOVE 3,SPT(3)
	TLNN 3,16		; DISC OR DRUM?
	TLNN 3,1		; NO -- NON-EXISTENT
	 JRST RELCXB		; EXISTS, DONE
	TLZ 1,(1B5)		; NON-EXISTENT, CLEAR "EXISTS" BIT
	JRST RELCXB

;SET PAGE ACCESSIBILITY

MSPACS:	PUSH P,2
	CALL SETCPT		;MAP PT
	POP P,2
	SKIPN CPTPGA(1)		;PAGE EXISTS?
	JRST RELCPT		;NO, IGNORE CALL
	HLRZ 3,1
	CAIGE 3,NOFN		;FILE?
	TLZ 2,TRAPUB+COPYB	;YES, DISALLOW BITS
	XOR 2,CPTPGA(1)		;SET BITS 2-4
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	XORB 2,CPTPGA(1)
	JRST RELCPT

;MRPAC - JSYS FOR MONITOR DDT
;DOESN'T WORK CORRECTLY FOR RES MON ADDRESSES WHEN MAPRESMON IS ON

.MRPAC:	JSYS MENTR
	MOVE 2,0(P)		;RETURN PC
	TLNE 2,UMODF		;FROM MONITOR?
	JRST ITRAP		;NO, ILLEGAL FROM USER
	TLNE 1,400000		;USER?
	JRST [	CALL FPTA	;YES, GET PTN.PN
		JRST MRPC3]
	MOVEI 2,0(1)		;MONITOR, GET ADDRESS
	CAIGE 2,100000		;RESIDENT MON?
	JRST [	MOVSI 1,RWX+1B28 ;YES, MEANS PRIVATE AND ALL ACCESS
		JRST MRPC2]
	CAIGE 2,PPRMA		;NON-RES MON?
	JRST [	LSH 2,-^D9	;NO, IS RESIDENT MAPPED MON
		SKIPE 1,MMAP(2)	;REQUESTED PAGE EXISTS?
		TLO 1,1B28	;YES
		JRST MRPC2]	;RETURN CONTENTS OF MMAP
	CAIL 2,CXBPGA		;CHECK SPECIAL PAGES
	CAILE 2,CPYPGA		;SETPT, ETC. PAGES?
	CAIGE 2,PPRMA+NRSPG*1000 ;SWAPPER PAGES?
	JRST MRPC1		;YES, RETURN NO-ACCESS
	CALL FPTA
MRPC3:	CALL MRPACS
MRPC2:	UMOVEM 1,2		;RETURN RESULT IN 2 LIKE RPACS
	JRST MRETN

MRPC1:	MOVSI 1,(1B10)		;NO-ACCESS
	JRST MRPC2

;SET PAGE IN MONITOR OR USER MAP (INTERNAL MONITOR CALL)
; AC1/ OFN,,PN   (OFN IS SPT POINTER, PN IS 0-777)
; AC2/ 18-35 VIRTUAL ADDRESS OF PAGE (NOT PAGE NUMBER)
;       0    1 => USER MAP, 0 => MONITOR MAP
;       2-4, 8, 9  READ, WRITE, XCT ALLOW BITS (SAME AS PAGER MAP WORD)

SETMPG:	ADD P,BHC+7		;SAVE AC'S
	JUMPGE P,MSTKOV
	MOVEM 1,-6(P)		;THIS IS FASTER THAN BLT OR PUSH
	MOVEM 2,-5(P)
	MOVEM 3,-4(P)
	MOVEM 4,-3(P)
	MOVEM 5,-2(P)
	MOVEM 6,-1(P)
	MOVEM 7,0(P)
	HLLZ 3,2		;GET ACCESS AND DISPOSAL
	PUSH P,3
	EXCH 1,2
	CALL FPTA		;CONVERT ADDRESS TO PTN.PN
	JRST SETP8

;SET PAGE TABLE (FOR PROCESS OR FILE)
; AC1/ SOURCE IDENTIFIER
; AC2/ DESTINATION IDENTIFIER
; AC3/ 2-4, 8, 9 ACCESS PERMISSION, 15-17 DISPOSAL

;IDENT IS OFN.PN (PAGE IN FILE), 0.OFN (INDEX BLOCK),
; PTN.PN (PAGE IN PROCESS), OR 0.PTN (PROCESS PT)

SETPT:	ADD P,BHC+7		;SAVE AC'S
	JUMPGE P,MSTKOV
	MOVEM 1,-6(P)
	MOVEM 2,-5(P)
	MOVEM 3,-4(P)
	MOVEM 4,-3(P)
	MOVEM 5,-2(P)
	MOVEM 6,-1(P)
	MOVEM 7,0(P)
	PUSH P,3		;SAVE ACCESS BITS
	EXCH 1,2
SETP8:	CALL RELMPG		;RELEASE EXISTING PAGE
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	SKIPE CPTPGA(1)		;ANYONE GET PAGE IN MEANTIME
	JRST [	ULOCK SYSLCK	;RELEASE SYSLCK
		OKSKED		;TRY AGAIN
		JRST SETP8]
	JUMPE 2,SETPT1		;NO NEW PAGE TO SET
SETP5A:	CAMN 1,2		;DON'T ALLOW MAP TO SELF
	JRST SETPF1
	HLRZ 3,2		;GET OFN
	JUMPE 3,SETMXB		;OFN=0 MEANS SPTN IN RH
	TDNE 2,[XWD -SPTM-1,777000] ;LEGAL PTN AND PN?
	BUG(HLT,<ILLEGAL SOURCE IDENTIFIER GIVEN TO SETPT>)
	CALL SETXB1		;MAP INDEX BLOCK
;
	HLRZ 3,2		;SEE IF INDEX BLOCK IS IN CORE
	MOVE 3,SPT(3)
	TLNN 3,17
	JRST SETP72		;IT IS
	ULOCK SYSLCK		;RELEASE SYSLCK
	OKSKED
	MOVES CXBPGA		;DUMMY REF. AND DIRTY PAGE
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	SKIPE CPTPGA(1)		;DID PAGE COME BACK WHILE OKSKED
	JRST [	ULOCK SYSLCK	;YES-HAVE TO START OVER
		OKSKED
		JRST SETP8]
;
SETP72:	MOVE 3,CXBPGA(2)	;GET WORD FROM XB
	HLRZ 4,1		;GET DESTINATION PTN
	CAIGE 4,NOFN		;FILE?
	JRST SETP7		;YES
	HLRZ 4,2		;GET SOURCE PTN
	CAIL 4,NOFN		;PROCESS?
	JRST SETP5		;YES, GO SETUP INDIRECT POINTER
	TLNE 3,SHRBIT+INDBIT	;PRIVATE?
	JRST SETMP3		;NO
	TLNN 3,ACCESB		;PAGE EXISTS?
	JRST SETP3		;NO, GO CREATE IT
SETP4:	MOVE 4,SPTC		;YES
	CAMGE 4,SPC0		;ROOM IN SPT? (SPT < C FULL)
	JRST SETMP6		;YES
	SETCM 4,3		;GET ACCESS OF SOURCE
	TLNE 4,RWX		;ALL POSSIBLE?
	SKIPG FRESPT		;NO, SHOULDN'T USE IND PTR
	JRST SETP5		;USE IND PTR
	JRST SETMP6		;USE SHR PTR

SETP5:	SKIPGE INDFLG		;ALLOWING USE OF INDIRECT POINTERS?
	JRST SETPF2		;NO, GO TRY ALTERNATIVES
REPEAT 0,<			;!! MAH @ SUMEX 4/75 !! PATCHED OUT UPON
				;RECOMMENDATION OF ED TAFT @ PARC
	TLNE 3,INDBIT		;SOURCE CONTAINS IND PTR?
	JRST [	CALL RELCXB	;YES, TRACE DOWN
		ROTC 2,-^D9	;CONSTRUCT IDENT OF PAGE POINTED
		ANDI 3,SPTM	;TO BY IND PTR
		LSH 2,-^D9
		ROTC 2,-^D18
		JRST SETP5A]	;AND USE THAT AS SOURCE
>
	LSHC 2,-^D9		;CONSTRUCT INDIRECT POINTER
	LSH 2,-^D9
	LSHC 2,^D9
	TLO 2,ACCESB+INDBIT
SETMP4:	LDB 3,[POINT 13,2,26]	;GET OFN OF INDEX BLOCK
SETMP5:	MOVSI 4,1B31
	CAIE 3,0		;IF NO OWNING PT
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT OF INDEX BLOCK
	POP P,3			;RECOVER ACCESS BITS
	XOR 2,3			;PUT ACCESS BITS IN PTR
	TLZ 2,RWX+TRAPUB+COPYB	;USER ALLOWED TO SPECIFY THESE
	XOR 2,3
	MOVEM 2,CPTPGA(1)	;PUT MAP WORD IN MAP
SETPT2:	CALL RELCPT		;RELEASE PT MAPPING
	CALL SWPCXB		;GET RID OF INDEX BLOCK

	ULOCK SYSLCK		;RELEASE SYSLCK
	MOVE 1,-6(P)
	MOVE 2,-5(P)
	MOVE 3,-4(P)
	MOVE 4,-3(P)
	MOVE 5,-2(P)
	MOVE 6,-1(P)
	MOVE 7,0(P)
	SUB P,BHC+7
	CALL RELCXB
	OKSKED
	RET

SETPT1:	POP P,3			;FLUSH ACCESS BITS
	JRST SETPT2

SETP3:	MOVSI 3,RWXB+1
SETP3A:	MOVEM 3,CXBPGA(2)	;PUT IN XB
	JRST SETP4

;SETMPG (CONT.)

SETPF2:	TLNE 3,SHRBIT+INDBIT	;SHARED NOW?
	JRST SETMP3		;YES, USE SAME POINTER
	JUMPE 3,[MOVSI 3,RWXB+1	;IF SOURCE CURRENTLY EMPTY,
		JRST SETP3A]	;USE UNASSIGNED ADDRESS INDICATION
	SKIPLE FRESPT		;ANY SPT SPACE AT ALL?
	JRST SETMP6		;YES, GO ASSIGN A SLOT
	MOVEI 1,		;GIVE ERROR INDICATION
	JRST SETPTE

SETMP3:	MOVE 2,3		;ALREADY SHARED, USE SAME POINTER
	TLNE 2,INDBIT		;INDIRECT?
	JRST SETMP4		;YES
SETMP7:	LDB 3,[POINT 13,2,26]
	MOVSI 4,1B31		;SHARED,
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT IN SPT
	HLRZ 3,SPTH(3)		;GET OFN FOR THIS PAGE
	JRST SETMP5		;GO INCREMENT SHARE COUNT OF XB

SETMP6:	SKIPG 4,FRESPT		;ASSIGN NEW SPT SLOT
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 4,0(4)		;GET CDR
	EXCH 4,FRESPT		;LIST OF FREE SLOTS
	SUBI 4,SPT		;MAKE RELATIVE
	AOS SPTC		;COUNT OF USED SPT ENTRIES
	TLNE 3,17		;IN CORE?
	JRST SETP2
	CAME 2,CST2(3)		;CHECK OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(3)		;RECORD NEW LOCATION OF CORE ADDRESS
	HLRZ 6,2		;YES, UPDATE LOCK COUNT FOR
	MOVE 6,SPT(6)		;OWNING PT
	MOVSI 5,-PLKV		;REDUCE IT, BECAUSE IT WILL HAVE
	ADDM 5,CST1(6)		;ONE LESS CORE ADDRESS IN IT
SETP2:	TLZ 3,-1B31		;FLUSH BITS IN ORIGINAL POINTER
	MOVEM 3,SPT(4)		;PUT IT IN SPT
	MOVEM 2,SPTH(4)		;PUT OFN.PN IN SPTH
	HLRZ 3,2		;SAVE OFN
	LSH 4,^D9		;CONSTRUCT SHARE POINTER
	TLO 4,SHRBIT
	XOR 4,CXBPGA(2)		;WITH PROTECTION BITS FROM PT
	TLZ 4,RWXB
	XORB 4,CXBPGA(2)	;PUT CONSTRUCTED SHARE POINTER IN PT
	MOVE 2,4		;AS WELL AS PROCESS MAP
	MOVSI 4,1B31		;BUMP SHARE COUNT FOR POINTER PUT
	ADDM 4,SPT(3)		;IN XB
	JRST SETMP7		;GO INCREMENT SHARE COUNTS, ETC.

SETMXB:	CAIL 2,SSPT		;LEGAL NUMBER?
	BUG(HLT,<ILLEGAL SPT INDEX GIVEN TO SETMXB>)
	HLRZ 3,1		;GET DESTINATION PTN
	CAIGE 3,NOFN		;FILE?
	BUG(HLT,<ILLEGAL DESTINATION IDENTIFIER TO SETMPG OR SETPT>)
	MOVEI 3,0(2)		;REQUEST WAS FOR INDEX BLOCK
	LSH 2,^D9		;MAKE IT INTO SHARE POINTER
	TLO 2,SHRBIT+RWXB
	JRST SETMP5

;DESTINATION IS FILE

SETP7:	HLRZ 4,2		;GET SOURCE PTN
	CAIGE 4,NOFN		;IS FILE?
	JRST SETPF1		;YES, ERROR
	TLNE 3,SHRBIT+INDBIT	;NOT PRIVATE?
	JRST SETPF		;YES
	JUMPE 3,SETP7K		;PAGE NEVER REFERENCED
	TLNE 3,10		;NOW ON DISK?
	JRST SETP71		;YES
	TLNE 3,16		;NOW ON DRUM?
	JRST SETP7D		;YES, GO ADJUST DRUM BACKUP ADR
	PUSH P,1		;IN CORE,
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	POP P,1
	MOVSI 4,PLKV		;IN CORE,
	ADDB 4,CST1(3)		;GET BACKUP ADR AND LOCK PAGE
	TLNE 4,10		;DISK?
	JRST SETP7C		;YES
	TLNE 4,16		;DRUM?
	JRST SETP7E		;YES
	MOVEI 4,CST1(3)		;NOT ASSIGNED, PUT BACKUP ADR IN CST1
	CALL SETP7A		;ASSIGN BACKUP ADR AND STORE IT
SETP7C:	PUSH P,3
	MOVEM 1,CST2(3)		;IN CORE, ADJUST CST
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;UNLOCK PAGE
	HLRZ 4,2		;SOURCE PTN
	MOVE 4,SPT(4)
	MOVSI 3,-PLKV
	ADDM 3,CST1(4)		;REDUCE LOCK COUNT OF PT
	HLRZ 4,1
	SKIP CPTPGA		;FIX BY R. SCHULTZ  MAKE SURE PAGE IS STILL THERE
	MOVE 4,SPT(4)
	MOVSI 3,PLKV
	ADDM 3,CST1(4)		;INCREASE LOCK COUNT OF XB
	POP P,3
SETP71:	SETZM CXBPGA(2)		;PUT SOURCE PTR IN DEST MAP
	HLRZ 4,0(P)		;GET USER SPECIFIED ACCESS
	ANDI 4,RWX
	TLZ 3,-1B31
	TLO 3,ACCESB(4)		;PUT ACCESS AND ACCESS BIT IN PTR
	MOVEM 3,CPTPGA(1)
	EXCH 1,2		;EXCHANGE SOURCE AND DESTINATION PT'S
	MOVE 3,PSB+CPTPG
	EXCH 3,PSB+CXBPG
	MOVEM 3,PSB+CPTPG
	MONCLR CPTPG		;CLEAR AR'S FOR LOCAL MAPPING
	MONCLR CXBPG
	JRST SETP72		;NOW AS IF PAGE WAS IN FILE

SETP7K:	MOVSI 3,RWXB		;NEW PAGE, SETUP POINTER
	MOVEI 4,3		;WHERE TO STORE ADDRESS
	CALL SETP7A		;ASSIGN DISK ADDRESS
	TLO 3,NEWFB		;SET NEW FILE BIT
	JRST SETP71
;;;	JRST SETP73

SETP7D:	MOVE 4,3
SETP7E:	PUSH P,2
	PUSH P,3
	MOVE 2,4		;DRUM ADDRESS
	CALL GDSTX		;GET DST INDEX
	MOVEI 4,DST(2)		;WHERE TO STORE ADDRESS
	POP P,3
	POP P,2
	MOVE 5,0(4)		;PRESENT BACKUP
	TLNN 5,10		;DISK?
SETP73:	CALL SETP7A		;NO, ASSIGN DISK ADDRESS AND STORE IT
	TLNN 3,17
	JRST SETP7C
	JRST SETP71

SETP7A:	HLRZ 5,1		;GET OFN OF DESTINATION FILE
	PUSH P,1		;SAVE STUFF
	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVE 1,SPTH(5)		;GET XB ADRESS AND CLASS
	CALL DSKASN		;ASSIGN DISK ADDRESS FOR PAGE
	JRST SETP7X		;DISK FULL
SETP7Y:	MOVE 5,1
	POP P,4
	POP P,3
	POP P,2
	POP P,1
	DPB 5,[POINT 22,0(4),35]	;STORE ADDRESS WHERE GIVEN
	RET

SETP7X:	SUB P,BHC+4+1		;FLUSH 4 TEMPS AND 1 RETURN
	MOVEI 1,OPNX10		;'NO ROOM'
	MOVEM 1,LSTERR
	MOVEI 1,^D20		;SIZE EXCEEDED PSI
	CALL PSIRQ0
	JRST SETPT1

;POINTER NOW IN SPT OWNED BY FORK. MOVE IT TO FILE

SETPF:	LDB 4,[POINT 13,3,26]	;GET SPTN
	CAMN 2,SPTH(4)		;IS OWNED BY SOURCE?
	TLNE 3,INDBIT		;AND NOT INDIRECT?
	JRST SETPF1		;SORRY, CAN'T GIVE AWAY UNOWNED PAGES
	MOVEM 1,SPTH(4)		;SET NEW OWNERSHIP
	MOVSI 5,-1B31
	AND 5,SPT(4)		;GET CURRENT SHARE COUNT
	HLRZ 4,1
	ADDM 5,SPT(4)		;TRANSFER SHARE COUNT TO NEW OWNING PT
	MOVN 5,5
	HLRZ 4,2
	ADDM 5,SPT(4)		;AWAY FROM OLD PT
	JRST SETMP3		;NOW SETUP SHARE POINTER IN DEST

SETPF1:	MOVEI 1,		;ILLEGAL PAGE TO FILE ATTEMPTED
SETPTE:	MOVEM 1,LSTERR
	MOVEI 1,^D11		;IO ERROR CHANNEL
	CALL PSIRQ0
	RESKED
	JRST SETPT1		;CLEAN UP AND EXIT

;PUT INDEX BLOCK IN FIXED PAGE (CXBPG) OF PP MAP FOR TEMP USE

SETXB1:	CALL RELCXB		;RELEASE CURRENT ONE
	NOINT			;NO INTERRUPTS WHILE XB MAPPED
	LSH 3,^D9
	TLO 3,RWXB-XCTB+SHRBIT	;MAKE INTO SHARE POINTER, NO XCT
	MOVEM 3,PSB+CXBPG	;PUT INTO CURRENT X BLOCK PAGE
IFN KIFLG,<SETKIM(CXBPG,3,2)> ;SET KI MAP
	RET

;RELEASE INDEX BLOCK NOW IN FIXED PAGE

RELCXB:	SKIPN PSB+CXBPG
	RET			;NONE THERE NOW
	SETZM PSB+CXBPG		;CLEAR MAP
	MONCLR CXBPG		;CLEAR MONTOR AR'S
	OKINT
	RET

SWPCXB:	PUSH P,1
	LDB 1,[POINT 13,PSB+CXBPG,26]
	CAIL 1,1		;IS OFN?
	CAIL 1,NOFN
	JRST POP1		;NO, IGNORE IT
	MOVE 1,SPT(1)		;YES, INITIATE SWPOUT
;;;	CALL SWPOT0
	TLNN 1,17
	CALL DECOR
POP1:	POP P,1
	RET

;MAP CURRENT PAGE TABLE FOR TEMP USE

SETCPT:	CALL RELCPT		;RELEASE CURRENT ONE
	NOINT
	HLRZ 2,1		;MAKE SHARE POINTER
	LSH 2,^D9
	TLO 2,RWXB-XCTB+SHRBIT
	MOVEM 2,PSB+CPTPG
IFN KIFLG,<SETKIM(CPTPG,2,1)>
	RET

;RELEASE CURRENT PT MAPPING

RELCPT:	SKIPN PSB+CPTPG		;ANYTHING THERE?
	RET			;NO
	SETZM PSB+CPTPG		;CLEAR MAP
	MONCLR CPTPG			;CLEAR AR'S
	OKINT
	RET

;RELEASE PAGE FROM MAP
; AC1/ OFN.PN OF PAGE

RELMPG:	PUSH P,3
	PUSH P,2
RELMP6:
	CALL SETCPT
	PUSH P,1
;
;   I4 CHANGE
	MOVES CPTPGA		;DUMMY REF. AND DIRTY PAGE
;
RELMP5:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RELMPR		;EMPTY
IFN KIFLG,<
	MOVE 4,FORKX
	HRRZ 3,FKPGS(4)
	HLRZ 4,1
	CAIE 4,0(3)		;PSB
	JRST RELKI2
	MOVEI 3,0(1)
	ROT 3,-1
	SKIPL 3
	HRRZS KIEPT(3)
	SKIPGE 3
	HLLZS KIEPT(3)
	DATAO PAG,KIPGWD
	JRST RELKI1
RELKI2:			>	;END KIFLG
	CALL PRSTOP		;STOP OTHER CPU WHILE CHANGING PAGE TABLES
IFN KIFLG,<AOS KIRFLG>
	PGRCLD		;CLEAR AR'S
;
;   I4 CHANGE
;			UNLOCK PAGES FORCIBLY LOCKED
RELKI1:	TLZE 2,LKPBIT
	JRST [MOVEM 2,CPTPGA(1)
		CALL RELCPT
		CALL MULKPG
		POP P,1
		ULOCK SYSLCK	;RELEASE SYSLCK
		CALL PRGO
		OKSKED
		JRST RELMP6]
;
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELP3
	HLRZ 3,1		;GET PTN
	TLNE 2,INDBIT		;INDIRECT POINTER
	JRST RELMP3		;THAT'S OK
	CAIGE 3,NOFN		;OWNED BY FILE?
	JRST RELMP4		;CAN'T DELETE FILE PAGE STILL SHARED
	LDB 3,[POINT 13,2,26]	;GET SPTN
	CAMN 1,SPTH(3)		;OWNER TRYING TO DELETE?
	JRST RELMP4		;MUST WAIT TILL UNSHARED
RELMP3:
;
;   I4 CHANGE
	MOVE 4,CPTPGA(1)
;
	SETZM CPTPGA(1)		;CLEAR MAP WORD
	MOVE 3,2		;SAVE POINTER
	LSH 2,-^D9
	ANDI 2,SPTM		;GET SPT INDEX
	MOVSI 1,-1B31
	TLNN 3,INDBIT		;INDIRECT POINTER, OR
	CAIGE 2,NOFN		;OFN?
	JRST RELP1		;YES
	HLRZ 3,SPTH(2)		;IS SHARE POINTER, GET OFN
	JUMPE 3,RELP1		;IF UNOWNED SPTN
;
;   I4 CHANGE
	MOVE 1,SPT(2)
	TLNE 1,-1B30
	JRST RELMX4
	MOVE 1,0(P)
	MOVEM 4,CPTPGA(1)
	MOVE 4,SPT(3)
	TLNE 4,17
	JRST RELMX2
	LDB 4,[POINT 6,CST0(4),5]
	CAIN 4,6
	JRST RELMX2
	MOVE 4,SPT(2)
	TLNE 4,17
	JRST [TLNN 4,10
		TLNN 4,16   ;ASSIGNED
		JRST RELMX3
		JRST RELMX1]
	LDB 4,[POINT 6,CST0(4),5]
	CAIN 4,6
	JRST RELMX1
RELMX3:	SETZM CPTPGA(1)
RELMX4:	MOVSI 1,-1B31
;
;
	ADDM 1,SPT(3)		;REDUCE SHARE COUNT OF OFN
	ADDB 1,SPT(2)		;REDUCE SHARE COUNT OF PAGE OR XB
	TLNE 1,-1B31		;COUNT NOW 0?
	JRST RELMPR		;NO
	TLNE 1,17		;CORE?
	JRST RELMP2		;NO
	CALL AGESET		;IN CORE, SET AGE
	MOVSI 4,PLKV
	ADDM 4,CST1(1)		;AND LOCK WHILE ADJUSTING
RELMP2:	MOVSI 4,-1B31
	ADDM 4,SPT(3)		;REDUCE SHARE COUNT OF XB
	CALL SETXB1		;MAP OWNING XB
	MOVE 4,SPTH(2)		;GET OWNING PTN.PN
	MOVES CXBPGA	;DUMMY REF. AND DIRTY PAGE
	XOR 1,CXBPGA(4)		;PUT ADDRESS BACK IN XB WITH ORIGINAL
	TLZ 1,-1B31-SHRBIT-INDBIT
	XORB 1,CXBPGA(4)	;ACCESS BITS
	TLNN 1,16		;UNREFERENCED DISK ADR?
	TLNN 1,17
	CAIA			;NO
	SETZM CXBPGA(4)		;YES, DELETE IT
	CALL RELCXB		;RELEASE XB
	MOVE 3,2
	ADDI 2,SPT
	EXCH 2,FRESPT		;RETURN SPT SLOT TO FREE LIST
	MOVEM 2,@FRESPT
	SOS SPTC
	TLNE 1,17		;PAGE IN CORE?
	JRST RELP4		;NO
	CAME 3,CST2(1)		;CONFIRM OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(1)		;YES, CHANGE RECORD OF OWNING PT
	HLRZ 4,4		;PTN OF OWNING PT
	MOVE 4,SPT(4)		;CORE ADDRESS OF IT
	MOVSI 2,PLKV
	ADDM 2,CST1(4)		;INCREMENT LOCK COUNT
	MOVSI 4,-PLKV
	ADDM 4,CST1(1)		;UNLOCK PAGE
	JRST RELP2

RELP4:	TLNN 1,10		;DISK ADR?
	TLNN 1,16		;NOT ASSIGNED?
	JRST RELMPR		;YES
	MOVE 1,4
	PUSH P,7
	MOVE 7,FORKX
	CALL SWPIN		;GET IT OFF DRUM
	POP P,7
	JRST RELMPR
RELP2:	CALL AGESET		;MAKE PAGE IN USE
	HLRZ 2,CST2(1)		;SEE WHO OWNS PAGE
	CAIG 2,NFDIB+3		;SYSTEM FILE? (DIR OR BITTAB)
	JRST [	CALL DECOR	;YES, DEASSIGN BUT DON'T SWAPOUT IMMED
		JRST RELMPR]
;;;	CALL SWPOT0		;SWAP IT OUT
	CALL DECOR
RELMPR:	ULOCK SYSLCK		;RELEASE SYSLCK
	CALL PRGO		;START OTHER CPU
	POP P,1
	POP P,2
	POP P,3
SKORET:	OKSKED			;RE-ENABLE SCHEDULING
	RET

RELP3:	TLNE 2,17		;IN CORE?
	JRST RELP32		;NO, CAN RELEASE ALL.
;  I4 CHANGE
	LDB 4,[POINT 6,CST0(2),5]
	MOVSI 3,DWRBIT		;YES, WRITE IN PROGRESS?
;   I4 CHANGE
	CAIE 4,6
;;;	TDNN 3,CST3(2)
	TDNE 3,CST3(2)
	JRST .+2
	JRST RELP32		;NO, NO PROBLEM
	ULOCK SYSLCK		;RELEASE SYSLCK
	CALL PRGO		;START OTHER PROCESSOR
	MOVEI 1,DWRTST		;YES, MUST WAIT FOR COMPLETION
	HRLI 1,0(2)
	JSYS SCHEDR
	MOVE 1,0(P)		;RECOVER OFN.PN
	JRST RELMP5		;GO TRY AGAIN

RELP32:	CALL REMFPG		;RELEASE ALL STORAGE
	JRST RELMPR

DWRTST:
;   I4 CHANGE
	LDB 3,[POINT 6,CST0(1),5]
	MOVSI 2,DWRBIT		;SCHED TEST FOR WRITE COMPLETED
;   I4 CHANGE
	CAIE 3,6
	TDNE 2,CST3(1)
	JRST 0(4)
	JRST 1(4)

; SCHEDULER TEST FOR PAGE UNLOCKED

PLCKT:	MOVSI 2,-PLKV
	TDNE 2,CST1(1)
	JRST 0(4)
	JRST 1(4)

RELP1:	ADDM 1,SPT(2)
	JRST RELMPR

RELMP4:	SUB P,BHC+3		;FLUSH TEMPS
	ULOCK SYSLCK		;RELEASE SYSLCK
	CALL PRGO		;START THE OTHER CPU
	MOVEI 1,		;ILLEG UNMAPPING
	MOVEM 1,LSTERR
	MOVEI 1,^D11
	CALL PSIRQ0		;GENERATE ITRAP
	SETZB 1,2
	JRST SKORET

;REMOVE PAGE FROM SYSTEM (DELETE PERMANENT AND TEMPORARY ADDRESSES)

;	ENTERED WITH SYSLCK LOCKED; EXITS WITH IT LOCKED
REMFPG:	MOVE 3,CPTPGA(1)	;GET MAP WORD
	SETZM CPTPGA(1)		;CLEAR MAP WORD
REMFP1:	TLNE 3,10		;DISK?
	JRST REMFF		;YES
	TLNE 3,16		;DRUM?
	JRST REMFD		;YES
	TLNE 3,17		;CORE?
	RET			;DONE
	MOVEI 1,0(3)
	CAMG 1,NHIPG		;LEGAL PAGE?
	CAMGE 1,SWPCOR
	BUG(HLT,<ILLEGAL CORE PAGE NUMBER TO REMFPG>)
	CALL AGESET
	CALL DECOR
	HLRZ 2,CST2(1)		;GET PTN OF OWNING PT
	JUMPE 2,REMFP2		;NONE, SPT
	MOVE 3,SPT(2)		;GET ADR OF OWNING PT
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;DECREMENT LOCK COUNT
REMFP2:	MOVE 2,TODCLK		;SETUP OVERDUE TIME
	ADDI 2,^D2000		;AS 2 SEC FROM NOW
REMFP4:	MOVSI 3,(77B5)
	MOVSI 4,-PLKV
	HLOCKI SWPPI		;LOCK RPLQ LOCK
	SETZM CST2(1)		;FLUSH SOURCE
	TDNE 3,CST0(1)		;PAGE NOW ON RPLQ?
	TDNE 4,CST1(1)		;LOCKED?
	JRST REMF21		;YES, IS OR WILL BE PUT ON RPLQ
	MOVSI 3,DWRBIT
	TDNE 3,CST3(1)		;BEING WRITTEN?
	JRST REMFP3		;YES, MUST WAIT
REMFP5:	JSP 4,ONRQX		;PUT PAGE ON RPLQ
REMF22:	MOVSI 3,-PLKV
	AND 3,CST1(1)		;FLUSH BACKUP ADDRESS, LEAVE LK CNT
	EXCH 3,CST1(1)		;GET BACKUP ADDRESS
	JRST REMFP1

REMFP3:
	HULOCK SWPPI		;RELEASE LOCK
	OKPI
	CAML 2,TODCLK		;WAITED LONG ENOUGH?
	JRST REMFP4		;NO, KEEP WAITING
	BUG(CHK,<SWAP WRITE FAILED TO COMPLETE IN 2 SEC>)
	HLOCKI SWPPI		;LOCK FROM PI LEVEL
	ANDCAM 3,CST3(1)	;FORCE COMPLETION
	JRST REMFP5

REMF21:
	HULOCK SWPPI
	OKPI
	JRST REMF22

REMFD:	MOVE 1,3
	PUSH P,1
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,2
	CALL GDSTX
	MOVE 3,DST(2)		;GET BACKUP ADDRESS
	SETOM DST(2)		;MAKE DST SLOT EMPTY
	JRST REMFP1

REMFF:	MOVE 1,3
	ULOCK SYSLCK		;RELEASE LOCK
	CALL DEDSK		;DEASSIGN DISK ADDRESS
	DLOCK SYSLCK		;LOCK SYSLCK AGAIN
	RET
;
;   I4 CHANGE
RELMX1:
	MOVE 3,2
RELMX2:
	ULOCK SYSLCK		;RELEASE LOCK
	CALL PRGO		;LET OTHER CPU RUN
	OKSKED
	CALL SETXB1
	MOVE 4,CXBPGA	;DUMMY READ
	CALL RELCXB
	MOVE 1,0(P)
	JRST RELMP5
;
;

;CONSTRUCT PTN.PN FOR
;ADDRESS GIVEN IN 18-35 OF AC1
;BIT 0 OF AC1 SAYS USER (IF 1) OR MONITOR (IF 0) ADDRESS
;RETURN WITH PTN.PN IN AC1

FPTA:	PUSH P,1
	MOVEI 1,0(1)		;CLEAR LH
	LSH 1,-^D9		;GET PAGE NUMBER
	EXCH 1,0(P)		;GET ARG, SAVE PN
	JUMPL 1,FPTAU		;USER MODE IF BIT 0 IS 1
	MOVE 1,0(P)
	CAIL 1,PPMPG		;WHICH PART OF MONITOR?
	JRST FPTA1		;PRIVATE PER PROCESS
	CAIL 1,PJMPG
	JRST FPTA2		;PRIVATE PER JOB
	CAIL 1,PPRMPG
	JRST FPTA3		;PRIVATE PER PROCESSOR AND SWAPPABLE
	BUG(HLT,<FPTA - ARG POINTS TO RESIDENT MONITOR>)

FPTA1:	CAIGE 1,DDPG1		;DISALLOW SPECIAL PAGES
	BUG(HLT,<FPTA - ILLEGAL PAGE IN PROCESS AREA>)
FPTA5:	MOVE 1,FORKX		;GET SPTN OF PSB
	JRST FPTA4

FPTAU:	MOVE 1,FORKX		;GET SPTN OF UPT OR IF NONE, PSB
	HLL 1,FKPGS(1)
	TLNN 1,-1
FPTA4:	HRLZ 1,FKPGS(1)
FPTAR:	HLLM 1,0(P)		;COMBINE WITH PAGE NUMBER
	JRST POP1		;POP TO 1 AND RETURN

FPTA2:	CAIG 1,JSBPG
	JRST FPTA5		;JSB, NOT INDIRECT PTR
	LDB 1,[POINT 13,PSB+JSBPG,26]	;SPTN OF JSB
	HRLM 1,0(P)
	HRREI 1,-PJMPG+JOBMAP-JSB ;FIRST JOB PAGE MAPPED BY JOBMAP+0
	ADDM 1,0(P)
	JRST POP1

FPTA3:	HRL 1,MMSPTN		;PERMANENT SPTN OF MON MAP
	JRST FPTAR

;LOCK, UNLOCK PAGE ON REQUEST (FOR DTA IO, ETC.)

MLKMA:	TLNN 1,(1B0)		;LOCK PAGE GIVEN ADDRESS. USER?
	SKIPA 0(1)		;NO, MON. REF PAGE TO ENSURE EXISTS
	XCTUU [SKIP 0(1)]
	CALL FPTA		;TRANSLATE ADDRESS TO OFN.PN
MLKPG:	PUSH P,1
	CALL GETONT		;GET PTN.PN OR OWNING PT
	TLNN 2,17		;PAGE NOW IN CORE?
	JRST MLKPG3		;YES.
	TLNN 2,16		;NO, EXISTS?
	JRST MLKPG2		;NO
	CALL SWPINW		;INITIATE SWAP AND WAIT FOR COMPL.
	POP P,1
	ULOCK SYSLCK
	OKSKED
	JRST MLKPG		;TRY AGAIN

MLKPG2:
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED			;MUST REF PAGE TO CREATE IT
	TLNE 2,-1		;IN SPT?
	BUG(HLT,<MLKPG: NONX PAGE NOT IN SPT>)
	CALL SETCPT
	SKIP CPTPGA
	CALL RELCPT
	POP P,1
	JRST MLKPG

MLKPG1:	POP P,1
	MOVE 1,CST1(2)
	TLNE 1,-PLKV		;PAGE LOCKED NOW?
	JRST MLKPG4
	AOS LOKPGS		;NO, COUNT IT
MLKPG4:
	MOVSI 1,PLKV
	ADDB 1,CST1(2)		;INCREMENT LOCK COUNT
	AOS LOKSUM
	MOVEI 1,0(2)
	CALL AGESET		;SET AGE
	AOS KIMLKF		;SET FLAG
IFN IMSSS,< IFN KIFLG,< SKIPE KIMLKF >>
	MONCLR 0
	ULOCK SYSLCK		;RELEASE LOCK
	JRST SKORET		;OKSKED AND RETURN

MULKPG:	PUSH P,2
	CALL GETONT		;GET OWNING PT
	TLNE 2,17		;PAGE NOW IN CORE?
	BUG(HLT,<MULKPG - TRIED TO UNLOCK PAGE NOT LOCKED>)
	CALL MULK1
	POP P,2
	ULOCK SYSLCK		;RELEASE SYSLCK
	JRST SKORET

MULK1:	MOVSI 1,-PLKV
	TDNN 1,CST1(2)		;LOCK COUNT NON-ZERO?
	BUG(HLT,<TRIED TO UNLOCK PAGE NOT LOCKED>)
	ADDB 1,CST1(2)		;DECREMENT LOCK COUNT
	TLNE 1,-PLKV		;NOW UNLOCKED?
	JRST MULK2		;NO
	SOS LOKPGS
	IFN KIFLG,<AOS KIMLKF>	;NOTE CHANGE OF LOCK STATE
	CONSZ PI,177B27		;CAN'T EXECUTE FROM INTERRUPT LEVEL
	JRST MULK2		;SINCE SYSLCK ISNT LOCKED
	SKIPE CST2(2)		;STILL EXISTS?
	JRST MULK2		;YES
	PUSH P,4		;NO, HAS BEEN DELETED
	MOVEI 1,0(2)
	JSP 4,ONRQ		;PUT ON REPLACABLE QUEUE
	POP P,4
MULK2:	SOS LOKSUM
	RET

IFN KIFLG,< INTERN KILRT
KILRT:	AOS KIMLKF
	MONCLR 0
	RET
>

;
;   I4 CHANGE
MLKPG3:
	LDB 1,[POINT 6,CST0(2),5]
	CAIE 1,6
	JRST MLKPG1
	ULOCK SYSLCK		;RELEASE LOCK
	MOVSI 1,0(2)
	HRRI 1,SWPRT
	JSYS SCHEDR
	POP P,1
	JRST MLKPG
;
;
;GET CORE PAGE GIVEN ADDRESS OR IDENTIFIER
;CLOBBERS 2

GETCPA:	CALL FPTA		;CONVERT ADDRESS TO IDENTIFIER
GETCPP:	HLRZ 2,1		;PT IDENT
	MOVE 2,SPT(2)		;ADR OF IT
	TLNE 2,17		;IN CORE?
	BUG(HLT,<GETCPP-PAGE NOT IN CORE>)
	CALL MOVRCA		;MOVE 1,PT(1)
	TLNN 1,SHRBIT+INDBIT	;PRIVATE PTR?
	RET			;YES
	TLNN 1,INDBIT		;INDIRECT?
	JRST [	LDB 2,[POINT 13,1,26]  ;SHARED,GET SPT IDX
		MOVE 1,SPT(2)
		RET]
	LSHC 1,-^D9		;REFORMAT INTO PTN,PN
	ANDI 1,SPTM
	LSH 1,^D9
	LSHC 1,^D9
	JRST GETCPP

;GIVEN CORE PAGE IN 2 AND N IN 1,FETCH NTH WORD FROMM PAGE
;KI VERSION IS IN KISRV
;CAN BE CALLED AT ANY PI LEVEL

   IFN KAFLG,<
MOVRCA:	HRLI 2,RWXB		;CONSTRUCT PTR
	PIOFF
	MOVEM 2,MMAP+PIPG
	CONO PGR,1		;CLEAR MONAR'S
	MOVE 1,PIPG(1)
	PION
	RET
>

;UNLOCK PAGE GIVEN MONITOR ADDRESS
;ASSUMED NOSKED OR INSKED

MULKMP:	MOVEI 1,0(1)
	LSH 1,-^D9
	CAIL 1,PPRMPG+NRSPG
	CAIL 1,PPMPG
	BUG(HLT,<MULKMP - ILLEGAL MONITOR ADDRESS>)
	MOVE 1,MMAP(1)		;GET CORE ADDRESS
	TLZ 1,-1B31		;FLUSH POINTER BITS
	JRST MULKCR

;UNLOCK PAGE GIVEN CORE PAGE NUMBER IN 1

MULKCR:	CAML 1,SWPCOR		;LEGAL?
	CAIL 1,MAXCOR
	BUG(HLT,<MULKCR - ILLEGAL CORE PAGE NUMBER>)
	PUSH P,2
	MOVEI 2,0(1)
	CALL MULK1
	POP P,2
	RET

;GET OWNING PAGE TABLE
;GIVEN PTN.PN, LOCATE PT CURRENTLY HAVING ADDRESS OF PAGE

GETONT:	CALL SETCPT		;MAP GIVEN PAGE TABLE
;  I4 CHANGE
	MOVE 2,CPTPGA(1)
;
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELCPT		;YES, RELEASE CPT AND RETURN
	TLNN 2,INDBIT		;INDIRECT POINTER?
	JRST GETON1		;NO, SHARE POINTER.
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	LSHC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 2,SPTM
	LSH 2,^D9
	LSHC 2,^D9
	CALL RELCPT		;RELEASE CPT
	MOVE 1,2
	JRST GETONT		;TRY AGAIN

GETON1:	LDB 1,[POINT 13,2,26]	;FOR SHARE POINTER, RETURN SPTN
	MOVE 2,SPT(1)		;AND CURRENT ADDRESS
	JRST RELCPT		;RELEASE CPT AND RETURN

;SETUP PAGER FOR PROCESS

SETPPG:	HRRZ 10,FKPT(7)		;GET PROCESS NUMBER
IFN KIFLG,<CALL KILUPT>		;SET UP UPT PTR
	HRRZ 1,FKPGS(7)		;GET PSB
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PSB NOT IN CORE>)
	CALL AGESET
	HRRZM 1,PGR71		;LEAVE CORE PAGE NUMBER FOR PAGER
	HRRZ 1,FKPGS(7)
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT	;MAKE SHARE POINTER TO PSB
	MOVEM 1,MMAP+FITPG	;PUT IN PPR MAP
IFN KAFLG,<	MONCLR FITPG >
IFN KIFLG,<MOVE 2,PGR71
	IORI 2,KIAXB+KIWB
	MONSET(FITPG,2,1)
	DATAO PAG,KIPGWD>
	MOVEM 1,FITPGA+PSBPG	;IN PSB
	HLRZ 1,FKPGS(7)		;GET PT
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PT NOT IN CORE>)
	CALL AGESET
SETPG1:	HRLM 1,PGR71		;LEAVE FOR PAGER
	HRRZ 1,FKCNO(7)
	MOVE 2,BITS-^D9(1)	;PROCESS USE BIT
	HLRZ 1,FKNR(7)		;GET PROCESS AGE
	ROTC 1,-^D9
	MOVEM 2,PGR72
	PGRCLD		;LOAD PAGER FROM 71,72
	MOVE 1,ACBAS		;SET AC BASE REGISTER
	SETACB 1
	RET

;PRELOAD PAGES FOR FORK, FORKX IN 7

IFDEF I4SW,<
PRELD:	RET
POSTPG:	RET
>
IFNDEF I4SW,<
PRELD:	SKIPE PGR71		;PAGER INITIALIZED?
	SKIPN PRELDF		;PRELOADING IN OPERATION?
	JRST PREL2		;NO
	SETOM PRELRQ		;SET FLAG NOTING PRELOADING SWAPS
	PUSH P,10
	HRRZ 11,FKNR(7)		;CURRENT WS SIZE
	SUBI 11,4		;LESS PSB, UPT, AND 2 RESERVE
	HRRZ 1,FKPGS(7)		;PSB
	LSH 1,^D9		;MAP IT WITH SHARE PTR
	TLO 1,RWXB+SHRBIT
	MOVEM 1,MMAP+FITPG
	HLRZ 1,FKPGS(7)		;PAGE TABLE
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT
	MOVEM 1,MMAP+PRLPG	;MAP IT
	MONCLR
	MOVSI 10,-NWSPGS	;SETUP TO SCAN WS BIT WORDS
PREL1:	SKIPE 5,XWSPGS(10)	;ANY PAGES THIS WORD?
PREL6:	JFFO 5,PREL3		;YES
	AOBJN 10,PREL1
PREL7:	POP P,10
PREL2:	SETZM PRELRQ
	RET

PREL3:	ANDCM 5,BITS(6)		;REMOVE BIT FOR PAGE JUST FOUND
	PUSH P,5		;SAVE PARTIAL BIT WORD
	MOVEI 5,0(10)		;COMPUTE PAGE NUMBER IN UPT
	IMULI 5,^D36
	ADDI 6,0(5)
	SKIPE 2,PRLPGA(6)	;GET POINTER FROM UPT
	TLNE 2,INDBIT		;INDIRECT?
	JRST PREL4		;YES, NOT INTERESTED
	HLLZ 1,FKPGS(7)		;CONSTRUCT IDENTIFIER FOR PRIVATE CASE
	HRRI 1,0(6)		;PTN.PN
	TLNE 2,SHRBIT		;SHARE PTR?
	JRST [	LSH 2,-^D9	;YES, GET SPT INDEX
		ANDI 2,SPTM
		MOVEI 1,0(2)	;THAT WILL BE IDENTIFIER
		MOVE 2,SPT(1)	;AND SPT CONTAINS ADDRESS
		JRST .+1]
	TLNE 2,17		;PAGE NOW IN CORE?
	JRST [	SKIPLE NRPLQ	;MAKE SURE THERE'S ROOM
		TLNN 2,16	;AND PAGE IS ASSIGNED
		JRST PREL4
		CALL SWPIN	;NO, SWAP IT IN
		JRST PREL4]
	LDB 1,[POINT 6,CST0(2),5] ;PAGE IS IN CORE, SEE WHAT STATE
	JUMPE 1,PREL5		;ON REPLACABLE
	CAIE 1,4		;BEING WRITTEN?
	JRST PREL4		;NO, ANYTHING ELSE IS OK
	MOVSI 1,(2B5)
	EXCH 1,CST0(2)		;SET NEW STATE, GET OLD
	TLNN 1,(77B5)		;NOW ON REPLACABLE?
	JRST PREL5		;YES
	SOS IOIP		;NO, HAVE NOW DISABLED COMPLETION ACTION
PREL4:	POP P,5			;RECOVER PARTIAL BIT WORD
	SOJG 11,PREL6		;KEEP GOING UNLESS WS EXHAUSTED
	JRST PREL7		;QUIT

PREL5:	SOS NRPLQ		;TAKE PAGE OFF REPLACABLE
	PIOFF
	HLOCK SWPPI		;LOCK SWPPI LOCK
	MOVE 1,CST3(2)
	HLLM 1,0(1)
	MOVS 1,1
	HLRM 1,0(1)
	HULOCK SWPPI		;RELEASE LOCK
	PION
	SETZM CST3(2)
	MOVSI 1,(2B5)		;SET PAGE TO READ COMPLETE STATE
	HRRI 1,0(7)		;INCLUDE FORK NO
	MOVEM 1,CST0(2)		;IN CASE PROCESS DOES NOT REF IT
	JRST PREL4

;CHECK WS BITS AS PROCESS LEAVES BALSET

POSTPG:	PUSH P,1
	JSP 4,STIME		;TIME THIS
	HRRZ 1,FKPGS(7)
	LSH 1,^D9		;MAP PSB
	TLO 1,RWXB+SHRBIT
	MOVEM 1,MMAP+FITPG
	HLRZ 1,FKPGS(7)		;PAGE TABLE
	LSH 1,^D9		;MAP IT VIA SHR PTR
	TLO 1,RWXB+SHRBIT
	MOVEM 1,MMAP+PRLPG
	MONCLR PRLPG
	MOVSI 6,-NWSPGS		;SCAN WS BIT WORDS
	SETZ 3,			;COUNTING BITS
REMB2:	SKIPE 4,XWSPGS(6)	;ANY BITS HERE?
REMB7:	JFFO 4,REMB5		;YES, FIND ONE
	AOBJN 6,REMB2
	ADDI 3,3		;PAGES IN WS PLUS 3 FOR MON OVHD
	CAIGE 3,6		;SET NR TO: MAX(6,SIZ,WSBITS+3)
	MOVEI 3,6
	HRRZ 2,FKWSP(7)		;SIZE
	CAIGE 3,0(2)
	MOVEI 3,0(2)
	HRRZ 2,FKNR(7)		;CURRENT NR
	CAILE 3,0(2)		;ABOVE .G. CURRENT?
	MOVEI 3,0(2)		;YES, KEEP CURRENT
	HRRM 3,FKNR(7)		;SET NEW NR
	JSP 4,ETIME		;GET TIME SPENT HERE
	ADDM 1,PPGTIM		;ACCUMULATE IT
	POP P,1
	RET

;SWAP OUT PURGED PAGE

GCSWP:	MOVE 2,CST1(1)
	TLNE 2,-PLKV
	RET
	MOVSI 2,DWRBIT
	TDNE 2,CST3(1)		;DON'T SWAP PAGE IF NOW BEING WRITTEN
	RET
	MOVE 2,CST0(1)
	TLNN 2,(7B2)		;NOW ASSIGNED?
	JRST GCSW1		;NO, SWAP IT
	HLRZ 2,CST3(1)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	PUSH P,1
	CAIGE 2,NFKS		;ASSIGNED?
	CALL SOSWSP		;YES, DEASSIGN IT
	POP P,1
GCSW1:	JRST SWPOUT		;SWAP OUT PAGE

;LOOK AT PAGE IN WS

REMB5:	ANDCM 4,BITS(5)		;REMOVE BIT FROM TEMP WORD
	MOVEI 1,0(6)		;COMPUTE PAGE NUMBER IN PT
	IMULI 1,^D36
	ADDI 1,0(5)
	SKIPE 1,PRLPGA(1)	;PAGE NOW EMPTY?
	TLNE 1,INDBIT		;OR INDIRECT?
	JRST REMB6		;YES, FORGET IT
	TLNE 1,SHRBIT		;SHR PTR?
	JRST [	LSH 1,-^D9
		ANDI 1,SPTM	;YES, GET ADDRESS FROM SPT
		MOVE 1,SPT(1)
		JRST .+1]
	TLNE 1,17		;PAGE NOW IN CORE?
	JRST REMB6		;NO, FORGET IT
	MOVE 2,CST0(1)
	TLNN 2,(7B2)		;PAGE IN USE?
	JRST [	TLC 2,(02B5)	;NO, BUT IS READ COMPLETED?
		TLNE 2,(77B5)
		JRST REMB6	;NO, FLUSH IT
		JRST .+1]	;YES, KEEP IT
	PUSH P,3
	PUSH P,4
	SKIPG SWRSAF		;PAGE IS TO BE KEPT. REASSIGNING ADRS?
	JRST POSTP1		;NO
	MOVE 2,CST1(1)		;YES, GET OLD ADDRESS
	TLNN 2,10		;DRUM?
	TLNN 2,16
	JRST POSTP1		;NO
	CALL GDSTX		;GET DST INDEX FOR OLD DRUM ADR
	PUSH P,DST(2)		;SAVE BACKUP ADR
	SETOM DST(2)		;CLEAR OLD DST SLOT
	PUSH P,1		;SAVE CORE ADDRESS
	MOVE 1,CST1(1)
	CALL DASDRM		;DEASSIGN OLD DRUM ADR
	CALL DRMASN		;ASSIGN NEW DRUM ADR IN SEQUENCE
	BUG(HLT,<DRUM COMPLETELY FULL>)
	TLO 1,1			;NOTE NEW ADDRESS
	MOVE 2,1
	POP P,1
	DPB 2,[POINT 22,CST1(1),35] ;STORE NEW DRUM ADR
	CALL GDSTX
	POP P,DST(2)		;PUT BACKUP ADR IN NEW DST SLOT
POSTP1:	SKIPLE POSPGF		;POST PURGING REQUESTED?
	CALL GCSWP		;YES, SWAP OUT THE PAGE
	POP P,4
	POP P,3
	AOJA 3,REMB7		;COUNT PAGE AND CONTINUE

REMB6:	SKIPN -1(P)		;FORK WAS DISMISSED OR FORCED OUT?
	AOJA 3,REMB7		;FORCED OUT, DON'T FLUSH UNREF PGS
	MOVE 2,BITS(5)
	ANDCAM 2,XWSPGS(6)	;DISMISSED, FLUSH UNREF PAGES
	JRST REMB7
>; END OF I4SW

;DEASSIGN CORE

DECOR:	PUSH P,3		;MUST BE TRANSPARENT TO AC'S
	PUSH P,2
	TLNE 1,17		;GIVEN MAP WORD, NOW IN CORE?
	JRST DECRR		;NO, NOTHING TO DO
	MOVE 3,CST0(1)
	TLNN 3,(70B5)		;PAGE IN USE?
	JRST DECRR		;NO
	HLRZ 2,CST3(1)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;ASSIGNED?
	JRST DECRR		;NO, NOTHING ELSE TO DO
	PUSH P,1
	CALL SOSWSP		;REDUCE N FOR THIS PROCESS
	POP P,1
	MOVSI 2,-PLKV
	TDNE 2,CST1(1)		;PAGE WAS LOCKED?
	JRST [	AOS BALSHC	;YES, CHARGE TO OVERHEAD
		AOS SUMNR
		JRST .+1]
	MOVSI 2,7777
	NOPI
	HLOCK SWPPI
	IORM 2,CST3(1)		;MAKE PAGE UNASSIGNED
	HULOCK SWPPI
	OKPI
DECRR:	POP P,2
	POP P,3
	RET

;SWAP OUT PAGE REQUESTED BY PROCESS

SWPOT0:	TLNE 1,17		;IN CORE?
	RET			;NO
	PUSH P,2
	PUSH P,7
	MOVE 7,FORKX
	MOVE 2,CST0(1)
	TLNN 2,(7B2)		;IN USE?
	JRST SWPOT1		;NO
	HLRZ 2,CST3(1)		;ASSIGNMENT
	ANDI 2,7777
	CAIE 2,0(7)		;ASSIGNED HERE?
	JRST SWPOT1		;NO
	SOS FKWSP(2)
	MOVSI 2,7777
	IORM 2,CST3(1)		;DEASSIGN IT
	MOVE 2,CST1(1)
	TLNE 2,-PLKV		;CAN SWAP IT OUT?
	JRST [	AOS BALSHC	;NO, CHARGE TO OVERHEAD
		AOS SUMNR
		JRST SWPOT1]
	MOVSI 2,DWRBIT
	TDNE 2,CST3(1)		;BEING WRITTEN?
	JRST SWPOT1		;YES
	PUSH P,3
	PUSH P,4
	PUSH P,5
	CALL SWPOUT
	POP P,5
	POP P,4
	POP P,3
SWPOT1:	POP P,7
	POP P,2
	RET

;GARBAGE COLLECT CORE, REMOVE PAGES OF PROCESSES NOT IN BAL SET

GCCOR0:	JSP 4,STIME		; ENTER HERE TO DEPG ALL RPLQ
	JRST GCCORX		; CALLED FROM GCALC

GCCOR:	JSP 4,STIME		;TIME GCCOR ACTIVITY
	AOS NGCCOR		;COUNT OCCURRANCES
	CALL PRSTOP		;STOP OTHER CPU
	MOVE 1,NRPMIN
	MOVE 3,NOF
	CAIL 3,NOFN-12
	MOVE 1,NRPLQ		;GETTING CLOSE TO FILLING OFN
	CAMLE 1,NRPLQ
GCCORX:	MOVE 1,NRPLQ		;  INSPECT N PAGES
	JUMPE 1,GCPC2		;N MAY BE 0 ...
	HRRZ 7,RPLQ		;ON REPLACABLE QUEUE
GCPC1:	MOVEI 3,0(7)
	SUBI 3,CST3		;GET PAGE NUMBER
	CALL DEPG		;UNDO POINTER AND FLUSH BACK PTR,
	SETZM CST2(3)		;THUS UNLOCKING OWNING PT
	HRRZ 7,0(7)
	SOJG 1,GCPC1
GCPC2:	PUSH P,10
	MOVE 10,NRPLQ
	ADD 10,IOIP		;WRITES NOW IN PROGRESS
	MOVN 1,BALSHC		;RESET COUNT OF PAGES RETAINED IN
	ADDM 1,SUMNR		;BALSET BECAUSE OF SHARING
	SETZB 11,BALSHC		;INIT WORD TO HOLD USE BITS OF BALSET
	MOVEI 5,BALSET		;PROCESSES
	SETZ 2,0		;COUNT BALSET ENTRIES
GCCOR3:	CAML 5,FBALS		;LOOKED AT ALL BALSET PROCESSES?
	JRST  [ CAME 2,SUMNR
		JFCL
		MOVEM 2,SUMNR
		JRST GCCOR2]
	MOVE 1,0(5)
	TLNE 1,(1B2+1B3)	;VALID PROCESS NUMBER?
	AOJA 5,GCCOR3		;NO
	HRRZ 1,FKCNO(1)
	IOR 11,BITS(1)		;PROCESS IN BALSET
	HRRZ 1,0(5)
	HRRZ 1,FKNR(1)
	ADDI 2,0(1)		;ADD FKNR'S
	AOJA 5,GCCOR3

GCCQ1:	AOS BALSHC		;CHARGE TO OVERHEAD
GCCQ:	HLRZ 2,CST3(6)		;GET FORK ASSIGNMENT
	ANDI 2,7777
	CAIGE 2,NFKS		;NONE?
	SKIPL FKPT(2)		;OR CURRENTLY EXISTENT FORK?
	JRST GCC1		;YES
	CALL SOSWSP
	MOVSI 1,7777		;PAGE ASSIGNED TO DELETED FORK
	IORM 1,CST3(6)		;REMOVE ASSIGNMENT
	JRST GCC1

;DECREMENT WSP AND RELEASE CORE NUMBER IF WSP 0

SOSWSP:	SOS 1,FKWSP(2)
	TRNE 1,777777		;WSP NOW 0?
	RET			;NO
	HLRZ 1,FKPT(2)
	CAIN 1,LOLST		;ON LOW PRIORITY LIST
	RET
	CAIE 1,GOLST		;PROCESS STILL ACTIVE?
	CAIGE 1,NBP
	RET			;YES, DON'T RELEASE NUMBER
	HRRZ 1,FKCNO(2)
	JUMPE 1,R		;NO NUMBER (?)
	HLLZS FKCNO(2)
	MOVE 1,BITS(1)
	IORM 1,FRECB
	RET

GCCOR2:	ANDCAM 11,PUBCL		;FOR PROCESSES WHICH CAME BACK IN BALSET
	MOVE 6,SWPCOR		;START AFTER RES MON
	SETZ 5,			;BITS FOR PROCESSES
GCC2:	LDB 1,[POINT 6,CST0(6),5] ;CODE FIELD
	CAIN 1,2		;READ COMPL?
	JRST [	CAMGE 10,NRPMIN	;TIGHT FOR CORE?
		JRST GCCS	;YES, GRAB A PRELOADED PAGE
		HRRZ 2,CST0(6)	;GET NO. OF INITIATING FORK
		CAIGE 2,NFKS	;IF NOT A FORKX,
		SKIPGE 3,FKPT(2) ;OR FORK DELETED?
		JRST GCCS	;FLUSH PAGE
		HLRZ 2,3
		MOVSI 1,(1B3)
		CAIGE 2,NBP	;IF FORK NOT IN BALSET,
		TDNE 1,BALSET(3) ;OR BEING FLUSHED
		JRST GCCS	;COLLECT PAGE
		JRST GCC1]	;LEAVE PAGE
	CAIGE 1,10		;PAGE IN USE
	JRST GCC1		;NO
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;PAGE NOW ASSIGNED?
	JRST GCCS		;NO, COLLECT IT
	MOVE 1,PUBCL		;PROCESS BITS TO BE CLEARED
	ANDCAB 1,CST0(6)
	SKIPGE 3,FKPT(2)	;FORK HAS BEEN DELETED?
	JRST GCCS		;YES, COLLECT
	HLRZ 3,3		;CURRENT LOCATON
	CAIE 3,WTLST		;ON WAIT LIST, OR
;
;   I4 CHANGE
	CAIN 3,GOLST
	JRST GCCS
	CAIE 3,LOLST	;LOW PRIORITY QUEUE
	CAMG 10,NRPMIN
	JRST GCCS
	JRST GCC1
;	THE FOLLOWING IS EFFECTIVELY NO-OPED
;
	TDNN 1,11		;NO USERS IN BALSET?
	JRST GCCS		;YES, COLLECT
	CAIL 3,NBP		;OWNER IN BALSET?
	JRST GCCOR4		;NO
	HRRZ 3,FKPT(2)
	MOVSI 1,(1B3)
	TDNN 1,BALSET(3)	;OWNER LEAVING BALSET?
	JRST GCC1		;NOW ASSIGNED TO BALSET PROCESS
GCCOR4:	AOS BALSHC
	JRST GCC1

GCCS:	;;;CAML 10,NRPLEV	;GOT ENOUGH PAGES?
;;;	SKIPGE CGFLG		;AND NOT FORCED GC?
;;;	JRST .+2		;NO, KEEP COLLECTING
;;;	JRST GCC1		;YES, CONTINUE SCAN BUT DON'T COLLECT
	MOVE 2,CST1(6)		;BACKUP ADDRESS
	TLNE 2,-PLKV		;PAGE LOCKED?
	JRST GCCQ1		;YES, LEAVE IT
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;PAGE BEING WRITTEN?
	JRST GCCQ		;YES, LEAVE IT
	MOVE 1,CST0(6)
	TLNN 1,(7B2)		;PAGE ASSIGNED?
	JRST GCCS1		;NO
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;ASSIGNED?
	JRST GCCS1		;NO
	CALL SOSWSP
GCCS1:	MOVEI 1,0(6)		;SWAPOUT
	PUSH P,5
	CALL SWPOUT
	AOJ 10,			;COUNT PAGES COLLECTED
	POP P,5
GCC1:	CAMGE 6,NHIPG		;STOP AFTER HIGHEST KNOWN PAGE
	AOJA 6,GCC2
	MOVE 1,BALSHC
	ADDM 1,SUMNR		;UPDATE TOTAL RESERVE FOR SHARED PAGES
	SETZM PUBCL
	SETZM CGFLG
	SETZM REMFLG
	CALL PRGO		;START OTHER CPU
	POP P,10
	JSP 4,ETIME		;END TIMING OF GCCOR
	ADDM 1,SKDTM2		;CLOCK FOR GCCOR TIME
	RET

;INITIATE SWAP OF PAGE
;CALLED IN SCHEDULER FROM GCCOR

SWPOUT:	IFN KIFLG,<AOS KIRFLG>	;FORCE RESETTING OF UPTS
	SKIPN 2,CST2(1)		;GET BACKUP
	JRST BKUPN		;PAGE HAS NO BACKUP, FLUSH IT
	TLNE 2,-1		;SPT?
	JRST SWPU1		;NO
	MOVE 3,SPT(2)
	TLNN 3,-1B31		;SHARE COUNT 0?
	JRST BKUPD		;YES, SWAP TO DISK
	CAIL 2,NOFN		;OFN?
	JRST BKUPS		;NO, SHARED PAGE. GO CHECK REQUEST BIT
	MOVE 2,CST1(1)		;YES, CHECK BACKUP ADDRESS
	TLNN 2,10		;DISK?
	JRST BKUP0		;NO, DRUM ADR ALREADY ASSIGNED
	SKIPL DRUMP		;YES, MUST ENSURE SWAP TO DRUM
	SKIPG DRMFRE
	JRST SWPO3		;OR LEAVE IN CORE IF CAN'T
	JRST SWOFN		;GO ASN DRM ADR, EVEN IF DRM SPC LOW

BKUP0:	MOVE 2,CST1(1)		;CORE PAGE NUMBER IN 1, GET BACKUP ADR
	TLNE 2,16
	TLNE 2,10		;DISK OR NOTHING?
	JRST SWPO4		;YES
	TLZE 2,1		;NEWLY ASSIGNED DRUM ADDRESS? (POSTPG)
	JRST [	MOVEM 2,CST1(1)	;YES, REMOVE NEW BIT
		CALL GDSTX
		JRST SWPP1]	;AND WRITE OUT PAGE
	MOVE 3,CST0(1)		;NO, DRUM.
	TLNE 3,(CORMB)		;PAGE WRITTEN INTO?
	JRST SWPO1		;YES
	LDB 3,[POINT 6,CST0(1),5]
	CAIE 3,2
	JRST SWPOQ1
	HRRZ 3,CST0(1)	
	CAIN 3,-1
	JRST SWPO10
SWPOQ1:	HRRZ 3,CST1(1)
	SKIPN DNOGO
	CAMGE 3,MAXDRM
	JRST SWPOQ
	JRST SWPO9
SWPOQ:	MOVE 3,CST0(1)
	TLNE 3,77B23		;PAGE NOW ON REPLACABLE QUEUE?
	JSP 4,ONRQ		;NO, PUT IT THERE
SWPO3:	RET

SWPU1:	HLRZ 2,2		;GET PTN
	CAIGE 2,NOFN		;FILE?
	JRST BKUPD		;YES, SWAP TO DISK
BKUPS:	MOVE 2,CST3(1)
	TLNE 2,DSKSWB		;SWAP TO DISK REQUESTED?
	JRST BKUPDR		;YES
	JRST BKUP0		;PROCESS, SWAP TO DRUM

SWPO1:	CALL GDSTX
SWPO5:	MOVSI 3,BWRBIT		;SET BACKUP WRITTEN BIT
	IORM 3,DST(2)
SWPO2:	MOVSI 3,(CORMB)
	ANDCAM 3,CST0(1)	;CLEAR WRITTEN BIT
	LDB 3,[POINT 6,CST0(1),5]
	CAIE 3,2
	JRST SWPO6
	HRRZ 3,CST0(1)
	CAIE 3,-1
	JRST SWPO6
SWPO10:	PUSH P,[CALL DRMASD]	;ASS. DISK ADDR.
SWPO8:	MOVE 2,CST1(1)		;GET DRUM ADDRESS
	CALL GDSTX
	PUSH P,DST(2)		;SAVE OLD DST
	SETOM DST(2)
	PUSH P,1
	MOVE 1,CST1(1)
	CALL DASDRM		;REL. DRUM PAGE
	XCT -2(P)		;ASS. NEW ADDRESS
	BUG(HLT,<DRUM FULL-IMPOSSIBLE>)	;DRUM FULL-IMPOSSIBLE
	MOVE 2,1
	MOVE 1,-2(P)
	MOVEI 3,0(2)
	CAML 3,MAXDRM		;ON DRUM ASSIGNED
	JRST  [ CAME 1,[CALL DRMASD] ;TRYING TO ASSIGN DRUM
		SETOM DNOGO	;YES, FLAG NO MORE DRUM
		JRST .+1 ]
	POP P,1
	DPB 2,[POINT 22,CST1(1),35];PUT NEW ADDRESS IN CST
	CALL GDSTX
	POP P,DST(2)		;STORE BACKUP ADDRESS
	POP P,2			;REMOVE CALL ADDRESS
SWPO7:	MOVEI 3,4
	DPB 3,[POINT 6,CST0(1),5];WRITE IN PROGRESS
	AOS IOIP
	HRLI 1,DWRBIT
	CALL DRMIO		;INITIATE DRUM WRITE
	AOS DRMWR		;COUNT DRUM WRITES FOR STATISTICS
	JRST SWPO3

SWPO6:	HRRZ 2,CST1(1)
	SKIPN DNOGO
	CAMGE 2,MAXDRM		;ON DRUM
	JRST SWPO7		;YES
SWPO9:	PUSH P,[CALL DRMASN]	;ASS TRUE DRUM ADDRESS
	JRST SWPO8


SWPO4:	MOVSI 3,SWPERR
	TDNE 3,CST3(1)		;ERROR READING FROM DISK?
	JRST BKUPN		;YES, DON'T WRITE IT
	MOVE 3,DRMFRE
	SKIPLE DISKP		;IF NO DISK, DON'T MAKE ADD'L SWAP ADRS
	CAMGE 3,DRMIN0		;DRUM NEARLY FULL?
	TLNN 2,10		;YES, SEND TO DISK IF HAVE DISK ADDRESS
	SKIPGE DRUMP		;SWAPPING POSSIBLE?
	JRST [	TLNE 2,10	;NO, DID WE HAVE A DISK ADDRESS?
		JRST BKUPD	;YES, SEND TO DISK (WHATEVER IT IS)
		JRST SWPO3]	;NO PLACE TO PUT PAGE, LEAVE IT IN CORE
SWOFN:	PUSH P,1
	CALL DRMASN		;ASSIGN DRUM ADDRESS
	BUG(HLT,<DRUM COMPLETELY FULL>)
	MOVE 2,1
	POP P,1
	MOVE 4,CST1(1)		;GET PREVIOUS BACKUP ADDRESS
	MOVEM 2,CST1(1)		;SET DRUM AS NEW BACKUP ADDRESS
	CALL GDSTX
	MOVEM 4,DST(2)		;PREVIOUS BACKUP ADDRESS TO DST
	PUSH P,2
	MOVE 2,CST1(1)
	CALL STBTWD		;SET REF. FLAG
	POP P,2
SWPP1:	MOVE 3,CST0(1)
	TLNE 3,(CORMB)		;PAGE WRITTEN WHILE IN CORE?
	JRST SWPO5		;YES, SET BACKUP WRITTEN BIT ALSO
	JRST SWPO2		;NO

;SWAP PAGE TO DISK

BKUPD:	MOVSI 2,DSKSWB
	ANDCAM 2,CST3(1)	;FLUSH REQUEST BIT IF ANY
BKUPDR:	MOVE 2,CST1(1)		;GET BACKUP ADDRESS
	TLNN 2,16		;NONE?
	JRST BKUP7		;YES
	TLNE 2,10		;DISK?
	JRST BKUP3		;YES
	CALL GDSTX		;DRUM
	MOVE 3,DST(2)		;GET NEXT LEVEL BACKUP ADDRESS
	MOVSI 4,(CORMB)
	TLZE 3,BWRBIT		;WRITTEN SINCE BACKUP?
	IORM 4,CST0(1)		;YES, SET CORE WRITTEN BIT
	SETOM DST(2)		;RELEASE DST SLOT
	EXCH 3,CST1(1)
	PUSH P,1
	MOVE 1,3
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,1
	JRST BKUPDR

BKUP7:	BUG(HLT,<BKUPD - BAD CST1 ENTRY OR INCONSISTENT CST>)

BKUP3:	MOVSI 3,(CORMB)		;CLEAR CHANGED IN CORE BIT
	MOVSI 2,SWPERR
	TDNN 2,CST3(1)		;DON'T WRITE IF ERROR FROM READ
	TDNN 3,CST0(1)		;CHANGED?
	JRST BKUPN		;NO, DON'T HAVE TO WRITE
	ANDCAM 3,CST0(1)
	HRLI 1,DWRBIT		;REQUEST WRITE
	AOS DSKWR		;COUNT IT FOR STATISTICS
	AOS IOIP		;NOTE WRITE IN PROGRESS
	MOVSI 3,NEWFB
	ANDCAM 3,CST1(1)	;MAKE SURE NO NEWFB STILL AROUND
	MOVEI 3,4		;INDICATE WRITE IN PROGRESS
	DPB 3,[POINT 6,CST0(1),5]
	CALL DSKIO
	JRST SWPO3

BKUPN:	MOVE 3,CST0(1)
	JRST SWPOQ		;GO PUT PAGE IN QUEUE

;PAGER TRAP

PGRTRP:	XWD TRAPPC,.+1
	SKIPN INSKED
	CONSZ PI,177B27		;FROM PI ROUTINE?
	BUG(HLT,<PAGER TRAP FROM SCHEDULER OR WHILE PI IN PROGRESS>)
	AOSLE NSKED
	AOSGE INTDF
	BUG(HLT,<PAGER TRAP WITH BAD NSKED OR INTDF>)
	AOSE TRAPC		;FIRST TRAP?
	JRST PGRT4		;NO, GO CHECK RECURSIVE OR ITERATIVE
	MOVEM P,TRAPAP		;SAVE AC-P
	MOVE P,TRAPSP		;SETUP TRAP STACK
	AOS UTRPCT		;COUNT TRAPS (BUT NOT RECURSIVE ONES)
	PUSH P,7		;SAVE AC'S 1-7
PGRT2:	ADD P,BHC+6
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	MOVEM 1,-5(P)		;FASTER THAN BLT OR PUSH
	MOVEM 2,-4(P)
	MOVEM 3,-3(P)
	MOVEM 4,-2(P)
	MOVEM 5,-1(P)
	MOVEM 6,0(P)
	MOVE 1,TRAPPC		;RETURN
	PUSH P,1		;SAVE IT
	TLNE 1,UMODF		;FROM USER?
	MOVEM 1,UPDL		;YES, LEAVE IT WHERE IT CAN BE FOUND
PGRT3:	SKIPE TRAPC		;IF RECURSIVE TRAP,
	PUSH P,TRAPSW		;OLD STATUS WORD
	PUSH P,TRAPWD		;WRITE DATA
	MOVE 1,TRAPS0		;FROM WHERE PAGER STORED IT
	TLNE 1,(1B10+1B12)	;PI CYC OR NXM?
	BUG(HLT,<PAGER TRAP ON PI CYCLE OR NXM>)
	MOVEM 1,TRAPSW		;TO SAFE PLACE
	SKIPE TRAPC
	JRST PGRT5		;NESTED TRAP, DON'T COUNT TIME TWICE
	JSP 3,UCLOCK		;INIT CLOCK TO TIME TRAP CODE
	PUSH P,FKRT
   IFN  KIFLG,<
	PUSH P,KIMAC1		;SAVE MUUO TEMPS
	PUSH P,KIMAC2>
PGRT5: 	
	SETZM TRAPPC		;INDICATE TRAP STARTED
	DLOCK SYSLCK		;LOCK SYSLOCK
PGRTD:	HLLZ 1,TRAPSW		;GET TRAP STATUS
	TLNE 1,(1B9)		;PARITY ERROR?
	JRST PGRME		;YES
	SETZ 2,
	ROTC 1,2		;GET TOP 2 BITS
	MOVE 3,TABA(2)		;APPROPRIATE DISPATCH TABLE
	JFFO 1,.+2		;FIND TRAP-CAUSING BIT
	BUG(HLT,<PAGER TRAP WITH BAD OR MISSING TRAP STATUS WORD>)
	MOVE 7,FORKX		;GET FORK AND PROCESS NUMBER
	JRST 0(3)

PGRT4:	PUSH P,7		;TRAPSK ALREADY EXISTS
	HRRZ 7,TRAPPC		;CHECK TRAP PC FOR EITHER OF THE
	CAIE 7,PGMV1+1		;WRITE INSTRUCTIONS DONE TO
	CAIN 7,PGMV2+1		;FINISH UP A WRITE TRAP
	SOSA TRAPC		;TRAP IS ITERATIVE NOT RECURSIVE
	JRST PGRT2		;TRUE RECURSIVE TRAP
	SOS NSKED		;UNDO EFFECTS OF ENTERING TRAP CODE
	SOS INTDF
	POP P,7			;ADJUST VARIABLES AND REPROCESS TRAP
	JRST PGRT3

PGRME:	MOVE 2,[SIXBIT /PAGER/]
	MOVEM 2,DEVMPE		;REQUEST CORE SCAN
	ISB APRCHN
	BUG(CHK,<PARITY ERROR DETECTED BY PAGER>)
	JRST PGUNTP		;TRY AGAIN

;DISPATCH PROCEDURE FOR TRAP STATUS BITS

TABA:	EXP TRP0,TRP1,TRP2,TRP3

TRP1:	CAIL 2,7
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB1(2)

TAB1:	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	JRST NIC		;SHARED NOT IN CORE
	JRST NIC		;PAGE TABLE NOT IN CORE
	JRST NIC		;2ND INDIRECT PRIV NOT IN CORE
	JRST NIC		;INDIRECT SHARED NOT IN CORE
	JRST NIC		;IND PT NIC
	JRST ILIND		;EXCESSIVE IND.

TRP2:
TRP3:	CAIL 2,7		;INDIRECT OR ORIGINAL PT EQUIVALENT
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB2(2)

TAB2:	JRST NIC		;PRIVATE NOT IN CORE
	JRST WCPY		;WRITE COPY TRAP
	JRST UTRP		;USER TRAP
	JRST NPG		;ACCESS (OR BIT 10-11 = 3)
	JRST ILRD		;ILLEGAL READ OR XCT
	JRST ILWR		;ILLEGAL WRITE
	BUG(HLT,<PAGER TRAP ON ALR VIOLATION OR ILLEGAL FORMAT>)

;TRAP CODE 0, CST WORD BITS 0-2 = 0

TRP0:	CALL GETTPD		;DECODE EFFECTIVE ADDRESS
	TLNE 2,17		;PAGE MUST BE IN CORE
	JRST NIC
	HLRZ 1,CST0(2)		;GET AGE CODE
	LSH 1,-^D12
	CAIL 1,10
	JRST NIC		;CHANGED STATE RECENTLY
TRP0A:	CAIN 1,6		;READ IN PROGRESS?
	JRST TRP0R		;YES, WAIT FOR IT TO FINISH
	CAIN 1,2		;READ COMPLETED?
	JRST NICN		;YES, GO GET IT
	CAIE 1,4		;SNATCHING BACK PAGE?
	CAIN 1,0
	CAIA			;YES
	JRST NIC		;NO, GO AHEAD
	CALL CHKRPQ		;MAKE SURE ENOUGH PAGES
	JRST .+2		;WASN'T, HAD TO RESKED
	JRST NIC		;OK
	CALL GETTPD
	TLNE 2,17		;STILL IN CORE?
	JRST NIC		;NO
	HLRZ 1,CST0(2)
	LSH 1,-^D12
	CAIL 1,10
	JRST NIC
	JRST TRP0A

TRAPSP:	IOWD NTSK,TRAPSK	;POINTER TO LOCAL STACK

;ASSIGN PAGE AND SET AGE

AGESET:	MOVE 7,FORKX
AGESN:	PUSH P,2
	MOVEI 2,0(1)
AGES1:	HLRZ 1,CST0(2)
	LSH 1,-^D12
	CAIL 1,10		;NOW ASSIGNED?
	JRST [	HLRZ 1,CST3(2)	;YES, FIND OUT WHERE
		ANDI 1,7777
		CAML 2,SWPCOR	;NOT SWAPPABLE PAGE? OR
		CAIN 1,0(7)	;THIS PROCESS?
		JRST AGES2	;YES, OK
		CAIL 1,NFKS	;ANY PROCESS?
		JRST ATP1	;NO
		PUSH P,2
		MOVEI 2,0(1)
		CALL SOSWSP	;REDUCE WSP
		POP P,2
		JRST ATP1]	;GO ASSIGN TO THIS PROCESS
AGESX:	XCT TRP0T(1)
AGES2:	MOVEI 1,0(2)
	POP P,2
	RET

TRP0T:	JRST ATP0		;AVAILABLE AND ON REPLACABLE QUEUE
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP1R		;READ COMPLETED
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP4		;WRITE IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP2		;READ IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)

TRP0R:	MOVSI 1,0(2)
	HRRI 1,SWPRT
	CALL PGIWT		;WAIT FOR PAGE AND ACCOUNT
	JRST NICN

ATP1R:	MOVSI 1,SWPERR		;CHECK FOR ERROR ON READ
	TDNN 1,CST3(2)
	JRST ATP1		;NO ERROR
	PUSH P,2
	MOVEI 1,^D11		;FILE DATA ERROR PSI CHANNEL
	MOVEI 2,0(7)		;GET FORK NUMBER
	CALL PSIRQ		;INTERRUPT THE FORK
	RESKED
	POP P,2
	JRST ATP1

ATP2:	MOVSI 1,0(2)
	HRRI 1,SWPRT		;READ NOW IN PROGRESS OR COMPLETED
	JSYS SCHEDP		;RESCHEDULE UNTIL AVAILABLE
	JRST AGES1		;CHECK AGE AGAIN

ATP4:	
	HLOCKI SWPPI		;LOCK SWPPI
	LDB 1,[POINT 6,CST0(2),5] ;GET GUARANTEED UP TO DATE STATE
	CAIE 1,4		;WRITE IN PROGRESS?
	JRST [	HULOCK SWPPI	;RELEASE LOCK
		OKPI		;NOT WRITE, LOOK AT STATE AGAIN
		JRST AGES1]
	SETZM CST0(2)		;INHIBIT COMPLETION ACTION
	HULOCK SWPPI		;RELEASE LOCK
	OKPI
	SOS IOIP
	JRST ATP1

ATP0:	SOS NRPLQ		;ONE LESS PAGE ON REPLACABLE
	HLOCKI SWPPI		;LOCK SWPPI
	MOVE 1,CST3(2)		;UNQUEUE PAGE FROM REPLACABLE
	HLLM 1,0(1)
	MOVS 1,1
	HLRM 1,0(1)
	HULOCK SWPPI		;RELEASE LOCK
	OKPI
	SETZM CST3(2)
ATP1:	AOS 1,FKWSP(7)		;INCREASE OWNERSHIP COUNT
	PUSH P,2
	MOVEI 1,0(1)
	PUSH P,1
	HRRZ 2,FKPT(7)		;GET PROCESS NUMBER
	MOVSI 1,1B21
	TDNE 1,BALSET(2)	;HALF REMOVED PROCESS?
	JRST ATP1A		;YES
	HRRZ 1,FKNR(7)		;GET CURRENT RESERVE
	CAML 1,0(P)		;LESS THAN CURRENT SIZE?
	JRST ATP1A		;NO, OK
	SUB 1,0(P)		;YES, CALCULATE DIFFERENCE
	MOVN 1,1
	ADDM 1,FKNR(7)		;INCREASE RESERVE
	ADDM 1,SUMNR
ATP1A:	SUB P,BHC+1		;FLUSH GARBAGE
	HLRZ 1,FKNR(7)		;GET UPDATED AGE
	POP P,2			;RESTORE PAGE NUMBER
	HLOCKI SWPPI
	DPB 1,[POINT 9,CST0(2),8]	;NEW AGE OF PAGE
	DPB 7,[POINT 12,CST3(2),17]	;ASSIGN PAGE TO PROCESS
	HLLZS CST0(2)		;CLEAR PUB FIELD
	HULOCK SWPPI
	OKPI
	JRST AGES2

;ILLEGAL REFERENCE TRAPS

ILRD:	MOVEI 1,^D16		;MR TRAP CHANNEL
	MOVE 2,TRAPSW
	TLNE 2,2		;EXECUTE REFERENCE?
	MOVEI 1,^D18		;YES, MX
ILRF:	CALL PSIRQ0		;REQUEST INTERRUPT, THIS FORK
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;IN CASE USER WANTS TRAP STATUS
	MOVE 2,<-2*KIFLG-1>(P)		;WRITE DATA (ASSUMING TOP-LEVEL TRAP)
	MOVEM 2,UTRWD
	MOVE 2,<-2*KIFLG-2>(P)		;PC
	TLNN 2,UMODF		;USER?
	SKIPGE INTDF		;OR INTERRUPTABLE?
	JRST .+3		;YES
	TLNE 1,12		;MUST DEFER INTERRUPT, READ REF?
	AOS <-2*KIFLG-2>(P)		;YES, DONOT RESTART INSTRUCTION
	TLO 1,12		;SET BITS TO PREVENT WRITE-COMPLETION
	MOVEM 1,TRAPSW		;ACTION ON UNTRAP
	JRST PGUNTP

ILWR:	MOVE 1,TRAPSW
	TLNE 1,1		;MON REF BELOW 400000?
	TRNE 1,400000
	SKIPA 1,[^D17]		;NO, INITIATE MW INTERRUPT
	BUG(HLT,<ATTEMPTED MODIFY REFERENCE TO PROTECTED MONITOR>)
	JRST ILRF

ILIND:	MOVE 1,TRAPSW		;SEE IF READ OR WRITE
	TLNE 1,12
	JRST ILRD		;GIVE READ TRAP INTERRUPT
	JRST ILWR		;OR WRITE TRAP INTERRUPT

UTRP:	MOVEI 3,TRAPUB
	CALL GETTD1		;FIND PAGE WITH TRAPUB SET
	TLNN 2,(3)		;ANY CHANGES WHILE UNPROTECTED?
	JRST PGUNTP		;BIT NOT SET ANYMORE
	HLRZ 6,1
	CAIGE 6,NOFN		;COULDN'T BE IN FILE XB
	BUG(HLT,<TRAP-TO-USER IN FILE INDEX BLOCK>)
	CALL SETSPG		;MAP PT HOLDING PTR
	MOVSI 2,TRAPUB
	ANDCAM 2,CSWPGA(1)	;CLEAR THE BIT
	CALL RELSPG
	MOVEI 1,^D21
	CALL PSIRQ0		;INTERRUPT ON CHN 21
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;SAVE TRAP STATUS WORD ONLY
	JRST PGUNTP		;FINISH UP WRITE IF ANY AND UNTRAP

;PAGE NOT IN EXISTANCE TRAPS

NPG:	MOVE 1,TRAPSW
	TLNE 1,1		;MONITOR?
	JRST [	MOVEI 1,0(1)	;YES, LEGAL PAGE?
		CAIL 1,JSB
		CAIL 1,JSB+1000
		CAIA
		JRST MILRF1
		CAIL 1,PPMA
		CAIL 1,DDPG1A
		JRST NPG1	;YES
		JRST MILRF1]	;MONITOR MALFUNCTION
NPG1:	CALL GETTPD		;NEW PAGE NEEDED
	HLRZ 6,1		;GET PT NUMBER
	CAIGE 6,NOFN		;MUST BE PT, NOT OFN
	JRST NPG2
	CALL SETSPG		;MAP IT
	SKIPE 2,CSWPGA(1)	;BE SURE PT SLOT NOW EMPTY
	JRST NPGBAD		;IT'S NOT, PROBABLY SPURIOUS TRAP
	MOVSI 2,RWXB+1
	MOVEM 2,CSWPGA(1)	;SETUP NULL POINTER
	CALL RELSPG		;RELEASE MAP
	MOVE 1,PSICHM
	MOVE 2,TRAPSW
	TLNN 2,1		;USER MAP, AND
	TRNN 1,1B22		;CHANNEL 22 ON?
	JRST NIC		;NO
	MOVEI 1,^D22		;YES, REQUEST INTERRUPT
	CALL PSIRQ0
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW
	JRST NIC

MILRF1:	BUG(HLT,<ILLEGAL ADDRESS REFERENCE IN MONITOR>)

NPGBAD:
	CALL RELSPG		;CLEAN UP
	JRST PGUNTP		;GO UNTRAP AND TRY AGAIN

;THIS COULD CONCEIVABLY HAPPEN ON AN IND PTR TO A FILE FROM WHICH
;THE PAGE WAS REMOVED

NPG2:	JRST ILIND		;CAN ONLY GIVE TRAP TO USER

;COPY-ON-WRITE TRAP

WCPY:	MOVE 1,TRAPSW
	TLNE 1,(1B4+1B6)	;OTHER TRAPS ALSO?
	JRST [	TLZ 1,(1B3)	;YES, CLEAR WRITE COPY
		MOVEM 1,TRAPSW	;FROM TRAP CAUSE
		JRST PGRTD]	;AND GO HANDLE THE OTHER CAUSE
WCPY6:
	CALL GETTPD
	TLNE 2,17		;ACTUAL PAGE IN CORE?
	JRST NIC		;NO, GET IT IN FIRST
;
;   I4 CHANGE
	JUMPE 2,ILWR		;PAGE DOESNT EXIST AT ALL--ERROR
	LDB 3,[POINT 6,CST0(2),5]
	CAIN 3,6
	JRST WCPY5
;
	MOVEI 3,COPYB
	CALL GETTD1		;WILL STOP ON FIRST POINTER WITH COPYB
	TLNN 2,(3)		;ANY CHANGES WHILE UNPROTECTED?
	JRST NIC		;YES-TREAT AS NOT IN CORE
	HLRZ 6,1		;PTN
	CAIG 6,NOFN
	BUG(HLT,<COPY-WRITE POINTER IN INDEX BLOCK>)
	CALL SETSPG		;MAP THE PT
	MOVSI 2,RWX
	AND 2,CSWPGA(1)		;GET ACCESS OF SOURCE PAGE
	IOR 2,[XWD WRITEB+ACCESB+1,1] ;MAKE PRIV PTR WITH UNASS ADR
	EXCH 2,CSWPGA(1)	;EXCH IT WITH THE WC POINTER
	TLNN 2,SHRBIT+INDBIT	;IT SHOULD BE SHARED OR INDIRECT
	JRST WCPY4		;BUT IT'S NOT
	TLO 2,READB		;MAKE SURE WE CAN READ FROM THE PAGE
	MOVEM 2,PSB+CPYPG	;PUT THE ORIG POINTER IN MON MAP
	CALL RELSPG
	PUSH P,1		;SAVE ORIG PTN.PN
WCPY2:	MOVEI 1,CPYPG		;CONSTRUCT IDENT FOR COPY SOURCE PAGE
	HRL 1,FKPGS(7)
	CALL GETPGD		;TRACK IT DOWN
	TLNE 2,17		;IN CORE?
	BUG(HLT,<WCPY - PAGE SHOULD BE IN CORE HERE>)
	MOVEI 1,0(2)
	CALL AGESET		;FIX THE PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;AND LOCK IT DURING NEXT SWAPIN
	EXCH 1,0(P)		;SAVE CORE PN, GET ORIG PTN.PN
	CALL SWPINP		;THIS WILL COPY FROM CPYPG TO A NEW PAGE
	POP P,1
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK THE SOURCE PAGE
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
	CALL MRPT		;GET IDENT OF SHARE PAGE BEING RELEASED
	SETZ 1,			;INDIRECT TO FORK
	PUSH P,1
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
;   I4 CHANGE
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
;
	CALL RELMPG		;RELEASE THE ORIG PAGE FROM MON MAP
	CALL RELCPT		;CLEANUP FROM RELMPG
;;;	OKSKED
	POP P,1
	JUMPE 1,WCPY3		;IGNORE INDIRECT TO FORK PTR
	MOVE 5,0
	MOVE 6,11		;SAVE AC'S USED BY OFNJFN
	CALL JFNDCR		;DECREMENT MAP COUNT FOR JFN
	MOVE 0,5
	MOVE 11,6		;RESTORE AC'S
WCPY3:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	JRST NIC		;UPDATE STATS AND CONTINUE

WCPY4:	TLZ 2,COPYB		;MAKE IT LOOK LIKE WE COPIED IT
	TLO 2,WRITEB
	MOVEM 2,CSWPGA(1)
	CALL RELSPG
	JRST NIC2
;
;   I4 CHANGE
WCPY5:
	ULOCK SYSLCK		;UNLOCK SYSLCK
	MOVSI 1,0(2)
	HRRI 1,SWPRT
	JSYS SCHEDR
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK AGAIN
	JRST WCPY6
;

;NOT IN CORE TRAP

NICN:   ;;;	JSP 3,UCLOCK		;UPDATE CLOCKS
	JRST NICN1		;DON'T COUNT AS FAULT FOR IFAV

NIC:   ;;;	JSP 3,UCLOCK		;UPDATE CLOCKS
	JRST NICN2
	MOVE 1,IFAV		;UPDATE INTERFAULT AV
	FMPR 1,IFAVC0		;AV' = (C*AV + TIME)/(C+1)
	SETZ 2,
	EXCH 2,IFTIM		;ACCUMULATED TIME SINCE LAST FAULT
	FSC 2,233		;FLOAT IT
	FADR 1,2
	FDVR 1,IFAVC1
	MOVEM 1,IFAV
;  I4 CHANGE
NICN2:
	MOVE 2,JOBNO
	HRRZ 2,JOBNAM(2)	;GET SUBSYSTEM INDEX
	AOS SPFLTS(2)		;ACCOUNT PAGE FAULTS FOR SUBSYSTEM
NICN1:	LDB 1,[POINT 9,FKNR(7),8] ;GET LAST XGC AGE
	LDB 2,[POINT 9,FKNR(7),17] ;CURRENT AGE
	SUBI 2,0(1)		;NOW-THEN
	CAIGE 2,0		;WRAPAROUND?
	ADDI 2,1000-100		;YES
	CAML 2,GCRATE		;TIME FOR ANOTHER XGC?
	JRST NICMG		;YES
NICMG1:	CALL NICCKS		;CHECK FOR ALLOWABLE SIZE
NIC2:	MOVE 3,TRAPSW
	TLNN 3,1		;USER MAP REF?
	JRST [	LSH 3,-^D9	;YES, UPDATE WS BITS
		ANDI 3,777
		IDIVI 3,^D36
		MOVE 4,BITS(4)
		IORM 4,WSPGS(3)
		JRST .+1]
	CALL GETTPD		;DECODE TRAP ADDRESS
	JUMPE 2,NPG		;PAGE WENT AWAY
	TLNE 2,17		;PAGE IN CORE?
	JRST NIC6		;NO
	MOVEI 1,0(2)		;YES
	CALL AGESET		;SET AGE
	JRST PGUNTP		;RESUME PROCESS

NIC6:	TLNN 2,16		;UNASSIGNED ADR?
	JRST NIC6A		;YES
NIC6B:	CALL CHKRPQ		;CHECK FOR ENOUGH PAGES FREE
	JRST NIC2		;WASN'T, HAD TO RESKED
NIC8:	CALL SWPINW		;SWAP IN THE PAGE
	JRST NIC2

;ADJUST CAPT IF NECESSARY, THEN DO CORE MGT

NICMG:   ;;;	MOVE 1,IFAV		;CURRENT INTERFAULT AVERAGE
	JRST NICMG1
	FDVR 1,IFAMEA		;COMPUTE RATIO OF ACTUAL/DESIRED
	MOVE 2,CAPT		;CURRENT WINDOW SIZE
	MOVE 3,2
	ASH 3,-4		;ADJUST UP OR DOWN BY 1/16
	CAMGE 1,[0.5]		;IFAV NOW TO LOW?
	ADD 2,3			;YES, MAKE CAPT LARGER
	CAML 1,[1.5]		;IFAV NOW TO HIGH?
	SUB 2,3			;YES, MAKE CAPT SMALLER
	CAMLE 2,CAPTMX		;SEE IF CAPT WITHIN LIMITS
	MOVE 2,CAPTMX
	CAMGE 2,CAPTMN
	MOVE 2,CAPTMN
	MOVEM 2,CAPT
	CAMGE 1,[1.5]		;WAS IFAV TOO HIGH?
	JRST NICMG3		;NO
	HRRZ 2,FKNR(7)		;YES, REDUCE NR
	ASH 2,-4		;BY 1/16
	MOVN 2,2
	ADDM 2,SUMNR
	ADDM 2,FKNR(7)
NICMG3:	MOVE 1,CAPT		;USE CURRENT CAPT
	CALL XGC
	JRST NICMG1

;AVERAGE SWAP LATENCY * 2 - CONTROLS DESIRED INTERFAULT AVERAGE

SWPLAT:	40.0			;2 * 20MS FOR BRYANT DRUM
IFAMEA:	40.0			;IDEAL IFAV

AGTICK==^D20			;MILLISECONDS PER TICK OF AGE REGISTER
ICAPT:	^D1000/AGTICK		;WINDOW SIZE IN TICKS
CAPTMX:	^D1500/AGTICK		;MAX CAPT
CAPTMN:	^D500/AGTICK		;MIN CAPT
GCRATE:	^D1000/AGTICK		;RECIPROCAL OF GC FREQUENCY

;DECAY CONSTANT FOR INTERFAULT AVERAGE

IFAVC0:	EXP 100.0		;LARGER C IMPLIES SLOWER IFAV CHANGE
IFAVC1:	EXP 101.0		;IFAVC0+1

NIC6A:	TLNE 1,-1		;IN SPT?
	JRST [	HLRZ 6,1	;NO, GET XB
		CAIL 6,NOFN	;OFN?
		JRST NIC6B	;NO
		CALL SETSPG
		MOVSI 2,PLKV
		ADDM 2,CST1(6)	;LOCK PT WHILE ASSIGNING
		CALL RELSPG
		HLRZ 2,1
		JRST NIC6C]
	HLRZ 2,SPTH(1)		;GET OWNING PT
	JUMPE 2,NIC6B		;IGNORE IF NONE OR NOT OFN
	CAIL 2,NOFN
	JRST NIC6B
NIC6C:	PUSH P,1
	MOVE 1,SPTH(2)		;CLASS, TRACK, ETC.
;;;	ULOCK SYSLCK		;RELEASE LOCK
;;;	OKSKED
	CALL DSKASN		;ASSIGN DISK ADDRESS FOR FILE PAGE
	JRST NIC6D		;RAN OUT
	;			TEST FOR DISK ASSIGNMENT WHILE UNPROTECTED
;;;	NOSKED
;;;	DLOCK SYSLCK		;GET SYSLCK
	PUSH P,1
	MOVE 3,TRAPSW
	CALL GETTPD
	TLNE 2,17		;PAGE NOW IN CORE
	TLNE 2,16
	JRST [	;ULOCK SYSLCK	;PAGE WAS ASSIGNED IN MEANTIME
		POP P,1
		CALL DEDSK	;RELEASE DISK SPACE
		POP P,1
		;DLOCK SYSLCK	;TRY AGAIN
		JRST NIC2]
	POP P,2
	TLO 2,NEWFB		;INDICATE PAGE NEVER PREVIOUSLY WRITTEN
	POP P,1
	TLNN 1,-1		;IN SPT?
	JRST [	DPB 2,[POINT 22,SPT(1),35] ;YES, STORE NEW ADDRESS
		JRST NIC6B]	;NOW GO SWAP IN PAGE
	HLRZ 6,1
	CALL SETSPG		;MAP XB
	DPB 2,[POINT 22,CSWPGA(1),35] ;STORE NEW ADDRESS IN XB
	MOVSI 2,-PLKV
	ADDM 2,CST1(6)		;UNDO LOCK ABOVE
	CALL RELSPG
	JRST NIC6B		;NOW PROCEED WITH SWAP

NIC6D:	POP P,1
	TLNN 1,-1		;IN SPT?
	JRST NIC6E		;YES
	HLRZ 6,1		;NO, MUST UNDO LOCK
	CALL SETSPG
	MOVSI 2,-PLKV
	ADDM 2,CST1(6)
	CALL RELSPG
NIC6E:	MOVEI 1,OPNX10		;'NO ROOM'
	MOVEM 1,LSTERR
	MOVEI 1,^D20		;MACH SIZE EXCEEDED INT CHANNEL
	JRST ILRF		;GENERATE ILLEG REF INT

;CHECK FOR SUFFICIENT PAGES ON RPLQ

CHKRPQ:	MOVE 2,NSKED
	CAILE 2,1		;NOSKED PROCESS?
	JRST RSKP		;YES, ALLOW PAGE
	MOVE 2,NRPMX		;OTHERWISE, ALLOW PAGE IF NRPLQ ABOVE
	CAMN 7,FXBST		;MINIMUM, WHICH IS MINNR FOR FAVORED
	MOVEI 2,MINNR		;FORK, NRPMX FOR OTHERS
	CAMGE 2,NRPLQ
	JRST RSKP		;ALLOW PAGE
	ULOCK SYSLCK		;RELEASE SYSLCK
	OKSKED			;NO, MUST WAIT FOR MORE PAGES
	MOVEI 1,TRP0CT
	HRLI 1,0(2)		;MINIMUM NRPLQ
	JSYS SCHEDP
	NOSKED
	DLOCK SYSLCK		;GRAB SYSLCK
	RET			;RETURN NOSKIP BECAUSE RESKED DONE

TRP0CT:	HRRZ 2,FKPT(7)
	MOVSI 3,(1B3)
	TDNE 3,BALSET(2)	;FORK TO BE REMOVED?
	JRST 1(4)		;YES, ALLOW IT TO RESUME
	MOVE 2,NRPLQ
	CAIG 2,0(1)		;ABOVE STATED MIN?
	CAMLE 2,NRPMIN		;OR ABOVE NORMAL MIN?
	JRST 1(4)		;YES, UNBLOCK
	AOS CGFLG		;NO, SAY PAGES NEEDED
	JRST 0(4)

;CHECK OVERALL SIZE FOR PHYSICAL CORE LIMITS

IFNDEF I4SW,<		;REMOVE THIS FOR I4 SYSTEM-DOESNT WORK
NICCKS:	MOVE 1,CAPT		;INIT WINDOW SIZE FOR POSSIBLE XGC
	ASH 1,-3		;IS 1/8 REG CAPT
NIC3B:	PUSH P,1
NIC3A:	HRRZ 1,FKNR(7)
	HRRZ 3,FKWSP(7)
	CAIG 1,0(3)		;RESERVE GREATER THAN CURRENT ASSMT?
	JRST NIC3C		;NO, GO MAKE IT SO
	CAML 1,NPMAX		;DEFINITELY TOO BIG?
	JRST NIC3		;YES
	CAMGE 1,SNPMAX		;DEFINITELY NOT TOO BIG?
	JRST NIC3E		;YES
	MOVE 2,NBPROC		;MAYBE TOO BIG - YES IF OTHER
	CAILE 2,1		;PROCESSES IN BALSET
	JRST NIC3
	SKIPE 2,NRBST		;YES IF SMALL FORK WAITING TO GET IN
	CAML 2,SJSIZ
	JRST NIC3E
NIC3:	CAILE 1,1(3)		;NR .G. SIZE+1?
	JRST [	SOS FKNR(7)	;YES, REDUCE NR
		SOS SUMNR
		JRST NIC3A]
	CALL GCPG		;TRY COLLECTING JUST 1 PAGE
	JRST .+2		;FAILED, MAYBE NO USER MAP PAGES
	JRST NIC3A
	MOVE 1,0(P)		;GET WINDOW SIZE
	CALL XGC		;DO GC
	POP P,1
	ASH 1,-1		;IF ANOTHER GC NECESSARY, USE
	JRST NIC3B		;SMALLER WINDOW

>;	END OF I4 SWITH

IFDEF I4SW,<	;USE THIS CODE FOR I4

NICCKS:	MOVEI 1,50
NIC3B:	PUSH P,1
NIC3A:	HRRZ 1,FKNR(7)
	HRRZ 3,FKWSP(7)
	CAIN 3,0(1)
	JRST NIC3AA
	CAIG 1,0(3)
	JRST NIC3BB
	JRST NIC3E
NIC3AA:	SKIPG TRAPC		;ONLY IF IN OUTER LEVEL TRAP
	CAMGE 1,NPMAX
	JRST NIC3F
NIC3BB:	MOVE 1,0(P)
	CALL XGC
	POP P,1
	ASH 1,-1
	HRRZ 3,FKNR(7)
	HRRZ 2,FKWSP(7)
	SUBI 2,0(3)
	JUMPGE 2,NIC3B
	ADDM 2,FKNR(7)
	ADDM 2,SUMNR
	JRST NIC3B

>; END OF I4 SWITCH

NIC3E:	POP P,1			;FLUSH TEMP
	RET

IFNDEF I4SW,<
NIC3C:	MOVE 2,RJAV
	CAMGE 2,[2.0]		;LESS THAN 2 FORKS AV?
	JRST NIC3F		;YES, ALLOW NR GROWTH
	MOVE 1,IFAV
	CAMG 1,IFAMEA		;PROCESS FAULT AV .G. DESIRED?
	JRST NIC3F		;NO, ALLOW
	CALL GCPG		;YES, REMOVE 1 PAGE
	JRST NIC3F		;COULDN'T, HAVE TO ALLOW NR INCREASE
	JRST NIC3A
>; END OF I4SW

NIC3F:	HRRZ 1,FKNR(7)
	HRRZ 3,FKWSP(7)
	SUBI 3,-1(1)		;SET RESERVE TO BE CURRENT SIZE +1
	ADDM 3,SUMNR
	ADDM 3,FKNR(7)
NIC3D:	MOVE 1,SUMNR
	CAMG 1,MAXNR		;BALSET TOO LARGE NOW?
	JRST NIC3A		;NO
	MOVEI 1,JSKP		;YES, GIVE SCHED CHANCE TO DO SOMETHING
	JSYS SCHEDP
	JRST NIC3A

;REMOVE 1 PAGE FROM PROCESS.  SELECT FIRST PAGE OLDER THAN CAPT,
;OR OLDEST PAGE

;
;   I4 CHANGE
IFNDEF I4SW,<
GCPG:	MOVSI 6,-NWSPGS		;SET TO SCAN WS BIT TABLE
	PUSH P,[0]		;WILL REMEMBER OLDEST PAGE FOUND
	LDB 3,[POINT 9,FKNR(7),17] ;PROCESS AGE NOW
	PUSH P,3
	SUB 3,CAPT		;CUTOFF AGE
	PUSH P,3
	MOVE 3,-1(P)		;USE CURRENT AGE AS INIT MIN AGE
GCPG2:	SKIPE 4,WSPGS(6)
GCPG3:	JFFO 4,GCPG1		;FIND PAGE IN USE
	AOBJN 6,GCPG2
	SUB P,BHC+2		;DIDN'T FIND PAGE OLDER THAN CAPT
	POP P,1			;USE OLDEST PAGE SEEN
	JUMPE 1,R		;DIDN'T FIND COLLECTABLE PAGE
	JRST GCPG4		;COLLECT IT

GCPG1:	ANDCM 4,BITS(5)
	MOVEI 1,0(6)
	IMULI 1,^D36		;COMPUTE MAP PAGE NUMBER
	ADDI 1,0(5)
	SKIPE 1,UPTA(1)		;GET MAP WORD
	TLNE 1,INDBIT
	JRST GCPG3		;IGNORE EMPTY OR INDIRECT
	TLNE 1,SHRBIT		;SHARE PTR?
	JRST [	LSH 1,-^D9	;YES, TRACE
		ANDI 1,SPTM
		MOVE 1,SPT(1)
		JRST .+1]
	TLNE 1,17		;IN CORE?
	JRST GCPG3		;NO
	HLRZ 2,CST0(1)
	TRNN 2,(7B2)		;ASSIGNED?
	JRST GCPG3		;NO
	HLRZ 5,CST3(1)		;YES, TO THIS PROCESS?
	ANDI 5,7777
	CAIE 5,0(7)
	JRST GCPG3		;NO
	LSH 2,-^D9		;YES, GET AGE
	CAMLE 2,-1(P)		;CHECK WRAPAROUND
	SUBI 2,1000-100
	CAMLE 2,0(P)		;OUTSIDE CAPT WINDOW?
	JRST [	MOVE 5,2	;NO, SAVE AGE
		CAMG 2,3	;OLDEST PAGE SEEN?
		CALL SWPCHK	;SWAPPABLE?
		JRST GCPG3	;NO
		MOVE 3,5	;YES, REMEMBER OLDEST AGE
		MOVEM 1,-2(P)	;AND PAGE
		JRST GCPG3]
	CALL SWPCHK		;CAN SWAPOUT PAGE?
	JRST GCPG3		;NO
	SUB P,BHC+3		;YES, FLUSH TEMPS
GCPG4:	SOS FKWSP(7)		;DEASSIGN PAGE
	CALL SWPOUT		;SWAP IT
	AOS 0(P)		;RETURN GOOD
	RET
;
>; END OF I4 SWITCH

;CHECK IF PAGE IS SWAPPABLE NOW

SWPCHK:	MOVE 2,CST1(1)
	TLNE 2,-PLKV
	RET			;PAGE IS LOCKED OR HAS NO SWAP ADR
	MOVSI 2,DWRBIT
	TDNN 2,CST3(1)		;BEING WRITTEN?
	AOS 0(P)		;NO, OK
	RET

;COLLECT OLD PAGES FOR THIS PROCESS, CALLED WITH CUTOFF DIFFERENCE IN 1
;THE PAGES ASSIGNED TO THIS PROCESS ARE ASSUMED TO HAVE AGES RANGING
;FROM M1 TO M2.  M2 IS THE CURRENT AGE, LH OF FKNR. WE WISH TO
;FLUSH ALL PAGES OLDER THAN M, WHERE M1<M<M2.  IF EACH PAGE     >>
;HAS BEN REFERENCED ONLY ONCE, THE AGES WOULD BE EVENLY DISTRIBUTED
;BETWEEN M1 AND M2.  HOWEVER, PAGES ACTIVELY BEING USED SHOULD
;HAVE AGES CLOSER TO M2.  THEREFORE, WE PICK A CUTOFF AGE BY
;SUBTRACTING A SMALL NUMBER FROM M2.  TO PREVENT EXCESSIVE COLLECTION
;WHERE ALL PAGES HAVE BEEN REFERENCED RECENTLY, WE SET A LIMIT
;ON THE TOTAL NUMBER OF PAGES WHICH CAN BE FLUSHED, AND STOP
;IF WE HIT THIS LIMIT. ALSO, SINCE AGES CAN WRAP AROUND THE 9-BIT
;FIELD, AGES GREATER THAN M2 ARE ASSUMED TO BE LEFT FROM THE PREVIOUS
;WRAP AROUND AND ARE ADJUSTED ACCORDINGLY.

XGC:	HRRZ 4,FKCNO(7)
	PUSH P,BITS(4)		;PROCESS USE BIT FOR THIS PROCESS
	MOVE 6,SWPCOR		;FIRST SWAPPING PAGE
	HRRZ 4,FKWSP(7)		;NUMBER PAGES NOW IN CORE
;	ASH 4,-1		;COMPUTE 1/2 CURRENT SIZE
	PUSH P,4		;MAX NUMBER OF PAGES TO COLLECT
	LDB 3,[POINT 9,FKNR(7),17] ;CURRENT AGE CLOCK
	DPB 3,[POINT 9,FKNR(7),8] ;REMEMBER 'TIME' OF LAST XGC
	PUSH P,3
	SUBI 3,0(1)		;CUTOFF AGE, 'OLD'=NOW-DIFFERENCE
	PUSH P,3
	CALL PRSTOP		;STOP OTHER PROCESSOR
XGC2:	HLRZ 1,CST0(6)
	TRNN 1,700000		;PAGE IN USE?
	JRST XGC1		;NO
	HLRZ 2,CST3(6)
	ANDI 2,7777
	CAIE 2,0(7)		;ASSIGNED TO THIS PROCESS?
	JRST XGC1		;NO
	LSH 1,-^D9		;YES, GET AGE FIELD
	MOVE 2,-3(P)		;PROCESS USE BIT
	ANDCA 2,CST0(6)		;LOOK AT OTHER PROCESS USE BITS
	TDNE 2,[377777777]	;IF ANY ON, MEANS REFERENCES BY OTHER
	MOVE 1,-1(P)		;PROCESSE, AGE INVALID SO USE CURRENT
	CAMLE 1,-1(P)		;IF .G. NOW, MUST NOT HAVE WRAPPED
	SUBI 1,1000-100		;SO WRAP IT
	CAMLE 1,0(P)		;.G. OLD?
	JRST XGC1		;YES, SAVE IT
	MOVE 2,CST1(6)
	TLNE 2,-PLKV		;DON'T SWAP PAGE IF LOCKED
	JRST XGC1
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;DON'T SWAP PAGE IF NOW BEING WRITTEN
	JRST XGC1
	SOS FKWSP(7)		;DEASSIGN PAGE FROM THIS PROCESS
	MOVEI 1,0(6)
	CALL SWPOUT		;SWAP IT OUT
	SOSG -2(P)		;COLLECTED ENOUGH PAGES?
	JRST XGC3		;YES
XGC1:	CAMGE 6,NHIPG		;STOP AFTER HIGHEST KNOWN PAGE
	AOJA 6,XGC2		;NO, LOOK AT NEXT PAGE
XGC3:	CALL PRGO		;START OTHER PROCESSOR
	SUB P,BHC+4		;FLUSH STACK
	PGRCLD
	RET			;IGNORE ALL THE REST

	SETZ 3,
	MOVSI 6,-NWSPGS		;SETUP TO UPDATE WS BITS
XGC5:	SKIPE 4,WSPGS(6)
XGC6:	JFFO 4,XGC4		;FOUND BIT FOR PAGE
	AOBJN 6,XGC5
	RET

XGC4:	ANDCM 4,BITS(5)		;DON'T FIND THAT BIT NEXT TIME
	MOVEI 1,0(6)		;COMPUTE PAGE NUMBER
	IMULI 1,^D36
	ADDI 1,0(5)
	SKIPE 1,UPTA(1)		;PAGE DELETED?
	TLNE 1,INDBIT		;OR INDIRECT?
	JRST XGC7		;YES, FORGET IT
	TLNE 1,SHRBIT		;SHR PTR?
	JRST [	LSH 1,-^D9	;YES, GET ACTUAL ADDRESS
		ANDI 1,SPTM
		MOVE 1,SPT(1)
		JRST .+1]
	TLNE 1,17		;PAGE NOW IN CORE?
	JRST XGC7		;NO, FLUSH IT
	MOVE 2,CST0(1)
	TLNE 2,(7B2)		;STILL IN USE?
	AOJA 3,XGC6		;YES, COUNT IT AND LEAVE IT
	TLC 2,(02B5)		;READ COMPLETED?
	TLNE 2,(77B5)
	JRST XGC7		;NO
	CALL AGESET
	AOJA 3,XGC6		;COUNT PAGE AND KEEP IT

XGC7:	MOVE 1,BITS(5)
	ANDCAM 1,WSPGS(6)	;CLEAR BIT FOR PAGE NO LONGER IN WS
	JRST XGC6

;RELEASE WORKING SET JSYS

.RWSET:	JSYS MENTR
	NOSKED
	DLOCK SYSLCK		;GRAB SYSLCK
	MOVE 7,FORKX
	SETZ 1,			;USE 0 WINDOW SIZE
	CALL XGC		;COLLECT ALL PAGES
	HRRZ 1,FKWSP(7)		;SET NEW NR TO MAX(6,SIZE)
	CAIGE 1,6		;SIZE .GE. 6?
	MOVEI 1,6		;NO, USE 6 AS NEW NR
	HRRZ 2,FKNR(7)
	SUBI 1,0(2)
	ADDM 1,FKNR(7)
	ADDM 1,SUMNR
	ULOCK SYSLCK		;RELEASE LOCK
	OKSKED
	JRST MRETN

;RESUME PROCESS AFTER PAGER TRAP

PGUNTP:
	ULOCK SYSLCK		;RELEASE LOCK
	SKIPE TRAPC		;OUTER LEVEL TRAP?
	JRST PGU4		;NO
   IFN KIFLG,<
	POP P,KIMAC2
	POP P,KIMAC1>	;RESTORE UUO TEMPS
	JSP 3,UCLOCK		;COMPLETE TIMING OF TRAP CODE
	POP P,1			;FKRT AT TIME OF ENTRY
	MOVE 2,FKRT
	SUB 2,1			;TIME OF TRAP CODE
	ADDM 2,PTTIM		;PAGE TRAP TIME FOR THIS FORK
	ADDM 2,SPTTIM		;PAGE TRAP TIME FOR SYSTEM
PGU4:
	IFN KAFLG,<
	CONO PGR,0>		;LOAD WITH NEW AGE
	POP P,2			;RECOVER WRITE DATA
	MOVE 3,TRAPSW		;GET TRAP BITS
	SKIPE TRAPC		;IF RECURSIVE TRAP,
	POP P,TRAPSW		;RESTORE OLD STATUS WORD
	TLNE 3,12		;READ OR XCT?
	JRST PGU1		;YES, RESTART INSTRUCTION
	TLNE 3,1		;USER OR MONITOR?
	JRST PGU2		;MONITOR
PGMV1:	UMOVEM 2,0(3)		;USER
PGU1:	POP P,1			;GET RETURN
	TLNN 1,UMODF		;TO USER?
	JRST PGU3		;NO, MONITOR
	MOVEM 1,FPC		;USER, CAN PUT RETURN IN FPC
	MOVE 7,-6(P)
	MOVE 1,-5(P)
	MOVE 2,-4(P)
	MOVE 3,-3(P)
	MOVE 4,-2(P)
	MOVE 5,-1(P)
	MOVE 6,0(P)
	MOVE P,TRAPAP		;USER MODE, SO MUST BE TOP LEVEL TRAP
	SETOM TRAPC
	SETOM INTDF		;FOR USER, MUST BE -1
	OKSKED
	XCT MJRSTF		;RETURN, WILL GET DEFERRED INTERRUPT TOO

PGMV2:
PGU2:	MOVEM 2,0(3)		;STORE MONITOR WRITE DATA
	JRST PGU1

PGU3:	AOS INSKED		;ENTER SCHEDULER FLAG
	SOS NSKED		;LIKE OKSKED
	MOVEM 1,PPC		;SETUP TO RETURN THROUGH SCHEDULER
	MOVE 7,-6(P)
	MOVE 1,-5(P)
	MOVE 2,-4(P)
	MOVE 3,-3(P)
	MOVE 4,-2(P)
	MOVE 5,-1(P)
	PIOFF	
	HRRZ 6,MJRSTF
	CAIN 6,FPC	;PSEUDO INTERRUPT
	SETOM PGUNTF	;SET SCHEDULER FLAG
	MOVE 6,0(P)
	SUB P,BHC+7
	SOSGE TRAPC		;TOP LEVEL TRAP?
	MOVE P,TRAPAP		;RESTORE AC-P
	SOS INTDF		;REDUCE NO-PSI COUNT
	PION
	SKIPN PGUNTF
	JRST RSKD1		;EXIT THROUGH SCHEDULER
	ISB SCDCHN		;CALL SCHEDULER
	JRST .-1

;GET PAGE DATA
;TRACES PTN.PN IN 1 TO NOT IN CORE OR CORE PAGE NUMBER OR WRITE COPY
;RETURN AS GETTPD

GETPGD:	HLRZ 2,1		;PTN TO 2
	MOVEI 1,0(1)		;PN TO 1
	SETZ 3,			;NO SPECIAL BITS TO STOP ON
	JRST GETPD1		;FOLLOW LIKE IND POINTER

;GET TRAP DATA
;RETURNS OFN.PN OR 0.SPTN IN 1
; MAP WORD IN 2

GETTPD:	SETZ 3,			;NO SPECIAL BITS TO STOP ON
GETTD1:	HRRZ 1,TRAPSW		;TRAP EFFECTIVE ADDRESS
	LSH 1,-^D9		;PAGE NUMBER
	HLRZ 2,TRAPSW		;TRAP BITS
	TRNE 2,1		;USER OR MONITOR?
	JRST NIC4		;MONITOR
	HLL 1,FKPGS(7)		;USER, GET PAGE TABLE SPTN
	MOVE 2,UPTA(1)
NICI2:	TLNE 2,0(3)		;REQUESTED BIT ON?
	RET			;YES, STOP HERE
	TLNE 2,INDBIT		;INDIRECT POINTER?
	JRST NICI		;YES
	TLNN 2,SHRBIT		;SHARE POINTER?
	RET			;NO, PRIVATE
	LSH 2,-^D9		;YES, SHIFT TO B35
	ANDI 2,SPTM		;FLUSH BITS
NICI1:	MOVEI 1,0(2)
	MOVE 2,SPT(1)
	RET

NICI:	SETZ 1,			;INDIRECT POINTER.
	ROTC 1,-^D9		;GET OFN TO 2, PN TO 1
	ROT 1,^D9
	ANDI 2,SPTM
GETPD1:	MOVE 6,SPT(2)		;GET PAGE TABLE ADDRESS
	TLNE 6,17		;IN CORE?
	JRST NICI1		;NO, THAT'S THE TROUBLE.
	HRLI 1,0(2)		;YES, PUT OFN IN 1
	MOVEI 6,0(2)
	CALL SETSPG		;MAP PT
	MOVE 2,CSWPGA(1)	;GET MAP WORD
	CALL RELSPG		;CLEAR TEMPORARY MAP WORD
	JRST NICI2		;GO ANALYZE THIS POINTER

NIC4:	CAIL 1,PJMPG		;MONITOR MAP, WHICH ONE?
	JRST NIC4A		;IN PSB
	CAIL 1,PPRMPG+NRSPG
	JRST NIC4B		;IN RES MON
	BUG(HLT,<PAGE FAULT ON RESIDENT MONITOR ADDRESS>)

NIC4A:	HRL 1,FKPGS(7)		;PSB
	MOVE 2,PSB(1)
	JRST NICI2

NIC4B:	HRL 1,MMSPTN		;PERMANENT SWP MON OFN
	MOVE 2,MMAP(1)
	JRST NICI2

;SWAP IN PAGE TABLE OR PSB
;CALLED FROM SCHED

SWPIN0:	TLNE 1,-1		;SPTN?
	JRST SWP01		;NO
	MOVE 3,SPT(1)		;YES, GET CURRENT ADDRESS
	TLNE 3,17		;OUT OF CORE?
	JRST SWP01		;YES
	LDB 2,[POINT 6,CST0(3),5] ;AGE CODE
	CAIE 2,2		;BEING READ OR COMPLETED?
	CAIN 2,6
	JRST SWP03		;YES
	MOVEI 1,0(3)
	CALL AGESN		;GRAB PAGE OFF RPLQ
SWP03:	MOVSI 1,0(3)		;ALREADY IN CORE
	JRST SWP02

SWP01:	CALL SWPIN
	HLRZ 3,1
SWP02:	MOVSI 2,PLKV
	ADDM 2,CST1(3)		;LOCK PAGE
	RET

;SWAPIN AND WAIT AND STAY NOSKED

SWPINP:	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK AGAIN
	CALL SWPINW
	ULOCK SYSLCK		;RELEASE SYSLCK
	OKSKED
	RET

;WAIT FOR PAGE AND ACCOUNT

PGIWT:
	ULOCK SYSLCK		;RELEASE SYSLCK
	JSYS SCHEDR
	MOVNI 2,5		;CHARGE 5 MS PER PAGE FAULT
	ADDM 2,RJQNT		;CHARGE AGAINST QUANTUM
	NOSKED
	DLOCK SYSLCK		;LOCK SYSLCK
	RET

;SWAP IN AND WAIT FOR COMPLETION

SWPINW:	MOVE 7,FORKX
	AOS USWPCT		;COUNT SWAPS
	TLNE 1,-1		;PT?
	JRST SWPIW2		;YES
	CALL SWPIN		;SWAPIN AND WAIT FOR COMPLETION
;
;  I4 CHANGE
SWPIW1:	HLRZ 2,1
	LDB 2,[POINT 6,CST0(2),5]
	CAIE 2,2
;
	CALL PGIWT
	HLRZ 1,1		;RESTORE PAGE NO TO R.H.
	RET

SWPIW2:	PUSH P,1		;SAVE ORIG REQUEST
	HLRZ 1,1		;GET PT
	MOVE 3,SPT(1)
	TLNE 3,17		;CORE?
	JRST SWPIW3		;NO
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;SO IT DOESN'T SNEAK AWAY
SWPIW4:	EXCH 1,0(P)		;SAVE CORE PAGE NUMBER, GET ORIG OFN.PN
	CALL SWPIN		;SWAP THE ORIG PAGE
	EXCH 1,0(P)		;GET PT CORE PAGE NUMBER
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK IT
	POP P,1
	JRST SWPIW1

SWPIW3:	NOSKED
	CALL SWPIN		;SWAP IN THE PT
	OKSKED
	HLRZ 2,1
	MOVSI 3,PLKV
	ADDM 3,CST1(2)		;LOCK IT
	HRRI 1,SWPRT
	JSYS SCHEDP		;WAIT TO FINISH
	HLRZ 1,1
	CALL AGESET
	JRST SWPIW4		;NOW GO GET THE PAGE

;SWAP IN PAGE
;AC1/ OFN.PN OR 0.SPTN
;RETURNS AC1/ CORE PAGE NO IN LH

SWPIN:	MOVE 3,NRPLQ		;NUMBER OF REPLACABLE PAGES
	JUMPE 3,SWPQT		;GO WAIT IF NONE
SWPIL1:	SOS NRPLQ
	HRRZ 3,RPLQ		;YES, REMOVE FROM QUEUE
	SUBI 3,CST3
	HLOCKI SWPPI		;PROTECT FROM INTERRUPTS
	MOVE 4,CST3(3)
	HLLM 4,0(4)
	MOVS 4,4
	HLRM 4,0(4)
	HULOCK SWPPI		;RELEASE LOCK
	OKPI
	SETZM CST3(3)
	AOSE SWPKI		;LOCK OUT KI PAGING
	JRST .-1
	CALL DEPG		;RESET PREVIOUS OWNERSHIP
	SETOM SWPKI		;LET KI GO
	TLNE 1,-1		;NEW PAGE FROM PT OR SPT?
	JRST SWPI3		;PT
	MOVE 4,SPT(1)		;SPT, GET ADDRESS
	TLNN 4,17
	BUG(HLT,<SWPIN - SPT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,SPT(1),35]	;STORE NEW (CORE) ADDRESS
SWPI4:	TLZ 4,-1B31		;FLUSH BITS
	MOVEM 4,CST1(3)		;STORE BACKUP ADDRESS
	MOVEM 1,CST2(3)		;STORE LOCATION OF OWNING PT
	TLNE 4,16		;BACKUP ADDRESS ASSIGNED?
	JRST SWPI5		;YES, GO READ IN PAGE
	MOVSI 1,400000		;SET LEGAL AGE SO PAGER DOESN'T TRAP
	TLO 1,(CORMB)
	MOVEM 1,CST0(3)
	TLO 3,RWXB		;NO, ZERO OUT PAGE
	MOVEM 3,MMAP+CSWPG
IFN KIFLG,<MOVEI 1,KIAXB+KIWB(3)
	MONSET(CSWPG,1,2)>
	SETZM CSWPGA
	MOVEI 1,CSWPGA+1
	HRLI 1,-1(1)
	TRNE 4,1		;SPECIAL UNASSIGNED POINTER?
	MOVE 1,[XWD CPYPGA,CSWPGA] ;YES, COPY FROM CPYPG
	BLT 1,CSWPGA+777
	CALL RELSPG
	MOVSI 1,(2B5+CORMB)	;SET STATUS OF PAGE TO READ COMPLETED
	HRRI 1,0(7)		;INCLUDE FORK NUMBER
	MOVEM 1,CST0(3)
	MOVSI 1,0(3)		;RETURN PAGE NUMBER
	HRRI 1,SWPRT		;RETURN APPROPRIATE SCHED TEST
	RET

;PUT A PAGE IN THE AVAILABLE POOL OF SWAPPING PAGES
;PAGE MUST HAVE BEEN PREVIOUSLY UNACCOUNTED FOR (NEW MEM BOX)
;  OR CAN BE A PAGE FROM RES MON MAP (USED TO FLUSH DDT, ETC.)
;
;ACCEPTS: 1 - REAL PAGE NUMBER
;RETURNS: +1 ALWAYS

MAKPGA:	PUSH P,2		;SAVE REGISTERS
	PUSH P,3
	PUSH P,4
	NOSKED
	LDB 2,[POINT 6,CST0(1),5]
	CAIE 2,01		; IS IT UN AVAILABLE?
	 JRST MAKPGX		; NO, NOTHING TO DO
	CAMGE 1,SWPCOR
	 MOVEM 1,SWPCOR		; KEEP MIN AVAILABLE AS SWPCOR
	SETZM CST1(1)
	SETZM CST2(1)
	SETZM CST3(1)
	SETZM CST0(1)
	JSP 4,ONRQ		;PUT PAGE ON REPLACABLE QUEUE
	AOS TOTRC		;UPDATE COUNT OF AVAILABLE CORE PAGES
	AOS MAXNR
	CALL FIXRC		; FIX UP TOTRC DEPENDENT VARIABLES
MAKPGX:	OKSKED
	POP P,4			;RESTORE REGISTERS
	POP P,3
	POP P,2
	RET



;REMOVE A SET OF PAGES FROM THE SWAPPABLE STORE
;ACCEPTS IN 	1: PAGE NUMBER OF FIRST PAGE TO BE REMOVED
;		2: PAGE NUMBER OF LAST PAGE TO BE REMOVED
;	CALL MAKPGU
; RETURNS
;	+1	; SOME PAGES LOCKED, RH(1) #LOCKED, LH(1) ONE OF THEM
;	+2	; SUCCESS

MAKPGU:	SUBI 2,-1(1)		; NUMBER OF PAGES
	MOVNS 2
	HRL 1,2
	SETZM PGELCT		; NO LOCKED PAGES FOUND YET
	MOVEM 1,FSHBAL		; CAUSE SCHEDULER TO FLUSH BALSET ETC.
	MOVEI 1,FSHBAL
	CALL DISGE		; WAIT FOR PAGES TO BE FLUSHED
	SKIPN 1,PGELCT		; ANY LOCKED PAGES FOUND
	AOS 0(P)		; NO, SUCCESS RETURN
	RET

; FLUSH ALL PAGES FROM CORE (USED FOR TAKING PAGES OUT OF CIRCULATION)

GCALC:	PUSH P,NRPLQ		; SAVE CURRENT VALUE OF NRPLQ
	HRROS CGFLG		; FORCED GC
	CALL GCCOR0		; DEPG AS MUCH AS POSSIBLE THEN GC
	POP P,1
	SKIPN IOIP
	CAME 1,NRPLQ
	 JRST GCALC		; LOOP UNTIL NO CHANGE IN NRPLQ AND NO IOIP
	HRROS CGFLG
	CALL GCCOR0		; ONCE MORE FOR LUCK
	SETCM 3,FSHBAL		; GET FLUSH FLAG
	JUMPE 3,GCEFS1		; IF NOT AOBJN POINTER, DON'T REMOVE PAGES
	SETCA 3,		; ELSE GET AOBJN POINTER TO PAGES TO FLUSH
GCFSH:	LDB 1,[POINT 6,CST0(3),5]
	JUMPN 1,[		; NOT ON REPLACEABLE QUEUE
		CAIN 1,01	; ALREADY UNAVAILABLE?
		 JRST GCEFSH	; YES, OK
		SKIPN PGELCT	; NO, MUST BE LOCKED. FIRST LOCKED PAGE?
		 HRLM 3,PGELCT	; YES, SAVE PAGE NUMBER
		AOS PGELCT
		JRST GCEFSH]
	MOVE 4,CST3(3)		; TAKE OFF RPLQ
	HLLM 4,0(4)
	MOVSS 4
	HLRM 4,0(4)
	SOS NRPLQ		; ACCOUNT FOR THIS STOLEN PAGE
	SOS TOTRC		; ADJUST REAL CORE COUNT
	SOS MAXNR		; AND MAXNR
	CALL FIXRC		; FIX VARIABLES DEPENDENT ON TOTRC
	SETZM CST1(3)		; CLEAR CST
	SETZM CST2(3)
	SETZM CST3(3)
	MOVSI 4,(1B5)
	MOVEM 4,CST0(3)
	HRRZ 1,3
	CAMN 1,SWPCOR		; EQUAL TO SWPCOR?
	 JRST [	AOS 1,SWPCOR	; YES, BUMP SWPCOR
		LDB 1,[POINT 6,CST0(1),5]
		CAIN 1,01	; NEXT ONE UNAVAILABLE?
		 JRST .		; YES, BUMP AGAIN
		JRST .+1]	; ELSE CONTINUE
GCEFSH:	AOBJN 3,GCFSH
GCEFS1:	SETZM FSHBAL
	RET

; FIX RC VARIABLES

FIXRC:	MOVE 4,TOTRC
	ASH 4,-2		; AND MAXLOK
	CAIGE 4,10
	MOVEI 4,10
	MOVEM 4,MAXLOK
	MOVE 4,TOTRC		; AND MAXBP
	LSH 4,-5
	CAIL 4,NBP
	MOVEI 4,NBP-1
	CAIGE 4,7
	MOVEI 4,7		;AT LEAST 7
	MOVEM 4,MAXBP
	RET

SWPI3:	HLRZ 6,1		;GET OWNING PT OFN
	CALL SETSPG		;MAP PT
	MOVSI 4,PLKV
	ADDM 4,CST1(6)		;INCREMENT LOCK COUNT
	MOVE 4,CSWPGA(1)
	TLNN 4,17
	BUG(HLT,<SWPIN - PT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,CSWPGA(1),35]	;STORE NEW (CORE) ADDRESS
	CALL RELSPG
	JRST SWPI4

SWPQT:	PUSH P,1		;SAVE REQUESTED PAGE IDENT
	MOVEI 1,SWPWTT		;RESCHEDULE UNTIL NRPLQ NON-0
	JSYS SCHEDP
	POP P,1
	JRST SWPIN

SWPWTT:	SKIPLE NRPLQ
	JRST 1(4)
	AOS CGFLG		;REQUEST CORE
	JRST 0(4)

SWPI5:	MOVEI 1,0(3)
IFN KAFLG,<
	MOVE 2,CST2(1)		;FIGURE OUT IF PAGE IS MAYBE A PT
	TLNE 2,-1		;IN SPT?
	JRST SWPI6		;NO, COULDN'T BE PAGE TABLE
	CAIL 2,NOFN		;PAGE IS PAGE TABLE IF IT IS FILE XB,
	SKIPN SPTH(2)		;OR IF IT IS SHARED BUT DOES NOT
	JRST .+2		;BELONG TO ANY PT OR XB
	JRST SWPI6
	MOVEI 2,0(1)		;BEFORE INITIATING SWAP OF PT,
	TLO 2,RWXB		;FILL THE ENTIRE CORE PAGE WITH
	MOVEM 2,MMAP+CSWPG	;PTRS WHICH WILL CAUSE THE PAGER TO
	MOVSI 2,400000		;TRAP IN A SAFE WAY SHOULD IT HAPPEN
	TLO 2,(CORMB)
	MOVEM 2,CST0(1)		;TO INTERPRET AN INDIRECT PTR WHICH
IFN KIFLG,<MOVEI 2,KIAXB+KIWB(1)
	MONSET(CSWPG,2,3)>
	MOVE 2,[XWD CSWPGA,CSWPGA+1] ;GOES THROUGH THIS PT BEFORE
	MOVSI 3,RWXB+1		;THE READ IS COMPLETED. THIS IS DONE
	MOVEM 3,-1(2)		;BECAUSE THE PAGER DOES NOT CHECK
	BLT 2,CSWPGA+777	;CST0 WHEN READING A PTR FROM AN IND
	CALL RELSPG		;PT AND SO DOESN'T NOTICE IF THE PAGE
>;END IFN KAFLG
SWPI6:	MOVSI 2,(6B5)		;IS BEING SWAPPED IN.
	HRRI 2,0(7)		;INCLUDE FORK NO.
	MOVEM 2,CST0(1)		;PUT READ-IN-PROGRESS CODE IN CST0
	TLNE 4,10		;DISK?
	JRST SWPIK		;YES
	TLNE 4,14		;DRUM?
	BUG(HLT,<SWPIN - ILLEGAL SWAP ADDRESS>)
	SKIPN DRNSET
	JRST [	HRRZ 2,CST1(1)
		CALL STBTWD	;SET DRUM REF. BIT
		JRST SWPI10]
	HLLOS CST0(1)
SWPI10:	CALL DRMIO		;YES, INITIATE READ
	AOS DRMRD		;COUNT DRUM READS FOR STATISTICS
	MOVSI 1,0(1)
	HRRI 1,SWPRT		;RETURN APPROPRIATE SCHED TEST
	RET

SWPIK:	TLNE 4,NEWFB		;NEWLY ASSIGNED PAGE?
	JRST [	CALL SWPZPG	;YES, ZERO IT
		MOVSI 2,NEWFB
		ANDCAM 2,CST1(1)
		MOVSI 2,(2B5+CORMB)
		HLLM 2,CST0(1)	;SET TO READ COMPLETED AND MODIFIED
		JRST .+2]
	CALL DSKIO		;INITIATE DISK READ
	AOS DSKRD		;COUNT DISK READS FOR STATISTICS
	MOVSI 1,0(1)		;RETURN APPROPRIATE SCHED TEST
	HRRI 1,DSKRT
	RET

DEPG:	MOVE 4,CST2(3)		;GET LOCATION OF PT OWNING OLD CONTENTS
	JUMPE 4,R		;0 => WAS NONE
	MOVE 5,CST1(3)		;GET BACKUP ADDRESS
	TLNE 4,-1		;PT OR SPT
	JRST SWPI1		;PT
	DPB 5,[POINT 22,SPT(4),35]	;SPT, RESTORE BACKUP ADDRESS
	MOVSI 6,-1B31
	CAIGE 4,NOFN		;FILE XB?
	TDNE 6,SPT(4)		;WITH SHARE COUNT NOW 0?
	RET			;NO
	SETOM SPTH(4)		;DELETE OFN
	SOS NOF
	RET

SWPI1:	HLRZ 6,4
	CALL SETSPG		;MAP PT
	MOVSI 2,-PLKV
	ADDB 2,CST1(6)		;DECREMENT LOCK COUNT
	DPB 5,[POINT 22,CSWPGA(4),35]	;STORE BACKUP ADDRESS
	CALL RELSPG		;RELEASE TEMPORARY MAP WORD
	RET

SETSPG:	PUSH P,1
	MOVE 1,SPT(6)		;GET ADDRESS
	TDNE 1,[XWD 17,-MAXCOR]
	BUG(HLT,<SWPIN - PAGE TABLE NOT IN CORE>)
	HLL 1,CST0(1)		;CHECK AGE
	TLNN 1,(7B2)		;NOW ASSIGNED?
	CALL AGESN		;NO, SET AGE
	LSH 6,^D9		;MAKE SHARE POINTER FROM OFN IN 6
	TLO 6,RWXB-XCTB+SHRBIT
	MOVEM 6,MMAP+CSWPG	;PUT IN PAGE RESERVED FOR SWAPPER
IFN KIFLG,<MOVEI 6,KIAXB(1)
	HLL 1,CST0(1)
	TLNE 1,(CORMB)
	TRO 6,KIWB
	MONSET(CSWPG,6,1) >
	MOVEI 6,0(1)		;RETURN CORE ADR
	POP P,1
	RET

RELSPG:	SETZM MMAP+CSWPG	;CLEAR MAP WORD
	MONCLR CSWPG			;CLEAR MON AR'S
	RET

;ZERO CORE PAGE GIVEN IN 1

SWPZPG:	MOVEI 2,0(1)
	TLO 2,RWXB		;CONSTRUCT PRIVATE POINTER TO PAGE
	MOVEM 2,MMAP+CSWPG	;PUT IN MON MAP
	MOVSI 3,400000		;GET LEGAL AGE
	TLO 3,(CORMB)
	EXCH 3,CST0(1)		;SAVE OLD AGE
IFN  KIFLG,<MOVEI 2,KIAXB+KIWB(1)
	MONSET(CSWPG,2,1) >
	MOVE 2,[XWD CSWPGA,CSWPGA+1]
	SETZM -1(2)
	BLT 2,CSWPGA+777	;ZERO THE PAGE
	TLO 3,(CORMB)		;NOTE PAGE WRITTEN INTO
	MOVEM 3,CST0(1)		;RESTORE AGE
	JRST RELSPG		;CLEAR PAGE FROM MMAP AND RETURN

;SCHEDULER TEST FOR PSB AND PT READ COMPLETED

SWPINT:	MOVE 3,4		;SAVE RETURN
	HRRZ 1,FKPGS(7)		;PSB
	MOVE 1,SPT(1)		;ASSIGNED PAGE
	JSP 4,SWPRT		;DONE?
	JRST 0(3)		;NO, RETURN NOT RUNNABLE
	CALL AGESN		;SET AGE
	SKIPN INDFLG		;LOCKING PSB'S?
	JRST SWPIT1		;NO
	HRRZ 1,FKJOB(7)		;YES, GET SPT
	MOVE 1,SPT(1)		;CORE ADDRESS
	JSP 4,SWPRT		;CHECK IT
	JRST 0(3)		;NOT READY
	CALL AGESN
SWPIT1:	HLRZ 1,FKPGS(7)		;PT
	MOVE 1,SPT(1)
	JSP 4,SWPRT		;PT READY?
	JRST 0(3)		;NO
	CALL AGESN
	JRST 1(3)

;SCHEDULER TEST FOR READ COMPLETED

DSKRT:	JFCL			;SAME AS SWPRT
SWPRT:	MOVE 2,CST0(1)		;PAGE STATE CODE
	TLC 2,(06B5)		;COMPARE WITH READ-IN-PROG CODE
	TLNN 2,(77B5)
	JRST 0(4)		;READ STILL IN PROG
	JRST 1(4)

;SWAP COMPLETION ROUTINE, CALLED FROM DRUM AND DISK INTERRUPT CODE

SWPDON:
	MOVSI 2,DWRBIT		;WRITE BIT
	TDNE 2,CST3(1)		;WAS WRITE?
	JRST SWPD1		;YES
	AOS PSKED		;INDICATE READ COMPLETED
;;;	ISB SCDCHN
	HLOCKI SWPPI
	MOVSI 2,4B23
SWPD2:	ANDCAM 2,CST0(1)	;CLEAR I/O IN PROGRESS
SWPD21:	HULOCK SWPPI		;RELEASE LOCK
	OKPI
	JRST 0(4)

SWPD1:	NOPI			;OPEN CODED TO SAVE OVERHEAD
	AOSG SWPPI		;- DONT TURN OFF INTERRUPTS TOO LONG
	JRST SWPDX1
	OKPI
	JRST SWPD1
SWPDX1:	ANDCAM 2,CST3(1)	;CLEAR WRITE BIT
	LDB 2,[POINT 6,CST0(1),5]	;GET TRAP CODE
	CAIE 2,4		;STILL SAYS WRITE?
	JRST [	SKIPE CST2(1)	;NO, PAGE USED AGAIN.  STILL EXISTS?
		JRST SWPD21	;YES
		JRST ONRQX]	;IT WAS DELETED, PUT ON RPLQ
	SOS IOIP		;WRITE NO LONGER IN PROGRESS
	MOVE 2,CST1(1)		;IF WRITE WAS TO DISK, AND PAGE
	HLR 2,CST2(1)		;IS STILL IN SPT
	TLNE 2,10
	TRNE 2,-1
	JRST ONRQX
	MOVEI 2,7777		;FAKE A REFERENCE IN ORDER TO
	HRLZM 2,CST3(1)		;KEEP THE PAGE ON THE DRUM
	DPB 2,[POINT 9,CST0(1),8]
	JRST SWPD21

ONRQ:	
	HLOCKI SWPPI		;ENTRY POINT IN WHICH LOCKS AREN'T SET
ONRQX:	MOVEI 2,CST3(1)		;ENTRY WHEN PI ALREADY OFF
	HLRZ 3,RPLQ
	HRL 3,0(3)
	HRRM 2,0(3)
	MOVSM 3,0(2)
	HRLM 2,RPLQ
	AOS NRPLQ
	MOVSI 2,77B23
	JRST SWPD2









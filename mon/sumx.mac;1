;<MON>SUMX.MAC			7/75		EDIT BY HEATHMAN
;MINOR EXTERNAL CHANGES WHILE ADDING NEW TYMNET HANDLER
	SEARCH	STENEX,PROLOG
	TITLE	SUMX

; A FILE OF GENERAL SUMEX RELATED ROUTINES

	EXTERN TYPEX,TYP33,NORMTF,TYPCRT,TYMX0,TYPNVT
	INTERN JBTINI

NTYPTB=NLINES-NDTY-NPTY-NNVTLN-NTYMTT	;NUMBER OF HARDWIRED LINES
LS TYPTB,NTYPTB			;INITIAL TYPES FOR HARDWIRED LINES

JBTINI:	MOVE 2,CTRLTT		;CTRLTT INITIALIZATION 
	MOVE 3,NORMTF
	MOVEI 4,TYPEX

IFDEF IMPCHN,<
	CAIL 2,NVTLO		;NVT?
	CAIL 2,NVTLO+NNVTLN
	 CAIA
	JRST  [MOVEI 2,3B33	;YES
	       STPAR		;YES, FLAP HDX BITS TO FORCE OUT TELNET CTRL
	       MOVEI 4,TYPNVT	;TYPE TO TTY 33 FOR NO PADDING
	       JRST JBTIN2]
>
IFDEF TYMSW,<
	CAIL 2,TYMTTL		;TYMNET LINE?
	CAIL 2,TYMTTL+NTYMTT
	CAIA
	 JRST TYMX0		;YES
>
IFDEF I4SW,<
	CAIL 2,PTYLO		;PTY?
	CAIL 2,PTYLO+NPTY
	CAIA
	 JRST  [MOVEI 4,TYPCRT	;YES, SET TYPE TO GENERAL SCOPE TYPE
		MOVEI 3,3B25+1B26+1B29 ;INF WIDTH, LENGTH, ASCII, LINKS
		JRST JBTIN2]
>
	CAIL 2,DTYLO		;DIALUP?
	CAIL 2,DTYLO+NDTY
	CAIA
	 JRST JBTIN2		;DIALUP OR NOT INSIDE TABLE
	
	CALL XTYPX		;TRANSLATE REAL LINE # TO TYPTB INDEX
	SKIPN TYPTB(2)		;VALID TABLE ENTRY?
	 JRST JBTIN2		;NO, USE PRESET DEFAULTS

	MOVE 3,TYPTB(2) 	;YES GET TABLE TTFLGS
	MOVE 4,3
	TRZ 3,77B23		;ZERO TYPE FIELD
	ANDI 4,77B23		;GET TYPE FIELD
	LSH 4,-^D12

JBTIN2:	MOVE 2,3
	SFMOD
	STPAR
	MOVE 2,4
	STTYP
	RET

; ROUTINE CALLED FROM JOB 0 (CHKR IN SWPMON) TO UPDATE TYPTB, INTERNAL
; INITIAL TTY TYPE TABLES

	EXTERN	BHC
	INTERN	TTYPCK

LS TTYPCL,1

TTYPCK: MOVSI 1,(1B2+1B17)	;OLD FILE ONLY FROM STRING IN 2
	HRROI 2,[ASCIZ /<SYSTEM>TTY.TYPE/]
	GTJFN
	 RET			;NOT THERE OR SOMETHING
	PUSH P,1		;SAVE JFN

	MOVE 2,[XWD 1,14]	;GET LAST WRITE TIME AND DATE 
	MOVEI 3,3		;INTO 3
	GTFDB

	CAMGE 3,TTYPCL		;WRITTEN LATELY SINCE LAST READ?
	 JRST TYPCK9		;NO

	GTAD			;GET NOW
	SKIPGE			;TIME SET YET?
	 JRST TYPCK9		;NO, SKIP UPDATE
	MOVEM 1,TTYPCL		;YES, UPDATE LAST READ DATE

	MOVE 1,(P)
	MOVE 2,[XWD 070000,200000] ;READ ASCII FROZEN
	OPENF
	 JRST TYPCK9		;COULDN'T OPEN, TRY LATER

TYPCK1:	MOVEI 3,^D8		;READ IN LINE # IN OCTAL
	NIN	
	 JRST TYPCK8		;FAILED, FILE FORMAT SCREWED UP
	PUSH P,2		;SAVE TTY #

	NIN			;READ IN STTYP WORD IN OCTAL
	 JRST  [SUB P,BHC+1
		JRST TYPCK8]
	ANDI 2,77
	PUSH P,2		;SAVE TYPE WORD

	NIN			;READ IN SFMOD WORD IN OCTAL
	 JRST  [SUB P,BHC+2
		JRST TYPCK8]	;FILE FORMAT ERROR

	TRZ 2,77B23		;ZERO OUT WAKEUP BITS TO USE TO STORE TTTYPE
				;IN
	EXCH 2,-1(P)		;EXCHANGE SFMOD WORD FOR TTY #
	PUSH P,2		;AND SAVE IT AGAIN

	GTSTS			;AN EOF ANY WHERE?
	TLNE 2,(1B8)
	 JRST  [SUB P,BHC+3
		JRST TYPCK8]	;FILE FORMAT ERROR

	POP P,2			;GET TTY #
	POP P,3			;GET TYPE
	LSH 3,^D12		;SHIFT INTO BITS 18-23
	IOR 3,(P)		;GET REST OF BITS
	SUB P,BHC+1		;RESET STACK
	CALL XTYPX		;XLATE TTY # INTO TYPTB #
	 MOVEM 3,TYPTB(2)

	BKJFN			;BACK UP TO TERMINATOR OF LAST NIN
	 JRST TYPCK8

TYPCK2:	BIN			;SEARCH FOR EOL
	PUSH P,2	
	GTSTS
	TLNE 2,(1B8)		;EOF?
	 JRST  [SUB P,BHC+1	;YES
		JRST TYPCK8]
	POP P,2
	CAIN 2,37		;EOL?
	 JRST TYPCK1		;YES, GO READ NEXT LINE
	CAIN 2,15		;CR?
	 JRST  [BIN		;SKIP OVER LF
		JRST TYPCK1]	;AND GO ON TO NEXT LINE
 	JRST TYPCK2		;NO, KEEP LOOKING

TYPCK8:	MOVE 1,(P)		;GET JFN
	TLO 1,(1B0)		;RELEASE THE FILE
	CLOSF
	 JFCL			;SHOULDN'T HAPPEN
	
TYPCK9:	POP P,1			;GET JFN
	RLJFN			;RELEASE IT
	 JFCL			;SHOULDN'T HAPPEN

	RET		

; SUBROUTINE TO TRANSLATE REAL TTY # TO TYPTB INDEX
; SKIP RETURN IF ILLEGAL TTY #

XTYPX:	AOS (P)
IFDEF IMPCHN,<
	CAIGE 2,NVTLO
	 JRST .+4
	CAIGE 2,NVTLO+NNVTLN
	 RET			;A NET TTY IS ILLEGAL TYPTB LINE
	SUBI 2,NNVTLN
>
IFDEF TYMSW,<
	CAIGE 2,TYMTTL
	 JRST .+4
	CAIG 2,TYMTTL+NTYMTT-1
	 RET			;TYMNET TTY IS ILLEGAL TYPTB LINE
	SUBI 2,NTYMTT
>
IFDEF I4SW,<
	CAIGE 2,PTYLO
	 JRST .+4
	CAIGE 2,PTYLO+NPTY
	 RET			;PTY IS ILLEGAL TYPTB LINE
	SUBI 2,NPTY
>
	CAIGE 2,DTYLO
	 JRST .+4
	CAIGE 2,DTYLO+NDTY
	 RET			;DTY IS ILLEGAL TYPTB LINE
	SUBI 2,NDTY

	SKIPL 2			;NEG OR TOO LARG LINE # IS ILLEGAL
	CAIL 2,NTYPTB
	 JRST .+2
	SOS (P)
	RET
	SUBTTL	DDER STORAGE

	EXTERN	DWRBIT,DSKIO,FILOFN,SETMPG,BUGHLT,JB0FLG,CVDSK,BUGNTE
	EXTERN	SETXB1,RELCXB,UDSKIO,UDSKSW
	INTERN	DDERTP,DRMEUT,DSKEDA,DSKEUT,DDERWD,DDERBP,DDERS,DDERJ,DDERJI

; ERROR FILE FORMAT IS:

DDERFF==0		;FREE BLOCK QUEUE START
DDERFI==1		;INPUT QUEUE
DDERFO==2		;OUTPUT QUEUE
DDERNW==10		;EACH BLOCK IS THIS MANY WORDS
DDERFS==10000		;AND THE ERROR BLOCKS OCCUPY THE FIRST 10000 WORDS
			;OF THE FILE, AFTER THAT COME GOOD/BAD DATA PAGES
DDERFM==DDERFS-1	;MASK TO INSURE SAFE FILE POINTERS

LS(DDERLL,1)		;PROCESS LOCK, AOSE LOCK

; DDERST THROUGH DDERLW+DDERNW-1 BLT'ED TO ZERO UPON RESET
LS(DDERST,1)		;STATE WORD, .G. 0 TO CALL SCHED LEVEL
			;MINUS TO CALL JOB 0
LS(DDERLW,DDERNW)	;ERROR BLOCK, FIRST WORD RESERVED FOR CHAIN LINKING
			;WHEN BLOCK IN ERROR FILE
DDERBP=DDERLW+1		;GOOD/BAD DATA PAGE WORD; -1 MEANS NO PAGES ASSOCIATED
			;WITH THIS ERROR, 0 MEANS PAGES ASSOCIATED, AND
			;WHEN WRITTEN IN ERROR FILE, LH IS BAD PAGE NUMBER
			;AND RH IS GOOD PAGE NUMBER
DDERTP=DDERLW+2		;ERROR DEVICE AND TYPE
			;LH HAS OPERATION TYPE CODE FOR USE IN LOGGING
			;FILE: 0 - DRUM SWAPPER, 1 - DRUM UTILITY, 
			;2 - DISK SWAPPER, 3 - DISK UTILITY
DDERWD=DDERLW+3		;START OF DEVICE DEPENDENT ERROR WORDS
DRMEUT=DDERWD+3		;DRUM UTILITY INDEX WORD (DRMSTS)
DSKEDA=DDERWD+1		;HARDWARE DISK ADDRESS (DSKDAW) FOR DISK OPERATIONS
DSKEUT=DDERWD+3		;DISK UTILITY INDEX WORD (DSKSTS)
; DDERST THROUGH DDERLW+DDERNW-1 BLT'ED TO ZERO UPON RESET

LS(DDERBB,1)		;BAD DATA DISK BUFFER HARDWARE FORMAT ADDRESS
LS(DDERGB,1)		;GOOD DATA DISK BUFFER HARDWARE FORMAT ADDRESS
LS(DDERA1,4)		;TEMP AC STORAGE WHILE IN SCHED LEVEL ROUTINES
	SUBTTL DDERS - DISK/DRUM ERROR LOGGING SCHED ROUTINE
	
DDERS:	SKIPG DDERST		;ANYTHING FOR US TO DO?
	 RET			;NO

	SKIPE DDERA1+3		;IS THIS A RESTART? (CHECK THE RETURN PC)
	 JRST  [MOVE 4,[DDERA1,,1] ;YES, RESTORE REGISTERS
		BLT 4,4
		JRST (4)]	;AND JUMP INTO PROPER PLACE

	SKIPL DDERGB		;GOOD BUFFER AND
	SKIPGE 1,DDERBB		;BAD BUFFER ALLOCATED?
	 JRST DDERS1		;NO, ABORT DATA COPY
	CALL CVDSK		;CONVERT TO HARDWARE
	MOVE 2,[10,,1000]
	MOVE 3,DDERST
	CALL UDSKIO
	 JSP 4,DDERS9		;COMMAND QUE FULL
	JSP 4,UDSKSW		;WAIT FOR COMMAND TO FINISH
	 JSP 4,DDERS9		;COMMAND NOT FINISHED YET
	SKIPE 1
DDERS1:	SETOM DDERBP		;BAD WRITE, ABORT DATA COPY

	CALL @DDERTP		;REQUE ORIGINAL OP
	 JSP 4,DDERS9
	HRRZ 3,DDERTP		;GET DEVICE DEPENDENT DISPATCH TABLE ADDRESS
	JSP 4,1(3)		;WAIT FOR COMPLETION
	 JSP 4,DDERS9
	JUMPN 1,[JSP 4,2(3)	;BAD COMPLETION
		SETOM DDERBP	;ABORT DATA COPY
		JRST DDERS3]

	SKIPGE DDERBP		;CONTINUE DATA COPY?
	 JRST DDERS2		;NO

	MOVE 1,DDERGB		;YES, WRITE OUT DATA TO GOOD BUFFER
	CALL CVDSK		;CONVERT TO HARDWARE
	MOVE 2,[10,,1000]
	MOVE 3,DDERST
	CALL UDSKIO
	 JSP 4,DDERS9
	JSP 4,UDSKSW
	 JSP 4,DDERS9
	SKIPE 1
	 SETOM DDERBP		;BAD WRITE, ABORT DATA COPY

DDERS2:	HRRZ 3,DDERTP		;GET DEVICE DEPENDENT DISPATCH TABLE ADDRESS
	JSP 4,3(3)		;GOOD REQUE COMPLETION, RELEASE PAGE
				;TO SWAPPER OR UTILITY OP
DDERS3:	SETOM DDERST		;SET STATE TO CALL IN JOB 0 ROUTINES
	AOS JB0FLG		;TO PROCESS REST OF ERROR
	SETZM DDERA1
	MOVE 1,[DDERA1,,DDERA1+1]
	BLT 1,DDERA1+3
	RET

DDERS9:	SUBI 4,2		;RESET RETURN ADDRESS TO INSTRUCTION BEFORE
				;CALL
	MOVEM 1,DDERA1		;BLT IMPORTANT REGISTERS
	MOVE 1,[2,,DDERA1+1]
	BLT 1,DDERA1+3
	RET			;RETURN TO SCHEDULER
	SUBTTL DDERJ JOB 0 DISK/DRUM ERROR LOGGING HANDLER

; CHECK FOR DDER REQUEST

DDERJ:	SKIPL DDERST		;JOB 0 WORK?
	 RET			;NOT YET

	MOVSI 1,1
	HRROI 2,[ASCIZ \<SYSTEM>RECOVERABLE.ERRORS\]
	GTJFN
	 JRST  DDERJ9		;SKIP RECORDING AND RESET ON GTJFN FAILURE
	PUSH P,1		;SAVE JFN
	MOVE 2,[440000,,300000]	;OPEN FROZEN, READ, WRITE
	OPENF
	 JRST  [EXCH 1,(P)	;BAD OPEN, SAVE REASON, CLOSE FILE
		HRRZS 1
		RLJFN
		 JFCL
		POP P,1		;GET ERROR REASON
		CAIE 1,OPNX9	;FILE BUSY
		JRST DDERJ9	;NO, SKIP RECORDING AND RESET
		AOS JB0FLG	;YES, NOTIFY JOB 0
		RET]		;TO TRY AGAIN

DDERJ2:	HRRZ 1,(P)		;GET JFN
	FFFFP			;FIND FIRST FREE FILE PAGE
	TLZ 1,-1		;JUST LOOK AT FILE PAGE NUMBER
	CAIGE 1,10		;LEGAL HOLE?
	 JRST DDERJ7		;NO, INITIALIZE FILE

	HRRZ 1,(P)		;GET JFN
	MOVEI 3,DDERFF		;GET FREE ERROR BITS BLOCK
	RIN
	ANDI 2,DDERFM		;MUST BE INSIDE FIRST 10 PAGES
	JUMPE 2,DDERJ8		;NO ROOM TO STORE ERROR, SKIP AND RESET
	PUSH P,2		;SAVE FREE BLOCK NUMBER

	SKIPGE DDERBP		;ARE "GOOD" AND "BAD" BUFFERS ASSOCIATED
	 JRST DDERJ3		;WITH THIS ERROR? NO.

	HRRZ 1,-1(P)		;GET JFN AGAIN
	LSH 1,SJFN		;CONVERT TO JFN INDEX
	HLRZ 3,FILOFN(1)	;GET OFN NUMBER
	CALL SETXB1		;GET XB

	MOVE 1,[-770,,10]	;SET UP TO SEARCH THROUGH XB FOR FREE PAGES
	MOVNI 2,2		;FIND THIS MANY FREE PAGES
DDER12:	SKIPE CXBPGA(1)		;PAGE FREE?
	 JRST DDER10		;NO
	PUSH P,1		;YES, SAVE PAGE NUMBER
	AOJGE 2,DDER11		;FOUND ALL THE PAGES WE WANT
DDER10:	AOBJN 1,DDER12		;NOT YET, GO FOR MORE
	ADDI 2,2		;FIND OUT HOW MANY PAGE NUMBERS ON STACK
	SUB P,BHC(2)		;AND POP THEM
	CALL RELCXB		;RELEASE XB
	SETOM DDERBP		;SAY NO DATA BLOCKS WITH THIS ERROR
	JRST DDERJ3		;AND SKIP ASSIGNING PAGES

DDER11:	POP P,1			;GET FILE PAGE NUMBER
	MOVE 2,DDERBB		;GET BAD BUFFER DISK ADDRESS
	TLO 2,160040		;MAKE INTO PAGE POINTER
	MOVEM 2,CXBPGA(1)	;ADD IT TO FILE
	HRLM 1,DDERBP		;AND NOTE BAD BUFFER PAGE NUMBER

	POP P,1			;GET FILE PAGE NUMBER
	MOVE 2,DDERGB		;GET GOOD BUFFER DISK ADDRESS
	TLO 2,160040		;MAKE INTO PAGE POINTER
	MOVEM 2,CXBPGA(1)	;ADD PAGE TO FILE
	HRRM 1,DDERBP		;AND NOTE GOOD BUFFER PAGE NUMBER

	CALL RELCXB		;RELEASE XB

	CALL DDERJ0		;ASSIGN TWO NEW BUFFER PLACES
	
DDERJ3:	GTAD			;GET TIME AND DATE FOR ERROR BLOCK
	MOVEM 1,DDERTP		;SAVE IT IN THE TYPE FIELD

	HRRZ 1,-1(P)		;GET JFN
	MOVE 3,(P)		;UNCHAING ERROR BLOCK FROM FREE CHAIN
	RIN
	ANDI 2,DDERFM		;INSURE OK POINTER
	MOVEI 3,DDERFF
	ROUT

	SETZM DDERLW		;END OF OUTPUT CHAIN IS ZERO
	MOVE 2,(P)		;GET BLOCK ADDRESS
	SFPTR
	 JSR BUGHLT		;SHOULD NOT HAPPEN
	MOVE 2,[POINT 36,DDERLW]
	MOVNI 3,DDERNW		;SAVE ERROR BITS IN BLOCK
	SOUT
	
	MOVEI 3,DDERFI		;GET INPUT QUEUE POINTER
	RIN
	ANDI 2,DDERFM
	EXCH 2,(P)		;TRADE FOR BLOCK POINTER
	ROUT			;PUT BLOCK POINTER IN INPUT QUEUE
	POP P,3			;AND
	ROUT			;IN LAST BLOCK OF QUEUE
	JRST .+2

DDERJ8:	BUG(NTE,<DDERJ: NO ROOM IN <SYSTEM>RECOVERABLE.ERRORS>)
	POP P,1			;GET JFN
	HRRZS 1
	CLOSF			;CLOSE AND RELEASE FILE
	 JFCL
	JRST .+2
	
DDERJ9: BUG(NTE,<DDERJ: COULDN'T GTJFN <SYSTEM>RECOVERABLE.ERRORS>)
DDERJ4:	SETZM DDERST		;RESET PROCESS AND ERROR BIT BUFFER
	MOVE 1,[DDERST,,DDERST+1]
	BLT 1,DDERLW+DDERNW-1
;	SETOM DDERLL		;UNLOCK PROCESS
	SETZM DDERLL
	RET
; DISK/DRUM ERROR RECORDING INITIALIZATION

DDERJI:	;CALL DDERJ0
	JFCL
	JRST DDERJ4

; GET BUFFER PAGES ROUTINE

DDERJ0:	
	MOVSI 1,200000		;GET TWO DISK PAGES
	DSKAS
	 JRST DDERJ5		;NONE LEFT
	MOVE 2,1
	MOVSI 1,200000
	DSKAS
DDERJ5:	 SETOB 1,2		;NONE LEFT
	MOVEM 1,DDERBB
	MOVEM 2,DDERGB		;SAVE HARDWARE ADDRESS FOR QUICK 
	RET

; INITIALIZE ERROR FILE

DDERJ7:	HRLZ 1,(P)		;GET JFN
	MOVSI 4,-1000		;UNMAP ALL PAGES
DDER71:	HRR 1,4			;SET IN PAGE NUMBER
	RPACS
	TLNN 2,(1B5)		;PAGE EXISTS?
	 JRST DDER72		;NO
	MOVE 2,1
	SETO 1,			;YES, DELETE IT
	PMAP
	MOVE 1,2
DDER72:	AOBJN 4,DDER71		

	HLRZS 1			;POSITION JFN FOR RIN,ROUTS
	SETZ 2,			;SET UP INPUT,OUTPUT QUEUE POINTERS
	MOVEI 3,DDERFO
	ROUT
	MOVEI 3,DDERFI
	MOVEI 2,DDERFO
	ROUT

	MOVEI 3,DDERFS-DDERNW	;CHAIN TOGETHER FREE BLOCKS
	SETZ 2,
DDERJ6:	ROUT
	MOVE 2,3
	SUBI 3,DDERNW
	JUMPG 3,DDERJ6
	MOVEI 3,DDERFF
	ROUT			;SET UP FREE QUEUE
	JRST DDERJ2		;CONTINUE

	END



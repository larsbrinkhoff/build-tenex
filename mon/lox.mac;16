;<MON>LOX.MAC;16    19-APR-77 15:42:35    EDIT BY SWEER
;un half killed some symbols for anal program


INTERN DLOCKR,JLOCKR,JULCKR,HLOCKR,SLOCKR,CPUSW0

INTERN HLOCKP,USYSLK








;		INITIALIZATION REQUIRED BY EACH CPU

CPUINI:
;			SET UP JSR'S DONE VIA PAGE TABLE (KIEPT)
	MOVE 1,[JRST KIPSB1]
	MOVEM 1,KIPSAB+1	;SET AC BASE ENTRY
	MOVE 1,[JRST KIPCL0]
	MOVEM 1,KIPCLD+1	;PGRCLD ENTRY
	MOVE 1,CPUID
	MOVE 2,PI7P0(1)		;SET UP SCHEDULER STACK POINTER
	MOVEM 2,PI7P
	AOS INSKED		;MORE INITIALIZATION
	MOVE 1,[JRST BUGH9]
	MOVEM 1,BUGHLT+1
	MOVE 1,[JRST BUGC9]
	MOVEM 1,BUGCHK+1
	MOVE 1,[JRST BUGN9]
	MOVEM 1,BUGNTE+1
	MOVNI 2,2
	SKIPE CPUID
	JRST CPUIN1		;DONT DO FOR CPU1
	MOVE 3,KIECPU		;SET UP FORKX FOR CPU1 IN CASE IT DOESN'T
				;RUN
	MOVEM 2,FORKX-KIEPT(3)
	SETOM OVERH
	SETOM GENLCK
	SETOM STOPLK
	SETOM SYSLCK
	SETOM IMPLCK
	SETOM TTYLCK
	SETOM LONFLK
	SETOM RQOLCK
	SETOM IMPPI
	SETOM DLSPI
	SETOM SWPPI
	SETOM SWPKI
	SETOM DRPI
	SETOM DSKPI
	SETOM PILCK
	SETOM DDTLCK
	SETOM RQILCK
	SETOM KIMLOK
	SETOM SKDLCK
	SETOM SW20LK
	SETOM PLTLOK
	SETOM PTYLCK
	SETOM NOPILK
	SETOM PSILCK
	MOVSI 1,-NJOBS
	SETOM JOBLCK(1)
	AOBJN 1,.-1
	SETOM STOPFG
	RET


CPUIN1:
	MOVEM 2,FORKX
	SETZM PGUNTF
	SETOM TTNIT1
	SETOM NOPILK
	SETZM BUGHLT
	SETZM BUGCHK
	SETOM OVERH
	SETOM STOPFG+1
	MOVE 1,[JRST SCDRQ0]
	MOVEM 1,SCDRQ+1
	RET

;			SWITCH PROCESS TO CPU0 OR CPU1
CPUSW1:	PUSH P,[1B2]		;SWITCH TO CPU1
	SKIPA
CPUSW0:	PUSH P,[1B1]		;SWITCH TO CPU0
	AOS OVERH
	SKIPN INSKED		;IN SCHEDULER
	CONSZ PI,177B27		;OR PI IN PROGRESS
	JRST CPSW1		;SHOULD ALREADY BE ON CORRECT CPU
	PUSH P,1
	PUSH P,2
	MOVE 1, FORKX
	MOVE 2,-2(P)
	IORM 2,FKCNO(1)		;SET TEMPORARY FORCED-CPU FLAG
	TLNN 2,(1B1)		;CPU 0?
	JRST [SKIPE CPUID	;WANT TO BE ON CPU 1
		JRST CPSW2	;ON CORRECT CPU
		JRST .+3]
	SKIPN CPUID		;WANT TO BE ON CPU 0
	JRST CPSW2		;WE ARE
	SOS OVERH
	MOVEI 1,JSKP
	JSYS SCHEDP		;RESCHEDULE
	AOS OVERH
CPSW2:
	POP P,2
	POP P,1
CPSW1:
	SUB P,BHC+1
	SOS OVERH
	RET


;			LOCKS AND LOCK ROUTINES

LS GENLCK,1	;GENERAL LOCK USED TO PROTECT LOCK ROUTINES
		;WHEN SETTING UP ANOTHER LOCK
LS STOPLK,3	;STOP CPU LOCK-FOR RELMPG AND GARBAGE COLLECT
LS STOPFG,2	;STOP FLAG FOR EACH CPU-0=STOPPED, -1=RUNNING

LS JOBLCK,NJOBS ;JOB LOCK FOR EACH JOB--PROTECTS FORK MANIPULATION
		;WITHIN A JOB
LS JOBLKF,NJOBS ;ID OF FORK OWING JOBLCK

;		LOCKS THAT DISMISS IF LOCK IS UNAVAILABLE
;		AND REQUESTOR IS NOT THE SCHEDULER
;		IF SCHEDULER CAN'T GET THE LOCK, A FAIL RETURN IS GIVEN
LS SYSLCK,3	;FOR CST'S, SPT'S AND SWAPPING
LS IMPLCK,3	;FOR IMP RELATED CODE
LS TTYLCK,3	;FOR TTYSRV RELATED CODE
LS LONFLK,3	;PROTECT LONG-FILE CODE IN DISC
LS RQOLCK,3	;SCHEDULER SPECIAL REQUEST OUTPUT QUEUE

;		HANG LOCKS USED IN BOTH INTERRUPT AND NON-INTERRUPT CODE
LS IMPPI,2	;IMP INTERRUPT CODE
LS DLSPI,2	;TTYSRV INTERRUPT CODE
LS SWPPI,2	;REPLACEABLE Q AND SWAP COMPLETION
LS SWPKI,2	;SWPIN AND KI ROUTINE INTERLOCK
LS DRPI,2	;DRUM Q'S
LS DSKPI,2	;DISK Q'S
LS PILCK,2	;CATCH-ALL PI LOCK
LS DDTLCK,2	;LOCK FOR DDT AND CRASHES
LS RQILCK,2	;SCHEDULER SPECIAL REQUEST INPUT QUEUE
LS PLTLOK,2	;PLOTTER LOCK
LS PTYLCK,2	;PSEUDO TTY LOCK
LS PSILCK,2	;PSEUDO INTERRUPT LOCK

;		HANG LOCKS USED ONLY AT NON-INTERRUPT LEVEL
LS KIMLOK,2	;KISRV LOCKED-PAGES TEMPLATE CODE
LS SKDLCK,2	;SCHEDULER WTLST AND BALSET PROCESSING ROUTINES
LS SW20LK,2	;SCHEDULER CODE THAT EXAMINES SWITCHES

KS NOPILK,2	;FOR MULTIPLE PIOFFS

;		OTHER VARIABLES
CP1ON=110	;FLAG SETTABLE IN EDDT OR MDDT SAYING
		;WHETHER OR NOT TO RUN ON 2 PROCESSORS
		;0=2 PROCESSORS, 1=USE ONLY CPU0

DDTFLG: 1	;NON-ZERO MEANS CPU STOPS WHEN OTHER CPU
		;HITS BREAKPOINT OR CRASHES

LS CP0INF,2	;SET WHEN EACH PROCESSOR COMPLETES INITIALIZATION
		;0=NOT FINISHED, -1=READY TO RUN
CP1INF=CP0INF+1
KS OVERH,1	;OVERHEAD FLAG FOR HARDWARE MONITORING
LS JLKDIS,1	;COUNTER FOR DISM ON JOBLOCK

;		HANG LOCK ROUTINE
;  INPUT
;   CALL HLOCKR
;   WITH AC1 = ADR OF LOCK

;   OUTPUT
;   HANGS UNTIL LOCK IS AVAILABLE AND RETURNS +1 WITH LOCK LOCKED

HLOCKR:
	AOS OVERH		;VAR FOR OVERHEAD MONITORING
	AOSE (1)		;LOCK AVAIL
	JRST .-1		;NO-WAIT
HLOCR1:	ADDI 1,1		;SAVE CALLING PC FOR DEBUGGING
	EXCH 1,(P)
	MOVEM 1,@0(P)
	EXCH 1,(P)
	SOS OVERH
	RET

HLOCKP:	AOS OVERH		;TURN PIOFF AND THEN LOCK
	NOPI
	AOSG (1)
	JRST HLOCR1
	OKPI
	JRST HLOCKP+1


;		STOP PROCESSOR LOCK
;   INPUT
;   NOSKED AND SYSLCK MUST BE SET IF ENTERED FROM RELMPG
;   NOT REQUIRED IF CALLED FROM SCHEDULER GARBAGE COLLECT

PRSTOP:
	AOS OVERH		;ACCOUNT FOR OVERHEAD
	PUSH P,1
PRSTP1:
	AOSE GENLCK		;PROTECT THIS CODE
	JRST .-1
	MOVE 1,FORKX
	AOSE STOPLK		;STOP LOCK AVAIL?
	JRST [	SKIPG STOPLK	;NO
		JSR BUGHLT	;CLOBBERED
		CAMN 1,STOPLK+1  ;DO WE OWN STOPLK
		JRST .+1	;YES, OK TO CONTINUE
		SOS STOPLK	;SOMEONE TRYING TO STOP AT SAME TIME
		SETOM GENLCK
		SKIPE INSKED
		JRST PRSTP3	;OK. GO AHEAD
		CALL PRTST	;STOP OURSELVES
		JRST PRSTP1]
	MOVEM 1,STOPLK+1	;SAVE OWNING FORK OR SCHED ID
	MOVE 1,-1(P)		;SAVE CALLING PC FOR DEBUG
	MOVEM 1,STOPLK+2
	SETOM GENLCK
PRSTP2:
	CALL PRRUN
	JRST PRSTP2
PRSTP3:	POP P,1
	SOS OVERH
	RET

PRRUN:	MOVE 1,CPUID	;TEST TO SEE IF OTHER PROC. RUNNING
	XORI 1,1
	SKIPGE CP0INF(1);OTHER PROC. HALTED
	SKIPL STOPFG(1)	;OTHER PROC. STOPPED
	AOS 0(P)
	RET

PRTST:	AOS OVERH	;TEST FOR STOPPING AND STOP IF REQUIRED
	PUSH P,1
	PUSH P,2
	AOSE GENLCK		;PROTECT THIS CODE
	JRST .-1
	MOVE 2,FORKX
	SKIPGE STOPLK
	JRST PRTST1
	CALL PRRUN
	SKIPA
	JRST PRTST1
	SETOM GENLCK
	MOVE 1,CPUID
	SETZM STOPFG(1)		;INDICATE WE ARE STOPPED
	JUMPL 2,PRTST3		;DO WE HAVE A CURRENT FORK
	HRRZ 2,FKPT(2)		;WHILE STOPPED, CHECK TO SEE IF
				;PAGE TABLE SHOULD BE CLEARED
PRTST2:
	SKIPN KIRFLG
	SKIPGE KITBL(2)
	JRST	[PGRCLD		;CLEAR IT AND WAIT FOR SIGNAL TO START
		JRST PRTST3]
	SKIPL STOPLK
	JRST PRTST2
	SKIPN KIRFLG
	SKIPGE KITBL(2)		;CHECK ONCE MORE
	JRST [	SETOM STOPFG(1)		;SAY WE ARENT STOPPED
		PGRCLD
		JRST PRTST4]
	JRST PRTST4
PRTST3:
	SKIPL STOPLK		;CAN WE CONTINUE YET?
	JRST .-1		;NO
PRTST4:
	SETOM STOPFG(1)
	SKIPA
PRTST1:	SETOM GENLCK
	POP P,2
	POP P,1
	SOS OVERH
	RET


PRGO:			;UNLOCK THE STOPLK--LET PROCESSOR GO
	AOS OVERH
	AOSE GENLCK
	JRST .-1
	PUSH P,1
	MOVE 1,STOPLK
	CAMGE 1,[-1]
	JSR BUGHLT
	MOVE 1,FORKX
	SKIPL STOPLK		;LOCK LOCKED
	CAME 1,STOPLK+1		;OURS
	JRST PRGO1
	SOS STOPLK		;RELEASE STOPLK
	SKIPL STOPLK
	JRST PRGO1		;ONE MORE LEVEL TO GO
	SETOM GENLCK
	MOVE 1,CPUID
	XORI 1,1		;MAKE SURE OTHER CPU HAS STARTED
PRGO2:
	SKIPGE CP0INF(1)	;DON'T BOTHER IF 1 CPU RUNNING
	SKIPGE STOPFG(1)
	SKIPA
	JRST PRGO2
	SKIPA
PRGO1:	SETOM GENLCK
	POP P,1
	SOS OVERH
	RET

;			DISMISS LOCK ROUTINE
;   INPUT
;   CALL DLOCKR
;   WITH AC1 = ADDRESS OF LOCK

;   FUNCTION
;   THIS LOCK CAN BE LOCKED MULTIPLY BY SAME PROCESS; IF PROCESS CAN'T
;   GET LOCK, IT IS DISMISSED THEN RETRIED LATER.
;   SCHEDULER CAN'T BE DISMISSED; FOR LOCKS LIKE IMPLCK, OR TTYLCK,
;   THE LOCK HAS ALREADY BEEN SECURED FOR THE SCHEDULER BY USING
;   SLOCKR.  SYSLCK IS TREATED SPECIALLY.

;   OUTPUT
;   LOCK IS LOCKED AND RETURN IS TO PC+1

DLOCKR:
	AOS OVERH		;OVERHEAD FLAG
	PUSH P,2
	PUSH P,3
DLCKR4:
	AOSE GENLCK		;PROTECT LOCK SETTING
	JRST .-1
	MOVE 2,(1)
	CAMGE 2,[-1]
	JSR BUGHLT
	MOVE 2,FORKX
	AOSE (1)		;LOCK AVAIL
	CAMN 2,1(1)		;AND OUR LOCK
	JRST DLCKR1		;YES
	SOS (1)			;KEEP COUNT CORRECT FOR MULTIPLE LOCK
	MOVE 3,KIECPU
	MOVE 2,1(1)		;GET LOCKING ID
	SKIPE INSKED		;IN SCHEDULER
	JRST [	CAIE 1,SYSLCK	;IF SYSLCK, MAY BE OK TO CONTINUE ANYWAY
		JSR BUGHLT	;CAN'T DISMISS OTHERWISE
		SKIPGE STOPLK
		CAME 2,FORKX-KIEPT(3)
		JRST DLCKR3
		SETOM GENLCK
		JFCL
		JFCL
		JRST DLCKR4]
	SETOM GENLCK
	CAMN 2,FORKX-KIEPT(3)	;LOCKING FORK STILL RUNNING
	JRST [	CALL PRTST	;SEE IF WE SHOULD STOP
		JRST DLCKR4]	;TRY AGAIN
	HRL 1,1
	HRRI 1,DISLT		;DISMISS UNTIL LESS THAN 0
	SOS OVERH
	JSYS SCHEDP		;DISMISS AND STAY IN BALSET
	AOS OVERH
	HLRZ 1,1
	JRST DLCKR4		;TRY AGAIN
DLCKR1:
	MOVEM 2,1(1)		;SAVE ID
	MOVE 2,-2(P)		;SAVE PC FOR DEBUGGING
	MOVEM 2,2(1)
DLCKR3:	SETOM GENLCK
	POP P,3
	POP P,2
	SOS OVERH
	RET


USYSLK:	AOS OVERH
	PUSH P,1		;ROUTINE TO UNLOCK SYSLCK
	MOVE 1,FORKX
	AOSE GENLCK
	JRST .-1
	CAMN 1,SYSLCK+1
	SOS SYSLCK		;WE DID--UNLOCK SYSLCK
	MOVE 1,SYSLCK
	CAMGE 1,[-1]
	JSR BUGHLT		;SHOULDNT BE
	SETOM GENLCK
	POP P,1
	SOS OVERH
	RET

;			SKIP LOCK
;   INPUT
;   CALL SLOCKR
;   AC1 - ADR OF LOCK

;   FUNCTION
;   USED BY SCHEDULER TO SECURE TTYLCK OR IMPLCK BEFORE CONTINUING
;   ALSO HAS SOME OTHER USES BY SCHEDULER

;   OUTPUT
;   RETURNS +1 IF LOCK NOT AVAILABLE
;   RETURNS +1 IF LOCK AVAILABLE

SLOCKR:
	PUSH P,2
	MOVE 2,FORKX
	SKIPA
SLCKR1:	PUSH P,2		;ALTERNATE ENTRY POINT
	PUSH P,3
	AOS OVERH
	AOSE GENLCK
	JRST .-1
	MOVE 3,(1)
	CAMGE 3,[-1]
	JSR BUGHLT		;LOCK CLOBBERED
	AOSE (1)
	CAMN 2,1(1)
	JRST [AOS -2(P)		;SUCCESS RETURN
		MOVEM 2,1(1)	;SAVE FORK ID
		JRST .+2]
	SOS (1)			;KEEP COUNT STRAIGHT FOR MULTIPLE LOCKINGS
	SETOM GENLCK
	POP P,3
	POP P,2
	SOS OVERH
	RET

JLOCKR:	NOSKED		;LOCK JOB LOCK ROUTINE
	AOS OVERH
	PUSH P,1
	MOVE 1,JOBNO		;ASSUME FOR THIS JOB
	PUSH P,2
	NOINT
JLCK1:	NOPI
	AOSE GENLCK
	JRST  [ OKPI
		JRST JLCK1 ]
	MOVE 2,JOBLCK(1)
	SKIPN INSKED		;CANT BE IN SCHEDULER
	CAMGE 2,[-1]
	JSR BUGHLT		;LOCK CLOBBERED
	MOVE 2,FORKX
	AOSE JOBLCK(1)		;JOBLCK AVAIL
	JRST [
		CAME 2,JOBLKF(1) ;NOT AVAIL-WE ALREADY OWN IT?
		JRST JLCKR3	;NO-HAVE TO WAIT
		JRST JLCKR2]	;YES-BUMP LOCK COUNT
	MOVEM 2,JOBLKF(1)	;SAVE ID
	CALL JLKTS1		;TEST FOR CONDITIONS ALLOWING JOBLCK
	JRST JLCKR2		;OK TO LOCK JOBLCK
JLCKR3:
	SOS JOBLCK(1)		;HAVE TO WAIT-CLEAN UP FIRST
	SETOM GENLCK
	OKPI
	SOS OVERH
	HRL 1,1			;SAVE JOB NO.
	HRRI 1,JLKTST
	AOS JLKDIS		;COUNT DISMISSES
	JSYS SCHEDR
	JRST JLCKR4		;HAVE JOBLCK UPON RETURN
JLCKR2:	
	SETOM GENLCK
	OKPI
	SOS OVERH
	OKSKED
JLCKR4:
	POP P,2
	POP P,1
	RET

JLKTS1:			;MAKE SURE OTHER CONDITIONS ALLOWING
			;JOBLCK TO BE LOCKED ARE SATISFIED
	MOVE 2,KIECPU		;OTHER CPU'S PAGE TABLE 
	MOVE 2,FORKX-KIEPT(2)	;FORK RUNNING ON OTHER CPU
	JUMPL 2,JLKTS2		;THERE IS NONE
	HLRZ 2,FKJOB(2)		;DOES FORK BELONG TO OUR JOB
	CAIN 2,(1)
	JRST JLKTS3		;IT DOES-CAN'T HAVE JOBLCK YET
JLKTS2:
	SKIPGE SYSLCK		;DOES OUR JOB OWN SYSLCK
	JRST JLKTS4		;NOT LOCKED
	MOVE 2,SYSLCK+1
	JUMPL 2,JLKTS4
	CAMN 2,FORKX		;THIS JOB
	JRST JLKTS4		;YES-SUCCESS
	HLRZ 2,FKJOB(2)
	CAIN 2,(1)		;OUR JOB?
JLKTS3:	AOS (P)
JLKTS4:	RET

JLKTST:			;TEST ROUTINE FOR JOBLCK
	AOS OVERH
	AOSE GENLCK
	JRST .-1
	MOVE 2,JOBLCK(1)
	CAMGE 2,[-1]
	JSR BUGHLT		;LOCK CLOBBERED
	AOSE JOBLCK(1)		;JOBLCK AVAIL
	JRST	[
		HRRZ 2,7	;GET FORK
		CAME 2,JOBLKF(1)
		JRST JLKTS5	;NOT OUR FORK
		JRST JLKTS6]	;OUR FORK - OK
	HRRZM 7,JOBLKF(1)
	CALL JLKTS1		;CHECK OTHER CONDITIONS
JLKTS6:	JRST [ SETOM GENLCK	;WE HAVE IT
		SOS OVERH
		JRST 1(4)]
JLKTS5:
	SOS JOBLCK(1)
	SETOM GENLCK
	SOS OVERH
	JRST 0(4)


JULCKR:	AOS OVERH	;UNLOCK JOBLCK 
	PUSH P,1
	MOVE 1,JOBNO
	SOS 1,JOBLCK(1)
	CAMGE 1,[-1]
	JSR BUGCHK		;MAKE SURE NOT MORE THAN -1
	POP P,1
	OKINT
	SOS OVERH
	RET
